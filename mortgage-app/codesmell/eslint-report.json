[{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\.angular\\cache\\19.2.5\\mortgage-app\\vite\\deps\\@angular_animations.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\.angular\\cache\\19.2.5\\mortgage-app\\vite\\deps\\@angular_common.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\.angular\\cache\\19.2.5\\mortgage-app\\vite\\deps\\@angular_common_http.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\.angular\\cache\\19.2.5\\mortgage-app\\vite\\deps\\@angular_core.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\.angular\\cache\\19.2.5\\mortgage-app\\vite\\deps\\@angular_forms.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\.angular\\cache\\19.2.5\\mortgage-app\\vite\\deps\\@angular_platform-browser.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\.angular\\cache\\19.2.5\\mortgage-app\\vite\\deps\\@angular_platform-browser_animations.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\.angular\\cache\\19.2.5\\mortgage-app\\vite\\deps\\@angular_router.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\.angular\\cache\\19.2.5\\mortgage-app\\vite\\deps\\@ngrx_effects.js","messages":[{"ruleId":"@typescript-eslint/no-non-null-assertion","message":"Definition for rule '@typescript-eslint/no-non-null-assertion' was not found.","line":573,"column":5,"endLine":573,"endColumn":73,"severity":2,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  FEATURE_STATE_PROVIDER,\n  ROOT_STORE_PROVIDER,\n  ScannedActionsSubject,\n  Store,\n  StoreFeatureModule,\n  StoreRootModule,\n  createAction\n} from \"./chunk-LLD5PQMB.js\";\nimport {\n  ENVIRONMENT_INITIALIZER,\n  ErrorHandler,\n  Inject,\n  Injectable,\n  InjectionToken,\n  NgModule,\n  Optional,\n  inject,\n  makeEnvironmentProviders,\n  setClassMetadata,\n  ɵɵdefineInjectable,\n  ɵɵdefineInjector,\n  ɵɵdefineNgModule,\n  ɵɵinject\n} from \"./chunk-Z7RWVO2Z.js\";\nimport \"./chunk-PEBH6BBU.js\";\nimport {\n  defer,\n  merge\n} from \"./chunk-WPM5VTLQ.js\";\nimport {\n  Observable,\n  Subject,\n  catchError,\n  concatMap,\n  dematerialize,\n  exhaustMap,\n  filter,\n  finalize,\n  groupBy,\n  ignoreElements,\n  map,\n  materialize,\n  mergeMap,\n  take\n} from \"./chunk-4S3KYZTJ.js\";\nimport {\n  __spreadProps,\n  __spreadValues\n} from \"./chunk-WDMUDEB6.js\";\n\n// node_modules/@ngrx/effects/fesm2022/ngrx-effects.mjs\nvar DEFAULT_EFFECT_CONFIG = {\n  dispatch: true,\n  functional: false,\n  useEffectsErrorHandler: true\n};\nvar CREATE_EFFECT_METADATA_KEY = \"__@ngrx/effects_create__\";\nfunction createEffect(source, config = {}) {\n  const effect = config.functional ? source : source();\n  const value = __spreadValues(__spreadValues({}, DEFAULT_EFFECT_CONFIG), config);\n  Object.defineProperty(effect, CREATE_EFFECT_METADATA_KEY, {\n    value\n  });\n  return effect;\n}\nfunction getCreateEffectMetadata(instance) {\n  const propertyNames = Object.getOwnPropertyNames(instance);\n  const metadata = propertyNames.filter((propertyName) => {\n    if (instance[propertyName] && instance[propertyName].hasOwnProperty(CREATE_EFFECT_METADATA_KEY)) {\n      const property = instance[propertyName];\n      return property[CREATE_EFFECT_METADATA_KEY].hasOwnProperty(\"dispatch\");\n    }\n    return false;\n  }).map((propertyName) => {\n    const metaData = instance[propertyName][CREATE_EFFECT_METADATA_KEY];\n    return __spreadValues({\n      propertyName\n    }, metaData);\n  });\n  return metadata;\n}\nfunction getEffectsMetadata(instance) {\n  return getSourceMetadata(instance).reduce((acc, {\n    propertyName,\n    dispatch,\n    useEffectsErrorHandler\n  }) => {\n    acc[propertyName] = {\n      dispatch,\n      useEffectsErrorHandler\n    };\n    return acc;\n  }, {});\n}\nfunction getSourceMetadata(instance) {\n  return getCreateEffectMetadata(instance);\n}\nfunction getSourceForInstance(instance) {\n  return Object.getPrototypeOf(instance);\n}\nfunction isClassInstance(obj) {\n  return !!obj.constructor && obj.constructor.name !== \"Object\" && obj.constructor.name !== \"Function\";\n}\nfunction isClass(classOrRecord) {\n  return typeof classOrRecord === \"function\";\n}\nfunction getClasses(classesAndRecords) {\n  return classesAndRecords.filter(isClass);\n}\nfunction isToken(tokenOrRecord) {\n  return tokenOrRecord instanceof InjectionToken || isClass(tokenOrRecord);\n}\nfunction mergeEffects(sourceInstance, globalErrorHandler, effectsErrorHandler) {\n  const source = getSourceForInstance(sourceInstance);\n  const isClassBasedEffect = !!source && source.constructor.name !== \"Object\";\n  const sourceName = isClassBasedEffect ? source.constructor.name : null;\n  const observables$ = getSourceMetadata(sourceInstance).map(({\n    propertyName,\n    dispatch,\n    useEffectsErrorHandler\n  }) => {\n    const observable$ = typeof sourceInstance[propertyName] === \"function\" ? sourceInstance[propertyName]() : sourceInstance[propertyName];\n    const effectAction$ = useEffectsErrorHandler ? effectsErrorHandler(observable$, globalErrorHandler) : observable$;\n    if (dispatch === false) {\n      return effectAction$.pipe(ignoreElements());\n    }\n    const materialized$ = effectAction$.pipe(materialize());\n    return materialized$.pipe(map((notification) => ({\n      effect: sourceInstance[propertyName],\n      notification,\n      propertyName,\n      sourceName,\n      sourceInstance\n    })));\n  });\n  return merge(...observables$);\n}\nvar MAX_NUMBER_OF_RETRY_ATTEMPTS = 10;\nfunction defaultEffectsErrorHandler(observable$, errorHandler, retryAttemptLeft = MAX_NUMBER_OF_RETRY_ATTEMPTS) {\n  return observable$.pipe(catchError((error) => {\n    if (errorHandler) errorHandler.handleError(error);\n    if (retryAttemptLeft <= 1) {\n      return observable$;\n    }\n    return defaultEffectsErrorHandler(observable$, errorHandler, retryAttemptLeft - 1);\n  }));\n}\nvar Actions = class _Actions extends Observable {\n  constructor(source) {\n    super();\n    if (source) {\n      this.source = source;\n    }\n  }\n  lift(operator) {\n    const observable = new _Actions();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n  static {\n    this.ɵfac = function Actions_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _Actions)(ɵɵinject(ScannedActionsSubject));\n    };\n  }\n  static {\n    this.ɵprov = ɵɵdefineInjectable({\n      token: _Actions,\n      factory: _Actions.ɵfac,\n      providedIn: \"root\"\n    });\n  }\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(Actions, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], () => [{\n    type: Observable,\n    decorators: [{\n      type: Inject,\n      args: [ScannedActionsSubject]\n    }]\n  }], null);\n})();\nfunction ofType(...allowedTypes) {\n  return filter((action) => allowedTypes.some((typeOrActionCreator) => {\n    if (typeof typeOrActionCreator === \"string\") {\n      return typeOrActionCreator === action.type;\n    }\n    return typeOrActionCreator.type === action.type;\n  }));\n}\nvar _ROOT_EFFECTS_GUARD = new InjectionToken(\"@ngrx/effects Internal Root Guard\");\nvar USER_PROVIDED_EFFECTS = new InjectionToken(\"@ngrx/effects User Provided Effects\");\nvar _ROOT_EFFECTS = new InjectionToken(\"@ngrx/effects Internal Root Effects\");\nvar _ROOT_EFFECTS_INSTANCES = new InjectionToken(\"@ngrx/effects Internal Root Effects Instances\");\nvar _FEATURE_EFFECTS = new InjectionToken(\"@ngrx/effects Internal Feature Effects\");\nvar _FEATURE_EFFECTS_INSTANCE_GROUPS = new InjectionToken(\"@ngrx/effects Internal Feature Effects Instance Groups\");\nvar EFFECTS_ERROR_HANDLER = new InjectionToken(\"@ngrx/effects Effects Error Handler\", {\n  providedIn: \"root\",\n  factory: () => defaultEffectsErrorHandler\n});\nvar ROOT_EFFECTS_INIT = \"@ngrx/effects/init\";\nvar rootEffectsInit = createAction(ROOT_EFFECTS_INIT);\nfunction reportInvalidActions(output, reporter) {\n  if (output.notification.kind === \"N\") {\n    const action = output.notification.value;\n    const isInvalidAction = !isAction(action);\n    if (isInvalidAction) {\n      reporter.handleError(new Error(`Effect ${getEffectName(output)} dispatched an invalid action: ${stringify(action)}`));\n    }\n  }\n}\nfunction isAction(action) {\n  return typeof action !== \"function\" && action && action.type && typeof action.type === \"string\";\n}\nfunction getEffectName({\n  propertyName,\n  sourceInstance,\n  sourceName\n}) {\n  const isMethod = typeof sourceInstance[propertyName] === \"function\";\n  const isClassBasedEffect = !!sourceName;\n  return isClassBasedEffect ? `\"${sourceName}.${String(propertyName)}${isMethod ? \"()\" : \"\"}\"` : `\"${String(propertyName)}()\"`;\n}\nfunction stringify(action) {\n  try {\n    return JSON.stringify(action);\n  } catch {\n    return action;\n  }\n}\nvar onIdentifyEffectsKey = \"ngrxOnIdentifyEffects\";\nfunction isOnIdentifyEffects(instance) {\n  return isFunction(instance, onIdentifyEffectsKey);\n}\nvar onRunEffectsKey = \"ngrxOnRunEffects\";\nfunction isOnRunEffects(instance) {\n  return isFunction(instance, onRunEffectsKey);\n}\nvar onInitEffects = \"ngrxOnInitEffects\";\nfunction isOnInitEffects(instance) {\n  return isFunction(instance, onInitEffects);\n}\nfunction isFunction(instance, functionName) {\n  return instance && functionName in instance && typeof instance[functionName] === \"function\";\n}\nvar EffectSources = class _EffectSources extends Subject {\n  constructor(errorHandler, effectsErrorHandler) {\n    super();\n    this.errorHandler = errorHandler;\n    this.effectsErrorHandler = effectsErrorHandler;\n  }\n  addEffects(effectSourceInstance) {\n    this.next(effectSourceInstance);\n  }\n  /**\n   * @internal\n   */\n  toActions() {\n    return this.pipe(groupBy((effectsInstance2) => isClassInstance(effectsInstance2) ? getSourceForInstance(effectsInstance2) : effectsInstance2), mergeMap((source$) => {\n      return source$.pipe(groupBy(effectsInstance));\n    }), mergeMap((source$) => {\n      const effect$ = source$.pipe(exhaustMap((sourceInstance) => {\n        return resolveEffectSource(this.errorHandler, this.effectsErrorHandler)(sourceInstance);\n      }), map((output) => {\n        reportInvalidActions(output, this.errorHandler);\n        return output.notification;\n      }), filter((notification) => notification.kind === \"N\" && notification.value != null), dematerialize());\n      const init$ = source$.pipe(take(1), filter(isOnInitEffects), map((instance) => instance.ngrxOnInitEffects()));\n      return merge(effect$, init$);\n    }));\n  }\n  static {\n    this.ɵfac = function EffectSources_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _EffectSources)(ɵɵinject(ErrorHandler), ɵɵinject(EFFECTS_ERROR_HANDLER));\n    };\n  }\n  static {\n    this.ɵprov = ɵɵdefineInjectable({\n      token: _EffectSources,\n      factory: _EffectSources.ɵfac,\n      providedIn: \"root\"\n    });\n  }\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(EffectSources, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], () => [{\n    type: ErrorHandler\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [EFFECTS_ERROR_HANDLER]\n    }]\n  }], null);\n})();\nfunction effectsInstance(sourceInstance) {\n  if (isOnIdentifyEffects(sourceInstance)) {\n    return sourceInstance.ngrxOnIdentifyEffects();\n  }\n  return \"\";\n}\nfunction resolveEffectSource(errorHandler, effectsErrorHandler) {\n  return (sourceInstance) => {\n    const mergedEffects$ = mergeEffects(sourceInstance, errorHandler, effectsErrorHandler);\n    if (isOnRunEffects(sourceInstance)) {\n      return sourceInstance.ngrxOnRunEffects(mergedEffects$);\n    }\n    return mergedEffects$;\n  };\n}\nvar EffectsRunner = class _EffectsRunner {\n  get isStarted() {\n    return !!this.effectsSubscription;\n  }\n  constructor(effectSources, store) {\n    this.effectSources = effectSources;\n    this.store = store;\n    this.effectsSubscription = null;\n  }\n  start() {\n    if (!this.effectsSubscription) {\n      this.effectsSubscription = this.effectSources.toActions().subscribe(this.store);\n    }\n  }\n  ngOnDestroy() {\n    if (this.effectsSubscription) {\n      this.effectsSubscription.unsubscribe();\n      this.effectsSubscription = null;\n    }\n  }\n  static {\n    this.ɵfac = function EffectsRunner_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _EffectsRunner)(ɵɵinject(EffectSources), ɵɵinject(Store));\n    };\n  }\n  static {\n    this.ɵprov = ɵɵdefineInjectable({\n      token: _EffectsRunner,\n      factory: _EffectsRunner.ɵfac,\n      providedIn: \"root\"\n    });\n  }\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(EffectsRunner, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], () => [{\n    type: EffectSources\n  }, {\n    type: Store\n  }], null);\n})();\nvar EffectsRootModule = class _EffectsRootModule {\n  constructor(sources, runner, store, rootEffectsInstances, storeRootModule, storeFeatureModule, guard) {\n    this.sources = sources;\n    runner.start();\n    for (const effectsInstance2 of rootEffectsInstances) {\n      sources.addEffects(effectsInstance2);\n    }\n    store.dispatch({\n      type: ROOT_EFFECTS_INIT\n    });\n  }\n  addEffects(effectsInstance2) {\n    this.sources.addEffects(effectsInstance2);\n  }\n  static {\n    this.ɵfac = function EffectsRootModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _EffectsRootModule)(ɵɵinject(EffectSources), ɵɵinject(EffectsRunner), ɵɵinject(Store), ɵɵinject(_ROOT_EFFECTS_INSTANCES), ɵɵinject(StoreRootModule, 8), ɵɵinject(StoreFeatureModule, 8), ɵɵinject(_ROOT_EFFECTS_GUARD, 8));\n    };\n  }\n  static {\n    this.ɵmod = ɵɵdefineNgModule({\n      type: _EffectsRootModule\n    });\n  }\n  static {\n    this.ɵinj = ɵɵdefineInjector({});\n  }\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(EffectsRootModule, [{\n    type: NgModule,\n    args: [{}]\n  }], () => [{\n    type: EffectSources\n  }, {\n    type: EffectsRunner\n  }, {\n    type: Store\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [_ROOT_EFFECTS_INSTANCES]\n    }]\n  }, {\n    type: StoreRootModule,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: StoreFeatureModule,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [_ROOT_EFFECTS_GUARD]\n    }]\n  }], null);\n})();\nvar EffectsFeatureModule = class _EffectsFeatureModule {\n  constructor(effectsRootModule, effectsInstanceGroups, storeRootModule, storeFeatureModule) {\n    const effectsInstances = effectsInstanceGroups.flat();\n    for (const effectsInstance2 of effectsInstances) {\n      effectsRootModule.addEffects(effectsInstance2);\n    }\n  }\n  static {\n    this.ɵfac = function EffectsFeatureModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _EffectsFeatureModule)(ɵɵinject(EffectsRootModule), ɵɵinject(_FEATURE_EFFECTS_INSTANCE_GROUPS), ɵɵinject(StoreRootModule, 8), ɵɵinject(StoreFeatureModule, 8));\n    };\n  }\n  static {\n    this.ɵmod = ɵɵdefineNgModule({\n      type: _EffectsFeatureModule\n    });\n  }\n  static {\n    this.ɵinj = ɵɵdefineInjector({});\n  }\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(EffectsFeatureModule, [{\n    type: NgModule,\n    args: [{}]\n  }], () => [{\n    type: EffectsRootModule\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [_FEATURE_EFFECTS_INSTANCE_GROUPS]\n    }]\n  }, {\n    type: StoreRootModule,\n    decorators: [{\n      type: Optional\n    }]\n  }, {\n    type: StoreFeatureModule,\n    decorators: [{\n      type: Optional\n    }]\n  }], null);\n})();\nvar EffectsModule = class _EffectsModule {\n  static forFeature(...featureEffects) {\n    const effects = featureEffects.flat();\n    const effectsClasses = getClasses(effects);\n    return {\n      ngModule: EffectsFeatureModule,\n      providers: [effectsClasses, {\n        provide: _FEATURE_EFFECTS,\n        multi: true,\n        useValue: effects\n      }, {\n        provide: USER_PROVIDED_EFFECTS,\n        multi: true,\n        useValue: []\n      }, {\n        provide: _FEATURE_EFFECTS_INSTANCE_GROUPS,\n        multi: true,\n        useFactory: createEffectsInstances,\n        deps: [_FEATURE_EFFECTS, USER_PROVIDED_EFFECTS]\n      }]\n    };\n  }\n  static forRoot(...rootEffects) {\n    const effects = rootEffects.flat();\n    const effectsClasses = getClasses(effects);\n    return {\n      ngModule: EffectsRootModule,\n      providers: [effectsClasses, {\n        provide: _ROOT_EFFECTS,\n        useValue: [effects]\n      }, {\n        provide: _ROOT_EFFECTS_GUARD,\n        useFactory: _provideForRootGuard\n      }, {\n        provide: USER_PROVIDED_EFFECTS,\n        multi: true,\n        useValue: []\n      }, {\n        provide: _ROOT_EFFECTS_INSTANCES,\n        useFactory: createEffectsInstances,\n        deps: [_ROOT_EFFECTS, USER_PROVIDED_EFFECTS]\n      }]\n    };\n  }\n  static {\n    this.ɵfac = function EffectsModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _EffectsModule)();\n    };\n  }\n  static {\n    this.ɵmod = ɵɵdefineNgModule({\n      type: _EffectsModule\n    });\n  }\n  static {\n    this.ɵinj = ɵɵdefineInjector({});\n  }\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(EffectsModule, [{\n    type: NgModule,\n    args: [{}]\n  }], null, null);\n})();\nfunction createEffectsInstances(effectsGroups, userProvidedEffectsGroups) {\n  const effects = [];\n  for (const effectsGroup of effectsGroups) {\n    effects.push(...effectsGroup);\n  }\n  for (const userProvidedEffectsGroup of userProvidedEffectsGroups) {\n    effects.push(...userProvidedEffectsGroup);\n  }\n  return effects.map((effectsTokenOrRecord) => isToken(effectsTokenOrRecord) ? inject(effectsTokenOrRecord) : effectsTokenOrRecord);\n}\nfunction _provideForRootGuard() {\n  const runner = inject(EffectsRunner, {\n    optional: true,\n    skipSelf: true\n  });\n  const rootEffects = inject(_ROOT_EFFECTS, {\n    self: true\n  });\n  const hasEffects = !(rootEffects.length === 1 && rootEffects[0].length === 0);\n  if (hasEffects && runner) {\n    throw new TypeError(`EffectsModule.forRoot() called twice. Feature modules should use EffectsModule.forFeature() instead.`);\n  }\n  return \"guarded\";\n}\nfunction act(configOrProject, errorFn) {\n  const {\n    project,\n    error,\n    complete,\n    operator,\n    unsubscribe\n  } = typeof configOrProject === \"function\" ? {\n    project: configOrProject,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    error: errorFn,\n    operator: concatMap,\n    complete: void 0,\n    unsubscribe: void 0\n  } : __spreadProps(__spreadValues({}, configOrProject), {\n    operator: configOrProject.operator || concatMap\n  });\n  return (source) => defer(() => {\n    const subject = new Subject();\n    return merge(source.pipe(operator((input, index) => defer(() => {\n      let completed = false;\n      let errored = false;\n      let projectedCount = 0;\n      return project(input, index).pipe(materialize(), map((notification) => {\n        switch (notification.kind) {\n          case \"E\":\n            errored = true;\n            return {\n              kind: \"N\",\n              value: error(notification.error, input)\n            };\n          case \"C\":\n            completed = true;\n            return complete ? {\n              kind: \"N\",\n              value: complete(projectedCount, input)\n            } : void 0;\n          default:\n            ++projectedCount;\n            return notification;\n        }\n      }), filter((n) => n != null), dematerialize(), finalize(() => {\n        if (!completed && !errored && unsubscribe) {\n          subject.next(unsubscribe(projectedCount, input));\n        }\n      }));\n    }))), subject);\n  });\n}\nfunction provideEffects(...effects) {\n  const effectsClassesAndRecords = effects.flat();\n  const effectsClasses = getClasses(effectsClassesAndRecords);\n  return makeEnvironmentProviders([effectsClasses, {\n    provide: ENVIRONMENT_INITIALIZER,\n    multi: true,\n    useValue: () => {\n      inject(ROOT_STORE_PROVIDER);\n      inject(FEATURE_STATE_PROVIDER, {\n        optional: true\n      });\n      const effectsRunner = inject(EffectsRunner);\n      const effectSources = inject(EffectSources);\n      const shouldInitEffects = !effectsRunner.isStarted;\n      if (shouldInitEffects) {\n        effectsRunner.start();\n      }\n      for (const effectsClassOrRecord of effectsClassesAndRecords) {\n        const effectsInstance2 = isClass(effectsClassOrRecord) ? inject(effectsClassOrRecord) : effectsClassOrRecord;\n        effectSources.addEffects(effectsInstance2);\n      }\n      if (shouldInitEffects) {\n        const store = inject(Store);\n        store.dispatch(rootEffectsInit());\n      }\n    }\n  }]);\n}\nexport {\n  Actions,\n  EFFECTS_ERROR_HANDLER,\n  EffectSources,\n  EffectsFeatureModule,\n  EffectsModule,\n  EffectsRootModule,\n  EffectsRunner,\n  ROOT_EFFECTS_INIT,\n  USER_PROVIDED_EFFECTS,\n  act,\n  createEffect,\n  defaultEffectsErrorHandler,\n  getEffectsMetadata,\n  mergeEffects,\n  ofType,\n  provideEffects,\n  rootEffectsInit\n};\n//# sourceMappingURL=@ngrx_effects.js.map\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\.angular\\cache\\19.2.5\\mortgage-app\\vite\\deps\\@ngrx_store.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\.angular\\cache\\19.2.5\\mortgage-app\\vite\\deps\\chart__js.js","messages":[{"ruleId":"@typescript-eslint/no-empty-function","message":"Definition for rule '@typescript-eslint/no-empty-function' was not found.","line":5656,"column":3,"endLine":5656,"endColumn":67,"severity":2,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  __spreadProps,\n  __spreadValues\n} from \"./chunk-WDMUDEB6.js\";\n\n// node_modules/@kurkle/color/dist/color.esm.js\nfunction round(v) {\n  return v + 0.5 | 0;\n}\nvar lim = (v, l, h) => Math.max(Math.min(v, h), l);\nfunction p2b(v) {\n  return lim(round(v * 2.55), 0, 255);\n}\nfunction n2b(v) {\n  return lim(round(v * 255), 0, 255);\n}\nfunction b2n(v) {\n  return lim(round(v / 2.55) / 100, 0, 1);\n}\nfunction n2p(v) {\n  return lim(round(v * 100), 0, 100);\n}\nvar map$1 = {\n  0: 0,\n  1: 1,\n  2: 2,\n  3: 3,\n  4: 4,\n  5: 5,\n  6: 6,\n  7: 7,\n  8: 8,\n  9: 9,\n  A: 10,\n  B: 11,\n  C: 12,\n  D: 13,\n  E: 14,\n  F: 15,\n  a: 10,\n  b: 11,\n  c: 12,\n  d: 13,\n  e: 14,\n  f: 15\n};\nvar hex = [...\"0123456789ABCDEF\"];\nvar h1 = (b) => hex[b & 15];\nvar h2 = (b) => hex[(b & 240) >> 4] + hex[b & 15];\nvar eq = (b) => (b & 240) >> 4 === (b & 15);\nvar isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\nfunction hexParse(str) {\n  var len = str.length;\n  var ret;\n  if (str[0] === \"#\") {\n    if (len === 4 || len === 5) {\n      ret = {\n        r: 255 & map$1[str[1]] * 17,\n        g: 255 & map$1[str[2]] * 17,\n        b: 255 & map$1[str[3]] * 17,\n        a: len === 5 ? map$1[str[4]] * 17 : 255\n      };\n    } else if (len === 7 || len === 9) {\n      ret = {\n        r: map$1[str[1]] << 4 | map$1[str[2]],\n        g: map$1[str[3]] << 4 | map$1[str[4]],\n        b: map$1[str[5]] << 4 | map$1[str[6]],\n        a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255\n      };\n    }\n  }\n  return ret;\n}\nvar alpha = (a, f) => a < 255 ? f(a) : \"\";\nfunction hexString(v) {\n  var f = isShort(v) ? h1 : h2;\n  return v ? \"#\" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;\n}\nvar HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction hsl2rgbn(h, s, l) {\n  const a = s * Math.min(l, 1 - l);\n  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n  return [f(0), f(8), f(4)];\n}\nfunction hsv2rgbn(h, s, v) {\n  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n  return [f(5), f(3), f(1)];\n}\nfunction hwb2rgbn(h, w, b) {\n  const rgb = hsl2rgbn(h, 1, 0.5);\n  let i;\n  if (w + b > 1) {\n    i = 1 / (w + b);\n    w *= i;\n    b *= i;\n  }\n  for (i = 0; i < 3; i++) {\n    rgb[i] *= 1 - w - b;\n    rgb[i] += w;\n  }\n  return rgb;\n}\nfunction hueValue(r, g, b, d, max) {\n  if (r === max) {\n    return (g - b) / d + (g < b ? 6 : 0);\n  }\n  if (g === max) {\n    return (b - r) / d + 2;\n  }\n  return (r - g) / d + 4;\n}\nfunction rgb2hsl(v) {\n  const range = 255;\n  const r = v.r / range;\n  const g = v.g / range;\n  const b = v.b / range;\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const l = (max + min) / 2;\n  let h, s, d;\n  if (max !== min) {\n    d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    h = hueValue(r, g, b, d, max);\n    h = h * 60 + 0.5;\n  }\n  return [h | 0, s || 0, l];\n}\nfunction calln(f, a, b, c) {\n  return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);\n}\nfunction hsl2rgb(h, s, l) {\n  return calln(hsl2rgbn, h, s, l);\n}\nfunction hwb2rgb(h, w, b) {\n  return calln(hwb2rgbn, h, w, b);\n}\nfunction hsv2rgb(h, s, v) {\n  return calln(hsv2rgbn, h, s, v);\n}\nfunction hue(h) {\n  return (h % 360 + 360) % 360;\n}\nfunction hueParse(str) {\n  const m = HUE_RE.exec(str);\n  let a = 255;\n  let v;\n  if (!m) {\n    return;\n  }\n  if (m[5] !== v) {\n    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n  }\n  const h = hue(+m[2]);\n  const p1 = +m[3] / 100;\n  const p2 = +m[4] / 100;\n  if (m[1] === \"hwb\") {\n    v = hwb2rgb(h, p1, p2);\n  } else if (m[1] === \"hsv\") {\n    v = hsv2rgb(h, p1, p2);\n  } else {\n    v = hsl2rgb(h, p1, p2);\n  }\n  return {\n    r: v[0],\n    g: v[1],\n    b: v[2],\n    a\n  };\n}\nfunction rotate(v, deg) {\n  var h = rgb2hsl(v);\n  h[0] = hue(h[0] + deg);\n  h = hsl2rgb(h);\n  v.r = h[0];\n  v.g = h[1];\n  v.b = h[2];\n}\nfunction hslString(v) {\n  if (!v) {\n    return;\n  }\n  const a = rgb2hsl(v);\n  const h = a[0];\n  const s = n2p(a[1]);\n  const l = n2p(a[2]);\n  return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;\n}\nvar map = {\n  x: \"dark\",\n  Z: \"light\",\n  Y: \"re\",\n  X: \"blu\",\n  W: \"gr\",\n  V: \"medium\",\n  U: \"slate\",\n  A: \"ee\",\n  T: \"ol\",\n  S: \"or\",\n  B: \"ra\",\n  C: \"lateg\",\n  D: \"ights\",\n  R: \"in\",\n  Q: \"turquois\",\n  E: \"hi\",\n  P: \"ro\",\n  O: \"al\",\n  N: \"le\",\n  M: \"de\",\n  L: \"yello\",\n  F: \"en\",\n  K: \"ch\",\n  G: \"arks\",\n  H: \"ea\",\n  I: \"ightg\",\n  J: \"wh\"\n};\nvar names$1 = {\n  OiceXe: \"f0f8ff\",\n  antiquewEte: \"faebd7\",\n  aqua: \"ffff\",\n  aquamarRe: \"7fffd4\",\n  azuY: \"f0ffff\",\n  beige: \"f5f5dc\",\n  bisque: \"ffe4c4\",\n  black: \"0\",\n  blanKedOmond: \"ffebcd\",\n  Xe: \"ff\",\n  XeviTet: \"8a2be2\",\n  bPwn: \"a52a2a\",\n  burlywood: \"deb887\",\n  caMtXe: \"5f9ea0\",\n  KartYuse: \"7fff00\",\n  KocTate: \"d2691e\",\n  cSO: \"ff7f50\",\n  cSnflowerXe: \"6495ed\",\n  cSnsilk: \"fff8dc\",\n  crimson: \"dc143c\",\n  cyan: \"ffff\",\n  xXe: \"8b\",\n  xcyan: \"8b8b\",\n  xgTMnPd: \"b8860b\",\n  xWay: \"a9a9a9\",\n  xgYF: \"6400\",\n  xgYy: \"a9a9a9\",\n  xkhaki: \"bdb76b\",\n  xmagFta: \"8b008b\",\n  xTivegYF: \"556b2f\",\n  xSange: \"ff8c00\",\n  xScEd: \"9932cc\",\n  xYd: \"8b0000\",\n  xsOmon: \"e9967a\",\n  xsHgYF: \"8fbc8f\",\n  xUXe: \"483d8b\",\n  xUWay: \"2f4f4f\",\n  xUgYy: \"2f4f4f\",\n  xQe: \"ced1\",\n  xviTet: \"9400d3\",\n  dAppRk: \"ff1493\",\n  dApskyXe: \"bfff\",\n  dimWay: \"696969\",\n  dimgYy: \"696969\",\n  dodgerXe: \"1e90ff\",\n  fiYbrick: \"b22222\",\n  flSOwEte: \"fffaf0\",\n  foYstWAn: \"228b22\",\n  fuKsia: \"ff00ff\",\n  gaRsbSo: \"dcdcdc\",\n  ghostwEte: \"f8f8ff\",\n  gTd: \"ffd700\",\n  gTMnPd: \"daa520\",\n  Way: \"808080\",\n  gYF: \"8000\",\n  gYFLw: \"adff2f\",\n  gYy: \"808080\",\n  honeyMw: \"f0fff0\",\n  hotpRk: \"ff69b4\",\n  RdianYd: \"cd5c5c\",\n  Rdigo: \"4b0082\",\n  ivSy: \"fffff0\",\n  khaki: \"f0e68c\",\n  lavFMr: \"e6e6fa\",\n  lavFMrXsh: \"fff0f5\",\n  lawngYF: \"7cfc00\",\n  NmoncEffon: \"fffacd\",\n  ZXe: \"add8e6\",\n  ZcSO: \"f08080\",\n  Zcyan: \"e0ffff\",\n  ZgTMnPdLw: \"fafad2\",\n  ZWay: \"d3d3d3\",\n  ZgYF: \"90ee90\",\n  ZgYy: \"d3d3d3\",\n  ZpRk: \"ffb6c1\",\n  ZsOmon: \"ffa07a\",\n  ZsHgYF: \"20b2aa\",\n  ZskyXe: \"87cefa\",\n  ZUWay: \"778899\",\n  ZUgYy: \"778899\",\n  ZstAlXe: \"b0c4de\",\n  ZLw: \"ffffe0\",\n  lime: \"ff00\",\n  limegYF: \"32cd32\",\n  lRF: \"faf0e6\",\n  magFta: \"ff00ff\",\n  maPon: \"800000\",\n  VaquamarRe: \"66cdaa\",\n  VXe: \"cd\",\n  VScEd: \"ba55d3\",\n  VpurpN: \"9370db\",\n  VsHgYF: \"3cb371\",\n  VUXe: \"7b68ee\",\n  VsprRggYF: \"fa9a\",\n  VQe: \"48d1cc\",\n  VviTetYd: \"c71585\",\n  midnightXe: \"191970\",\n  mRtcYam: \"f5fffa\",\n  mistyPse: \"ffe4e1\",\n  moccasR: \"ffe4b5\",\n  navajowEte: \"ffdead\",\n  navy: \"80\",\n  Tdlace: \"fdf5e6\",\n  Tive: \"808000\",\n  TivedBb: \"6b8e23\",\n  Sange: \"ffa500\",\n  SangeYd: \"ff4500\",\n  ScEd: \"da70d6\",\n  pOegTMnPd: \"eee8aa\",\n  pOegYF: \"98fb98\",\n  pOeQe: \"afeeee\",\n  pOeviTetYd: \"db7093\",\n  papayawEp: \"ffefd5\",\n  pHKpuff: \"ffdab9\",\n  peru: \"cd853f\",\n  pRk: \"ffc0cb\",\n  plum: \"dda0dd\",\n  powMrXe: \"b0e0e6\",\n  purpN: \"800080\",\n  YbeccapurpN: \"663399\",\n  Yd: \"ff0000\",\n  Psybrown: \"bc8f8f\",\n  PyOXe: \"4169e1\",\n  saddNbPwn: \"8b4513\",\n  sOmon: \"fa8072\",\n  sandybPwn: \"f4a460\",\n  sHgYF: \"2e8b57\",\n  sHshell: \"fff5ee\",\n  siFna: \"a0522d\",\n  silver: \"c0c0c0\",\n  skyXe: \"87ceeb\",\n  UXe: \"6a5acd\",\n  UWay: \"708090\",\n  UgYy: \"708090\",\n  snow: \"fffafa\",\n  sprRggYF: \"ff7f\",\n  stAlXe: \"4682b4\",\n  tan: \"d2b48c\",\n  teO: \"8080\",\n  tEstN: \"d8bfd8\",\n  tomato: \"ff6347\",\n  Qe: \"40e0d0\",\n  viTet: \"ee82ee\",\n  JHt: \"f5deb3\",\n  wEte: \"ffffff\",\n  wEtesmoke: \"f5f5f5\",\n  Lw: \"ffff00\",\n  LwgYF: \"9acd32\"\n};\nfunction unpack() {\n  const unpacked = {};\n  const keys = Object.keys(names$1);\n  const tkeys = Object.keys(map);\n  let i, j, k, ok, nk;\n  for (i = 0; i < keys.length; i++) {\n    ok = nk = keys[i];\n    for (j = 0; j < tkeys.length; j++) {\n      k = tkeys[j];\n      nk = nk.replace(k, map[k]);\n    }\n    k = parseInt(names$1[ok], 16);\n    unpacked[nk] = [k >> 16 & 255, k >> 8 & 255, k & 255];\n  }\n  return unpacked;\n}\nvar names;\nfunction nameParse(str) {\n  if (!names) {\n    names = unpack();\n    names.transparent = [0, 0, 0, 0];\n  }\n  const a = names[str.toLowerCase()];\n  return a && {\n    r: a[0],\n    g: a[1],\n    b: a[2],\n    a: a.length === 4 ? a[3] : 255\n  };\n}\nvar RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction rgbParse(str) {\n  const m = RGB_RE.exec(str);\n  let a = 255;\n  let r, g, b;\n  if (!m) {\n    return;\n  }\n  if (m[7] !== r) {\n    const v = +m[7];\n    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);\n  }\n  r = +m[1];\n  g = +m[3];\n  b = +m[5];\n  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));\n  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));\n  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));\n  return {\n    r,\n    g,\n    b,\n    a\n  };\n}\nfunction rgbString(v) {\n  return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);\n}\nvar to = (v) => v <= 31308e-7 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - 0.055;\nvar from = (v) => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\nfunction interpolate(rgb1, rgb2, t) {\n  const r = from(b2n(rgb1.r));\n  const g = from(b2n(rgb1.g));\n  const b = from(b2n(rgb1.b));\n  return {\n    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),\n    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),\n    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),\n    a: rgb1.a + t * (rgb2.a - rgb1.a)\n  };\n}\nfunction modHSL(v, i, ratio) {\n  if (v) {\n    let tmp = rgb2hsl(v);\n    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n    tmp = hsl2rgb(tmp);\n    v.r = tmp[0];\n    v.g = tmp[1];\n    v.b = tmp[2];\n  }\n}\nfunction clone(v, proto) {\n  return v ? Object.assign(proto || {}, v) : v;\n}\nfunction fromObject(input) {\n  var v = {\n    r: 0,\n    g: 0,\n    b: 0,\n    a: 255\n  };\n  if (Array.isArray(input)) {\n    if (input.length >= 3) {\n      v = {\n        r: input[0],\n        g: input[1],\n        b: input[2],\n        a: 255\n      };\n      if (input.length > 3) {\n        v.a = n2b(input[3]);\n      }\n    }\n  } else {\n    v = clone(input, {\n      r: 0,\n      g: 0,\n      b: 0,\n      a: 1\n    });\n    v.a = n2b(v.a);\n  }\n  return v;\n}\nfunction functionParse(str) {\n  if (str.charAt(0) === \"r\") {\n    return rgbParse(str);\n  }\n  return hueParse(str);\n}\nvar Color = class _Color {\n  constructor(input) {\n    if (input instanceof _Color) {\n      return input;\n    }\n    const type = typeof input;\n    let v;\n    if (type === \"object\") {\n      v = fromObject(input);\n    } else if (type === \"string\") {\n      v = hexParse(input) || nameParse(input) || functionParse(input);\n    }\n    this._rgb = v;\n    this._valid = !!v;\n  }\n  get valid() {\n    return this._valid;\n  }\n  get rgb() {\n    var v = clone(this._rgb);\n    if (v) {\n      v.a = b2n(v.a);\n    }\n    return v;\n  }\n  set rgb(obj) {\n    this._rgb = fromObject(obj);\n  }\n  rgbString() {\n    return this._valid ? rgbString(this._rgb) : void 0;\n  }\n  hexString() {\n    return this._valid ? hexString(this._rgb) : void 0;\n  }\n  hslString() {\n    return this._valid ? hslString(this._rgb) : void 0;\n  }\n  mix(color2, weight) {\n    if (color2) {\n      const c1 = this.rgb;\n      const c2 = color2.rgb;\n      let w2;\n      const p = weight === w2 ? 0.5 : weight;\n      const w = 2 * p - 1;\n      const a = c1.a - c2.a;\n      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;\n      w2 = 1 - w1;\n      c1.r = 255 & w1 * c1.r + w2 * c2.r + 0.5;\n      c1.g = 255 & w1 * c1.g + w2 * c2.g + 0.5;\n      c1.b = 255 & w1 * c1.b + w2 * c2.b + 0.5;\n      c1.a = p * c1.a + (1 - p) * c2.a;\n      this.rgb = c1;\n    }\n    return this;\n  }\n  interpolate(color2, t) {\n    if (color2) {\n      this._rgb = interpolate(this._rgb, color2._rgb, t);\n    }\n    return this;\n  }\n  clone() {\n    return new _Color(this.rgb);\n  }\n  alpha(a) {\n    this._rgb.a = n2b(a);\n    return this;\n  }\n  clearer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 - ratio;\n    return this;\n  }\n  greyscale() {\n    const rgb = this._rgb;\n    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n    rgb.r = rgb.g = rgb.b = val;\n    return this;\n  }\n  opaquer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 + ratio;\n    return this;\n  }\n  negate() {\n    const v = this._rgb;\n    v.r = 255 - v.r;\n    v.g = 255 - v.g;\n    v.b = 255 - v.b;\n    return this;\n  }\n  lighten(ratio) {\n    modHSL(this._rgb, 2, ratio);\n    return this;\n  }\n  darken(ratio) {\n    modHSL(this._rgb, 2, -ratio);\n    return this;\n  }\n  saturate(ratio) {\n    modHSL(this._rgb, 1, ratio);\n    return this;\n  }\n  desaturate(ratio) {\n    modHSL(this._rgb, 1, -ratio);\n    return this;\n  }\n  rotate(deg) {\n    rotate(this._rgb, deg);\n    return this;\n  }\n};\n\n// node_modules/chart.js/dist/chunks/helpers.segment.js\nfunction noop() {\n}\nvar uid = /* @__PURE__ */ (() => {\n  let id = 0;\n  return () => id++;\n})();\nfunction isNullOrUndef(value) {\n  return value === null || value === void 0;\n}\nfunction isArray(value) {\n  if (Array.isArray && Array.isArray(value)) {\n    return true;\n  }\n  const type = Object.prototype.toString.call(value);\n  if (type.slice(0, 7) === \"[object\" && type.slice(-6) === \"Array]\") {\n    return true;\n  }\n  return false;\n}\nfunction isObject(value) {\n  return value !== null && Object.prototype.toString.call(value) === \"[object Object]\";\n}\nfunction isNumberFinite(value) {\n  return (typeof value === \"number\" || value instanceof Number) && isFinite(+value);\n}\nfunction finiteOrDefault(value, defaultValue) {\n  return isNumberFinite(value) ? value : defaultValue;\n}\nfunction valueOrDefault(value, defaultValue) {\n  return typeof value === \"undefined\" ? defaultValue : value;\n}\nvar toPercentage = (value, dimension) => typeof value === \"string\" && value.endsWith(\"%\") ? parseFloat(value) / 100 : +value / dimension;\nvar toDimension = (value, dimension) => typeof value === \"string\" && value.endsWith(\"%\") ? parseFloat(value) / 100 * dimension : +value;\nfunction callback(fn, args, thisArg) {\n  if (fn && typeof fn.call === \"function\") {\n    return fn.apply(thisArg, args);\n  }\n}\nfunction each(loopable, fn, thisArg, reverse) {\n  let i, len, keys;\n  if (isArray(loopable)) {\n    len = loopable.length;\n    if (reverse) {\n      for (i = len - 1; i >= 0; i--) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    }\n  } else if (isObject(loopable)) {\n    keys = Object.keys(loopable);\n    len = keys.length;\n    for (i = 0; i < len; i++) {\n      fn.call(thisArg, loopable[keys[i]], keys[i]);\n    }\n  }\n}\nfunction _elementsEqual(a0, a1) {\n  let i, ilen, v0, v1;\n  if (!a0 || !a1 || a0.length !== a1.length) {\n    return false;\n  }\n  for (i = 0, ilen = a0.length; i < ilen; ++i) {\n    v0 = a0[i];\n    v1 = a1[i];\n    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction clone2(source) {\n  if (isArray(source)) {\n    return source.map(clone2);\n  }\n  if (isObject(source)) {\n    const target = /* @__PURE__ */ Object.create(null);\n    const keys = Object.keys(source);\n    const klen = keys.length;\n    let k = 0;\n    for (; k < klen; ++k) {\n      target[keys[k]] = clone2(source[keys[k]]);\n    }\n    return target;\n  }\n  return source;\n}\nfunction isValidKey(key) {\n  return [\"__proto__\", \"prototype\", \"constructor\"].indexOf(key) === -1;\n}\nfunction _merger(key, target, source, options) {\n  if (!isValidKey(key)) {\n    return;\n  }\n  const tval = target[key];\n  const sval = source[key];\n  if (isObject(tval) && isObject(sval)) {\n    merge(tval, sval, options);\n  } else {\n    target[key] = clone2(sval);\n  }\n}\nfunction merge(target, source, options) {\n  const sources = isArray(source) ? source : [source];\n  const ilen = sources.length;\n  if (!isObject(target)) {\n    return target;\n  }\n  options = options || {};\n  const merger = options.merger || _merger;\n  let current;\n  for (let i = 0; i < ilen; ++i) {\n    current = sources[i];\n    if (!isObject(current)) {\n      continue;\n    }\n    const keys = Object.keys(current);\n    for (let k = 0, klen = keys.length; k < klen; ++k) {\n      merger(keys[k], target, current, options);\n    }\n  }\n  return target;\n}\nfunction mergeIf(target, source) {\n  return merge(target, source, {\n    merger: _mergerIf\n  });\n}\nfunction _mergerIf(key, target, source) {\n  if (!isValidKey(key)) {\n    return;\n  }\n  const tval = target[key];\n  const sval = source[key];\n  if (isObject(tval) && isObject(sval)) {\n    mergeIf(tval, sval);\n  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n    target[key] = clone2(sval);\n  }\n}\nvar keyResolvers = {\n  // Chart.helpers.core resolveObjectKey should resolve empty key to root object\n  \"\": (v) => v,\n  // default resolvers\n  x: (o) => o.x,\n  y: (o) => o.y\n};\nfunction _splitKey(key) {\n  const parts = key.split(\".\");\n  const keys = [];\n  let tmp = \"\";\n  for (const part of parts) {\n    tmp += part;\n    if (tmp.endsWith(\"\\\\\")) {\n      tmp = tmp.slice(0, -1) + \".\";\n    } else {\n      keys.push(tmp);\n      tmp = \"\";\n    }\n  }\n  return keys;\n}\nfunction _getKeyResolver(key) {\n  const keys = _splitKey(key);\n  return (obj) => {\n    for (const k of keys) {\n      if (k === \"\") {\n        break;\n      }\n      obj = obj && obj[k];\n    }\n    return obj;\n  };\n}\nfunction resolveObjectKey(obj, key) {\n  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n  return resolver(obj);\n}\nfunction _capitalize(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\nvar defined = (value) => typeof value !== \"undefined\";\nvar isFunction = (value) => typeof value === \"function\";\nvar setsEqual = (a, b) => {\n  if (a.size !== b.size) {\n    return false;\n  }\n  for (const item of a) {\n    if (!b.has(item)) {\n      return false;\n    }\n  }\n  return true;\n};\nfunction _isClickEvent(e) {\n  return e.type === \"mouseup\" || e.type === \"click\" || e.type === \"contextmenu\";\n}\nvar PI = Math.PI;\nvar TAU = 2 * PI;\nvar PITAU = TAU + PI;\nvar INFINITY = Number.POSITIVE_INFINITY;\nvar RAD_PER_DEG = PI / 180;\nvar HALF_PI = PI / 2;\nvar QUARTER_PI = PI / 4;\nvar TWO_THIRDS_PI = PI * 2 / 3;\nvar log10 = Math.log10;\nvar sign = Math.sign;\nfunction almostEquals(x, y, epsilon) {\n  return Math.abs(x - y) < epsilon;\n}\nfunction niceNum(range) {\n  const roundedRange = Math.round(range);\n  range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;\n  const niceRange = Math.pow(10, Math.floor(log10(range)));\n  const fraction = range / niceRange;\n  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n  return niceFraction * niceRange;\n}\nfunction _factorize(value) {\n  const result = [];\n  const sqrt = Math.sqrt(value);\n  let i;\n  for (i = 1; i < sqrt; i++) {\n    if (value % i === 0) {\n      result.push(i);\n      result.push(value / i);\n    }\n  }\n  if (sqrt === (sqrt | 0)) {\n    result.push(sqrt);\n  }\n  result.sort((a, b) => a - b).pop();\n  return result;\n}\nfunction isNonPrimitive(n) {\n  return typeof n === \"symbol\" || typeof n === \"object\" && n !== null && !(Symbol.toPrimitive in n || \"toString\" in n || \"valueOf\" in n);\n}\nfunction isNumber(n) {\n  return !isNonPrimitive(n) && !isNaN(parseFloat(n)) && isFinite(n);\n}\nfunction almostWhole(x, epsilon) {\n  const rounded = Math.round(x);\n  return rounded - epsilon <= x && rounded + epsilon >= x;\n}\nfunction _setMinAndMaxByKey(array, target, property) {\n  let i, ilen, value;\n  for (i = 0, ilen = array.length; i < ilen; i++) {\n    value = array[i][property];\n    if (!isNaN(value)) {\n      target.min = Math.min(target.min, value);\n      target.max = Math.max(target.max, value);\n    }\n  }\n}\nfunction toRadians(degrees) {\n  return degrees * (PI / 180);\n}\nfunction toDegrees(radians) {\n  return radians * (180 / PI);\n}\nfunction _decimalPlaces(x) {\n  if (!isNumberFinite(x)) {\n    return;\n  }\n  let e = 1;\n  let p = 0;\n  while (Math.round(x * e) / e !== x) {\n    e *= 10;\n    p++;\n  }\n  return p;\n}\nfunction getAngleFromPoint(centrePoint, anglePoint) {\n  const distanceFromXCenter = anglePoint.x - centrePoint.x;\n  const distanceFromYCenter = anglePoint.y - centrePoint.y;\n  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n  if (angle < -0.5 * PI) {\n    angle += TAU;\n  }\n  return {\n    angle,\n    distance: radialDistanceFromCenter\n  };\n}\nfunction distanceBetweenPoints(pt1, pt2) {\n  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\nfunction _angleDiff(a, b) {\n  return (a - b + PITAU) % TAU - PI;\n}\nfunction _normalizeAngle(a) {\n  return (a % TAU + TAU) % TAU;\n}\nfunction _angleBetween(angle, start, end, sameAngleIsFullCircle) {\n  const a = _normalizeAngle(angle);\n  const s = _normalizeAngle(start);\n  const e = _normalizeAngle(end);\n  const angleToStart = _normalizeAngle(s - a);\n  const angleToEnd = _normalizeAngle(e - a);\n  const startToAngle = _normalizeAngle(a - s);\n  const endToAngle = _normalizeAngle(a - e);\n  return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;\n}\nfunction _limitValue(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\nfunction _int16Range(value) {\n  return _limitValue(value, -32768, 32767);\n}\nfunction _isBetween(value, start, end, epsilon = 1e-6) {\n  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\nfunction _lookup(table, value, cmp) {\n  cmp = cmp || ((index2) => table[index2] < value);\n  let hi = table.length - 1;\n  let lo = 0;\n  let mid;\n  while (hi - lo > 1) {\n    mid = lo + hi >> 1;\n    if (cmp(mid)) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n  return {\n    lo,\n    hi\n  };\n}\nvar _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? (index2) => {\n  const ti = table[index2][key];\n  return ti < value || ti === value && table[index2 + 1][key] === value;\n} : (index2) => table[index2][key] < value);\nvar _rlookupByKey = (table, key, value) => _lookup(table, value, (index2) => table[index2][key] >= value);\nfunction _filterBetween(values, min, max) {\n  let start = 0;\n  let end = values.length;\n  while (start < end && values[start] < min) {\n    start++;\n  }\n  while (end > start && values[end - 1] > max) {\n    end--;\n  }\n  return start > 0 || end < values.length ? values.slice(start, end) : values;\n}\nvar arrayEvents = [\"push\", \"pop\", \"shift\", \"splice\", \"unshift\"];\nfunction listenArrayEvents(array, listener) {\n  if (array._chartjs) {\n    array._chartjs.listeners.push(listener);\n    return;\n  }\n  Object.defineProperty(array, \"_chartjs\", {\n    configurable: true,\n    enumerable: false,\n    value: {\n      listeners: [listener]\n    }\n  });\n  arrayEvents.forEach((key) => {\n    const method = \"_onData\" + _capitalize(key);\n    const base = array[key];\n    Object.defineProperty(array, key, {\n      configurable: true,\n      enumerable: false,\n      value(...args) {\n        const res = base.apply(this, args);\n        array._chartjs.listeners.forEach((object) => {\n          if (typeof object[method] === \"function\") {\n            object[method](...args);\n          }\n        });\n        return res;\n      }\n    });\n  });\n}\nfunction unlistenArrayEvents(array, listener) {\n  const stub = array._chartjs;\n  if (!stub) {\n    return;\n  }\n  const listeners = stub.listeners;\n  const index2 = listeners.indexOf(listener);\n  if (index2 !== -1) {\n    listeners.splice(index2, 1);\n  }\n  if (listeners.length > 0) {\n    return;\n  }\n  arrayEvents.forEach((key) => {\n    delete array[key];\n  });\n  delete array._chartjs;\n}\nfunction _arrayUnique(items) {\n  const set2 = new Set(items);\n  if (set2.size === items.length) {\n    return items;\n  }\n  return Array.from(set2);\n}\nvar requestAnimFrame = function() {\n  if (typeof window === \"undefined\") {\n    return function(callback2) {\n      return callback2();\n    };\n  }\n  return window.requestAnimationFrame;\n}();\nfunction throttled(fn, thisArg) {\n  let argsToUse = [];\n  let ticking = false;\n  return function(...args) {\n    argsToUse = args;\n    if (!ticking) {\n      ticking = true;\n      requestAnimFrame.call(window, () => {\n        ticking = false;\n        fn.apply(thisArg, argsToUse);\n      });\n    }\n  };\n}\nfunction debounce(fn, delay) {\n  let timeout;\n  return function(...args) {\n    if (delay) {\n      clearTimeout(timeout);\n      timeout = setTimeout(fn, delay, args);\n    } else {\n      fn.apply(this, args);\n    }\n    return delay;\n  };\n}\nvar _toLeftRightCenter = (align) => align === \"start\" ? \"left\" : align === \"end\" ? \"right\" : \"center\";\nvar _alignStartEnd = (align, start, end) => align === \"start\" ? start : align === \"end\" ? end : (start + end) / 2;\nvar _textX = (align, left, right, rtl) => {\n  const check = rtl ? \"left\" : \"right\";\n  return align === check ? right : align === \"center\" ? (left + right) / 2 : left;\n};\nfunction _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {\n  const pointCount = points.length;\n  let start = 0;\n  let count = pointCount;\n  if (meta._sorted) {\n    const {\n      iScale,\n      vScale,\n      _parsed\n    } = meta;\n    const spanGaps = meta.dataset ? meta.dataset.options ? meta.dataset.options.spanGaps : null : null;\n    const axis = iScale.axis;\n    const {\n      min,\n      max,\n      minDefined,\n      maxDefined\n    } = iScale.getUserBounds();\n    if (minDefined) {\n      start = Math.min(\n        // @ts-expect-error Need to type _parsed\n        _lookupByKey(_parsed, axis, min).lo,\n        // @ts-expect-error Need to fix types on _lookupByKey\n        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo\n      );\n      if (spanGaps) {\n        const distanceToDefinedLo = _parsed.slice(0, start + 1).reverse().findIndex((point) => !isNullOrUndef(point[vScale.axis]));\n        start -= Math.max(0, distanceToDefinedLo);\n      }\n      start = _limitValue(start, 0, pointCount - 1);\n    }\n    if (maxDefined) {\n      let end = Math.max(\n        // @ts-expect-error Need to type _parsed\n        _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,\n        // @ts-expect-error Need to fix types on _lookupByKey\n        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1\n      );\n      if (spanGaps) {\n        const distanceToDefinedHi = _parsed.slice(end - 1).findIndex((point) => !isNullOrUndef(point[vScale.axis]));\n        end += Math.max(0, distanceToDefinedHi);\n      }\n      count = _limitValue(end, start, pointCount) - start;\n    } else {\n      count = pointCount - start;\n    }\n  }\n  return {\n    start,\n    count\n  };\n}\nfunction _scaleRangesChanged(meta) {\n  const {\n    xScale,\n    yScale,\n    _scaleRanges\n  } = meta;\n  const newRanges = {\n    xmin: xScale.min,\n    xmax: xScale.max,\n    ymin: yScale.min,\n    ymax: yScale.max\n  };\n  if (!_scaleRanges) {\n    meta._scaleRanges = newRanges;\n    return true;\n  }\n  const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;\n  Object.assign(_scaleRanges, newRanges);\n  return changed;\n}\nvar atEdge = (t) => t === 0 || t === 1;\nvar elasticIn = (t, s, p) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nvar elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\nvar effects = {\n  linear: (t) => t,\n  easeInQuad: (t) => t * t,\n  easeOutQuad: (t) => -t * (t - 2),\n  easeInOutQuad: (t) => (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),\n  easeInCubic: (t) => t * t * t,\n  easeOutCubic: (t) => (t -= 1) * t * t + 1,\n  easeInOutCubic: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),\n  easeInQuart: (t) => t * t * t * t,\n  easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),\n  easeInOutQuart: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2),\n  easeInQuint: (t) => t * t * t * t * t,\n  easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,\n  easeInOutQuint: (t) => (t /= 0.5) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2),\n  easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,\n  easeOutSine: (t) => Math.sin(t * HALF_PI),\n  easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),\n  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),\n  easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,\n  easeInOutExpo: (t) => atEdge(t) ? t : t < 0.5 ? 0.5 * Math.pow(2, 10 * (t * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n  easeInCirc: (t) => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),\n  easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),\n  easeInOutCirc: (t) => (t /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n  easeInElastic: (t) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n  easeOutElastic: (t) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n  easeInOutElastic(t) {\n    const s = 0.1125;\n    const p = 0.45;\n    return atEdge(t) ? t : t < 0.5 ? 0.5 * elasticIn(t * 2, s, p) : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n  },\n  easeInBack(t) {\n    const s = 1.70158;\n    return t * t * ((s + 1) * t - s);\n  },\n  easeOutBack(t) {\n    const s = 1.70158;\n    return (t -= 1) * t * ((s + 1) * t + s) + 1;\n  },\n  easeInOutBack(t) {\n    let s = 1.70158;\n    if ((t /= 0.5) < 1) {\n      return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));\n    }\n    return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);\n  },\n  easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),\n  easeOutBounce(t) {\n    const m = 7.5625;\n    const d = 2.75;\n    if (t < 1 / d) {\n      return m * t * t;\n    }\n    if (t < 2 / d) {\n      return m * (t -= 1.5 / d) * t + 0.75;\n    }\n    if (t < 2.5 / d) {\n      return m * (t -= 2.25 / d) * t + 0.9375;\n    }\n    return m * (t -= 2.625 / d) * t + 0.984375;\n  },\n  easeInOutBounce: (t) => t < 0.5 ? effects.easeInBounce(t * 2) * 0.5 : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5\n};\nfunction isPatternOrGradient(value) {\n  if (value && typeof value === \"object\") {\n    const type = value.toString();\n    return type === \"[object CanvasPattern]\" || type === \"[object CanvasGradient]\";\n  }\n  return false;\n}\nfunction color(value) {\n  return isPatternOrGradient(value) ? value : new Color(value);\n}\nfunction getHoverColor(value) {\n  return isPatternOrGradient(value) ? value : new Color(value).saturate(0.5).darken(0.1).hexString();\n}\nvar numbers = [\"x\", \"y\", \"borderWidth\", \"radius\", \"tension\"];\nvar colors = [\"color\", \"borderColor\", \"backgroundColor\"];\nfunction applyAnimationsDefaults(defaults2) {\n  defaults2.set(\"animation\", {\n    delay: void 0,\n    duration: 1e3,\n    easing: \"easeOutQuart\",\n    fn: void 0,\n    from: void 0,\n    loop: void 0,\n    to: void 0,\n    type: void 0\n  });\n  defaults2.describe(\"animation\", {\n    _fallback: false,\n    _indexable: false,\n    _scriptable: (name) => name !== \"onProgress\" && name !== \"onComplete\" && name !== \"fn\"\n  });\n  defaults2.set(\"animations\", {\n    colors: {\n      type: \"color\",\n      properties: colors\n    },\n    numbers: {\n      type: \"number\",\n      properties: numbers\n    }\n  });\n  defaults2.describe(\"animations\", {\n    _fallback: \"animation\"\n  });\n  defaults2.set(\"transitions\", {\n    active: {\n      animation: {\n        duration: 400\n      }\n    },\n    resize: {\n      animation: {\n        duration: 0\n      }\n    },\n    show: {\n      animations: {\n        colors: {\n          from: \"transparent\"\n        },\n        visible: {\n          type: \"boolean\",\n          duration: 0\n        }\n      }\n    },\n    hide: {\n      animations: {\n        colors: {\n          to: \"transparent\"\n        },\n        visible: {\n          type: \"boolean\",\n          easing: \"linear\",\n          fn: (v) => v | 0\n        }\n      }\n    }\n  });\n}\nfunction applyLayoutsDefaults(defaults2) {\n  defaults2.set(\"layout\", {\n    autoPadding: true,\n    padding: {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }\n  });\n}\nvar intlCache = /* @__PURE__ */ new Map();\nfunction getNumberFormat(locale, options) {\n  options = options || {};\n  const cacheKey = locale + JSON.stringify(options);\n  let formatter = intlCache.get(cacheKey);\n  if (!formatter) {\n    formatter = new Intl.NumberFormat(locale, options);\n    intlCache.set(cacheKey, formatter);\n  }\n  return formatter;\n}\nfunction formatNumber(num, locale, options) {\n  return getNumberFormat(locale, options).format(num);\n}\nvar formatters = {\n  values(value) {\n    return isArray(value) ? value : \"\" + value;\n  },\n  numeric(tickValue, index2, ticks) {\n    if (tickValue === 0) {\n      return \"0\";\n    }\n    const locale = this.chart.options.locale;\n    let notation;\n    let delta = tickValue;\n    if (ticks.length > 1) {\n      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n      if (maxTick < 1e-4 || maxTick > 1e15) {\n        notation = \"scientific\";\n      }\n      delta = calculateDelta(tickValue, ticks);\n    }\n    const logDelta = log10(Math.abs(delta));\n    const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n    const options = {\n      notation,\n      minimumFractionDigits: numDecimal,\n      maximumFractionDigits: numDecimal\n    };\n    Object.assign(options, this.options.ticks.format);\n    return formatNumber(tickValue, locale, options);\n  },\n  logarithmic(tickValue, index2, ticks) {\n    if (tickValue === 0) {\n      return \"0\";\n    }\n    const remain = ticks[index2].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));\n    if ([1, 2, 3, 5, 10, 15].includes(remain) || index2 > 0.8 * ticks.length) {\n      return formatters.numeric.call(this, tickValue, index2, ticks);\n    }\n    return \"\";\n  }\n};\nfunction calculateDelta(tickValue, ticks) {\n  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n    delta = tickValue - Math.floor(tickValue);\n  }\n  return delta;\n}\nvar Ticks = {\n  formatters\n};\nfunction applyScaleDefaults(defaults2) {\n  defaults2.set(\"scale\", {\n    display: true,\n    offset: false,\n    reverse: false,\n    beginAtZero: false,\n    bounds: \"ticks\",\n    clip: true,\n    grace: 0,\n    grid: {\n      display: true,\n      lineWidth: 1,\n      drawOnChartArea: true,\n      drawTicks: true,\n      tickLength: 8,\n      tickWidth: (_ctx, options) => options.lineWidth,\n      tickColor: (_ctx, options) => options.color,\n      offset: false\n    },\n    border: {\n      display: true,\n      dash: [],\n      dashOffset: 0,\n      width: 1\n    },\n    title: {\n      display: false,\n      text: \"\",\n      padding: {\n        top: 4,\n        bottom: 4\n      }\n    },\n    ticks: {\n      minRotation: 0,\n      maxRotation: 50,\n      mirror: false,\n      textStrokeWidth: 0,\n      textStrokeColor: \"\",\n      padding: 3,\n      display: true,\n      autoSkip: true,\n      autoSkipPadding: 3,\n      labelOffset: 0,\n      callback: Ticks.formatters.values,\n      minor: {},\n      major: {},\n      align: \"center\",\n      crossAlign: \"near\",\n      showLabelBackdrop: false,\n      backdropColor: \"rgba(255, 255, 255, 0.75)\",\n      backdropPadding: 2\n    }\n  });\n  defaults2.route(\"scale.ticks\", \"color\", \"\", \"color\");\n  defaults2.route(\"scale.grid\", \"color\", \"\", \"borderColor\");\n  defaults2.route(\"scale.border\", \"color\", \"\", \"borderColor\");\n  defaults2.route(\"scale.title\", \"color\", \"\", \"color\");\n  defaults2.describe(\"scale\", {\n    _fallback: false,\n    _scriptable: (name) => !name.startsWith(\"before\") && !name.startsWith(\"after\") && name !== \"callback\" && name !== \"parser\",\n    _indexable: (name) => name !== \"borderDash\" && name !== \"tickBorderDash\" && name !== \"dash\"\n  });\n  defaults2.describe(\"scales\", {\n    _fallback: \"scale\"\n  });\n  defaults2.describe(\"scale.ticks\", {\n    _scriptable: (name) => name !== \"backdropPadding\" && name !== \"callback\",\n    _indexable: (name) => name !== \"backdropPadding\"\n  });\n}\nvar overrides = /* @__PURE__ */ Object.create(null);\nvar descriptors = /* @__PURE__ */ Object.create(null);\nfunction getScope$1(node, key) {\n  if (!key) {\n    return node;\n  }\n  const keys = key.split(\".\");\n  for (let i = 0, n = keys.length; i < n; ++i) {\n    const k = keys[i];\n    node = node[k] || (node[k] = /* @__PURE__ */ Object.create(null));\n  }\n  return node;\n}\nfunction set(root, scope, values) {\n  if (typeof scope === \"string\") {\n    return merge(getScope$1(root, scope), values);\n  }\n  return merge(getScope$1(root, \"\"), scope);\n}\nvar Defaults = class {\n  constructor(_descriptors2, _appliers) {\n    this.animation = void 0;\n    this.backgroundColor = \"rgba(0,0,0,0.1)\";\n    this.borderColor = \"rgba(0,0,0,0.1)\";\n    this.color = \"#666\";\n    this.datasets = {};\n    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();\n    this.elements = {};\n    this.events = [\"mousemove\", \"mouseout\", \"click\", \"touchstart\", \"touchmove\"];\n    this.font = {\n      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n      size: 12,\n      style: \"normal\",\n      lineHeight: 1.2,\n      weight: null\n    };\n    this.hover = {};\n    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);\n    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);\n    this.hoverColor = (ctx, options) => getHoverColor(options.color);\n    this.indexAxis = \"x\";\n    this.interaction = {\n      mode: \"nearest\",\n      intersect: true,\n      includeInvisible: false\n    };\n    this.maintainAspectRatio = true;\n    this.onHover = null;\n    this.onClick = null;\n    this.parsing = true;\n    this.plugins = {};\n    this.responsive = true;\n    this.scale = void 0;\n    this.scales = {};\n    this.showLine = true;\n    this.drawActiveElementsOnTop = true;\n    this.describe(_descriptors2);\n    this.apply(_appliers);\n  }\n  set(scope, values) {\n    return set(this, scope, values);\n  }\n  get(scope) {\n    return getScope$1(this, scope);\n  }\n  describe(scope, values) {\n    return set(descriptors, scope, values);\n  }\n  override(scope, values) {\n    return set(overrides, scope, values);\n  }\n  route(scope, name, targetScope, targetName) {\n    const scopeObject = getScope$1(this, scope);\n    const targetScopeObject = getScope$1(this, targetScope);\n    const privateName = \"_\" + name;\n    Object.defineProperties(scopeObject, {\n      [privateName]: {\n        value: scopeObject[name],\n        writable: true\n      },\n      [name]: {\n        enumerable: true,\n        get() {\n          const local = this[privateName];\n          const target = targetScopeObject[targetName];\n          if (isObject(local)) {\n            return Object.assign({}, target, local);\n          }\n          return valueOrDefault(local, target);\n        },\n        set(value) {\n          this[privateName] = value;\n        }\n      }\n    });\n  }\n  apply(appliers) {\n    appliers.forEach((apply) => apply(this));\n  }\n};\nvar defaults = new Defaults({\n  _scriptable: (name) => !name.startsWith(\"on\"),\n  _indexable: (name) => name !== \"events\",\n  hover: {\n    _fallback: \"interaction\"\n  },\n  interaction: {\n    _scriptable: false,\n    _indexable: false\n  }\n}, [applyAnimationsDefaults, applyLayoutsDefaults, applyScaleDefaults]);\nfunction toFontString(font) {\n  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n    return null;\n  }\n  return (font.style ? font.style + \" \" : \"\") + (font.weight ? font.weight + \" \" : \"\") + font.size + \"px \" + font.family;\n}\nfunction _measureText(ctx, data, gc, longest, string) {\n  let textWidth = data[string];\n  if (!textWidth) {\n    textWidth = data[string] = ctx.measureText(string).width;\n    gc.push(string);\n  }\n  if (textWidth > longest) {\n    longest = textWidth;\n  }\n  return longest;\n}\nfunction _longestText(ctx, font, arrayOfThings, cache) {\n  cache = cache || {};\n  let data = cache.data = cache.data || {};\n  let gc = cache.garbageCollect = cache.garbageCollect || [];\n  if (cache.font !== font) {\n    data = cache.data = {};\n    gc = cache.garbageCollect = [];\n    cache.font = font;\n  }\n  ctx.save();\n  ctx.font = font;\n  let longest = 0;\n  const ilen = arrayOfThings.length;\n  let i, j, jlen, thing, nestedThing;\n  for (i = 0; i < ilen; i++) {\n    thing = arrayOfThings[i];\n    if (thing !== void 0 && thing !== null && !isArray(thing)) {\n      longest = _measureText(ctx, data, gc, longest, thing);\n    } else if (isArray(thing)) {\n      for (j = 0, jlen = thing.length; j < jlen; j++) {\n        nestedThing = thing[j];\n        if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) {\n          longest = _measureText(ctx, data, gc, longest, nestedThing);\n        }\n      }\n    }\n  }\n  ctx.restore();\n  const gcLen = gc.length / 2;\n  if (gcLen > arrayOfThings.length) {\n    for (i = 0; i < gcLen; i++) {\n      delete data[gc[i]];\n    }\n    gc.splice(0, gcLen);\n  }\n  return longest;\n}\nfunction _alignPixel(chart, pixel, width) {\n  const devicePixelRatio = chart.currentDevicePixelRatio;\n  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\nfunction clearCanvas(canvas, ctx) {\n  if (!ctx && !canvas) {\n    return;\n  }\n  ctx = ctx || canvas.getContext(\"2d\");\n  ctx.save();\n  ctx.resetTransform();\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.restore();\n}\nfunction drawPoint(ctx, options, x, y) {\n  drawPointLegend(ctx, options, x, y, null);\n}\nfunction drawPointLegend(ctx, options, x, y, w) {\n  let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;\n  const style = options.pointStyle;\n  const rotation = options.rotation;\n  const radius = options.radius;\n  let rad = (rotation || 0) * RAD_PER_DEG;\n  if (style && typeof style === \"object\") {\n    type = style.toString();\n    if (type === \"[object HTMLImageElement]\" || type === \"[object HTMLCanvasElement]\") {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(rad);\n      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n      ctx.restore();\n      return;\n    }\n  }\n  if (isNaN(radius) || radius <= 0) {\n    return;\n  }\n  ctx.beginPath();\n  switch (style) {\n    // Default includes circle\n    default:\n      if (w) {\n        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n      } else {\n        ctx.arc(x, y, radius, 0, TAU);\n      }\n      ctx.closePath();\n      break;\n    case \"triangle\":\n      width = w ? w / 2 : radius;\n      ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      ctx.closePath();\n      break;\n    case \"rectRounded\":\n      cornerRadius = radius * 0.516;\n      size = radius - cornerRadius;\n      xOffset = Math.cos(rad + QUARTER_PI) * size;\n      xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n      yOffset = Math.sin(rad + QUARTER_PI) * size;\n      yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n      ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n      ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n      ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n      ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n      ctx.closePath();\n      break;\n    case \"rect\":\n      if (!rotation) {\n        size = Math.SQRT1_2 * radius;\n        width = w ? w / 2 : size;\n        ctx.rect(x - width, y - size, 2 * width, 2 * size);\n        break;\n      }\n      rad += QUARTER_PI;\n    /* falls through */\n    case \"rectRot\":\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      ctx.closePath();\n      break;\n    case \"crossRot\":\n      rad += QUARTER_PI;\n    /* falls through */\n    case \"cross\":\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      break;\n    case \"star\":\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      rad += QUARTER_PI;\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      break;\n    case \"line\":\n      xOffset = w ? w / 2 : Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      break;\n    case \"dash\":\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);\n      break;\n    case false:\n      ctx.closePath();\n      break;\n  }\n  ctx.fill();\n  if (options.borderWidth > 0) {\n    ctx.stroke();\n  }\n}\nfunction _isPointInArea(point, area, margin) {\n  margin = margin || 0.5;\n  return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;\n}\nfunction clipArea(ctx, area) {\n  ctx.save();\n  ctx.beginPath();\n  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n  ctx.clip();\n}\nfunction unclipArea(ctx) {\n  ctx.restore();\n}\nfunction _steppedLineTo(ctx, previous, target, flip, mode) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  if (mode === \"middle\") {\n    const midpoint = (previous.x + target.x) / 2;\n    ctx.lineTo(midpoint, previous.y);\n    ctx.lineTo(midpoint, target.y);\n  } else if (mode === \"after\" !== !!flip) {\n    ctx.lineTo(previous.x, target.y);\n  } else {\n    ctx.lineTo(target.x, previous.y);\n  }\n  ctx.lineTo(target.x, target.y);\n}\nfunction _bezierCurveTo(ctx, previous, target, flip) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);\n}\nfunction setRenderOpts(ctx, opts) {\n  if (opts.translation) {\n    ctx.translate(opts.translation[0], opts.translation[1]);\n  }\n  if (!isNullOrUndef(opts.rotation)) {\n    ctx.rotate(opts.rotation);\n  }\n  if (opts.color) {\n    ctx.fillStyle = opts.color;\n  }\n  if (opts.textAlign) {\n    ctx.textAlign = opts.textAlign;\n  }\n  if (opts.textBaseline) {\n    ctx.textBaseline = opts.textBaseline;\n  }\n}\nfunction decorateText(ctx, x, y, line, opts) {\n  if (opts.strikethrough || opts.underline) {\n    const metrics = ctx.measureText(line);\n    const left = x - metrics.actualBoundingBoxLeft;\n    const right = x + metrics.actualBoundingBoxRight;\n    const top = y - metrics.actualBoundingBoxAscent;\n    const bottom = y + metrics.actualBoundingBoxDescent;\n    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n    ctx.strokeStyle = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.lineWidth = opts.decorationWidth || 2;\n    ctx.moveTo(left, yDecoration);\n    ctx.lineTo(right, yDecoration);\n    ctx.stroke();\n  }\n}\nfunction drawBackdrop(ctx, opts) {\n  const oldColor = ctx.fillStyle;\n  ctx.fillStyle = opts.color;\n  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);\n  ctx.fillStyle = oldColor;\n}\nfunction renderText(ctx, text, x, y, font, opts = {}) {\n  const lines = isArray(text) ? text : [text];\n  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== \"\";\n  let i, line;\n  ctx.save();\n  ctx.font = font.string;\n  setRenderOpts(ctx, opts);\n  for (i = 0; i < lines.length; ++i) {\n    line = lines[i];\n    if (opts.backdrop) {\n      drawBackdrop(ctx, opts.backdrop);\n    }\n    if (stroke) {\n      if (opts.strokeColor) {\n        ctx.strokeStyle = opts.strokeColor;\n      }\n      if (!isNullOrUndef(opts.strokeWidth)) {\n        ctx.lineWidth = opts.strokeWidth;\n      }\n      ctx.strokeText(line, x, y, opts.maxWidth);\n    }\n    ctx.fillText(line, x, y, opts.maxWidth);\n    decorateText(ctx, x, y, line, opts);\n    y += Number(font.lineHeight);\n  }\n  ctx.restore();\n}\nfunction addRoundedRectPath(ctx, rect) {\n  const {\n    x,\n    y,\n    w,\n    h,\n    radius\n  } = rect;\n  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);\n  ctx.lineTo(x, y + h - radius.bottomLeft);\n  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n  ctx.lineTo(x + w - radius.bottomRight, y + h);\n  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n  ctx.lineTo(x + w, y + radius.topRight);\n  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n  ctx.lineTo(x + radius.topLeft, y);\n}\nvar LINE_HEIGHT = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/;\nvar FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\nfunction toLineHeight(value, size) {\n  const matches = (\"\" + value).match(LINE_HEIGHT);\n  if (!matches || matches[1] === \"normal\") {\n    return size * 1.2;\n  }\n  value = +matches[2];\n  switch (matches[3]) {\n    case \"px\":\n      return value;\n    case \"%\":\n      value /= 100;\n      break;\n  }\n  return size * value;\n}\nvar numberOrZero = (v) => +v || 0;\nfunction _readValueToProps(value, props) {\n  const ret = {};\n  const objProps = isObject(props);\n  const keys = objProps ? Object.keys(props) : props;\n  const read = isObject(value) ? objProps ? (prop) => valueOrDefault(value[prop], value[props[prop]]) : (prop) => value[prop] : () => value;\n  for (const prop of keys) {\n    ret[prop] = numberOrZero(read(prop));\n  }\n  return ret;\n}\nfunction toTRBL(value) {\n  return _readValueToProps(value, {\n    top: \"y\",\n    right: \"x\",\n    bottom: \"y\",\n    left: \"x\"\n  });\n}\nfunction toTRBLCorners(value) {\n  return _readValueToProps(value, [\"topLeft\", \"topRight\", \"bottomLeft\", \"bottomRight\"]);\n}\nfunction toPadding(value) {\n  const obj = toTRBL(value);\n  obj.width = obj.left + obj.right;\n  obj.height = obj.top + obj.bottom;\n  return obj;\n}\nfunction toFont(options, fallback) {\n  options = options || {};\n  fallback = fallback || defaults.font;\n  let size = valueOrDefault(options.size, fallback.size);\n  if (typeof size === \"string\") {\n    size = parseInt(size, 10);\n  }\n  let style = valueOrDefault(options.style, fallback.style);\n  if (style && !(\"\" + style).match(FONT_STYLE)) {\n    console.warn('Invalid font style specified: \"' + style + '\"');\n    style = void 0;\n  }\n  const font = {\n    family: valueOrDefault(options.family, fallback.family),\n    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n    size,\n    style,\n    weight: valueOrDefault(options.weight, fallback.weight),\n    string: \"\"\n  };\n  font.string = toFontString(font);\n  return font;\n}\nfunction resolve(inputs, context, index2, info) {\n  let cacheable = true;\n  let i, ilen, value;\n  for (i = 0, ilen = inputs.length; i < ilen; ++i) {\n    value = inputs[i];\n    if (value === void 0) {\n      continue;\n    }\n    if (context !== void 0 && typeof value === \"function\") {\n      value = value(context);\n      cacheable = false;\n    }\n    if (index2 !== void 0 && isArray(value)) {\n      value = value[index2 % value.length];\n      cacheable = false;\n    }\n    if (value !== void 0) {\n      if (info && !cacheable) {\n        info.cacheable = false;\n      }\n      return value;\n    }\n  }\n}\nfunction _addGrace(minmax, grace, beginAtZero) {\n  const {\n    min,\n    max\n  } = minmax;\n  const change = toDimension(grace, (max - min) / 2);\n  const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;\n  return {\n    min: keepZero(min, -Math.abs(change)),\n    max: keepZero(max, change)\n  };\n}\nfunction createContext(parentContext, context) {\n  return Object.assign(Object.create(parentContext), context);\n}\nfunction _createResolver(scopes, prefixes = [\"\"], rootScopes, fallback, getTarget = () => scopes[0]) {\n  const finalRootScopes = rootScopes || scopes;\n  if (typeof fallback === \"undefined\") {\n    fallback = _resolve(\"_fallback\", scopes);\n  }\n  const cache = {\n    [Symbol.toStringTag]: \"Object\",\n    _cacheable: true,\n    _scopes: scopes,\n    _rootScopes: finalRootScopes,\n    _fallback: fallback,\n    _getTarget: getTarget,\n    override: (scope) => _createResolver([scope, ...scopes], prefixes, finalRootScopes, fallback)\n  };\n  return new Proxy(cache, {\n    /**\n    * A trap for the delete operator.\n    */\n    deleteProperty(target, prop) {\n      delete target[prop];\n      delete target._keys;\n      delete scopes[0][prop];\n      return true;\n    },\n    /**\n    * A trap for getting property values.\n    */\n    get(target, prop) {\n      return _cached(target, prop, () => _resolveWithPrefixes(prop, prefixes, scopes, target));\n    },\n    /**\n    * A trap for Object.getOwnPropertyDescriptor.\n    * Also used by Object.hasOwnProperty.\n    */\n    getOwnPropertyDescriptor(target, prop) {\n      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n    },\n    /**\n    * A trap for Object.getPrototypeOf.\n    */\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(scopes[0]);\n    },\n    /**\n    * A trap for the in operator.\n    */\n    has(target, prop) {\n      return getKeysFromAllScopes(target).includes(prop);\n    },\n    /**\n    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n    */\n    ownKeys(target) {\n      return getKeysFromAllScopes(target);\n    },\n    /**\n    * A trap for setting property values.\n    */\n    set(target, prop, value) {\n      const storage = target._storage || (target._storage = getTarget());\n      target[prop] = storage[prop] = value;\n      delete target._keys;\n      return true;\n    }\n  });\n}\nfunction _attachContext(proxy, context, subProxy, descriptorDefaults) {\n  const cache = {\n    _cacheable: false,\n    _proxy: proxy,\n    _context: context,\n    _subProxy: subProxy,\n    _stack: /* @__PURE__ */ new Set(),\n    _descriptors: _descriptors(proxy, descriptorDefaults),\n    setContext: (ctx) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),\n    override: (scope) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n  };\n  return new Proxy(cache, {\n    /**\n    * A trap for the delete operator.\n    */\n    deleteProperty(target, prop) {\n      delete target[prop];\n      delete proxy[prop];\n      return true;\n    },\n    /**\n    * A trap for getting property values.\n    */\n    get(target, prop, receiver) {\n      return _cached(target, prop, () => _resolveWithContext(target, prop, receiver));\n    },\n    /**\n    * A trap for Object.getOwnPropertyDescriptor.\n    * Also used by Object.hasOwnProperty.\n    */\n    getOwnPropertyDescriptor(target, prop) {\n      return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {\n        enumerable: true,\n        configurable: true\n      } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);\n    },\n    /**\n    * A trap for Object.getPrototypeOf.\n    */\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(proxy);\n    },\n    /**\n    * A trap for the in operator.\n    */\n    has(target, prop) {\n      return Reflect.has(proxy, prop);\n    },\n    /**\n    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n    */\n    ownKeys() {\n      return Reflect.ownKeys(proxy);\n    },\n    /**\n    * A trap for setting property values.\n    */\n    set(target, prop, value) {\n      proxy[prop] = value;\n      delete target[prop];\n      return true;\n    }\n  });\n}\nfunction _descriptors(proxy, defaults2 = {\n  scriptable: true,\n  indexable: true\n}) {\n  const {\n    _scriptable = defaults2.scriptable,\n    _indexable = defaults2.indexable,\n    _allKeys = defaults2.allKeys\n  } = proxy;\n  return {\n    allKeys: _allKeys,\n    scriptable: _scriptable,\n    indexable: _indexable,\n    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,\n    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable\n  };\n}\nvar readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;\nvar needsSubResolver = (prop, value) => isObject(value) && prop !== \"adapters\" && (Object.getPrototypeOf(value) === null || value.constructor === Object);\nfunction _cached(target, prop, resolve2) {\n  if (Object.prototype.hasOwnProperty.call(target, prop) || prop === \"constructor\") {\n    return target[prop];\n  }\n  const value = resolve2();\n  target[prop] = value;\n  return value;\n}\nfunction _resolveWithContext(target, prop, receiver) {\n  const {\n    _proxy,\n    _context,\n    _subProxy,\n    _descriptors: descriptors2\n  } = target;\n  let value = _proxy[prop];\n  if (isFunction(value) && descriptors2.isScriptable(prop)) {\n    value = _resolveScriptable(prop, value, target, receiver);\n  }\n  if (isArray(value) && value.length) {\n    value = _resolveArray(prop, value, target, descriptors2.isIndexable);\n  }\n  if (needsSubResolver(prop, value)) {\n    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors2);\n  }\n  return value;\n}\nfunction _resolveScriptable(prop, getValue, target, receiver) {\n  const {\n    _proxy,\n    _context,\n    _subProxy,\n    _stack\n  } = target;\n  if (_stack.has(prop)) {\n    throw new Error(\"Recursion detected: \" + Array.from(_stack).join(\"->\") + \"->\" + prop);\n  }\n  _stack.add(prop);\n  let value = getValue(_context, _subProxy || receiver);\n  _stack.delete(prop);\n  if (needsSubResolver(prop, value)) {\n    value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n  }\n  return value;\n}\nfunction _resolveArray(prop, value, target, isIndexable) {\n  const {\n    _proxy,\n    _context,\n    _subProxy,\n    _descriptors: descriptors2\n  } = target;\n  if (typeof _context.index !== \"undefined\" && isIndexable(prop)) {\n    return value[_context.index % value.length];\n  } else if (isObject(value[0])) {\n    const arr = value;\n    const scopes = _proxy._scopes.filter((s) => s !== arr);\n    value = [];\n    for (const item of arr) {\n      const resolver = createSubResolver(scopes, _proxy, prop, item);\n      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors2));\n    }\n  }\n  return value;\n}\nfunction resolveFallback(fallback, prop, value) {\n  return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\nvar getScope = (key, parent) => key === true ? parent : typeof key === \"string\" ? resolveObjectKey(parent, key) : void 0;\nfunction addScopes(set2, parentScopes, key, parentFallback, value) {\n  for (const parent of parentScopes) {\n    const scope = getScope(key, parent);\n    if (scope) {\n      set2.add(scope);\n      const fallback = resolveFallback(scope._fallback, key, value);\n      if (typeof fallback !== \"undefined\" && fallback !== key && fallback !== parentFallback) {\n        return fallback;\n      }\n    } else if (scope === false && typeof parentFallback !== \"undefined\" && key !== parentFallback) {\n      return null;\n    }\n  }\n  return false;\n}\nfunction createSubResolver(parentScopes, resolver, prop, value) {\n  const rootScopes = resolver._rootScopes;\n  const fallback = resolveFallback(resolver._fallback, prop, value);\n  const allScopes = [...parentScopes, ...rootScopes];\n  const set2 = /* @__PURE__ */ new Set();\n  set2.add(value);\n  let key = addScopesFromKey(set2, allScopes, prop, fallback || prop, value);\n  if (key === null) {\n    return false;\n  }\n  if (typeof fallback !== \"undefined\" && fallback !== prop) {\n    key = addScopesFromKey(set2, allScopes, fallback, key, value);\n    if (key === null) {\n      return false;\n    }\n  }\n  return _createResolver(Array.from(set2), [\"\"], rootScopes, fallback, () => subGetTarget(resolver, prop, value));\n}\nfunction addScopesFromKey(set2, allScopes, key, fallback, item) {\n  while (key) {\n    key = addScopes(set2, allScopes, key, fallback, item);\n  }\n  return key;\n}\nfunction subGetTarget(resolver, prop, value) {\n  const parent = resolver._getTarget();\n  if (!(prop in parent)) {\n    parent[prop] = {};\n  }\n  const target = parent[prop];\n  if (isArray(target) && isObject(value)) {\n    return value;\n  }\n  return target || {};\n}\nfunction _resolveWithPrefixes(prop, prefixes, scopes, proxy) {\n  let value;\n  for (const prefix of prefixes) {\n    value = _resolve(readKey(prefix, prop), scopes);\n    if (typeof value !== \"undefined\") {\n      return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;\n    }\n  }\n}\nfunction _resolve(key, scopes) {\n  for (const scope of scopes) {\n    if (!scope) {\n      continue;\n    }\n    const value = scope[key];\n    if (typeof value !== \"undefined\") {\n      return value;\n    }\n  }\n}\nfunction getKeysFromAllScopes(target) {\n  let keys = target._keys;\n  if (!keys) {\n    keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n  }\n  return keys;\n}\nfunction resolveKeysFromAllScopes(scopes) {\n  const set2 = /* @__PURE__ */ new Set();\n  for (const scope of scopes) {\n    for (const key of Object.keys(scope).filter((k) => !k.startsWith(\"_\"))) {\n      set2.add(key);\n    }\n  }\n  return Array.from(set2);\n}\nfunction _parseObjectDataRadialScale(meta, data, start, count) {\n  const {\n    iScale\n  } = meta;\n  const {\n    key = \"r\"\n  } = this._parsing;\n  const parsed = new Array(count);\n  let i, ilen, index2, item;\n  for (i = 0, ilen = count; i < ilen; ++i) {\n    index2 = i + start;\n    item = data[index2];\n    parsed[i] = {\n      r: iScale.parse(resolveObjectKey(item, key), index2)\n    };\n  }\n  return parsed;\n}\nvar EPSILON = Number.EPSILON || 1e-14;\nvar getPoint = (points, i) => i < points.length && !points[i].skip && points[i];\nvar getValueAxis = (indexAxis) => indexAxis === \"x\" ? \"y\" : \"x\";\nfunction splineCurve(firstPoint, middlePoint, afterPoint, t) {\n  const previous = firstPoint.skip ? middlePoint : firstPoint;\n  const current = middlePoint;\n  const next = afterPoint.skip ? middlePoint : afterPoint;\n  const d01 = distanceBetweenPoints(current, previous);\n  const d12 = distanceBetweenPoints(next, current);\n  let s01 = d01 / (d01 + d12);\n  let s12 = d12 / (d01 + d12);\n  s01 = isNaN(s01) ? 0 : s01;\n  s12 = isNaN(s12) ? 0 : s12;\n  const fa = t * s01;\n  const fb = t * s12;\n  return {\n    previous: {\n      x: current.x - fa * (next.x - previous.x),\n      y: current.y - fa * (next.y - previous.y)\n    },\n    next: {\n      x: current.x + fb * (next.x - previous.x),\n      y: current.y + fb * (next.y - previous.y)\n    }\n  };\n}\nfunction monotoneAdjust(points, deltaK, mK) {\n  const pointsLen = points.length;\n  let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n  for (let i = 0; i < pointsLen - 1; ++i) {\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent || !pointAfter) {\n      continue;\n    }\n    if (almostEquals(deltaK[i], 0, EPSILON)) {\n      mK[i] = mK[i + 1] = 0;\n      continue;\n    }\n    alphaK = mK[i] / deltaK[i];\n    betaK = mK[i + 1] / deltaK[i];\n    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n    if (squaredMagnitude <= 9) {\n      continue;\n    }\n    tauK = 3 / Math.sqrt(squaredMagnitude);\n    mK[i] = alphaK * tauK * deltaK[i];\n    mK[i + 1] = betaK * tauK * deltaK[i];\n  }\n}\nfunction monotoneCompute(points, mK, indexAxis = \"x\") {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  let delta, pointBefore, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n  for (let i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n    const iPixel = pointCurrent[indexAxis];\n    const vPixel = pointCurrent[valueAxis];\n    if (pointBefore) {\n      delta = (iPixel - pointBefore[indexAxis]) / 3;\n      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n    }\n    if (pointAfter) {\n      delta = (pointAfter[indexAxis] - iPixel) / 3;\n      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n    }\n  }\n}\nfunction splineCurveMonotone(points, indexAxis = \"x\") {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  const deltaK = Array(pointsLen).fill(0);\n  const mK = Array(pointsLen);\n  let i, pointBefore, pointCurrent;\n  let pointAfter = getPoint(points, 0);\n  for (i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n    if (pointAfter) {\n      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n    }\n    mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;\n  }\n  monotoneAdjust(points, deltaK, mK);\n  monotoneCompute(points, mK, indexAxis);\n}\nfunction capControlPoint(pt, min, max) {\n  return Math.max(Math.min(pt, max), min);\n}\nfunction capBezierPoints(points, area) {\n  let i, ilen, point, inArea, inAreaPrev;\n  let inAreaNext = _isPointInArea(points[0], area);\n  for (i = 0, ilen = points.length; i < ilen; ++i) {\n    inAreaPrev = inArea;\n    inArea = inAreaNext;\n    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n    if (!inArea) {\n      continue;\n    }\n    point = points[i];\n    if (inAreaPrev) {\n      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n    }\n    if (inAreaNext) {\n      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n    }\n  }\n}\nfunction _updateBezierControlPoints(points, options, area, loop, indexAxis) {\n  let i, ilen, point, controlPoints;\n  if (options.spanGaps) {\n    points = points.filter((pt) => !pt.skip);\n  }\n  if (options.cubicInterpolationMode === \"monotone\") {\n    splineCurveMonotone(points, indexAxis);\n  } else {\n    let prev = loop ? points[points.length - 1] : points[0];\n    for (i = 0, ilen = points.length; i < ilen; ++i) {\n      point = points[i];\n      controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);\n      point.cp1x = controlPoints.previous.x;\n      point.cp1y = controlPoints.previous.y;\n      point.cp2x = controlPoints.next.x;\n      point.cp2y = controlPoints.next.y;\n      prev = point;\n    }\n  }\n  if (options.capBezierPoints) {\n    capBezierPoints(points, area);\n  }\n}\nfunction _isDomSupported() {\n  return typeof window !== \"undefined\" && typeof document !== \"undefined\";\n}\nfunction _getParentNode(domNode) {\n  let parent = domNode.parentNode;\n  if (parent && parent.toString() === \"[object ShadowRoot]\") {\n    parent = parent.host;\n  }\n  return parent;\n}\nfunction parseMaxStyle(styleValue, node, parentProperty) {\n  let valueInPixels;\n  if (typeof styleValue === \"string\") {\n    valueInPixels = parseInt(styleValue, 10);\n    if (styleValue.indexOf(\"%\") !== -1) {\n      valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];\n    }\n  } else {\n    valueInPixels = styleValue;\n  }\n  return valueInPixels;\n}\nvar getComputedStyle = (element) => element.ownerDocument.defaultView.getComputedStyle(element, null);\nfunction getStyle(el, property) {\n  return getComputedStyle(el).getPropertyValue(property);\n}\nvar positions = [\"top\", \"right\", \"bottom\", \"left\"];\nfunction getPositionedStyle(styles, style, suffix) {\n  const result = {};\n  suffix = suffix ? \"-\" + suffix : \"\";\n  for (let i = 0; i < 4; i++) {\n    const pos = positions[i];\n    result[pos] = parseFloat(styles[style + \"-\" + pos + suffix]) || 0;\n  }\n  result.width = result.left + result.right;\n  result.height = result.top + result.bottom;\n  return result;\n}\nvar useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);\nfunction getCanvasPosition(e, canvas) {\n  const touches = e.touches;\n  const source = touches && touches.length ? touches[0] : e;\n  const {\n    offsetX,\n    offsetY\n  } = source;\n  let box = false;\n  let x, y;\n  if (useOffsetPos(offsetX, offsetY, e.target)) {\n    x = offsetX;\n    y = offsetY;\n  } else {\n    const rect = canvas.getBoundingClientRect();\n    x = source.clientX - rect.left;\n    y = source.clientY - rect.top;\n    box = true;\n  }\n  return {\n    x,\n    y,\n    box\n  };\n}\nfunction getRelativePosition(event, chart) {\n  if (\"native\" in event) {\n    return event;\n  }\n  const {\n    canvas,\n    currentDevicePixelRatio\n  } = chart;\n  const style = getComputedStyle(canvas);\n  const borderBox = style.boxSizing === \"border-box\";\n  const paddings = getPositionedStyle(style, \"padding\");\n  const borders = getPositionedStyle(style, \"border\", \"width\");\n  const {\n    x,\n    y,\n    box\n  } = getCanvasPosition(event, canvas);\n  const xOffset = paddings.left + (box && borders.left);\n  const yOffset = paddings.top + (box && borders.top);\n  let {\n    width,\n    height\n  } = chart;\n  if (borderBox) {\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  return {\n    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n  };\n}\nfunction getContainerSize(canvas, width, height) {\n  let maxWidth, maxHeight;\n  if (width === void 0 || height === void 0) {\n    const container = canvas && _getParentNode(canvas);\n    if (!container) {\n      width = canvas.clientWidth;\n      height = canvas.clientHeight;\n    } else {\n      const rect = container.getBoundingClientRect();\n      const containerStyle = getComputedStyle(container);\n      const containerBorder = getPositionedStyle(containerStyle, \"border\", \"width\");\n      const containerPadding = getPositionedStyle(containerStyle, \"padding\");\n      width = rect.width - containerPadding.width - containerBorder.width;\n      height = rect.height - containerPadding.height - containerBorder.height;\n      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, \"clientWidth\");\n      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, \"clientHeight\");\n    }\n  }\n  return {\n    width,\n    height,\n    maxWidth: maxWidth || INFINITY,\n    maxHeight: maxHeight || INFINITY\n  };\n}\nvar round1 = (v) => Math.round(v * 10) / 10;\nfunction getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {\n  const style = getComputedStyle(canvas);\n  const margins = getPositionedStyle(style, \"margin\");\n  const maxWidth = parseMaxStyle(style.maxWidth, canvas, \"clientWidth\") || INFINITY;\n  const maxHeight = parseMaxStyle(style.maxHeight, canvas, \"clientHeight\") || INFINITY;\n  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n  let {\n    width,\n    height\n  } = containerSize;\n  if (style.boxSizing === \"content-box\") {\n    const borders = getPositionedStyle(style, \"border\", \"width\");\n    const paddings = getPositionedStyle(style, \"padding\");\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  width = Math.max(0, width - margins.width);\n  height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);\n  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n  if (width && !height) {\n    height = round1(width / 2);\n  }\n  const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;\n  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {\n    height = containerSize.height;\n    width = round1(Math.floor(height * aspectRatio));\n  }\n  return {\n    width,\n    height\n  };\n}\nfunction retinaScale(chart, forceRatio, forceStyle) {\n  const pixelRatio = forceRatio || 1;\n  const deviceHeight = Math.floor(chart.height * pixelRatio);\n  const deviceWidth = Math.floor(chart.width * pixelRatio);\n  chart.height = Math.floor(chart.height);\n  chart.width = Math.floor(chart.width);\n  const canvas = chart.canvas;\n  if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {\n    canvas.style.height = `${chart.height}px`;\n    canvas.style.width = `${chart.width}px`;\n  }\n  if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {\n    chart.currentDevicePixelRatio = pixelRatio;\n    canvas.height = deviceHeight;\n    canvas.width = deviceWidth;\n    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    return true;\n  }\n  return false;\n}\nvar supportsEventListenerOptions = function() {\n  let passiveSupported = false;\n  try {\n    const options = {\n      get passive() {\n        passiveSupported = true;\n        return false;\n      }\n    };\n    if (_isDomSupported()) {\n      window.addEventListener(\"test\", null, options);\n      window.removeEventListener(\"test\", null, options);\n    }\n  } catch (e) {\n  }\n  return passiveSupported;\n}();\nfunction readUsedSize(element, property) {\n  const value = getStyle(element, property);\n  const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n  return matches ? +matches[1] : void 0;\n}\nfunction _pointInLine(p1, p2, t, mode) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: p1.y + t * (p2.y - p1.y)\n  };\n}\nfunction _steppedInterpolation(p1, p2, t, mode) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: mode === \"middle\" ? t < 0.5 ? p1.y : p2.y : mode === \"after\" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y\n  };\n}\nfunction _bezierInterpolation(p1, p2, t, mode) {\n  const cp1 = {\n    x: p1.cp2x,\n    y: p1.cp2y\n  };\n  const cp2 = {\n    x: p2.cp1x,\n    y: p2.cp1y\n  };\n  const a = _pointInLine(p1, cp1, t);\n  const b = _pointInLine(cp1, cp2, t);\n  const c = _pointInLine(cp2, p2, t);\n  const d = _pointInLine(a, b, t);\n  const e = _pointInLine(b, c, t);\n  return _pointInLine(d, e, t);\n}\nvar getRightToLeftAdapter = function(rectX, width) {\n  return {\n    x(x) {\n      return rectX + rectX + width - x;\n    },\n    setWidth(w) {\n      width = w;\n    },\n    textAlign(align) {\n      if (align === \"center\") {\n        return align;\n      }\n      return align === \"right\" ? \"left\" : \"right\";\n    },\n    xPlus(x, value) {\n      return x - value;\n    },\n    leftForLtr(x, itemWidth) {\n      return x - itemWidth;\n    }\n  };\n};\nvar getLeftToRightAdapter = function() {\n  return {\n    x(x) {\n      return x;\n    },\n    setWidth(w) {\n    },\n    textAlign(align) {\n      return align;\n    },\n    xPlus(x, value) {\n      return x + value;\n    },\n    leftForLtr(x, _itemWidth) {\n      return x;\n    }\n  };\n};\nfunction getRtlAdapter(rtl, rectX, width) {\n  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\nfunction overrideTextDirection(ctx, direction) {\n  let style, original;\n  if (direction === \"ltr\" || direction === \"rtl\") {\n    style = ctx.canvas.style;\n    original = [style.getPropertyValue(\"direction\"), style.getPropertyPriority(\"direction\")];\n    style.setProperty(\"direction\", direction, \"important\");\n    ctx.prevTextDirection = original;\n  }\n}\nfunction restoreTextDirection(ctx, original) {\n  if (original !== void 0) {\n    delete ctx.prevTextDirection;\n    ctx.canvas.style.setProperty(\"direction\", original[0], original[1]);\n  }\n}\nfunction propertyFn(property) {\n  if (property === \"angle\") {\n    return {\n      between: _angleBetween,\n      compare: _angleDiff,\n      normalize: _normalizeAngle\n    };\n  }\n  return {\n    between: _isBetween,\n    compare: (a, b) => a - b,\n    normalize: (x) => x\n  };\n}\nfunction normalizeSegment({\n  start,\n  end,\n  count,\n  loop,\n  style\n}) {\n  return {\n    start: start % count,\n    end: end % count,\n    loop: loop && (end - start + 1) % count === 0,\n    style\n  };\n}\nfunction getSegment(segment, points, bounds) {\n  const {\n    property,\n    start: startBound,\n    end: endBound\n  } = bounds;\n  const {\n    between,\n    normalize\n  } = propertyFn(property);\n  const count = points.length;\n  let {\n    start,\n    end,\n    loop\n  } = segment;\n  let i, ilen;\n  if (loop) {\n    start += count;\n    end += count;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n        break;\n      }\n      start--;\n      end--;\n    }\n    start %= count;\n    end %= count;\n  }\n  if (end < start) {\n    end += count;\n  }\n  return {\n    start,\n    end,\n    loop,\n    style: segment.style\n  };\n}\nfunction _boundSegment(segment, points, bounds) {\n  if (!bounds) {\n    return [segment];\n  }\n  const {\n    property,\n    start: startBound,\n    end: endBound\n  } = bounds;\n  const count = points.length;\n  const {\n    compare,\n    between,\n    normalize\n  } = propertyFn(property);\n  const {\n    start,\n    end,\n    loop,\n    style\n  } = getSegment(segment, points, bounds);\n  const result = [];\n  let inside = false;\n  let subStart = null;\n  let value, point, prevValue;\n  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);\n  const shouldStart = () => inside || startIsBefore();\n  const shouldStop = () => !inside || endIsBefore();\n  for (let i = start, prev = start; i <= end; ++i) {\n    point = points[i % count];\n    if (point.skip) {\n      continue;\n    }\n    value = normalize(point[property]);\n    if (value === prevValue) {\n      continue;\n    }\n    inside = between(value, startBound, endBound);\n    if (subStart === null && shouldStart()) {\n      subStart = compare(value, startBound) === 0 ? i : prev;\n    }\n    if (subStart !== null && shouldStop()) {\n      result.push(normalizeSegment({\n        start: subStart,\n        end: i,\n        loop,\n        count,\n        style\n      }));\n      subStart = null;\n    }\n    prev = i;\n    prevValue = value;\n  }\n  if (subStart !== null) {\n    result.push(normalizeSegment({\n      start: subStart,\n      end,\n      loop,\n      count,\n      style\n    }));\n  }\n  return result;\n}\nfunction _boundSegments(line, bounds) {\n  const result = [];\n  const segments = line.segments;\n  for (let i = 0; i < segments.length; i++) {\n    const sub = _boundSegment(segments[i], line.points, bounds);\n    if (sub.length) {\n      result.push(...sub);\n    }\n  }\n  return result;\n}\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n  let start = 0;\n  let end = count - 1;\n  if (loop && !spanGaps) {\n    while (start < count && !points[start].skip) {\n      start++;\n    }\n  }\n  while (start < count && points[start].skip) {\n    start++;\n  }\n  start %= count;\n  if (loop) {\n    end += start;\n  }\n  while (end > start && points[end % count].skip) {\n    end--;\n  }\n  end %= count;\n  return {\n    start,\n    end\n  };\n}\nfunction solidSegments(points, start, max, loop) {\n  const count = points.length;\n  const result = [];\n  let last = start;\n  let prev = points[start];\n  let end;\n  for (end = start + 1; end <= max; ++end) {\n    const cur = points[end % count];\n    if (cur.skip || cur.stop) {\n      if (!prev.skip) {\n        loop = false;\n        result.push({\n          start: start % count,\n          end: (end - 1) % count,\n          loop\n        });\n        start = last = cur.stop ? end : null;\n      }\n    } else {\n      last = end;\n      if (prev.skip) {\n        start = end;\n      }\n    }\n    prev = cur;\n  }\n  if (last !== null) {\n    result.push({\n      start: start % count,\n      end: last % count,\n      loop\n    });\n  }\n  return result;\n}\nfunction _computeSegments(line, segmentOptions) {\n  const points = line.points;\n  const spanGaps = line.options.spanGaps;\n  const count = points.length;\n  if (!count) {\n    return [];\n  }\n  const loop = !!line._loop;\n  const {\n    start,\n    end\n  } = findStartAndEnd(points, count, loop, spanGaps);\n  if (spanGaps === true) {\n    return splitByStyles(line, [{\n      start,\n      end,\n      loop\n    }], points, segmentOptions);\n  }\n  const max = end < start ? end + count : end;\n  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\nfunction splitByStyles(line, segments, points, segmentOptions) {\n  if (!segmentOptions || !segmentOptions.setContext || !points) {\n    return segments;\n  }\n  return doSplitByStyles(line, segments, points, segmentOptions);\n}\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\n  const chartContext = line._chart.getContext();\n  const baseStyle = readStyle(line.options);\n  const {\n    _datasetIndex: datasetIndex,\n    options: {\n      spanGaps\n    }\n  } = line;\n  const count = points.length;\n  const result = [];\n  let prevStyle = baseStyle;\n  let start = segments[0].start;\n  let i = start;\n  function addStyle(s, e, l, st) {\n    const dir = spanGaps ? -1 : 1;\n    if (s === e) {\n      return;\n    }\n    s += count;\n    while (points[s % count].skip) {\n      s -= dir;\n    }\n    while (points[e % count].skip) {\n      e += dir;\n    }\n    if (s % count !== e % count) {\n      result.push({\n        start: s % count,\n        end: e % count,\n        loop: l,\n        style: st\n      });\n      prevStyle = st;\n      start = e % count;\n    }\n  }\n  for (const segment of segments) {\n    start = spanGaps ? start : segment.start;\n    let prev = points[start % count];\n    let style;\n    for (i = start + 1; i <= segment.end; i++) {\n      const pt = points[i % count];\n      style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n        type: \"segment\",\n        p0: prev,\n        p1: pt,\n        p0DataIndex: (i - 1) % count,\n        p1DataIndex: i % count,\n        datasetIndex\n      })));\n      if (styleChanged(style, prevStyle)) {\n        addStyle(start, i - 1, segment.loop, prevStyle);\n      }\n      prev = pt;\n      prevStyle = style;\n    }\n    if (start < i - 1) {\n      addStyle(start, i - 1, segment.loop, prevStyle);\n    }\n  }\n  return result;\n}\nfunction readStyle(options) {\n  return {\n    backgroundColor: options.backgroundColor,\n    borderCapStyle: options.borderCapStyle,\n    borderDash: options.borderDash,\n    borderDashOffset: options.borderDashOffset,\n    borderJoinStyle: options.borderJoinStyle,\n    borderWidth: options.borderWidth,\n    borderColor: options.borderColor\n  };\n}\nfunction styleChanged(style, prevStyle) {\n  if (!prevStyle) {\n    return false;\n  }\n  const cache = [];\n  const replacer = function(key, value) {\n    if (!isPatternOrGradient(value)) {\n      return value;\n    }\n    if (!cache.includes(value)) {\n      cache.push(value);\n    }\n    return cache.indexOf(value);\n  };\n  return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);\n}\n\n// node_modules/chart.js/dist/chart.js\nvar Animator = class {\n  constructor() {\n    this._request = null;\n    this._charts = /* @__PURE__ */ new Map();\n    this._running = false;\n    this._lastDate = void 0;\n  }\n  _notify(chart, anims, date, type) {\n    const callbacks = anims.listeners[type];\n    const numSteps = anims.duration;\n    callbacks.forEach((fn) => fn({\n      chart,\n      initial: anims.initial,\n      numSteps,\n      currentStep: Math.min(date - anims.start, numSteps)\n    }));\n  }\n  _refresh() {\n    if (this._request) {\n      return;\n    }\n    this._running = true;\n    this._request = requestAnimFrame.call(window, () => {\n      this._update();\n      this._request = null;\n      if (this._running) {\n        this._refresh();\n      }\n    });\n  }\n  _update(date = Date.now()) {\n    let remaining = 0;\n    this._charts.forEach((anims, chart) => {\n      if (!anims.running || !anims.items.length) {\n        return;\n      }\n      const items = anims.items;\n      let i = items.length - 1;\n      let draw2 = false;\n      let item;\n      for (; i >= 0; --i) {\n        item = items[i];\n        if (item._active) {\n          if (item._total > anims.duration) {\n            anims.duration = item._total;\n          }\n          item.tick(date);\n          draw2 = true;\n        } else {\n          items[i] = items[items.length - 1];\n          items.pop();\n        }\n      }\n      if (draw2) {\n        chart.draw();\n        this._notify(chart, anims, date, \"progress\");\n      }\n      if (!items.length) {\n        anims.running = false;\n        this._notify(chart, anims, date, \"complete\");\n        anims.initial = false;\n      }\n      remaining += items.length;\n    });\n    this._lastDate = date;\n    if (remaining === 0) {\n      this._running = false;\n    }\n  }\n  _getAnims(chart) {\n    const charts = this._charts;\n    let anims = charts.get(chart);\n    if (!anims) {\n      anims = {\n        running: false,\n        initial: true,\n        items: [],\n        listeners: {\n          complete: [],\n          progress: []\n        }\n      };\n      charts.set(chart, anims);\n    }\n    return anims;\n  }\n  listen(chart, event, cb) {\n    this._getAnims(chart).listeners[event].push(cb);\n  }\n  add(chart, items) {\n    if (!items || !items.length) {\n      return;\n    }\n    this._getAnims(chart).items.push(...items);\n  }\n  has(chart) {\n    return this._getAnims(chart).items.length > 0;\n  }\n  start(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims) {\n      return;\n    }\n    anims.running = true;\n    anims.start = Date.now();\n    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);\n    this._refresh();\n  }\n  running(chart) {\n    if (!this._running) {\n      return false;\n    }\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.running || !anims.items.length) {\n      return false;\n    }\n    return true;\n  }\n  stop(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.items.length) {\n      return;\n    }\n    const items = anims.items;\n    let i = items.length - 1;\n    for (; i >= 0; --i) {\n      items[i].cancel();\n    }\n    anims.items = [];\n    this._notify(chart, anims, Date.now(), \"complete\");\n  }\n  remove(chart) {\n    return this._charts.delete(chart);\n  }\n};\nvar animator = new Animator();\nvar transparent = \"transparent\";\nvar interpolators = {\n  boolean(from2, to2, factor) {\n    return factor > 0.5 ? to2 : from2;\n  },\n  color(from2, to2, factor) {\n    const c0 = color(from2 || transparent);\n    const c1 = c0.valid && color(to2 || transparent);\n    return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to2;\n  },\n  number(from2, to2, factor) {\n    return from2 + (to2 - from2) * factor;\n  }\n};\nvar Animation = class {\n  constructor(cfg, target, prop, to2) {\n    const currentValue = target[prop];\n    to2 = resolve([cfg.to, to2, currentValue, cfg.from]);\n    const from2 = resolve([cfg.from, currentValue, to2]);\n    this._active = true;\n    this._fn = cfg.fn || interpolators[cfg.type || typeof from2];\n    this._easing = effects[cfg.easing] || effects.linear;\n    this._start = Math.floor(Date.now() + (cfg.delay || 0));\n    this._duration = this._total = Math.floor(cfg.duration);\n    this._loop = !!cfg.loop;\n    this._target = target;\n    this._prop = prop;\n    this._from = from2;\n    this._to = to2;\n    this._promises = void 0;\n  }\n  active() {\n    return this._active;\n  }\n  update(cfg, to2, date) {\n    if (this._active) {\n      this._notify(false);\n      const currentValue = this._target[this._prop];\n      const elapsed = date - this._start;\n      const remain = this._duration - elapsed;\n      this._start = date;\n      this._duration = Math.floor(Math.max(remain, cfg.duration));\n      this._total += elapsed;\n      this._loop = !!cfg.loop;\n      this._to = resolve([cfg.to, to2, currentValue, cfg.from]);\n      this._from = resolve([cfg.from, currentValue, to2]);\n    }\n  }\n  cancel() {\n    if (this._active) {\n      this.tick(Date.now());\n      this._active = false;\n      this._notify(false);\n    }\n  }\n  tick(date) {\n    const elapsed = date - this._start;\n    const duration = this._duration;\n    const prop = this._prop;\n    const from2 = this._from;\n    const loop = this._loop;\n    const to2 = this._to;\n    let factor;\n    this._active = from2 !== to2 && (loop || elapsed < duration);\n    if (!this._active) {\n      this._target[prop] = to2;\n      this._notify(true);\n      return;\n    }\n    if (elapsed < 0) {\n      this._target[prop] = from2;\n      return;\n    }\n    factor = elapsed / duration % 2;\n    factor = loop && factor > 1 ? 2 - factor : factor;\n    factor = this._easing(Math.min(1, Math.max(0, factor)));\n    this._target[prop] = this._fn(from2, to2, factor);\n  }\n  wait() {\n    const promises = this._promises || (this._promises = []);\n    return new Promise((res, rej) => {\n      promises.push({\n        res,\n        rej\n      });\n    });\n  }\n  _notify(resolved) {\n    const method = resolved ? \"res\" : \"rej\";\n    const promises = this._promises || [];\n    for (let i = 0; i < promises.length; i++) {\n      promises[i][method]();\n    }\n  }\n};\nvar Animations = class {\n  constructor(chart, config) {\n    this._chart = chart;\n    this._properties = /* @__PURE__ */ new Map();\n    this.configure(config);\n  }\n  configure(config) {\n    if (!isObject(config)) {\n      return;\n    }\n    const animationOptions = Object.keys(defaults.animation);\n    const animatedProps = this._properties;\n    Object.getOwnPropertyNames(config).forEach((key) => {\n      const cfg = config[key];\n      if (!isObject(cfg)) {\n        return;\n      }\n      const resolved = {};\n      for (const option of animationOptions) {\n        resolved[option] = cfg[option];\n      }\n      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {\n        if (prop === key || !animatedProps.has(prop)) {\n          animatedProps.set(prop, resolved);\n        }\n      });\n    });\n  }\n  _animateOptions(target, values) {\n    const newOptions = values.options;\n    const options = resolveTargetOptions(target, newOptions);\n    if (!options) {\n      return [];\n    }\n    const animations = this._createAnimations(options, newOptions);\n    if (newOptions.$shared) {\n      awaitAll(target.options.$animations, newOptions).then(() => {\n        target.options = newOptions;\n      }, () => {\n      });\n    }\n    return animations;\n  }\n  _createAnimations(target, values) {\n    const animatedProps = this._properties;\n    const animations = [];\n    const running = target.$animations || (target.$animations = {});\n    const props = Object.keys(values);\n    const date = Date.now();\n    let i;\n    for (i = props.length - 1; i >= 0; --i) {\n      const prop = props[i];\n      if (prop.charAt(0) === \"$\") {\n        continue;\n      }\n      if (prop === \"options\") {\n        animations.push(...this._animateOptions(target, values));\n        continue;\n      }\n      const value = values[prop];\n      let animation = running[prop];\n      const cfg = animatedProps.get(prop);\n      if (animation) {\n        if (cfg && animation.active()) {\n          animation.update(cfg, value, date);\n          continue;\n        } else {\n          animation.cancel();\n        }\n      }\n      if (!cfg || !cfg.duration) {\n        target[prop] = value;\n        continue;\n      }\n      running[prop] = animation = new Animation(cfg, target, prop, value);\n      animations.push(animation);\n    }\n    return animations;\n  }\n  update(target, values) {\n    if (this._properties.size === 0) {\n      Object.assign(target, values);\n      return;\n    }\n    const animations = this._createAnimations(target, values);\n    if (animations.length) {\n      animator.add(this._chart, animations);\n      return true;\n    }\n  }\n};\nfunction awaitAll(animations, properties) {\n  const running = [];\n  const keys = Object.keys(properties);\n  for (let i = 0; i < keys.length; i++) {\n    const anim = animations[keys[i]];\n    if (anim && anim.active()) {\n      running.push(anim.wait());\n    }\n  }\n  return Promise.all(running);\n}\nfunction resolveTargetOptions(target, newOptions) {\n  if (!newOptions) {\n    return;\n  }\n  let options = target.options;\n  if (!options) {\n    target.options = newOptions;\n    return;\n  }\n  if (options.$shared) {\n    target.options = options = Object.assign({}, options, {\n      $shared: false,\n      $animations: {}\n    });\n  }\n  return options;\n}\nfunction scaleClip(scale, allowedOverflow) {\n  const opts = scale && scale.options || {};\n  const reverse = opts.reverse;\n  const min = opts.min === void 0 ? allowedOverflow : 0;\n  const max = opts.max === void 0 ? allowedOverflow : 0;\n  return {\n    start: reverse ? max : min,\n    end: reverse ? min : max\n  };\n}\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n  if (allowedOverflow === false) {\n    return false;\n  }\n  const x = scaleClip(xScale, allowedOverflow);\n  const y = scaleClip(yScale, allowedOverflow);\n  return {\n    top: y.end,\n    right: x.end,\n    bottom: y.start,\n    left: x.start\n  };\n}\nfunction toClip(value) {\n  let t, r, b, l;\n  if (isObject(value)) {\n    t = value.top;\n    r = value.right;\n    b = value.bottom;\n    l = value.left;\n  } else {\n    t = r = b = l = value;\n  }\n  return {\n    top: t,\n    right: r,\n    bottom: b,\n    left: l,\n    disabled: value === false\n  };\n}\nfunction getSortedDatasetIndices(chart, filterVisible) {\n  const keys = [];\n  const metasets = chart._getSortedDatasetMetas(filterVisible);\n  let i, ilen;\n  for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n    keys.push(metasets[i].index);\n  }\n  return keys;\n}\nfunction applyStack(stack, value, dsIndex, options = {}) {\n  const keys = stack.keys;\n  const singleMode = options.mode === \"single\";\n  let i, ilen, datasetIndex, otherValue;\n  if (value === null) {\n    return;\n  }\n  let found = false;\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    datasetIndex = +keys[i];\n    if (datasetIndex === dsIndex) {\n      found = true;\n      if (options.all) {\n        continue;\n      }\n      break;\n    }\n    otherValue = stack.values[datasetIndex];\n    if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) {\n      value += otherValue;\n    }\n  }\n  if (!found && !options.all) {\n    return 0;\n  }\n  return value;\n}\nfunction convertObjectDataToArray(data, meta) {\n  const {\n    iScale,\n    vScale\n  } = meta;\n  const iAxisKey = iScale.axis === \"x\" ? \"x\" : \"y\";\n  const vAxisKey = vScale.axis === \"x\" ? \"x\" : \"y\";\n  const keys = Object.keys(data);\n  const adata = new Array(keys.length);\n  let i, ilen, key;\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    key = keys[i];\n    adata[i] = {\n      [iAxisKey]: key,\n      [vAxisKey]: data[key]\n    };\n  }\n  return adata;\n}\nfunction isStacked(scale, meta) {\n  const stacked = scale && scale.options.stacked;\n  return stacked || stacked === void 0 && meta.stack !== void 0;\n}\nfunction getStackKey(indexScale, valueScale, meta) {\n  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\nfunction getUserBounds(scale) {\n  const {\n    min,\n    max,\n    minDefined,\n    maxDefined\n  } = scale.getUserBounds();\n  return {\n    min: minDefined ? min : Number.NEGATIVE_INFINITY,\n    max: maxDefined ? max : Number.POSITIVE_INFINITY\n  };\n}\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n  const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n  return subStack[indexValue] || (subStack[indexValue] = {});\n}\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {\n    const value = stack[meta.index];\n    if (positive && value > 0 || !positive && value < 0) {\n      return meta.index;\n    }\n  }\n  return null;\n}\nfunction updateStacks(controller, parsed) {\n  const {\n    chart,\n    _cachedMeta: meta\n  } = controller;\n  const stacks = chart._stacks || (chart._stacks = {});\n  const {\n    iScale,\n    vScale,\n    index: datasetIndex\n  } = meta;\n  const iAxis = iScale.axis;\n  const vAxis = vScale.axis;\n  const key = getStackKey(iScale, vScale, meta);\n  const ilen = parsed.length;\n  let stack;\n  for (let i = 0; i < ilen; ++i) {\n    const item = parsed[i];\n    const {\n      [iAxis]: index2,\n      [vAxis]: value\n    } = item;\n    const itemStacks = item._stacks || (item._stacks = {});\n    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index2);\n    stack[datasetIndex] = value;\n    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n    const visualValues = stack._visualValues || (stack._visualValues = {});\n    visualValues[datasetIndex] = value;\n  }\n}\nfunction getFirstScaleId(chart, axis) {\n  const scales2 = chart.scales;\n  return Object.keys(scales2).filter((key) => scales2[key].axis === axis).shift();\n}\nfunction createDatasetContext(parent, index2) {\n  return createContext(parent, {\n    active: false,\n    dataset: void 0,\n    datasetIndex: index2,\n    index: index2,\n    mode: \"default\",\n    type: \"dataset\"\n  });\n}\nfunction createDataContext(parent, index2, element) {\n  return createContext(parent, {\n    active: false,\n    dataIndex: index2,\n    parsed: void 0,\n    raw: void 0,\n    element,\n    index: index2,\n    mode: \"default\",\n    type: \"data\"\n  });\n}\nfunction clearStacks(meta, items) {\n  const datasetIndex = meta.controller.index;\n  const axis = meta.vScale && meta.vScale.axis;\n  if (!axis) {\n    return;\n  }\n  items = items || meta._parsed;\n  for (const parsed of items) {\n    const stacks = parsed._stacks;\n    if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) {\n      return;\n    }\n    delete stacks[axis][datasetIndex];\n    if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) {\n      delete stacks[axis]._visualValues[datasetIndex];\n    }\n  }\n}\nvar isDirectUpdateMode = (mode) => mode === \"reset\" || mode === \"none\";\nvar cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);\nvar createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {\n  keys: getSortedDatasetIndices(chart, true),\n  values: null\n};\nvar DatasetController = class {\n  static defaults = {};\n  static datasetElementType = null;\n  static dataElementType = null;\n  constructor(chart, datasetIndex) {\n    this.chart = chart;\n    this._ctx = chart.ctx;\n    this.index = datasetIndex;\n    this._cachedDataOpts = {};\n    this._cachedMeta = this.getMeta();\n    this._type = this._cachedMeta.type;\n    this.options = void 0;\n    this._parsing = false;\n    this._data = void 0;\n    this._objectData = void 0;\n    this._sharedOptions = void 0;\n    this._drawStart = void 0;\n    this._drawCount = void 0;\n    this.enableOptionSharing = false;\n    this.supportsDecimation = false;\n    this.$context = void 0;\n    this._syncList = [];\n    this.datasetElementType = new.target.datasetElementType;\n    this.dataElementType = new.target.dataElementType;\n    this.initialize();\n  }\n  initialize() {\n    const meta = this._cachedMeta;\n    this.configure();\n    this.linkScales();\n    meta._stacked = isStacked(meta.vScale, meta);\n    this.addElements();\n    if (this.options.fill && !this.chart.isPluginEnabled(\"filler\")) {\n      console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\n    }\n  }\n  updateIndex(datasetIndex) {\n    if (this.index !== datasetIndex) {\n      clearStacks(this._cachedMeta);\n    }\n    this.index = datasetIndex;\n  }\n  linkScales() {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n    const chooseId = (axis, x, y, r) => axis === \"x\" ? x : axis === \"r\" ? r : y;\n    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, \"x\"));\n    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, \"y\"));\n    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, \"r\"));\n    const indexAxis = meta.indexAxis;\n    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n    meta.xScale = this.getScaleForId(xid);\n    meta.yScale = this.getScaleForId(yid);\n    meta.rScale = this.getScaleForId(rid);\n    meta.iScale = this.getScaleForId(iid);\n    meta.vScale = this.getScaleForId(vid);\n  }\n  getDataset() {\n    return this.chart.data.datasets[this.index];\n  }\n  getMeta() {\n    return this.chart.getDatasetMeta(this.index);\n  }\n  getScaleForId(scaleID) {\n    return this.chart.scales[scaleID];\n  }\n  _getOtherScale(scale) {\n    const meta = this._cachedMeta;\n    return scale === meta.iScale ? meta.vScale : meta.iScale;\n  }\n  reset() {\n    this._update(\"reset\");\n  }\n  _destroy() {\n    const meta = this._cachedMeta;\n    if (this._data) {\n      unlistenArrayEvents(this._data, this);\n    }\n    if (meta._stacked) {\n      clearStacks(meta);\n    }\n  }\n  _dataCheck() {\n    const dataset = this.getDataset();\n    const data = dataset.data || (dataset.data = []);\n    const _data = this._data;\n    if (isObject(data)) {\n      const meta = this._cachedMeta;\n      this._data = convertObjectDataToArray(data, meta);\n    } else if (_data !== data) {\n      if (_data) {\n        unlistenArrayEvents(_data, this);\n        const meta = this._cachedMeta;\n        clearStacks(meta);\n        meta._parsed = [];\n      }\n      if (data && Object.isExtensible(data)) {\n        listenArrayEvents(data, this);\n      }\n      this._syncList = [];\n      this._data = data;\n    }\n  }\n  addElements() {\n    const meta = this._cachedMeta;\n    this._dataCheck();\n    if (this.datasetElementType) {\n      meta.dataset = new this.datasetElementType();\n    }\n  }\n  buildOrUpdateElements(resetNewElements) {\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n    let stackChanged = false;\n    this._dataCheck();\n    const oldStacked = meta._stacked;\n    meta._stacked = isStacked(meta.vScale, meta);\n    if (meta.stack !== dataset.stack) {\n      stackChanged = true;\n      clearStacks(meta);\n      meta.stack = dataset.stack;\n    }\n    this._resyncElements(resetNewElements);\n    if (stackChanged || oldStacked !== meta._stacked) {\n      updateStacks(this, meta._parsed);\n      meta._stacked = isStacked(meta.vScale, meta);\n    }\n  }\n  configure() {\n    const config = this.chart.config;\n    const scopeKeys = config.datasetScopeKeys(this._type);\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n    this.options = config.createResolver(scopes, this.getContext());\n    this._parsing = this.options.parsing;\n    this._cachedDataOpts = {};\n  }\n  parse(start, count) {\n    const {\n      _cachedMeta: meta,\n      _data: data\n    } = this;\n    const {\n      iScale,\n      _stacked\n    } = meta;\n    const iAxis = iScale.axis;\n    let sorted = start === 0 && count === data.length ? true : meta._sorted;\n    let prev = start > 0 && meta._parsed[start - 1];\n    let i, cur, parsed;\n    if (this._parsing === false) {\n      meta._parsed = data;\n      meta._sorted = true;\n      parsed = data;\n    } else {\n      if (isArray(data[start])) {\n        parsed = this.parseArrayData(meta, data, start, count);\n      } else if (isObject(data[start])) {\n        parsed = this.parseObjectData(meta, data, start, count);\n      } else {\n        parsed = this.parsePrimitiveData(meta, data, start, count);\n      }\n      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];\n      for (i = 0; i < count; ++i) {\n        meta._parsed[i + start] = cur = parsed[i];\n        if (sorted) {\n          if (isNotInOrderComparedToPrev()) {\n            sorted = false;\n          }\n          prev = cur;\n        }\n      }\n      meta._sorted = sorted;\n    }\n    if (_stacked) {\n      updateStacks(this, parsed);\n    }\n  }\n  parsePrimitiveData(meta, data, start, count) {\n    const {\n      iScale,\n      vScale\n    } = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = new Array(count);\n    let i, ilen, index2;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index2 = i + start;\n      parsed[i] = {\n        [iAxis]: singleScale || iScale.parse(labels[index2], index2),\n        [vAxis]: vScale.parse(data[index2], index2)\n      };\n    }\n    return parsed;\n  }\n  parseArrayData(meta, data, start, count) {\n    const {\n      xScale,\n      yScale\n    } = meta;\n    const parsed = new Array(count);\n    let i, ilen, index2, item;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index2 = i + start;\n      item = data[index2];\n      parsed[i] = {\n        x: xScale.parse(item[0], index2),\n        y: yScale.parse(item[1], index2)\n      };\n    }\n    return parsed;\n  }\n  parseObjectData(meta, data, start, count) {\n    const {\n      xScale,\n      yScale\n    } = meta;\n    const {\n      xAxisKey = \"x\",\n      yAxisKey = \"y\"\n    } = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index2, item;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index2 = i + start;\n      item = data[index2];\n      parsed[i] = {\n        x: xScale.parse(resolveObjectKey(item, xAxisKey), index2),\n        y: yScale.parse(resolveObjectKey(item, yAxisKey), index2)\n      };\n    }\n    return parsed;\n  }\n  getParsed(index2) {\n    return this._cachedMeta._parsed[index2];\n  }\n  getDataElement(index2) {\n    return this._cachedMeta.data[index2];\n  }\n  applyStack(scale, parsed, mode) {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const value = parsed[scale.axis];\n    const stack = {\n      keys: getSortedDatasetIndices(chart, true),\n      values: parsed._stacks[scale.axis]._visualValues\n    };\n    return applyStack(stack, value, meta.index, {\n      mode\n    });\n  }\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    const parsedValue = parsed[scale.axis];\n    let value = parsedValue === null ? NaN : parsedValue;\n    const values = stack && parsed._stacks[scale.axis];\n    if (stack && values) {\n      stack.values = values;\n      value = applyStack(stack, parsedValue, this._cachedMeta.index);\n    }\n    range.min = Math.min(range.min, value);\n    range.max = Math.max(range.max, value);\n  }\n  getMinMax(scale, canStack) {\n    const meta = this._cachedMeta;\n    const _parsed = meta._parsed;\n    const sorted = meta._sorted && scale === meta.iScale;\n    const ilen = _parsed.length;\n    const otherScale = this._getOtherScale(scale);\n    const stack = createStack(canStack, meta, this.chart);\n    const range = {\n      min: Number.POSITIVE_INFINITY,\n      max: Number.NEGATIVE_INFINITY\n    };\n    const {\n      min: otherMin,\n      max: otherMax\n    } = getUserBounds(otherScale);\n    let i, parsed;\n    function _skip() {\n      parsed = _parsed[i];\n      const otherValue = parsed[otherScale.axis];\n      return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n    }\n    for (i = 0; i < ilen; ++i) {\n      if (_skip()) {\n        continue;\n      }\n      this.updateRangeFromParsed(range, scale, parsed, stack);\n      if (sorted) {\n        break;\n      }\n    }\n    if (sorted) {\n      for (i = ilen - 1; i >= 0; --i) {\n        if (_skip()) {\n          continue;\n        }\n        this.updateRangeFromParsed(range, scale, parsed, stack);\n        break;\n      }\n    }\n    return range;\n  }\n  getAllParsedValues(scale) {\n    const parsed = this._cachedMeta._parsed;\n    const values = [];\n    let i, ilen, value;\n    for (i = 0, ilen = parsed.length; i < ilen; ++i) {\n      value = parsed[i][scale.axis];\n      if (isNumberFinite(value)) {\n        values.push(value);\n      }\n    }\n    return values;\n  }\n  getMaxOverflow() {\n    return false;\n  }\n  getLabelAndValue(index2) {\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const parsed = this.getParsed(index2);\n    return {\n      label: iScale ? \"\" + iScale.getLabelForValue(parsed[iScale.axis]) : \"\",\n      value: vScale ? \"\" + vScale.getLabelForValue(parsed[vScale.axis]) : \"\"\n    };\n  }\n  _update(mode) {\n    const meta = this._cachedMeta;\n    this.update(mode || \"default\");\n    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n  }\n  update(mode) {\n  }\n  draw() {\n    const ctx = this._ctx;\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const elements2 = meta.data || [];\n    const area = chart.chartArea;\n    const active = [];\n    const start = this._drawStart || 0;\n    const count = this._drawCount || elements2.length - start;\n    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n    let i;\n    if (meta.dataset) {\n      meta.dataset.draw(ctx, area, start, count);\n    }\n    for (i = start; i < start + count; ++i) {\n      const element = elements2[i];\n      if (element.hidden) {\n        continue;\n      }\n      if (element.active && drawActiveElementsOnTop) {\n        active.push(element);\n      } else {\n        element.draw(ctx, area);\n      }\n    }\n    for (i = 0; i < active.length; ++i) {\n      active[i].draw(ctx, area);\n    }\n  }\n  getStyle(index2, active) {\n    const mode = active ? \"active\" : \"default\";\n    return index2 === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index2 || 0, mode);\n  }\n  getContext(index2, active, mode) {\n    const dataset = this.getDataset();\n    let context;\n    if (index2 >= 0 && index2 < this._cachedMeta.data.length) {\n      const element = this._cachedMeta.data[index2];\n      context = element.$context || (element.$context = createDataContext(this.getContext(), index2, element));\n      context.parsed = this.getParsed(index2);\n      context.raw = dataset.data[index2];\n      context.index = context.dataIndex = index2;\n    } else {\n      context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n      context.dataset = dataset;\n      context.index = context.datasetIndex = this.index;\n    }\n    context.active = !!active;\n    context.mode = mode;\n    return context;\n  }\n  resolveDatasetElementOptions(mode) {\n    return this._resolveElementOptions(this.datasetElementType.id, mode);\n  }\n  resolveDataElementOptions(index2, mode) {\n    return this._resolveElementOptions(this.dataElementType.id, mode, index2);\n  }\n  _resolveElementOptions(elementType, mode = \"default\", index2) {\n    const active = mode === \"active\";\n    const cache = this._cachedDataOpts;\n    const cacheKey = elementType + \"-\" + mode;\n    const cached = cache[cacheKey];\n    const sharing = this.enableOptionSharing && defined(index2);\n    if (cached) {\n      return cloneIfNotShared(cached, sharing);\n    }\n    const config = this.chart.config;\n    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n    const prefixes = active ? [`${elementType}Hover`, \"hover\", elementType, \"\"] : [elementType, \"\"];\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n    const names2 = Object.keys(defaults.elements[elementType]);\n    const context = () => this.getContext(index2, active, mode);\n    const values = config.resolveNamedOptions(scopes, names2, context, prefixes);\n    if (values.$shared) {\n      values.$shared = sharing;\n      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n    }\n    return values;\n  }\n  _resolveAnimations(index2, transition, active) {\n    const chart = this.chart;\n    const cache = this._cachedDataOpts;\n    const cacheKey = `animation-${transition}`;\n    const cached = cache[cacheKey];\n    if (cached) {\n      return cached;\n    }\n    let options;\n    if (chart.options.animation !== false) {\n      const config = this.chart.config;\n      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n      options = config.createResolver(scopes, this.getContext(index2, active, transition));\n    }\n    const animations = new Animations(chart, options && options.animations);\n    if (options && options._cacheable) {\n      cache[cacheKey] = Object.freeze(animations);\n    }\n    return animations;\n  }\n  getSharedOptions(options) {\n    if (!options.$shared) {\n      return;\n    }\n    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n  }\n  includeOptions(mode, sharedOptions) {\n    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n  }\n  _getSharedOptions(start, mode) {\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const previouslySharedOptions = this._sharedOptions;\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    return {\n      sharedOptions,\n      includeOptions\n    };\n  }\n  updateElement(element, index2, properties, mode) {\n    if (isDirectUpdateMode(mode)) {\n      Object.assign(element, properties);\n    } else {\n      this._resolveAnimations(index2, mode).update(element, properties);\n    }\n  }\n  updateSharedOptions(sharedOptions, mode, newOptions) {\n    if (sharedOptions && !isDirectUpdateMode(mode)) {\n      this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);\n    }\n  }\n  _setStyle(element, index2, mode, active) {\n    element.active = active;\n    const options = this.getStyle(index2, active);\n    this._resolveAnimations(index2, mode, active).update(element, {\n      options: !active && this.getSharedOptions(options) || options\n    });\n  }\n  removeHoverStyle(element, datasetIndex, index2) {\n    this._setStyle(element, index2, \"active\", false);\n  }\n  setHoverStyle(element, datasetIndex, index2) {\n    this._setStyle(element, index2, \"active\", true);\n  }\n  _removeDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n    if (element) {\n      this._setStyle(element, void 0, \"active\", false);\n    }\n  }\n  _setDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n    if (element) {\n      this._setStyle(element, void 0, \"active\", true);\n    }\n  }\n  _resyncElements(resetNewElements) {\n    const data = this._data;\n    const elements2 = this._cachedMeta.data;\n    for (const [method, arg1, arg2] of this._syncList) {\n      this[method](arg1, arg2);\n    }\n    this._syncList = [];\n    const numMeta = elements2.length;\n    const numData = data.length;\n    const count = Math.min(numData, numMeta);\n    if (count) {\n      this.parse(0, count);\n    }\n    if (numData > numMeta) {\n      this._insertElements(numMeta, numData - numMeta, resetNewElements);\n    } else if (numData < numMeta) {\n      this._removeElements(numData, numMeta - numData);\n    }\n  }\n  _insertElements(start, count, resetNewElements = true) {\n    const meta = this._cachedMeta;\n    const data = meta.data;\n    const end = start + count;\n    let i;\n    const move = (arr) => {\n      arr.length += count;\n      for (i = arr.length - 1; i >= end; i--) {\n        arr[i] = arr[i - count];\n      }\n    };\n    move(data);\n    for (i = start; i < end; ++i) {\n      data[i] = new this.dataElementType();\n    }\n    if (this._parsing) {\n      move(meta._parsed);\n    }\n    this.parse(start, count);\n    if (resetNewElements) {\n      this.updateElements(data, start, count, \"reset\");\n    }\n  }\n  updateElements(element, start, count, mode) {\n  }\n  _removeElements(start, count) {\n    const meta = this._cachedMeta;\n    if (this._parsing) {\n      const removed = meta._parsed.splice(start, count);\n      if (meta._stacked) {\n        clearStacks(meta, removed);\n      }\n    }\n    meta.data.splice(start, count);\n  }\n  _sync(args) {\n    if (this._parsing) {\n      this._syncList.push(args);\n    } else {\n      const [method, arg1, arg2] = args;\n      this[method](arg1, arg2);\n    }\n    this.chart._dataChanges.push([this.index, ...args]);\n  }\n  _onDataPush() {\n    const count = arguments.length;\n    this._sync([\"_insertElements\", this.getDataset().data.length - count, count]);\n  }\n  _onDataPop() {\n    this._sync([\"_removeElements\", this._cachedMeta.data.length - 1, 1]);\n  }\n  _onDataShift() {\n    this._sync([\"_removeElements\", 0, 1]);\n  }\n  _onDataSplice(start, count) {\n    if (count) {\n      this._sync([\"_removeElements\", start, count]);\n    }\n    const newCount = arguments.length - 2;\n    if (newCount) {\n      this._sync([\"_insertElements\", start, newCount]);\n    }\n  }\n  _onDataUnshift() {\n    this._sync([\"_insertElements\", 0, arguments.length]);\n  }\n};\nfunction getAllScaleValues(scale, type) {\n  if (!scale._cache.$bar) {\n    const visibleMetas = scale.getMatchingVisibleMetas(type);\n    let values = [];\n    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {\n      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n    }\n    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));\n  }\n  return scale._cache.$bar;\n}\nfunction computeMinSampleSize(meta) {\n  const scale = meta.iScale;\n  const values = getAllScaleValues(scale, meta.type);\n  let min = scale._length;\n  let i, ilen, curr, prev;\n  const updateMinAndPrev = () => {\n    if (curr === 32767 || curr === -32768) {\n      return;\n    }\n    if (defined(prev)) {\n      min = Math.min(min, Math.abs(curr - prev) || min);\n    }\n    prev = curr;\n  };\n  for (i = 0, ilen = values.length; i < ilen; ++i) {\n    curr = scale.getPixelForValue(values[i]);\n    updateMinAndPrev();\n  }\n  prev = void 0;\n  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {\n    curr = scale.getPixelForTick(i);\n    updateMinAndPrev();\n  }\n  return min;\n}\nfunction computeFitCategoryTraits(index2, ruler, options, stackCount) {\n  const thickness = options.barThickness;\n  let size, ratio;\n  if (isNullOrUndef(thickness)) {\n    size = ruler.min * options.categoryPercentage;\n    ratio = options.barPercentage;\n  } else {\n    size = thickness * stackCount;\n    ratio = 1;\n  }\n  return {\n    chunk: size / stackCount,\n    ratio,\n    start: ruler.pixels[index2] - size / 2\n  };\n}\nfunction computeFlexCategoryTraits(index2, ruler, options, stackCount) {\n  const pixels = ruler.pixels;\n  const curr = pixels[index2];\n  let prev = index2 > 0 ? pixels[index2 - 1] : null;\n  let next = index2 < pixels.length - 1 ? pixels[index2 + 1] : null;\n  const percent = options.categoryPercentage;\n  if (prev === null) {\n    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n  }\n  if (next === null) {\n    next = curr + curr - prev;\n  }\n  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n  const size = Math.abs(next - prev) / 2 * percent;\n  return {\n    chunk: size / stackCount,\n    ratio: options.barPercentage,\n    start\n  };\n}\nfunction parseFloatBar(entry, item, vScale, i) {\n  const startValue = vScale.parse(entry[0], i);\n  const endValue = vScale.parse(entry[1], i);\n  const min = Math.min(startValue, endValue);\n  const max = Math.max(startValue, endValue);\n  let barStart = min;\n  let barEnd = max;\n  if (Math.abs(min) > Math.abs(max)) {\n    barStart = max;\n    barEnd = min;\n  }\n  item[vScale.axis] = barEnd;\n  item._custom = {\n    barStart,\n    barEnd,\n    start: startValue,\n    end: endValue,\n    min,\n    max\n  };\n}\nfunction parseValue(entry, item, vScale, i) {\n  if (isArray(entry)) {\n    parseFloatBar(entry, item, vScale, i);\n  } else {\n    item[vScale.axis] = vScale.parse(entry, i);\n  }\n  return item;\n}\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n  const iScale = meta.iScale;\n  const vScale = meta.vScale;\n  const labels = iScale.getLabels();\n  const singleScale = iScale === vScale;\n  const parsed = [];\n  let i, ilen, item, entry;\n  for (i = start, ilen = start + count; i < ilen; ++i) {\n    entry = data[i];\n    item = {};\n    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n    parsed.push(parseValue(entry, item, vScale, i));\n  }\n  return parsed;\n}\nfunction isFloatBar(custom) {\n  return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;\n}\nfunction barSign(size, vScale, actualBase) {\n  if (size !== 0) {\n    return sign(size);\n  }\n  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\nfunction borderProps(properties) {\n  let reverse, start, end, top, bottom;\n  if (properties.horizontal) {\n    reverse = properties.base > properties.x;\n    start = \"left\";\n    end = \"right\";\n  } else {\n    reverse = properties.base < properties.y;\n    start = \"bottom\";\n    end = \"top\";\n  }\n  if (reverse) {\n    top = \"end\";\n    bottom = \"start\";\n  } else {\n    top = \"start\";\n    bottom = \"end\";\n  }\n  return {\n    start,\n    end,\n    reverse,\n    top,\n    bottom\n  };\n}\nfunction setBorderSkipped(properties, options, stack, index2) {\n  let edge = options.borderSkipped;\n  const res = {};\n  if (!edge) {\n    properties.borderSkipped = res;\n    return;\n  }\n  if (edge === true) {\n    properties.borderSkipped = {\n      top: true,\n      right: true,\n      bottom: true,\n      left: true\n    };\n    return;\n  }\n  const {\n    start,\n    end,\n    reverse,\n    top,\n    bottom\n  } = borderProps(properties);\n  if (edge === \"middle\" && stack) {\n    properties.enableBorderRadius = true;\n    if ((stack._top || 0) === index2) {\n      edge = top;\n    } else if ((stack._bottom || 0) === index2) {\n      edge = bottom;\n    } else {\n      res[parseEdge(bottom, start, end, reverse)] = true;\n      edge = top;\n    }\n  }\n  res[parseEdge(edge, start, end, reverse)] = true;\n  properties.borderSkipped = res;\n}\nfunction parseEdge(edge, a, b, reverse) {\n  if (reverse) {\n    edge = swap(edge, a, b);\n    edge = startEnd(edge, b, a);\n  } else {\n    edge = startEnd(edge, a, b);\n  }\n  return edge;\n}\nfunction swap(orig, v1, v2) {\n  return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\nfunction startEnd(v, start, end) {\n  return v === \"start\" ? start : v === \"end\" ? end : v;\n}\nfunction setInflateAmount(properties, {\n  inflateAmount\n}, ratio) {\n  properties.inflateAmount = inflateAmount === \"auto\" ? ratio === 1 ? 0.33 : 0 : inflateAmount;\n}\nvar BarController = class extends DatasetController {\n  static id = \"bar\";\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: \"bar\",\n    categoryPercentage: 0.8,\n    barPercentage: 0.9,\n    grouped: true,\n    animations: {\n      numbers: {\n        type: \"number\",\n        properties: [\"x\", \"y\", \"base\", \"width\", \"height\"]\n      }\n    }\n  };\n  static overrides = {\n    scales: {\n      _index_: {\n        type: \"category\",\n        offset: true,\n        grid: {\n          offset: true\n        }\n      },\n      _value_: {\n        type: \"linear\",\n        beginAtZero: true\n      }\n    }\n  };\n  parsePrimitiveData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n  parseArrayData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n  parseObjectData(meta, data, start, count) {\n    const {\n      iScale,\n      vScale\n    } = meta;\n    const {\n      xAxisKey = \"x\",\n      yAxisKey = \"y\"\n    } = this._parsing;\n    const iAxisKey = iScale.axis === \"x\" ? xAxisKey : yAxisKey;\n    const vAxisKey = vScale.axis === \"x\" ? xAxisKey : yAxisKey;\n    const parsed = [];\n    let i, ilen, item, obj;\n    for (i = start, ilen = start + count; i < ilen; ++i) {\n      obj = data[i];\n      item = {};\n      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\n      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\n    }\n    return parsed;\n  }\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    super.updateRangeFromParsed(range, scale, parsed, stack);\n    const custom = parsed._custom;\n    if (custom && scale === this._cachedMeta.vScale) {\n      range.min = Math.min(range.min, custom.min);\n      range.max = Math.max(range.max, custom.max);\n    }\n  }\n  getMaxOverflow() {\n    return 0;\n  }\n  getLabelAndValue(index2) {\n    const meta = this._cachedMeta;\n    const {\n      iScale,\n      vScale\n    } = meta;\n    const parsed = this.getParsed(index2);\n    const custom = parsed._custom;\n    const value = isFloatBar(custom) ? \"[\" + custom.start + \", \" + custom.end + \"]\" : \"\" + vScale.getLabelForValue(parsed[vScale.axis]);\n    return {\n      label: \"\" + iScale.getLabelForValue(parsed[iScale.axis]),\n      value\n    };\n  }\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n    const meta = this._cachedMeta;\n    meta.stack = this.getDataset().stack;\n  }\n  update(mode) {\n    const meta = this._cachedMeta;\n    this.updateElements(meta.data, 0, meta.data.length, mode);\n  }\n  updateElements(bars, start, count, mode) {\n    const reset = mode === \"reset\";\n    const {\n      index: index2,\n      _cachedMeta: {\n        vScale\n      }\n    } = this;\n    const base = vScale.getBasePixel();\n    const horizontal = vScale.isHorizontal();\n    const ruler = this._getRuler();\n    const {\n      sharedOptions,\n      includeOptions\n    } = this._getSharedOptions(start, mode);\n    for (let i = start; i < start + count; i++) {\n      const parsed = this.getParsed(i);\n      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {\n        base,\n        head: base\n      } : this._calculateBarValuePixels(i);\n      const ipixels = this._calculateBarIndexPixels(i, ruler);\n      const stack = (parsed._stacks || {})[vScale.axis];\n      const properties = {\n        horizontal,\n        base: vpixels.base,\n        enableBorderRadius: !stack || isFloatBar(parsed._custom) || index2 === stack._top || index2 === stack._bottom,\n        x: horizontal ? vpixels.head : ipixels.center,\n        y: horizontal ? ipixels.center : vpixels.head,\n        height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n        width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n      };\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? \"active\" : mode);\n      }\n      const options = properties.options || bars[i].options;\n      setBorderSkipped(properties, options, stack, index2);\n      setInflateAmount(properties, options, ruler.ratio);\n      this.updateElement(bars[i], i, properties, mode);\n    }\n  }\n  _getStacks(last, dataIndex) {\n    const {\n      iScale\n    } = this._cachedMeta;\n    const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta) => meta.controller.options.grouped);\n    const stacked = iScale.options.stacked;\n    const stacks = [];\n    const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);\n    const iScaleValue = currentParsed && currentParsed[iScale.axis];\n    const skipNull = (meta) => {\n      const parsed = meta._parsed.find((item) => item[iScale.axis] === iScaleValue);\n      const val = parsed && parsed[meta.vScale.axis];\n      if (isNullOrUndef(val) || isNaN(val)) {\n        return true;\n      }\n    };\n    for (const meta of metasets) {\n      if (dataIndex !== void 0 && skipNull(meta)) {\n        continue;\n      }\n      if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) {\n        stacks.push(meta.stack);\n      }\n      if (meta.index === last) {\n        break;\n      }\n    }\n    if (!stacks.length) {\n      stacks.push(void 0);\n    }\n    return stacks;\n  }\n  _getStackCount(index2) {\n    return this._getStacks(void 0, index2).length;\n  }\n  _getStackIndex(datasetIndex, name, dataIndex) {\n    const stacks = this._getStacks(datasetIndex, dataIndex);\n    const index2 = name !== void 0 ? stacks.indexOf(name) : -1;\n    return index2 === -1 ? stacks.length - 1 : index2;\n  }\n  _getRuler() {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const pixels = [];\n    let i, ilen;\n    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {\n      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n    }\n    const barThickness = opts.barThickness;\n    const min = barThickness || computeMinSampleSize(meta);\n    return {\n      min,\n      pixels,\n      start: iScale._startPixel,\n      end: iScale._endPixel,\n      stackCount: this._getStackCount(),\n      scale: iScale,\n      grouped: opts.grouped,\n      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n    };\n  }\n  _calculateBarValuePixels(index2) {\n    const {\n      _cachedMeta: {\n        vScale,\n        _stacked,\n        index: datasetIndex\n      },\n      options: {\n        base: baseValue,\n        minBarLength\n      }\n    } = this;\n    const actualBase = baseValue || 0;\n    const parsed = this.getParsed(index2);\n    const custom = parsed._custom;\n    const floating = isFloatBar(custom);\n    let value = parsed[vScale.axis];\n    let start = 0;\n    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n    let head, size;\n    if (length !== value) {\n      start = length - value;\n      length = value;\n    }\n    if (floating) {\n      value = custom.barStart;\n      length = custom.barEnd - custom.barStart;\n      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\n        start = 0;\n      }\n      start += value;\n    }\n    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\n    let base = vScale.getPixelForValue(startValue);\n    if (this.chart.getDataVisibility(index2)) {\n      head = vScale.getPixelForValue(start + length);\n    } else {\n      head = base;\n    }\n    size = head - base;\n    if (Math.abs(size) < minBarLength) {\n      size = barSign(size, vScale, actualBase) * minBarLength;\n      if (value === actualBase) {\n        base -= size / 2;\n      }\n      const startPixel = vScale.getPixelForDecimal(0);\n      const endPixel = vScale.getPixelForDecimal(1);\n      const min = Math.min(startPixel, endPixel);\n      const max = Math.max(startPixel, endPixel);\n      base = Math.max(Math.min(base, max), min);\n      head = base + size;\n      if (_stacked && !floating) {\n        parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);\n      }\n    }\n    if (base === vScale.getPixelForValue(actualBase)) {\n      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;\n      base += halfGrid;\n      size -= halfGrid;\n    }\n    return {\n      size,\n      base,\n      head,\n      center: head + size / 2\n    };\n  }\n  _calculateBarIndexPixels(index2, ruler) {\n    const scale = ruler.scale;\n    const options = this.options;\n    const skipNull = options.skipNull;\n    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\n    let center, size;\n    if (ruler.grouped) {\n      const stackCount = skipNull ? this._getStackCount(index2) : ruler.stackCount;\n      const range = options.barThickness === \"flex\" ? computeFlexCategoryTraits(index2, ruler, options, stackCount) : computeFitCategoryTraits(index2, ruler, options, stackCount);\n      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index2 : void 0);\n      center = range.start + range.chunk * stackIndex + range.chunk / 2;\n      size = Math.min(maxBarThickness, range.chunk * range.ratio);\n    } else {\n      center = scale.getPixelForValue(this.getParsed(index2)[scale.axis], index2);\n      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n    }\n    return {\n      base: center - size / 2,\n      head: center + size / 2,\n      center,\n      size\n    };\n  }\n  draw() {\n    const meta = this._cachedMeta;\n    const vScale = meta.vScale;\n    const rects = meta.data;\n    const ilen = rects.length;\n    let i = 0;\n    for (; i < ilen; ++i) {\n      if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {\n        rects[i].draw(this._ctx);\n      }\n    }\n  }\n};\nvar BubbleController = class extends DatasetController {\n  static id = \"bubble\";\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: \"point\",\n    animations: {\n      numbers: {\n        type: \"number\",\n        properties: [\"x\", \"y\", \"borderWidth\", \"radius\"]\n      }\n    }\n  };\n  static overrides = {\n    scales: {\n      x: {\n        type: \"linear\"\n      },\n      y: {\n        type: \"linear\"\n      }\n    }\n  };\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n  }\n  parsePrimitiveData(meta, data, start, count) {\n    const parsed = super.parsePrimitiveData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n    }\n    return parsed;\n  }\n  parseArrayData(meta, data, start, count) {\n    const parsed = super.parseArrayData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n  parseObjectData(meta, data, start, count) {\n    const parsed = super.parseObjectData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n  getMaxOverflow() {\n    const data = this._cachedMeta.data;\n    let max = 0;\n    for (let i = data.length - 1; i >= 0; --i) {\n      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n    }\n    return max > 0 && max;\n  }\n  getLabelAndValue(index2) {\n    const meta = this._cachedMeta;\n    const labels = this.chart.data.labels || [];\n    const {\n      xScale,\n      yScale\n    } = meta;\n    const parsed = this.getParsed(index2);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n    const r = parsed._custom;\n    return {\n      label: labels[index2] || \"\",\n      value: \"(\" + x + \", \" + y + (r ? \", \" + r : \"\") + \")\"\n    };\n  }\n  update(mode) {\n    const points = this._cachedMeta.data;\n    this.updateElements(points, 0, points.length, mode);\n  }\n  updateElements(points, start, count, mode) {\n    const reset = mode === \"reset\";\n    const {\n      iScale,\n      vScale\n    } = this._cachedMeta;\n    const {\n      sharedOptions,\n      includeOptions\n    } = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const parsed = !reset && this.getParsed(i);\n      const properties = {};\n      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n      properties.skip = isNaN(iPixel) || isNaN(vPixel);\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? \"active\" : mode);\n        if (reset) {\n          properties.options.radius = 0;\n        }\n      }\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n  resolveDataElementOptions(index2, mode) {\n    const parsed = this.getParsed(index2);\n    let values = super.resolveDataElementOptions(index2, mode);\n    if (values.$shared) {\n      values = Object.assign({}, values, {\n        $shared: false\n      });\n    }\n    const radius = values.radius;\n    if (mode !== \"active\") {\n      values.radius = 0;\n    }\n    values.radius += valueOrDefault(parsed && parsed._custom, radius);\n    return values;\n  }\n};\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n  let ratioX = 1;\n  let ratioY = 1;\n  let offsetX = 0;\n  let offsetY = 0;\n  if (circumference < TAU) {\n    const startAngle = rotation;\n    const endAngle = startAngle + circumference;\n    const startX = Math.cos(startAngle);\n    const startY = Math.sin(startAngle);\n    const endX = Math.cos(endAngle);\n    const endY = Math.sin(endAngle);\n    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n    const maxX = calcMax(0, startX, endX);\n    const maxY = calcMax(HALF_PI, startY, endY);\n    const minX = calcMin(PI, startX, endX);\n    const minY = calcMin(PI + HALF_PI, startY, endY);\n    ratioX = (maxX - minX) / 2;\n    ratioY = (maxY - minY) / 2;\n    offsetX = -(maxX + minX) / 2;\n    offsetY = -(maxY + minY) / 2;\n  }\n  return {\n    ratioX,\n    ratioY,\n    offsetX,\n    offsetY\n  };\n}\nvar DoughnutController = class extends DatasetController {\n  static id = \"doughnut\";\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: \"arc\",\n    animation: {\n      animateRotate: true,\n      animateScale: false\n    },\n    animations: {\n      numbers: {\n        type: \"number\",\n        properties: [\"circumference\", \"endAngle\", \"innerRadius\", \"outerRadius\", \"startAngle\", \"x\", \"y\", \"offset\", \"borderWidth\", \"spacing\"]\n      }\n    },\n    cutout: \"50%\",\n    rotation: 0,\n    circumference: 360,\n    radius: \"100%\",\n    spacing: 0,\n    indexAxis: \"r\"\n  };\n  static descriptors = {\n    _scriptable: (name) => name !== \"spacing\",\n    _indexable: (name) => name !== \"spacing\" && !name.startsWith(\"borderDash\") && !name.startsWith(\"hoverBorderDash\")\n  };\n  static overrides = {\n    aspectRatio: 1,\n    plugins: {\n      legend: {\n        labels: {\n          generateLabels(chart) {\n            const data = chart.data;\n            if (data.labels.length && data.datasets.length) {\n              const {\n                labels: {\n                  pointStyle,\n                  color: color2\n                }\n              } = chart.legend.options;\n              return data.labels.map((label, i) => {\n                const meta = chart.getDatasetMeta(0);\n                const style = meta.controller.getStyle(i);\n                return {\n                  text: label,\n                  fillStyle: style.backgroundColor,\n                  strokeStyle: style.borderColor,\n                  fontColor: color2,\n                  lineWidth: style.borderWidth,\n                  pointStyle,\n                  hidden: !chart.getDataVisibility(i),\n                  index: i\n                };\n              });\n            }\n            return [];\n          }\n        },\n        onClick(e, legendItem, legend) {\n          legend.chart.toggleDataVisibility(legendItem.index);\n          legend.chart.update();\n        }\n      }\n    }\n  };\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n    this.enableOptionSharing = true;\n    this.innerRadius = void 0;\n    this.outerRadius = void 0;\n    this.offsetX = void 0;\n    this.offsetY = void 0;\n  }\n  linkScales() {\n  }\n  parse(start, count) {\n    const data = this.getDataset().data;\n    const meta = this._cachedMeta;\n    if (this._parsing === false) {\n      meta._parsed = data;\n    } else {\n      let getter = (i2) => +data[i2];\n      if (isObject(data[start])) {\n        const {\n          key = \"value\"\n        } = this._parsing;\n        getter = (i2) => +resolveObjectKey(data[i2], key);\n      }\n      let i, ilen;\n      for (i = start, ilen = start + count; i < ilen; ++i) {\n        meta._parsed[i] = getter(i);\n      }\n    }\n  }\n  _getRotation() {\n    return toRadians(this.options.rotation - 90);\n  }\n  _getCircumference() {\n    return toRadians(this.options.circumference);\n  }\n  _getRotationExtents() {\n    let min = TAU;\n    let max = -TAU;\n    for (let i = 0; i < this.chart.data.datasets.length; ++i) {\n      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {\n        const controller = this.chart.getDatasetMeta(i).controller;\n        const rotation = controller._getRotation();\n        const circumference = controller._getCircumference();\n        min = Math.min(min, rotation);\n        max = Math.max(max, rotation + circumference);\n      }\n    }\n    return {\n      rotation: min,\n      circumference: max - min\n    };\n  }\n  update(mode) {\n    const chart = this.chart;\n    const {\n      chartArea\n    } = chart;\n    const meta = this._cachedMeta;\n    const arcs = meta.data;\n    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);\n    const chartWeight = this._getRingWeight(this.index);\n    const {\n      circumference,\n      rotation\n    } = this._getRotationExtents();\n    const {\n      ratioX,\n      ratioY,\n      offsetX,\n      offsetY\n    } = getRatioAndOffset(rotation, circumference, cutout);\n    const maxWidth = (chartArea.width - spacing) / ratioX;\n    const maxHeight = (chartArea.height - spacing) / ratioY;\n    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n    const outerRadius = toDimension(this.options.radius, maxRadius);\n    const innerRadius = Math.max(outerRadius * cutout, 0);\n    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n    this.offsetX = offsetX * outerRadius;\n    this.offsetY = offsetY * outerRadius;\n    meta.total = this.calculateTotal();\n    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n  _circumference(i, reset) {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const circumference = this._getCircumference();\n    if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n      return 0;\n    }\n    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);\n  }\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === \"reset\";\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const centerX = (chartArea.left + chartArea.right) / 2;\n    const centerY = (chartArea.top + chartArea.bottom) / 2;\n    const animateScale = reset && animationOpts.animateScale;\n    const innerRadius = animateScale ? 0 : this.innerRadius;\n    const outerRadius = animateScale ? 0 : this.outerRadius;\n    const {\n      sharedOptions,\n      includeOptions\n    } = this._getSharedOptions(start, mode);\n    let startAngle = this._getRotation();\n    let i;\n    for (i = 0; i < start; ++i) {\n      startAngle += this._circumference(i, reset);\n    }\n    for (i = start; i < start + count; ++i) {\n      const circumference = this._circumference(i, reset);\n      const arc = arcs[i];\n      const properties = {\n        x: centerX + this.offsetX,\n        y: centerY + this.offsetY,\n        startAngle,\n        endAngle: startAngle + circumference,\n        circumference,\n        outerRadius,\n        innerRadius\n      };\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? \"active\" : mode);\n      }\n      startAngle += circumference;\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n  calculateTotal() {\n    const meta = this._cachedMeta;\n    const metaData = meta.data;\n    let total = 0;\n    let i;\n    for (i = 0; i < metaData.length; i++) {\n      const value = meta._parsed[i];\n      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n        total += Math.abs(value);\n      }\n    }\n    return total;\n  }\n  calculateCircumference(value) {\n    const total = this._cachedMeta.total;\n    if (total > 0 && !isNaN(value)) {\n      return TAU * (Math.abs(value) / total);\n    }\n    return 0;\n  }\n  getLabelAndValue(index2) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index2], chart.options.locale);\n    return {\n      label: labels[index2] || \"\",\n      value\n    };\n  }\n  getMaxBorderWidth(arcs) {\n    let max = 0;\n    const chart = this.chart;\n    let i, ilen, meta, controller, options;\n    if (!arcs) {\n      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n        if (chart.isDatasetVisible(i)) {\n          meta = chart.getDatasetMeta(i);\n          arcs = meta.data;\n          controller = meta.controller;\n          break;\n        }\n      }\n    }\n    if (!arcs) {\n      return 0;\n    }\n    for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n      options = controller.resolveDataElementOptions(i);\n      if (options.borderAlign !== \"inner\") {\n        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n      }\n    }\n    return max;\n  }\n  getMaxOffset(arcs) {\n    let max = 0;\n    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {\n      const options = this.resolveDataElementOptions(i);\n      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n    }\n    return max;\n  }\n  _getRingWeightOffset(datasetIndex) {\n    let ringWeightOffset = 0;\n    for (let i = 0; i < datasetIndex; ++i) {\n      if (this.chart.isDatasetVisible(i)) {\n        ringWeightOffset += this._getRingWeight(i);\n      }\n    }\n    return ringWeightOffset;\n  }\n  _getRingWeight(datasetIndex) {\n    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n  }\n  _getVisibleDatasetWeightTotal() {\n    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n  }\n};\nvar LineController = class extends DatasetController {\n  static id = \"line\";\n  static defaults = {\n    datasetElementType: \"line\",\n    dataElementType: \"point\",\n    showLine: true,\n    spanGaps: false\n  };\n  static overrides = {\n    scales: {\n      _index_: {\n        type: \"category\"\n      },\n      _value_: {\n        type: \"linear\"\n      }\n    }\n  };\n  initialize() {\n    this.enableOptionSharing = true;\n    this.supportsDecimation = true;\n    super.initialize();\n  }\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {\n      dataset: line,\n      data: points = [],\n      _dataset\n    } = meta;\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {\n      start,\n      count\n    } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n    this._drawStart = start;\n    this._drawCount = count;\n    if (_scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n    line._chart = this.chart;\n    line._datasetIndex = this.index;\n    line._decimated = !!_dataset._decimated;\n    line.points = points;\n    const options = this.resolveDatasetElementOptions(mode);\n    if (!this.options.showLine) {\n      options.borderWidth = 0;\n    }\n    options.segment = this.options.segment;\n    this.updateElement(line, void 0, {\n      animated: !animationsDisabled,\n      options\n    }, mode);\n    this.updateElements(points, start, count, mode);\n  }\n  updateElements(points, start, count, mode) {\n    const reset = mode === \"reset\";\n    const {\n      iScale,\n      vScale,\n      _stacked,\n      _dataset\n    } = this._cachedMeta;\n    const {\n      sharedOptions,\n      includeOptions\n    } = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {\n      spanGaps,\n      segment\n    } = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === \"none\";\n    const end = start + count;\n    const pointsCount = points.length;\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n    for (let i = 0; i < pointsCount; ++i) {\n      const point = points[i];\n      const properties = directUpdate ? point : {};\n      if (i < start || i >= end) {\n        properties.skip = true;\n        continue;\n      }\n      const parsed = this.getParsed(i);\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? \"active\" : mode);\n      }\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n      prevParsed = parsed;\n    }\n  }\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n    const data = meta.data || [];\n    if (!data.length) {\n      return border;\n    }\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n  draw() {\n    const meta = this._cachedMeta;\n    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n    super.draw();\n  }\n};\nvar PolarAreaController = class extends DatasetController {\n  static id = \"polarArea\";\n  static defaults = {\n    dataElementType: \"arc\",\n    animation: {\n      animateRotate: true,\n      animateScale: true\n    },\n    animations: {\n      numbers: {\n        type: \"number\",\n        properties: [\"x\", \"y\", \"startAngle\", \"endAngle\", \"innerRadius\", \"outerRadius\"]\n      }\n    },\n    indexAxis: \"r\",\n    startAngle: 0\n  };\n  static overrides = {\n    aspectRatio: 1,\n    plugins: {\n      legend: {\n        labels: {\n          generateLabels(chart) {\n            const data = chart.data;\n            if (data.labels.length && data.datasets.length) {\n              const {\n                labels: {\n                  pointStyle,\n                  color: color2\n                }\n              } = chart.legend.options;\n              return data.labels.map((label, i) => {\n                const meta = chart.getDatasetMeta(0);\n                const style = meta.controller.getStyle(i);\n                return {\n                  text: label,\n                  fillStyle: style.backgroundColor,\n                  strokeStyle: style.borderColor,\n                  fontColor: color2,\n                  lineWidth: style.borderWidth,\n                  pointStyle,\n                  hidden: !chart.getDataVisibility(i),\n                  index: i\n                };\n              });\n            }\n            return [];\n          }\n        },\n        onClick(e, legendItem, legend) {\n          legend.chart.toggleDataVisibility(legendItem.index);\n          legend.chart.update();\n        }\n      }\n    },\n    scales: {\n      r: {\n        type: \"radialLinear\",\n        angleLines: {\n          display: false\n        },\n        beginAtZero: true,\n        grid: {\n          circular: true\n        },\n        pointLabels: {\n          display: false\n        },\n        startAngle: 0\n      }\n    }\n  };\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n    this.innerRadius = void 0;\n    this.outerRadius = void 0;\n  }\n  getLabelAndValue(index2) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index2].r, chart.options.locale);\n    return {\n      label: labels[index2] || \"\",\n      value\n    };\n  }\n  parseObjectData(meta, data, start, count) {\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n  }\n  update(mode) {\n    const arcs = this._cachedMeta.data;\n    this._updateRadius();\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n  getMinMax() {\n    const meta = this._cachedMeta;\n    const range = {\n      min: Number.POSITIVE_INFINITY,\n      max: Number.NEGATIVE_INFINITY\n    };\n    meta.data.forEach((element, index2) => {\n      const parsed = this.getParsed(index2).r;\n      if (!isNaN(parsed) && this.chart.getDataVisibility(index2)) {\n        if (parsed < range.min) {\n          range.min = parsed;\n        }\n        if (parsed > range.max) {\n          range.max = parsed;\n        }\n      }\n    });\n    return range;\n  }\n  _updateRadius() {\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n    const outerRadius = Math.max(minSize / 2, 0);\n    const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);\n    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n    this.outerRadius = outerRadius - radiusLength * this.index;\n    this.innerRadius = this.outerRadius - radiusLength;\n  }\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === \"reset\";\n    const chart = this.chart;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const scale = this._cachedMeta.rScale;\n    const centerX = scale.xCenter;\n    const centerY = scale.yCenter;\n    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\n    let angle = datasetStartAngle;\n    let i;\n    const defaultAngle = 360 / this.countVisibleElements();\n    for (i = 0; i < start; ++i) {\n      angle += this._computeAngle(i, mode, defaultAngle);\n    }\n    for (i = start; i < start + count; i++) {\n      const arc = arcs[i];\n      let startAngle = angle;\n      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\n      angle = endAngle;\n      if (reset) {\n        if (animationOpts.animateScale) {\n          outerRadius = 0;\n        }\n        if (animationOpts.animateRotate) {\n          startAngle = endAngle = datasetStartAngle;\n        }\n      }\n      const properties = {\n        x: centerX,\n        y: centerY,\n        innerRadius: 0,\n        outerRadius,\n        startAngle,\n        endAngle,\n        options: this.resolveDataElementOptions(i, arc.active ? \"active\" : mode)\n      };\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n  countVisibleElements() {\n    const meta = this._cachedMeta;\n    let count = 0;\n    meta.data.forEach((element, index2) => {\n      if (!isNaN(this.getParsed(index2).r) && this.chart.getDataVisibility(index2)) {\n        count++;\n      }\n    });\n    return count;\n  }\n  _computeAngle(index2, mode, defaultAngle) {\n    return this.chart.getDataVisibility(index2) ? toRadians(this.resolveDataElementOptions(index2, mode).angle || defaultAngle) : 0;\n  }\n};\nvar PieController = class extends DoughnutController {\n  static id = \"pie\";\n  static defaults = {\n    cutout: 0,\n    rotation: 0,\n    circumference: 360,\n    radius: \"100%\"\n  };\n};\nvar RadarController = class extends DatasetController {\n  static id = \"radar\";\n  static defaults = {\n    datasetElementType: \"line\",\n    dataElementType: \"point\",\n    indexAxis: \"r\",\n    showLine: true,\n    elements: {\n      line: {\n        fill: \"start\"\n      }\n    }\n  };\n  static overrides = {\n    aspectRatio: 1,\n    scales: {\n      r: {\n        type: \"radialLinear\"\n      }\n    }\n  };\n  getLabelAndValue(index2) {\n    const vScale = this._cachedMeta.vScale;\n    const parsed = this.getParsed(index2);\n    return {\n      label: vScale.getLabels()[index2],\n      value: \"\" + vScale.getLabelForValue(parsed[vScale.axis])\n    };\n  }\n  parseObjectData(meta, data, start, count) {\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n  }\n  update(mode) {\n    const meta = this._cachedMeta;\n    const line = meta.dataset;\n    const points = meta.data || [];\n    const labels = meta.iScale.getLabels();\n    line.points = points;\n    if (mode !== \"resize\") {\n      const options = this.resolveDatasetElementOptions(mode);\n      if (!this.options.showLine) {\n        options.borderWidth = 0;\n      }\n      const properties = {\n        _loop: true,\n        _fullLoop: labels.length === points.length,\n        options\n      };\n      this.updateElement(line, void 0, properties, mode);\n    }\n    this.updateElements(points, 0, points.length, mode);\n  }\n  updateElements(points, start, count, mode) {\n    const scale = this._cachedMeta.rScale;\n    const reset = mode === \"reset\";\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const options = this.resolveDataElementOptions(i, point.active ? \"active\" : mode);\n      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\n      const x = reset ? scale.xCenter : pointPosition.x;\n      const y = reset ? scale.yCenter : pointPosition.y;\n      const properties = {\n        x,\n        y,\n        angle: pointPosition.angle,\n        skip: isNaN(x) || isNaN(y),\n        options\n      };\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n};\nvar ScatterController = class extends DatasetController {\n  static id = \"scatter\";\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: \"point\",\n    showLine: false,\n    fill: false\n  };\n  static overrides = {\n    interaction: {\n      mode: \"point\"\n    },\n    scales: {\n      x: {\n        type: \"linear\"\n      },\n      y: {\n        type: \"linear\"\n      }\n    }\n  };\n  getLabelAndValue(index2) {\n    const meta = this._cachedMeta;\n    const labels = this.chart.data.labels || [];\n    const {\n      xScale,\n      yScale\n    } = meta;\n    const parsed = this.getParsed(index2);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n    return {\n      label: labels[index2] || \"\",\n      value: \"(\" + x + \", \" + y + \")\"\n    };\n  }\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {\n      data: points = []\n    } = meta;\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {\n      start,\n      count\n    } = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n    this._drawStart = start;\n    this._drawCount = count;\n    if (_scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n    if (this.options.showLine) {\n      if (!this.datasetElementType) {\n        this.addElements();\n      }\n      const {\n        dataset: line,\n        _dataset\n      } = meta;\n      line._chart = this.chart;\n      line._datasetIndex = this.index;\n      line._decimated = !!_dataset._decimated;\n      line.points = points;\n      const options = this.resolveDatasetElementOptions(mode);\n      options.segment = this.options.segment;\n      this.updateElement(line, void 0, {\n        animated: !animationsDisabled,\n        options\n      }, mode);\n    } else if (this.datasetElementType) {\n      delete meta.dataset;\n      this.datasetElementType = false;\n    }\n    this.updateElements(points, start, count, mode);\n  }\n  addElements() {\n    const {\n      showLine\n    } = this.options;\n    if (!this.datasetElementType && showLine) {\n      this.datasetElementType = this.chart.registry.getElement(\"line\");\n    }\n    super.addElements();\n  }\n  updateElements(points, start, count, mode) {\n    const reset = mode === \"reset\";\n    const {\n      iScale,\n      vScale,\n      _stacked,\n      _dataset\n    } = this._cachedMeta;\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {\n      spanGaps,\n      segment\n    } = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === \"none\";\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n    for (let i = start; i < start + count; ++i) {\n      const point = points[i];\n      const parsed = this.getParsed(i);\n      const properties = directUpdate ? point : {};\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? \"active\" : mode);\n      }\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n      prevParsed = parsed;\n    }\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n  }\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const data = meta.data || [];\n    if (!this.options.showLine) {\n      let max = 0;\n      for (let i = data.length - 1; i >= 0; --i) {\n        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n      }\n      return max > 0 && max;\n    }\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n    if (!data.length) {\n      return border;\n    }\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n};\nvar controllers = Object.freeze({\n  __proto__: null,\n  BarController,\n  BubbleController,\n  DoughnutController,\n  LineController,\n  PieController,\n  PolarAreaController,\n  RadarController,\n  ScatterController\n});\nfunction abstract() {\n  throw new Error(\"This method is not implemented: Check that a complete date adapter is provided.\");\n}\nvar DateAdapterBase = class _DateAdapterBase {\n  /**\n  * Override default date adapter methods.\n  * Accepts type parameter to define options type.\n  * @example\n  * Chart._adapters._date.override<{myAdapterOption: string}>({\n  *   init() {\n  *     console.log(this.options.myAdapterOption);\n  *   }\n  * })\n  */\n  static override(members) {\n    Object.assign(_DateAdapterBase.prototype, members);\n  }\n  options;\n  constructor(options) {\n    this.options = options || {};\n  }\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  init() {\n  }\n  formats() {\n    return abstract();\n  }\n  parse() {\n    return abstract();\n  }\n  format() {\n    return abstract();\n  }\n  add() {\n    return abstract();\n  }\n  diff() {\n    return abstract();\n  }\n  startOf() {\n    return abstract();\n  }\n  endOf() {\n    return abstract();\n  }\n};\nvar adapters = {\n  _date: DateAdapterBase\n};\nfunction binarySearch(metaset, axis, value, intersect) {\n  const {\n    controller,\n    data,\n    _sorted\n  } = metaset;\n  const iScale = controller._cachedMeta.iScale;\n  const spanGaps = metaset.dataset ? metaset.dataset.options ? metaset.dataset.options.spanGaps : null : null;\n  if (iScale && axis === iScale.axis && axis !== \"r\" && _sorted && data.length) {\n    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\n    if (!intersect) {\n      const result = lookupMethod(data, axis, value);\n      if (spanGaps) {\n        const {\n          vScale\n        } = controller._cachedMeta;\n        const {\n          _parsed\n        } = metaset;\n        const distanceToDefinedLo = _parsed.slice(0, result.lo + 1).reverse().findIndex((point) => !isNullOrUndef(point[vScale.axis]));\n        result.lo -= Math.max(0, distanceToDefinedLo);\n        const distanceToDefinedHi = _parsed.slice(result.hi).findIndex((point) => !isNullOrUndef(point[vScale.axis]));\n        result.hi += Math.max(0, distanceToDefinedHi);\n      }\n      return result;\n    } else if (controller._sharedOptions) {\n      const el = data[0];\n      const range = typeof el.getRange === \"function\" && el.getRange(axis);\n      if (range) {\n        const start = lookupMethod(data, axis, value - range);\n        const end = lookupMethod(data, axis, value + range);\n        return {\n          lo: start.lo,\n          hi: end.hi\n        };\n      }\n    }\n  }\n  return {\n    lo: 0,\n    hi: data.length - 1\n  };\n}\nfunction evaluateInteractionItems(chart, axis, position, handler, intersect) {\n  const metasets = chart.getSortedVisibleDatasetMetas();\n  const value = position[axis];\n  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\n    const {\n      index: index2,\n      data\n    } = metasets[i];\n    const {\n      lo,\n      hi\n    } = binarySearch(metasets[i], axis, value, intersect);\n    for (let j = lo; j <= hi; ++j) {\n      const element = data[j];\n      if (!element.skip) {\n        handler(element, index2, j);\n      }\n    }\n  }\n}\nfunction getDistanceMetricForAxis(axis) {\n  const useX = axis.indexOf(\"x\") !== -1;\n  const useY = axis.indexOf(\"y\") !== -1;\n  return function(pt1, pt2) {\n    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n  };\n}\nfunction getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\n  const items = [];\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return items;\n  }\n  const evaluationFunc = function(element, datasetIndex, index2) {\n    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {\n      return;\n    }\n    if (element.inRange(position.x, position.y, useFinalPosition)) {\n      items.push({\n        element,\n        datasetIndex,\n        index: index2\n      });\n    }\n  };\n  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\n  return items;\n}\nfunction getNearestRadialItems(chart, position, axis, useFinalPosition) {\n  let items = [];\n  function evaluationFunc(element, datasetIndex, index2) {\n    const {\n      startAngle,\n      endAngle\n    } = element.getProps([\"startAngle\", \"endAngle\"], useFinalPosition);\n    const {\n      angle\n    } = getAngleFromPoint(element, {\n      x: position.x,\n      y: position.y\n    });\n    if (_angleBetween(angle, startAngle, endAngle)) {\n      items.push({\n        element,\n        datasetIndex,\n        index: index2\n      });\n    }\n  }\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\nfunction getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  let items = [];\n  const distanceMetric = getDistanceMetricForAxis(axis);\n  let minDistance = Number.POSITIVE_INFINITY;\n  function evaluationFunc(element, datasetIndex, index2) {\n    const inRange2 = element.inRange(position.x, position.y, useFinalPosition);\n    if (intersect && !inRange2) {\n      return;\n    }\n    const center = element.getCenterPoint(useFinalPosition);\n    const pointInArea = !!includeInvisible || chart.isPointInArea(center);\n    if (!pointInArea && !inRange2) {\n      return;\n    }\n    const distance = distanceMetric(position, center);\n    if (distance < minDistance) {\n      items = [{\n        element,\n        datasetIndex,\n        index: index2\n      }];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      items.push({\n        element,\n        datasetIndex,\n        index: index2\n      });\n    }\n  }\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return [];\n  }\n  return axis === \"r\" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\n}\nfunction getAxisItems(chart, position, axis, intersect, useFinalPosition) {\n  const items = [];\n  const rangeMethod = axis === \"x\" ? \"inXRange\" : \"inYRange\";\n  let intersectsItem = false;\n  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index2) => {\n    if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {\n      items.push({\n        element,\n        datasetIndex,\n        index: index2\n      });\n      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\n    }\n  });\n  if (intersect && !intersectsItem) {\n    return [];\n  }\n  return items;\n}\nvar Interaction = {\n  evaluateInteractionItems,\n  modes: {\n    index(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || \"x\";\n      const includeInvisible = options.includeInvisible || false;\n      const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n      const elements2 = [];\n      if (!items.length) {\n        return [];\n      }\n      chart.getSortedVisibleDatasetMetas().forEach((meta) => {\n        const index2 = items[0].index;\n        const element = meta.data[index2];\n        if (element && !element.skip) {\n          elements2.push({\n            element,\n            datasetIndex: meta.index,\n            index: index2\n          });\n        }\n      });\n      return elements2;\n    },\n    dataset(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || \"xy\";\n      const includeInvisible = options.includeInvisible || false;\n      let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n      if (items.length > 0) {\n        const datasetIndex = items[0].datasetIndex;\n        const data = chart.getDatasetMeta(datasetIndex).data;\n        items = [];\n        for (let i = 0; i < data.length; ++i) {\n          items.push({\n            element: data[i],\n            datasetIndex,\n            index: i\n          });\n        }\n      }\n      return items;\n    },\n    point(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || \"xy\";\n      const includeInvisible = options.includeInvisible || false;\n      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\n    },\n    nearest(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || \"xy\";\n      const includeInvisible = options.includeInvisible || false;\n      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\n    },\n    x(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      return getAxisItems(chart, position, \"x\", options.intersect, useFinalPosition);\n    },\n    y(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      return getAxisItems(chart, position, \"y\", options.intersect, useFinalPosition);\n    }\n  }\n};\nvar STATIC_POSITIONS = [\"left\", \"top\", \"right\", \"bottom\"];\nfunction filterByPosition(array, position) {\n  return array.filter((v) => v.pos === position);\n}\nfunction filterDynamicPositionByAxis(array, axis) {\n  return array.filter((v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\nfunction sortByWeight(array, reverse) {\n  return array.sort((a, b) => {\n    const v0 = reverse ? b : a;\n    const v1 = reverse ? a : b;\n    return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;\n  });\n}\nfunction wrapBoxes(boxes) {\n  const layoutBoxes = [];\n  let i, ilen, box, pos, stack, stackWeight;\n  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\n    box = boxes[i];\n    ({\n      position: pos,\n      options: {\n        stack,\n        stackWeight = 1\n      }\n    } = box);\n    layoutBoxes.push({\n      index: i,\n      box,\n      pos,\n      horizontal: box.isHorizontal(),\n      weight: box.weight,\n      stack: stack && pos + stack,\n      stackWeight\n    });\n  }\n  return layoutBoxes;\n}\nfunction buildStacks(layouts2) {\n  const stacks = {};\n  for (const wrap of layouts2) {\n    const {\n      stack,\n      pos,\n      stackWeight\n    } = wrap;\n    if (!stack || !STATIC_POSITIONS.includes(pos)) {\n      continue;\n    }\n    const _stack = stacks[stack] || (stacks[stack] = {\n      count: 0,\n      placed: 0,\n      weight: 0,\n      size: 0\n    });\n    _stack.count++;\n    _stack.weight += stackWeight;\n  }\n  return stacks;\n}\nfunction setLayoutDims(layouts2, params) {\n  const stacks = buildStacks(layouts2);\n  const {\n    vBoxMaxWidth,\n    hBoxMaxHeight\n  } = params;\n  let i, ilen, layout;\n  for (i = 0, ilen = layouts2.length; i < ilen; ++i) {\n    layout = layouts2[i];\n    const {\n      fullSize\n    } = layout.box;\n    const stack = stacks[layout.stack];\n    const factor = stack && layout.stackWeight / stack.weight;\n    if (layout.horizontal) {\n      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n      layout.height = hBoxMaxHeight;\n    } else {\n      layout.width = vBoxMaxWidth;\n      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n    }\n  }\n  return stacks;\n}\nfunction buildLayoutBoxes(boxes) {\n  const layoutBoxes = wrapBoxes(boxes);\n  const fullSize = sortByWeight(layoutBoxes.filter((wrap) => wrap.box.fullSize), true);\n  const left = sortByWeight(filterByPosition(layoutBoxes, \"left\"), true);\n  const right = sortByWeight(filterByPosition(layoutBoxes, \"right\"));\n  const top = sortByWeight(filterByPosition(layoutBoxes, \"top\"), true);\n  const bottom = sortByWeight(filterByPosition(layoutBoxes, \"bottom\"));\n  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, \"x\");\n  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, \"y\");\n  return {\n    fullSize,\n    leftAndTop: left.concat(top),\n    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n    chartArea: filterByPosition(layoutBoxes, \"chartArea\"),\n    vertical: left.concat(right).concat(centerVertical),\n    horizontal: top.concat(bottom).concat(centerHorizontal)\n  };\n}\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\nfunction updateMaxPadding(maxPadding, boxPadding) {\n  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\nfunction updateDims(chartArea, params, layout, stacks) {\n  const {\n    pos,\n    box\n  } = layout;\n  const maxPadding = chartArea.maxPadding;\n  if (!isObject(pos)) {\n    if (layout.size) {\n      chartArea[pos] -= layout.size;\n    }\n    const stack = stacks[layout.stack] || {\n      size: 0,\n      count: 1\n    };\n    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n    layout.size = stack.size / stack.count;\n    chartArea[pos] += layout.size;\n  }\n  if (box.getPadding) {\n    updateMaxPadding(maxPadding, box.getPadding());\n  }\n  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, \"left\", \"right\"));\n  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, \"top\", \"bottom\"));\n  const widthChanged = newWidth !== chartArea.w;\n  const heightChanged = newHeight !== chartArea.h;\n  chartArea.w = newWidth;\n  chartArea.h = newHeight;\n  return layout.horizontal ? {\n    same: widthChanged,\n    other: heightChanged\n  } : {\n    same: heightChanged,\n    other: widthChanged\n  };\n}\nfunction handleMaxPadding(chartArea) {\n  const maxPadding = chartArea.maxPadding;\n  function updatePos(pos) {\n    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n    chartArea[pos] += change;\n    return change;\n  }\n  chartArea.y += updatePos(\"top\");\n  chartArea.x += updatePos(\"left\");\n  updatePos(\"right\");\n  updatePos(\"bottom\");\n}\nfunction getMargins(horizontal, chartArea) {\n  const maxPadding = chartArea.maxPadding;\n  function marginForPositions(positions2) {\n    const margin = {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0\n    };\n    positions2.forEach((pos) => {\n      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n    });\n    return margin;\n  }\n  return horizontal ? marginForPositions([\"left\", \"right\"]) : marginForPositions([\"top\", \"bottom\"]);\n}\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n  const refitBoxes = [];\n  let i, ilen, layout, box, refit, changed;\n  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {\n    layout = boxes[i];\n    box = layout.box;\n    box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));\n    const {\n      same,\n      other\n    } = updateDims(chartArea, params, layout, stacks);\n    refit |= same && refitBoxes.length;\n    changed = changed || other;\n    if (!box.fullSize) {\n      refitBoxes.push(layout);\n    }\n  }\n  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\nfunction setBoxDims(box, left, top, width, height) {\n  box.top = top;\n  box.left = left;\n  box.right = left + width;\n  box.bottom = top + height;\n  box.width = width;\n  box.height = height;\n}\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n  const userPadding = params.padding;\n  let {\n    x,\n    y\n  } = chartArea;\n  for (const layout of boxes) {\n    const box = layout.box;\n    const stack = stacks[layout.stack] || {\n      count: 1,\n      placed: 0,\n      weight: 1\n    };\n    const weight = layout.stackWeight / stack.weight || 1;\n    if (layout.horizontal) {\n      const width = chartArea.w * weight;\n      const height = stack.size || box.height;\n      if (defined(stack.start)) {\n        y = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n      } else {\n        setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n      }\n      stack.start = y;\n      stack.placed += width;\n      y = box.bottom;\n    } else {\n      const height = chartArea.h * weight;\n      const width = stack.size || box.width;\n      if (defined(stack.start)) {\n        x = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n      } else {\n        setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n      }\n      stack.start = x;\n      stack.placed += height;\n      x = box.right;\n    }\n  }\n  chartArea.x = x;\n  chartArea.y = y;\n}\nvar layouts = {\n  addBox(chart, item) {\n    if (!chart.boxes) {\n      chart.boxes = [];\n    }\n    item.fullSize = item.fullSize || false;\n    item.position = item.position || \"top\";\n    item.weight = item.weight || 0;\n    item._layers = item._layers || function() {\n      return [{\n        z: 0,\n        draw(chartArea) {\n          item.draw(chartArea);\n        }\n      }];\n    };\n    chart.boxes.push(item);\n  },\n  removeBox(chart, layoutItem) {\n    const index2 = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n    if (index2 !== -1) {\n      chart.boxes.splice(index2, 1);\n    }\n  },\n  configure(chart, item, options) {\n    item.fullSize = options.fullSize;\n    item.position = options.position;\n    item.weight = options.weight;\n  },\n  update(chart, width, height, minPadding) {\n    if (!chart) {\n      return;\n    }\n    const padding = toPadding(chart.options.layout.padding);\n    const availableWidth = Math.max(width - padding.width, 0);\n    const availableHeight = Math.max(height - padding.height, 0);\n    const boxes = buildLayoutBoxes(chart.boxes);\n    const verticalBoxes = boxes.vertical;\n    const horizontalBoxes = boxes.horizontal;\n    each(chart.boxes, (box) => {\n      if (typeof box.beforeLayout === \"function\") {\n        box.beforeLayout();\n      }\n    });\n    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n    const params = Object.freeze({\n      outerWidth: width,\n      outerHeight: height,\n      padding,\n      availableWidth,\n      availableHeight,\n      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n      hBoxMaxHeight: availableHeight / 2\n    });\n    const maxPadding = Object.assign({}, padding);\n    updateMaxPadding(maxPadding, toPadding(minPadding));\n    const chartArea = Object.assign({\n      maxPadding,\n      w: availableWidth,\n      h: availableHeight,\n      x: padding.left,\n      y: padding.top\n    }, padding);\n    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n    fitBoxes(boxes.fullSize, chartArea, params, stacks);\n    fitBoxes(verticalBoxes, chartArea, params, stacks);\n    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n      fitBoxes(verticalBoxes, chartArea, params, stacks);\n    }\n    handleMaxPadding(chartArea);\n    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n    chartArea.x += chartArea.w;\n    chartArea.y += chartArea.h;\n    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n    chart.chartArea = {\n      left: chartArea.left,\n      top: chartArea.top,\n      right: chartArea.left + chartArea.w,\n      bottom: chartArea.top + chartArea.h,\n      height: chartArea.h,\n      width: chartArea.w\n    };\n    each(boxes.chartArea, (layout) => {\n      const box = layout.box;\n      Object.assign(box, chart.chartArea);\n      box.update(chartArea.w, chartArea.h, {\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0\n      });\n    });\n  }\n};\nvar BasePlatform = class {\n  acquireContext(canvas, aspectRatio) {\n  }\n  releaseContext(context) {\n    return false;\n  }\n  addEventListener(chart, type, listener) {\n  }\n  removeEventListener(chart, type, listener) {\n  }\n  getDevicePixelRatio() {\n    return 1;\n  }\n  getMaximumSize(element, width, height, aspectRatio) {\n    width = Math.max(0, width || element.width);\n    height = height || element.height;\n    return {\n      width,\n      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n    };\n  }\n  isAttached(canvas) {\n    return true;\n  }\n  updateConfig(config) {\n  }\n};\nvar BasicPlatform = class extends BasePlatform {\n  acquireContext(item) {\n    return item && item.getContext && item.getContext(\"2d\") || null;\n  }\n  updateConfig(config) {\n    config.options.animation = false;\n  }\n};\nvar EXPANDO_KEY = \"$chartjs\";\nvar EVENT_TYPES = {\n  touchstart: \"mousedown\",\n  touchmove: \"mousemove\",\n  touchend: \"mouseup\",\n  pointerenter: \"mouseenter\",\n  pointerdown: \"mousedown\",\n  pointermove: \"mousemove\",\n  pointerup: \"mouseup\",\n  pointerleave: \"mouseout\",\n  pointerout: \"mouseout\"\n};\nvar isNullOrEmpty = (value) => value === null || value === \"\";\nfunction initCanvas(canvas, aspectRatio) {\n  const style = canvas.style;\n  const renderHeight = canvas.getAttribute(\"height\");\n  const renderWidth = canvas.getAttribute(\"width\");\n  canvas[EXPANDO_KEY] = {\n    initial: {\n      height: renderHeight,\n      width: renderWidth,\n      style: {\n        display: style.display,\n        height: style.height,\n        width: style.width\n      }\n    }\n  };\n  style.display = style.display || \"block\";\n  style.boxSizing = style.boxSizing || \"border-box\";\n  if (isNullOrEmpty(renderWidth)) {\n    const displayWidth = readUsedSize(canvas, \"width\");\n    if (displayWidth !== void 0) {\n      canvas.width = displayWidth;\n    }\n  }\n  if (isNullOrEmpty(renderHeight)) {\n    if (canvas.style.height === \"\") {\n      canvas.height = canvas.width / (aspectRatio || 2);\n    } else {\n      const displayHeight = readUsedSize(canvas, \"height\");\n      if (displayHeight !== void 0) {\n        canvas.height = displayHeight;\n      }\n    }\n  }\n  return canvas;\n}\nvar eventListenerOptions = supportsEventListenerOptions ? {\n  passive: true\n} : false;\nfunction addListener(node, type, listener) {\n  if (node) {\n    node.addEventListener(type, listener, eventListenerOptions);\n  }\n}\nfunction removeListener(chart, type, listener) {\n  if (chart && chart.canvas) {\n    chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n  }\n}\nfunction fromNativeEvent(event, chart) {\n  const type = EVENT_TYPES[event.type] || event.type;\n  const {\n    x,\n    y\n  } = getRelativePosition(event, chart);\n  return {\n    type,\n    chart,\n    native: event,\n    x: x !== void 0 ? x : null,\n    y: y !== void 0 ? y : null\n  };\n}\nfunction nodeListContains(nodeList, canvas) {\n  for (const node of nodeList) {\n    if (node === canvas || node.contains(canvas)) {\n      return true;\n    }\n  }\n}\nfunction createAttachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver((entries) => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\nfunction createDetachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver((entries) => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {\n    childList: true,\n    subtree: true\n  });\n  return observer;\n}\nvar drpListeningCharts = /* @__PURE__ */ new Map();\nvar oldDevicePixelRatio = 0;\nfunction onWindowResize() {\n  const dpr = window.devicePixelRatio;\n  if (dpr === oldDevicePixelRatio) {\n    return;\n  }\n  oldDevicePixelRatio = dpr;\n  drpListeningCharts.forEach((resize, chart) => {\n    if (chart.currentDevicePixelRatio !== dpr) {\n      resize();\n    }\n  });\n}\nfunction listenDevicePixelRatioChanges(chart, resize) {\n  if (!drpListeningCharts.size) {\n    window.addEventListener(\"resize\", onWindowResize);\n  }\n  drpListeningCharts.set(chart, resize);\n}\nfunction unlistenDevicePixelRatioChanges(chart) {\n  drpListeningCharts.delete(chart);\n  if (!drpListeningCharts.size) {\n    window.removeEventListener(\"resize\", onWindowResize);\n  }\n}\nfunction createResizeObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const container = canvas && _getParentNode(canvas);\n  if (!container) {\n    return;\n  }\n  const resize = throttled((width, height) => {\n    const w = container.clientWidth;\n    listener(width, height);\n    if (w < container.clientWidth) {\n      listener();\n    }\n  }, window);\n  const observer = new ResizeObserver((entries) => {\n    const entry = entries[0];\n    const width = entry.contentRect.width;\n    const height = entry.contentRect.height;\n    if (width === 0 && height === 0) {\n      return;\n    }\n    resize(width, height);\n  });\n  observer.observe(container);\n  listenDevicePixelRatioChanges(chart, resize);\n  return observer;\n}\nfunction releaseObserver(chart, type, observer) {\n  if (observer) {\n    observer.disconnect();\n  }\n  if (type === \"resize\") {\n    unlistenDevicePixelRatioChanges(chart);\n  }\n}\nfunction createProxyAndListen(chart, type, listener) {\n  const canvas = chart.canvas;\n  const proxy = throttled((event) => {\n    if (chart.ctx !== null) {\n      listener(fromNativeEvent(event, chart));\n    }\n  }, chart);\n  addListener(canvas, type, proxy);\n  return proxy;\n}\nvar DomPlatform = class extends BasePlatform {\n  acquireContext(canvas, aspectRatio) {\n    const context = canvas && canvas.getContext && canvas.getContext(\"2d\");\n    if (context && context.canvas === canvas) {\n      initCanvas(canvas, aspectRatio);\n      return context;\n    }\n    return null;\n  }\n  releaseContext(context) {\n    const canvas = context.canvas;\n    if (!canvas[EXPANDO_KEY]) {\n      return false;\n    }\n    const initial = canvas[EXPANDO_KEY].initial;\n    [\"height\", \"width\"].forEach((prop) => {\n      const value = initial[prop];\n      if (isNullOrUndef(value)) {\n        canvas.removeAttribute(prop);\n      } else {\n        canvas.setAttribute(prop, value);\n      }\n    });\n    const style = initial.style || {};\n    Object.keys(style).forEach((key) => {\n      canvas.style[key] = style[key];\n    });\n    canvas.width = canvas.width;\n    delete canvas[EXPANDO_KEY];\n    return true;\n  }\n  addEventListener(chart, type, listener) {\n    this.removeEventListener(chart, type);\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const handlers = {\n      attach: createAttachObserver,\n      detach: createDetachObserver,\n      resize: createResizeObserver\n    };\n    const handler = handlers[type] || createProxyAndListen;\n    proxies[type] = handler(chart, type, listener);\n  }\n  removeEventListener(chart, type) {\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const proxy = proxies[type];\n    if (!proxy) {\n      return;\n    }\n    const handlers = {\n      attach: releaseObserver,\n      detach: releaseObserver,\n      resize: releaseObserver\n    };\n    const handler = handlers[type] || removeListener;\n    handler(chart, type, proxy);\n    proxies[type] = void 0;\n  }\n  getDevicePixelRatio() {\n    return window.devicePixelRatio;\n  }\n  getMaximumSize(canvas, width, height, aspectRatio) {\n    return getMaximumSize(canvas, width, height, aspectRatio);\n  }\n  isAttached(canvas) {\n    const container = canvas && _getParentNode(canvas);\n    return !!(container && container.isConnected);\n  }\n};\nfunction _detectPlatform(canvas) {\n  if (!_isDomSupported() || typeof OffscreenCanvas !== \"undefined\" && canvas instanceof OffscreenCanvas) {\n    return BasicPlatform;\n  }\n  return DomPlatform;\n}\nvar Element = class {\n  static defaults = {};\n  static defaultRoutes = void 0;\n  x;\n  y;\n  active = false;\n  options;\n  $animations;\n  tooltipPosition(useFinalPosition) {\n    const {\n      x,\n      y\n    } = this.getProps([\"x\", \"y\"], useFinalPosition);\n    return {\n      x,\n      y\n    };\n  }\n  hasValue() {\n    return isNumber(this.x) && isNumber(this.y);\n  }\n  getProps(props, final) {\n    const anims = this.$animations;\n    if (!final || !anims) {\n      return this;\n    }\n    const ret = {};\n    props.forEach((prop) => {\n      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];\n    });\n    return ret;\n  }\n};\nfunction autoSkip(scale, ticks) {\n  const tickOpts = scale.options.ticks;\n  const determinedMaxTicks = determineMaxTicks(scale);\n  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);\n  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n  const numMajorIndices = majorIndices.length;\n  const first = majorIndices[0];\n  const last = majorIndices[numMajorIndices - 1];\n  const newTicks = [];\n  if (numMajorIndices > ticksLimit) {\n    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n    return newTicks;\n  }\n  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n  if (numMajorIndices > 0) {\n    let i, ilen;\n    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\n      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n    }\n    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n    return newTicks;\n  }\n  skip(ticks, newTicks, spacing);\n  return newTicks;\n}\nfunction determineMaxTicks(scale) {\n  const offset = scale.options.offset;\n  const tickLength = scale._tickSize();\n  const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n  const maxChart = scale._maxLength / tickLength;\n  return Math.floor(Math.min(maxScale, maxChart));\n}\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\n  const evenMajorSpacing = getEvenSpacing(majorIndices);\n  const spacing = ticks.length / ticksLimit;\n  if (!evenMajorSpacing) {\n    return Math.max(spacing, 1);\n  }\n  const factors = _factorize(evenMajorSpacing);\n  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {\n    const factor = factors[i];\n    if (factor > spacing) {\n      return factor;\n    }\n  }\n  return Math.max(spacing, 1);\n}\nfunction getMajorIndices(ticks) {\n  const result = [];\n  let i, ilen;\n  for (i = 0, ilen = ticks.length; i < ilen; i++) {\n    if (ticks[i].major) {\n      result.push(i);\n    }\n  }\n  return result;\n}\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\n  let count = 0;\n  let next = majorIndices[0];\n  let i;\n  spacing = Math.ceil(spacing);\n  for (i = 0; i < ticks.length; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = majorIndices[count * spacing];\n    }\n  }\n}\nfunction skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n  const start = valueOrDefault(majorStart, 0);\n  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\n  let count = 0;\n  let length, i, next;\n  spacing = Math.ceil(spacing);\n  if (majorEnd) {\n    length = majorEnd - majorStart;\n    spacing = length / Math.floor(length / spacing);\n  }\n  next = start;\n  while (next < 0) {\n    count++;\n    next = Math.round(start + count * spacing);\n  }\n  for (i = Math.max(start, 0); i < end; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = Math.round(start + count * spacing);\n    }\n  }\n}\nfunction getEvenSpacing(arr) {\n  const len = arr.length;\n  let i, diff;\n  if (len < 2) {\n    return false;\n  }\n  for (diff = arr[0], i = 1; i < len; ++i) {\n    if (arr[i] - arr[i - 1] !== diff) {\n      return false;\n    }\n  }\n  return diff;\n}\nvar reverseAlign = (align) => align === \"left\" ? \"right\" : align === \"right\" ? \"left\" : align;\nvar offsetFromEdge = (scale, edge, offset) => edge === \"top\" || edge === \"left\" ? scale[edge] + offset : scale[edge] - offset;\nvar getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);\nfunction sample(arr, numItems) {\n  const result = [];\n  const increment = arr.length / numItems;\n  const len = arr.length;\n  let i = 0;\n  for (; i < len; i += increment) {\n    result.push(arr[Math.floor(i)]);\n  }\n  return result;\n}\nfunction getPixelForGridLine(scale, index2, offsetGridLines) {\n  const length = scale.ticks.length;\n  const validIndex2 = Math.min(index2, length - 1);\n  const start = scale._startPixel;\n  const end = scale._endPixel;\n  const epsilon = 1e-6;\n  let lineValue = scale.getPixelForTick(validIndex2);\n  let offset;\n  if (offsetGridLines) {\n    if (length === 1) {\n      offset = Math.max(lineValue - start, end - lineValue);\n    } else if (index2 === 0) {\n      offset = (scale.getPixelForTick(1) - lineValue) / 2;\n    } else {\n      offset = (lineValue - scale.getPixelForTick(validIndex2 - 1)) / 2;\n    }\n    lineValue += validIndex2 < index2 ? offset : -offset;\n    if (lineValue < start - epsilon || lineValue > end + epsilon) {\n      return;\n    }\n  }\n  return lineValue;\n}\nfunction garbageCollect(caches, length) {\n  each(caches, (cache) => {\n    const gc = cache.gc;\n    const gcLen = gc.length / 2;\n    let i;\n    if (gcLen > length) {\n      for (i = 0; i < gcLen; ++i) {\n        delete cache.data[gc[i]];\n      }\n      gc.splice(0, gcLen);\n    }\n  });\n}\nfunction getTickMarkLength(options) {\n  return options.drawTicks ? options.tickLength : 0;\n}\nfunction getTitleHeight(options, fallback) {\n  if (!options.display) {\n    return 0;\n  }\n  const font = toFont(options.font, fallback);\n  const padding = toPadding(options.padding);\n  const lines = isArray(options.text) ? options.text.length : 1;\n  return lines * font.lineHeight + padding.height;\n}\nfunction createScaleContext(parent, scale) {\n  return createContext(parent, {\n    scale,\n    type: \"scale\"\n  });\n}\nfunction createTickContext(parent, index2, tick) {\n  return createContext(parent, {\n    tick,\n    index: index2,\n    type: \"tick\"\n  });\n}\nfunction titleAlign(align, position, reverse) {\n  let ret = _toLeftRightCenter(align);\n  if (reverse && position !== \"right\" || !reverse && position === \"right\") {\n    ret = reverseAlign(ret);\n  }\n  return ret;\n}\nfunction titleArgs(scale, offset, position, align) {\n  const {\n    top,\n    left,\n    bottom,\n    right,\n    chart\n  } = scale;\n  const {\n    chartArea,\n    scales: scales2\n  } = chart;\n  let rotation = 0;\n  let maxWidth, titleX, titleY;\n  const height = bottom - top;\n  const width = right - left;\n  if (scale.isHorizontal()) {\n    titleX = _alignStartEnd(align, left, right);\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleY = scales2[positionAxisID].getPixelForValue(value) + height - offset;\n    } else if (position === \"center\") {\n      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n    } else {\n      titleY = offsetFromEdge(scale, position, offset);\n    }\n    maxWidth = right - left;\n  } else {\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleX = scales2[positionAxisID].getPixelForValue(value) - width + offset;\n    } else if (position === \"center\") {\n      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n    } else {\n      titleX = offsetFromEdge(scale, position, offset);\n    }\n    titleY = _alignStartEnd(align, bottom, top);\n    rotation = position === \"left\" ? -HALF_PI : HALF_PI;\n  }\n  return {\n    titleX,\n    titleY,\n    maxWidth,\n    rotation\n  };\n}\nvar Scale = class _Scale extends Element {\n  constructor(cfg) {\n    super();\n    this.id = cfg.id;\n    this.type = cfg.type;\n    this.options = void 0;\n    this.ctx = cfg.ctx;\n    this.chart = cfg.chart;\n    this.top = void 0;\n    this.bottom = void 0;\n    this.left = void 0;\n    this.right = void 0;\n    this.width = void 0;\n    this.height = void 0;\n    this._margins = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    this.maxWidth = void 0;\n    this.maxHeight = void 0;\n    this.paddingTop = void 0;\n    this.paddingBottom = void 0;\n    this.paddingLeft = void 0;\n    this.paddingRight = void 0;\n    this.axis = void 0;\n    this.labelRotation = void 0;\n    this.min = void 0;\n    this.max = void 0;\n    this._range = void 0;\n    this.ticks = [];\n    this._gridLineItems = null;\n    this._labelItems = null;\n    this._labelSizes = null;\n    this._length = 0;\n    this._maxLength = 0;\n    this._longestTextCache = {};\n    this._startPixel = void 0;\n    this._endPixel = void 0;\n    this._reversePixels = false;\n    this._userMax = void 0;\n    this._userMin = void 0;\n    this._suggestedMax = void 0;\n    this._suggestedMin = void 0;\n    this._ticksLength = 0;\n    this._borderValue = 0;\n    this._cache = {};\n    this._dataLimitsCached = false;\n    this.$context = void 0;\n  }\n  init(options) {\n    this.options = options.setContext(this.getContext());\n    this.axis = options.axis;\n    this._userMin = this.parse(options.min);\n    this._userMax = this.parse(options.max);\n    this._suggestedMin = this.parse(options.suggestedMin);\n    this._suggestedMax = this.parse(options.suggestedMax);\n  }\n  parse(raw, index2) {\n    return raw;\n  }\n  getUserBounds() {\n    let {\n      _userMin,\n      _userMax,\n      _suggestedMin,\n      _suggestedMax\n    } = this;\n    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\n    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\n    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\n    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\n    return {\n      min: finiteOrDefault(_userMin, _suggestedMin),\n      max: finiteOrDefault(_userMax, _suggestedMax),\n      minDefined: isNumberFinite(_userMin),\n      maxDefined: isNumberFinite(_userMax)\n    };\n  }\n  getMinMax(canStack) {\n    let {\n      min,\n      max,\n      minDefined,\n      maxDefined\n    } = this.getUserBounds();\n    let range;\n    if (minDefined && maxDefined) {\n      return {\n        min,\n        max\n      };\n    }\n    const metas = this.getMatchingVisibleMetas();\n    for (let i = 0, ilen = metas.length; i < ilen; ++i) {\n      range = metas[i].controller.getMinMax(this, canStack);\n      if (!minDefined) {\n        min = Math.min(min, range.min);\n      }\n      if (!maxDefined) {\n        max = Math.max(max, range.max);\n      }\n    }\n    min = maxDefined && min > max ? max : min;\n    max = minDefined && min > max ? min : max;\n    return {\n      min: finiteOrDefault(min, finiteOrDefault(max, min)),\n      max: finiteOrDefault(max, finiteOrDefault(min, max))\n    };\n  }\n  getPadding() {\n    return {\n      left: this.paddingLeft || 0,\n      top: this.paddingTop || 0,\n      right: this.paddingRight || 0,\n      bottom: this.paddingBottom || 0\n    };\n  }\n  getTicks() {\n    return this.ticks;\n  }\n  getLabels() {\n    const data = this.chart.data;\n    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n  }\n  getLabelItems(chartArea = this.chart.chartArea) {\n    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n    return items;\n  }\n  beforeLayout() {\n    this._cache = {};\n    this._dataLimitsCached = false;\n  }\n  beforeUpdate() {\n    callback(this.options.beforeUpdate, [this]);\n  }\n  update(maxWidth, maxHeight, margins) {\n    const {\n      beginAtZero,\n      grace,\n      ticks: tickOpts\n    } = this.options;\n    const sampleSize = tickOpts.sampleSize;\n    this.beforeUpdate();\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins = Object.assign({\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }, margins);\n    this.ticks = null;\n    this._labelSizes = null;\n    this._gridLineItems = null;\n    this._labelItems = null;\n    this.beforeSetDimensions();\n    this.setDimensions();\n    this.afterSetDimensions();\n    this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;\n    if (!this._dataLimitsCached) {\n      this.beforeDataLimits();\n      this.determineDataLimits();\n      this.afterDataLimits();\n      this._range = _addGrace(this, grace, beginAtZero);\n      this._dataLimitsCached = true;\n    }\n    this.beforeBuildTicks();\n    this.ticks = this.buildTicks() || [];\n    this.afterBuildTicks();\n    const samplingEnabled = sampleSize < this.ticks.length;\n    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n    this.configure();\n    this.beforeCalculateLabelRotation();\n    this.calculateLabelRotation();\n    this.afterCalculateLabelRotation();\n    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === \"auto\")) {\n      this.ticks = autoSkip(this, this.ticks);\n      this._labelSizes = null;\n      this.afterAutoSkip();\n    }\n    if (samplingEnabled) {\n      this._convertTicksToLabels(this.ticks);\n    }\n    this.beforeFit();\n    this.fit();\n    this.afterFit();\n    this.afterUpdate();\n  }\n  configure() {\n    let reversePixels = this.options.reverse;\n    let startPixel, endPixel;\n    if (this.isHorizontal()) {\n      startPixel = this.left;\n      endPixel = this.right;\n    } else {\n      startPixel = this.top;\n      endPixel = this.bottom;\n      reversePixels = !reversePixels;\n    }\n    this._startPixel = startPixel;\n    this._endPixel = endPixel;\n    this._reversePixels = reversePixels;\n    this._length = endPixel - startPixel;\n    this._alignToPixels = this.options.alignToPixels;\n  }\n  afterUpdate() {\n    callback(this.options.afterUpdate, [this]);\n  }\n  beforeSetDimensions() {\n    callback(this.options.beforeSetDimensions, [this]);\n  }\n  setDimensions() {\n    if (this.isHorizontal()) {\n      this.width = this.maxWidth;\n      this.left = 0;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n      this.top = 0;\n      this.bottom = this.height;\n    }\n    this.paddingLeft = 0;\n    this.paddingTop = 0;\n    this.paddingRight = 0;\n    this.paddingBottom = 0;\n  }\n  afterSetDimensions() {\n    callback(this.options.afterSetDimensions, [this]);\n  }\n  _callHooks(name) {\n    this.chart.notifyPlugins(name, this.getContext());\n    callback(this.options[name], [this]);\n  }\n  beforeDataLimits() {\n    this._callHooks(\"beforeDataLimits\");\n  }\n  determineDataLimits() {\n  }\n  afterDataLimits() {\n    this._callHooks(\"afterDataLimits\");\n  }\n  beforeBuildTicks() {\n    this._callHooks(\"beforeBuildTicks\");\n  }\n  buildTicks() {\n    return [];\n  }\n  afterBuildTicks() {\n    this._callHooks(\"afterBuildTicks\");\n  }\n  beforeTickToLabelConversion() {\n    callback(this.options.beforeTickToLabelConversion, [this]);\n  }\n  generateTickLabels(ticks) {\n    const tickOpts = this.options.ticks;\n    let i, ilen, tick;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      tick = ticks[i];\n      tick.label = callback(tickOpts.callback, [tick.value, i, ticks], this);\n    }\n  }\n  afterTickToLabelConversion() {\n    callback(this.options.afterTickToLabelConversion, [this]);\n  }\n  beforeCalculateLabelRotation() {\n    callback(this.options.beforeCalculateLabelRotation, [this]);\n  }\n  calculateLabelRotation() {\n    const options = this.options;\n    const tickOpts = options.ticks;\n    const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);\n    const minRotation = tickOpts.minRotation || 0;\n    const maxRotation = tickOpts.maxRotation;\n    let labelRotation = minRotation;\n    let tickWidth, maxHeight, maxLabelDiagonal;\n    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n      this.labelRotation = minRotation;\n      return;\n    }\n    const labelSizes = this._getLabelSizes();\n    const maxLabelWidth = labelSizes.widest.width;\n    const maxLabelHeight = labelSizes.highest.height;\n    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n    if (maxLabelWidth + 6 > tickWidth) {\n      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n      maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n      labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));\n      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n    }\n    this.labelRotation = labelRotation;\n  }\n  afterCalculateLabelRotation() {\n    callback(this.options.afterCalculateLabelRotation, [this]);\n  }\n  afterAutoSkip() {\n  }\n  beforeFit() {\n    callback(this.options.beforeFit, [this]);\n  }\n  fit() {\n    const minSize = {\n      width: 0,\n      height: 0\n    };\n    const {\n      chart,\n      options: {\n        ticks: tickOpts,\n        title: titleOpts,\n        grid: gridOpts\n      }\n    } = this;\n    const display = this._isVisible();\n    const isHorizontal = this.isHorizontal();\n    if (display) {\n      const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n      if (isHorizontal) {\n        minSize.width = this.maxWidth;\n        minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n      } else {\n        minSize.height = this.maxHeight;\n        minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n      }\n      if (tickOpts.display && this.ticks.length) {\n        const {\n          first,\n          last,\n          widest,\n          highest\n        } = this._getLabelSizes();\n        const tickPadding = tickOpts.padding * 2;\n        const angleRadians = toRadians(this.labelRotation);\n        const cos = Math.cos(angleRadians);\n        const sin = Math.sin(angleRadians);\n        if (isHorizontal) {\n          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n        } else {\n          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n        }\n        this._calculatePadding(first, last, sin, cos);\n      }\n    }\n    this._handleMargins();\n    if (isHorizontal) {\n      this.width = this._length = chart.width - this._margins.left - this._margins.right;\n      this.height = minSize.height;\n    } else {\n      this.width = minSize.width;\n      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n    }\n  }\n  _calculatePadding(first, last, sin, cos) {\n    const {\n      ticks: {\n        align,\n        padding\n      },\n      position\n    } = this.options;\n    const isRotated = this.labelRotation !== 0;\n    const labelsBelowTicks = position !== \"top\" && this.axis === \"x\";\n    if (this.isHorizontal()) {\n      const offsetLeft = this.getPixelForTick(0) - this.left;\n      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n      let paddingLeft = 0;\n      let paddingRight = 0;\n      if (isRotated) {\n        if (labelsBelowTicks) {\n          paddingLeft = cos * first.width;\n          paddingRight = sin * last.height;\n        } else {\n          paddingLeft = sin * first.height;\n          paddingRight = cos * last.width;\n        }\n      } else if (align === \"start\") {\n        paddingRight = last.width;\n      } else if (align === \"end\") {\n        paddingLeft = first.width;\n      } else if (align !== \"inner\") {\n        paddingLeft = first.width / 2;\n        paddingRight = last.width / 2;\n      }\n      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n    } else {\n      let paddingTop = last.height / 2;\n      let paddingBottom = first.height / 2;\n      if (align === \"start\") {\n        paddingTop = 0;\n        paddingBottom = first.height;\n      } else if (align === \"end\") {\n        paddingTop = last.height;\n        paddingBottom = 0;\n      }\n      this.paddingTop = paddingTop + padding;\n      this.paddingBottom = paddingBottom + padding;\n    }\n  }\n  _handleMargins() {\n    if (this._margins) {\n      this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n      this._margins.top = Math.max(this.paddingTop, this._margins.top);\n      this._margins.right = Math.max(this.paddingRight, this._margins.right);\n      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n    }\n  }\n  afterFit() {\n    callback(this.options.afterFit, [this]);\n  }\n  isHorizontal() {\n    const {\n      axis,\n      position\n    } = this.options;\n    return position === \"top\" || position === \"bottom\" || axis === \"x\";\n  }\n  isFullSize() {\n    return this.options.fullSize;\n  }\n  _convertTicksToLabels(ticks) {\n    this.beforeTickToLabelConversion();\n    this.generateTickLabels(ticks);\n    let i, ilen;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      if (isNullOrUndef(ticks[i].label)) {\n        ticks.splice(i, 1);\n        ilen--;\n        i--;\n      }\n    }\n    this.afterTickToLabelConversion();\n  }\n  _getLabelSizes() {\n    let labelSizes = this._labelSizes;\n    if (!labelSizes) {\n      const sampleSize = this.options.ticks.sampleSize;\n      let ticks = this.ticks;\n      if (sampleSize < ticks.length) {\n        ticks = sample(ticks, sampleSize);\n      }\n      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);\n    }\n    return labelSizes;\n  }\n  _computeLabelSizes(ticks, length, maxTicksLimit) {\n    const {\n      ctx,\n      _longestTextCache: caches\n    } = this;\n    const widths = [];\n    const heights = [];\n    const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));\n    let widestLabelSize = 0;\n    let highestLabelSize = 0;\n    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n    for (i = 0; i < length; i += increment) {\n      label = ticks[i].label;\n      tickFont = this._resolveTickFontOptions(i);\n      ctx.font = fontString = tickFont.string;\n      cache = caches[fontString] = caches[fontString] || {\n        data: {},\n        gc: []\n      };\n      lineHeight = tickFont.lineHeight;\n      width = height = 0;\n      if (!isNullOrUndef(label) && !isArray(label)) {\n        width = _measureText(ctx, cache.data, cache.gc, width, label);\n        height = lineHeight;\n      } else if (isArray(label)) {\n        for (j = 0, jlen = label.length; j < jlen; ++j) {\n          nestedLabel = label[j];\n          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\n            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\n            height += lineHeight;\n          }\n        }\n      }\n      widths.push(width);\n      heights.push(height);\n      widestLabelSize = Math.max(width, widestLabelSize);\n      highestLabelSize = Math.max(height, highestLabelSize);\n    }\n    garbageCollect(caches, length);\n    const widest = widths.indexOf(widestLabelSize);\n    const highest = heights.indexOf(highestLabelSize);\n    const valueAt = (idx) => ({\n      width: widths[idx] || 0,\n      height: heights[idx] || 0\n    });\n    return {\n      first: valueAt(0),\n      last: valueAt(length - 1),\n      widest: valueAt(widest),\n      highest: valueAt(highest),\n      widths,\n      heights\n    };\n  }\n  getLabelForValue(value) {\n    return value;\n  }\n  getPixelForValue(value, index2) {\n    return NaN;\n  }\n  getValueForPixel(pixel) {\n  }\n  getPixelForTick(index2) {\n    const ticks = this.ticks;\n    if (index2 < 0 || index2 > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index2].value);\n  }\n  getPixelForDecimal(decimal) {\n    if (this._reversePixels) {\n      decimal = 1 - decimal;\n    }\n    const pixel = this._startPixel + decimal * this._length;\n    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);\n  }\n  getDecimalForPixel(pixel) {\n    const decimal = (pixel - this._startPixel) / this._length;\n    return this._reversePixels ? 1 - decimal : decimal;\n  }\n  getBasePixel() {\n    return this.getPixelForValue(this.getBaseValue());\n  }\n  getBaseValue() {\n    const {\n      min,\n      max\n    } = this;\n    return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;\n  }\n  getContext(index2) {\n    const ticks = this.ticks || [];\n    if (index2 >= 0 && index2 < ticks.length) {\n      const tick = ticks[index2];\n      return tick.$context || (tick.$context = createTickContext(this.getContext(), index2, tick));\n    }\n    return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));\n  }\n  _tickSize() {\n    const optionTicks = this.options.ticks;\n    const rot = toRadians(this.labelRotation);\n    const cos = Math.abs(Math.cos(rot));\n    const sin = Math.abs(Math.sin(rot));\n    const labelSizes = this._getLabelSizes();\n    const padding = optionTicks.autoSkipPadding || 0;\n    const w = labelSizes ? labelSizes.widest.width + padding : 0;\n    const h = labelSizes ? labelSizes.highest.height + padding : 0;\n    return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;\n  }\n  _isVisible() {\n    const display = this.options.display;\n    if (display !== \"auto\") {\n      return !!display;\n    }\n    return this.getMatchingVisibleMetas().length > 0;\n  }\n  _computeGridLineItems(chartArea) {\n    const axis = this.axis;\n    const chart = this.chart;\n    const options = this.options;\n    const {\n      grid,\n      position,\n      border\n    } = options;\n    const offset = grid.offset;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const ticksLength = ticks.length + (offset ? 1 : 0);\n    const tl = getTickMarkLength(grid);\n    const items = [];\n    const borderOpts = border.setContext(this.getContext());\n    const axisWidth = borderOpts.display ? borderOpts.width : 0;\n    const axisHalfWidth = axisWidth / 2;\n    const alignBorderValue = function(pixel) {\n      return _alignPixel(chart, pixel, axisWidth);\n    };\n    let borderValue, i, lineValue, alignedLineValue;\n    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n    if (position === \"top\") {\n      borderValue = alignBorderValue(this.bottom);\n      ty1 = this.bottom - tl;\n      ty2 = borderValue - axisHalfWidth;\n      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n      y2 = chartArea.bottom;\n    } else if (position === \"bottom\") {\n      borderValue = alignBorderValue(this.top);\n      y1 = chartArea.top;\n      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = this.top + tl;\n    } else if (position === \"left\") {\n      borderValue = alignBorderValue(this.right);\n      tx1 = this.right - tl;\n      tx2 = borderValue - axisHalfWidth;\n      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n      x2 = chartArea.right;\n    } else if (position === \"right\") {\n      borderValue = alignBorderValue(this.left);\n      x1 = chartArea.left;\n      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n      tx1 = borderValue + axisHalfWidth;\n      tx2 = this.left + tl;\n    } else if (axis === \"x\") {\n      if (position === \"center\") {\n        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n      y1 = chartArea.top;\n      y2 = chartArea.bottom;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = ty1 + tl;\n    } else if (axis === \"y\") {\n      if (position === \"center\") {\n        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n      tx1 = borderValue - axisHalfWidth;\n      tx2 = tx1 - tl;\n      x1 = chartArea.left;\n      x2 = chartArea.right;\n    }\n    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);\n    const step = Math.max(1, Math.ceil(ticksLength / limit));\n    for (i = 0; i < ticksLength; i += step) {\n      const context = this.getContext(i);\n      const optsAtIndex = grid.setContext(context);\n      const optsAtIndexBorder = border.setContext(context);\n      const lineWidth = optsAtIndex.lineWidth;\n      const lineColor = optsAtIndex.color;\n      const borderDash = optsAtIndexBorder.dash || [];\n      const borderDashOffset = optsAtIndexBorder.dashOffset;\n      const tickWidth = optsAtIndex.tickWidth;\n      const tickColor = optsAtIndex.tickColor;\n      const tickBorderDash = optsAtIndex.tickBorderDash || [];\n      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n      lineValue = getPixelForGridLine(this, i, offset);\n      if (lineValue === void 0) {\n        continue;\n      }\n      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\n      if (isHorizontal) {\n        tx1 = tx2 = x1 = x2 = alignedLineValue;\n      } else {\n        ty1 = ty2 = y1 = y2 = alignedLineValue;\n      }\n      items.push({\n        tx1,\n        ty1,\n        tx2,\n        ty2,\n        x1,\n        y1,\n        x2,\n        y2,\n        width: lineWidth,\n        color: lineColor,\n        borderDash,\n        borderDashOffset,\n        tickWidth,\n        tickColor,\n        tickBorderDash,\n        tickBorderDashOffset\n      });\n    }\n    this._ticksLength = ticksLength;\n    this._borderValue = borderValue;\n    return items;\n  }\n  _computeLabelItems(chartArea) {\n    const axis = this.axis;\n    const options = this.options;\n    const {\n      position,\n      ticks: optionTicks\n    } = options;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const {\n      align,\n      crossAlign,\n      padding,\n      mirror\n    } = optionTicks;\n    const tl = getTickMarkLength(options.grid);\n    const tickAndPadding = tl + padding;\n    const hTickAndPadding = mirror ? -padding : tickAndPadding;\n    const rotation = -toRadians(this.labelRotation);\n    const items = [];\n    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n    let textBaseline = \"middle\";\n    if (position === \"top\") {\n      y = this.bottom - hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === \"bottom\") {\n      y = this.top + hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === \"left\") {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (position === \"right\") {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (axis === \"x\") {\n      if (position === \"center\") {\n        y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n      }\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (axis === \"y\") {\n      if (position === \"center\") {\n        x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        x = this.chart.scales[positionAxisID].getPixelForValue(value);\n      }\n      textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n    }\n    if (axis === \"y\") {\n      if (align === \"start\") {\n        textBaseline = \"top\";\n      } else if (align === \"end\") {\n        textBaseline = \"bottom\";\n      }\n    }\n    const labelSizes = this._getLabelSizes();\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      label = tick.label;\n      const optsAtIndex = optionTicks.setContext(this.getContext(i));\n      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n      font = this._resolveTickFontOptions(i);\n      lineHeight = font.lineHeight;\n      lineCount = isArray(label) ? label.length : 1;\n      const halfCount = lineCount / 2;\n      const color2 = optsAtIndex.color;\n      const strokeColor = optsAtIndex.textStrokeColor;\n      const strokeWidth = optsAtIndex.textStrokeWidth;\n      let tickTextAlign = textAlign;\n      if (isHorizontal) {\n        x = pixel;\n        if (textAlign === \"inner\") {\n          if (i === ilen - 1) {\n            tickTextAlign = !this.options.reverse ? \"right\" : \"left\";\n          } else if (i === 0) {\n            tickTextAlign = !this.options.reverse ? \"left\" : \"right\";\n          } else {\n            tickTextAlign = \"center\";\n          }\n        }\n        if (position === \"top\") {\n          if (crossAlign === \"near\" || rotation !== 0) {\n            textOffset = -lineCount * lineHeight + lineHeight / 2;\n          } else if (crossAlign === \"center\") {\n            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n          } else {\n            textOffset = -labelSizes.highest.height + lineHeight / 2;\n          }\n        } else {\n          if (crossAlign === \"near\" || rotation !== 0) {\n            textOffset = lineHeight / 2;\n          } else if (crossAlign === \"center\") {\n            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n          } else {\n            textOffset = labelSizes.highest.height - lineCount * lineHeight;\n          }\n        }\n        if (mirror) {\n          textOffset *= -1;\n        }\n        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {\n          x += lineHeight / 2 * Math.sin(rotation);\n        }\n      } else {\n        y = pixel;\n        textOffset = (1 - lineCount) * lineHeight / 2;\n      }\n      let backdrop;\n      if (optsAtIndex.showLabelBackdrop) {\n        const labelPadding = toPadding(optsAtIndex.backdropPadding);\n        const height = labelSizes.heights[i];\n        const width = labelSizes.widths[i];\n        let top = textOffset - labelPadding.top;\n        let left = 0 - labelPadding.left;\n        switch (textBaseline) {\n          case \"middle\":\n            top -= height / 2;\n            break;\n          case \"bottom\":\n            top -= height;\n            break;\n        }\n        switch (textAlign) {\n          case \"center\":\n            left -= width / 2;\n            break;\n          case \"right\":\n            left -= width;\n            break;\n          case \"inner\":\n            if (i === ilen - 1) {\n              left -= width;\n            } else if (i > 0) {\n              left -= width / 2;\n            }\n            break;\n        }\n        backdrop = {\n          left,\n          top,\n          width: width + labelPadding.width,\n          height: height + labelPadding.height,\n          color: optsAtIndex.backdropColor\n        };\n      }\n      items.push({\n        label,\n        font,\n        textOffset,\n        options: {\n          rotation,\n          color: color2,\n          strokeColor,\n          strokeWidth,\n          textAlign: tickTextAlign,\n          textBaseline,\n          translation: [x, y],\n          backdrop\n        }\n      });\n    }\n    return items;\n  }\n  _getXAxisLabelAlignment() {\n    const {\n      position,\n      ticks\n    } = this.options;\n    const rotation = -toRadians(this.labelRotation);\n    if (rotation) {\n      return position === \"top\" ? \"left\" : \"right\";\n    }\n    let align = \"center\";\n    if (ticks.align === \"start\") {\n      align = \"left\";\n    } else if (ticks.align === \"end\") {\n      align = \"right\";\n    } else if (ticks.align === \"inner\") {\n      align = \"inner\";\n    }\n    return align;\n  }\n  _getYAxisLabelAlignment(tl) {\n    const {\n      position,\n      ticks: {\n        crossAlign,\n        mirror,\n        padding\n      }\n    } = this.options;\n    const labelSizes = this._getLabelSizes();\n    const tickAndPadding = tl + padding;\n    const widest = labelSizes.widest.width;\n    let textAlign;\n    let x;\n    if (position === \"left\") {\n      if (mirror) {\n        x = this.right + padding;\n        if (crossAlign === \"near\") {\n          textAlign = \"left\";\n        } else if (crossAlign === \"center\") {\n          textAlign = \"center\";\n          x += widest / 2;\n        } else {\n          textAlign = \"right\";\n          x += widest;\n        }\n      } else {\n        x = this.right - tickAndPadding;\n        if (crossAlign === \"near\") {\n          textAlign = \"right\";\n        } else if (crossAlign === \"center\") {\n          textAlign = \"center\";\n          x -= widest / 2;\n        } else {\n          textAlign = \"left\";\n          x = this.left;\n        }\n      }\n    } else if (position === \"right\") {\n      if (mirror) {\n        x = this.left + padding;\n        if (crossAlign === \"near\") {\n          textAlign = \"right\";\n        } else if (crossAlign === \"center\") {\n          textAlign = \"center\";\n          x -= widest / 2;\n        } else {\n          textAlign = \"left\";\n          x -= widest;\n        }\n      } else {\n        x = this.left + tickAndPadding;\n        if (crossAlign === \"near\") {\n          textAlign = \"left\";\n        } else if (crossAlign === \"center\") {\n          textAlign = \"center\";\n          x += widest / 2;\n        } else {\n          textAlign = \"right\";\n          x = this.right;\n        }\n      }\n    } else {\n      textAlign = \"right\";\n    }\n    return {\n      textAlign,\n      x\n    };\n  }\n  _computeLabelArea() {\n    if (this.options.ticks.mirror) {\n      return;\n    }\n    const chart = this.chart;\n    const position = this.options.position;\n    if (position === \"left\" || position === \"right\") {\n      return {\n        top: 0,\n        left: this.left,\n        bottom: chart.height,\n        right: this.right\n      };\n    }\n    if (position === \"top\" || position === \"bottom\") {\n      return {\n        top: this.top,\n        left: 0,\n        bottom: this.bottom,\n        right: chart.width\n      };\n    }\n  }\n  drawBackground() {\n    const {\n      ctx,\n      options: {\n        backgroundColor\n      },\n      left,\n      top,\n      width,\n      height\n    } = this;\n    if (backgroundColor) {\n      ctx.save();\n      ctx.fillStyle = backgroundColor;\n      ctx.fillRect(left, top, width, height);\n      ctx.restore();\n    }\n  }\n  getLineWidthForValue(value) {\n    const grid = this.options.grid;\n    if (!this._isVisible() || !grid.display) {\n      return 0;\n    }\n    const ticks = this.ticks;\n    const index2 = ticks.findIndex((t) => t.value === value);\n    if (index2 >= 0) {\n      const opts = grid.setContext(this.getContext(index2));\n      return opts.lineWidth;\n    }\n    return 0;\n  }\n  drawGrid(chartArea) {\n    const grid = this.options.grid;\n    const ctx = this.ctx;\n    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n    let i, ilen;\n    const drawLine = (p1, p2, style) => {\n      if (!style.width || !style.color) {\n        return;\n      }\n      ctx.save();\n      ctx.lineWidth = style.width;\n      ctx.strokeStyle = style.color;\n      ctx.setLineDash(style.borderDash || []);\n      ctx.lineDashOffset = style.borderDashOffset;\n      ctx.beginPath();\n      ctx.moveTo(p1.x, p1.y);\n      ctx.lineTo(p2.x, p2.y);\n      ctx.stroke();\n      ctx.restore();\n    };\n    if (grid.display) {\n      for (i = 0, ilen = items.length; i < ilen; ++i) {\n        const item = items[i];\n        if (grid.drawOnChartArea) {\n          drawLine({\n            x: item.x1,\n            y: item.y1\n          }, {\n            x: item.x2,\n            y: item.y2\n          }, item);\n        }\n        if (grid.drawTicks) {\n          drawLine({\n            x: item.tx1,\n            y: item.ty1\n          }, {\n            x: item.tx2,\n            y: item.ty2\n          }, {\n            color: item.tickColor,\n            width: item.tickWidth,\n            borderDash: item.tickBorderDash,\n            borderDashOffset: item.tickBorderDashOffset\n          });\n        }\n      }\n    }\n  }\n  drawBorder() {\n    const {\n      chart,\n      ctx,\n      options: {\n        border,\n        grid\n      }\n    } = this;\n    const borderOpts = border.setContext(this.getContext());\n    const axisWidth = border.display ? borderOpts.width : 0;\n    if (!axisWidth) {\n      return;\n    }\n    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n    const borderValue = this._borderValue;\n    let x1, x2, y1, y2;\n    if (this.isHorizontal()) {\n      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;\n      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n      y1 = y2 = borderValue;\n    } else {\n      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;\n      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n      x1 = x2 = borderValue;\n    }\n    ctx.save();\n    ctx.lineWidth = borderOpts.width;\n    ctx.strokeStyle = borderOpts.color;\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n    ctx.restore();\n  }\n  drawLabels(chartArea) {\n    const optionTicks = this.options.ticks;\n    if (!optionTicks.display) {\n      return;\n    }\n    const ctx = this.ctx;\n    const area = this._computeLabelArea();\n    if (area) {\n      clipArea(ctx, area);\n    }\n    const items = this.getLabelItems(chartArea);\n    for (const item of items) {\n      const renderTextOptions = item.options;\n      const tickFont = item.font;\n      const label = item.label;\n      const y = item.textOffset;\n      renderText(ctx, label, 0, y, tickFont, renderTextOptions);\n    }\n    if (area) {\n      unclipArea(ctx);\n    }\n  }\n  drawTitle() {\n    const {\n      ctx,\n      options: {\n        position,\n        title,\n        reverse\n      }\n    } = this;\n    if (!title.display) {\n      return;\n    }\n    const font = toFont(title.font);\n    const padding = toPadding(title.padding);\n    const align = title.align;\n    let offset = font.lineHeight / 2;\n    if (position === \"bottom\" || position === \"center\" || isObject(position)) {\n      offset += padding.bottom;\n      if (isArray(title.text)) {\n        offset += font.lineHeight * (title.text.length - 1);\n      }\n    } else {\n      offset += padding.top;\n    }\n    const {\n      titleX,\n      titleY,\n      maxWidth,\n      rotation\n    } = titleArgs(this, offset, position, align);\n    renderText(ctx, title.text, 0, 0, font, {\n      color: title.color,\n      maxWidth,\n      rotation,\n      textAlign: titleAlign(align, position, reverse),\n      textBaseline: \"middle\",\n      translation: [titleX, titleY]\n    });\n  }\n  draw(chartArea) {\n    if (!this._isVisible()) {\n      return;\n    }\n    this.drawBackground();\n    this.drawGrid(chartArea);\n    this.drawBorder();\n    this.drawTitle();\n    this.drawLabels(chartArea);\n  }\n  _layers() {\n    const opts = this.options;\n    const tz = opts.ticks && opts.ticks.z || 0;\n    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);\n    const bz = valueOrDefault(opts.border && opts.border.z, 0);\n    if (!this._isVisible() || this.draw !== _Scale.prototype.draw) {\n      return [{\n        z: tz,\n        draw: (chartArea) => {\n          this.draw(chartArea);\n        }\n      }];\n    }\n    return [{\n      z: gz,\n      draw: (chartArea) => {\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawTitle();\n      }\n    }, {\n      z: bz,\n      draw: () => {\n        this.drawBorder();\n      }\n    }, {\n      z: tz,\n      draw: (chartArea) => {\n        this.drawLabels(chartArea);\n      }\n    }];\n  }\n  getMatchingVisibleMetas(type) {\n    const metas = this.chart.getSortedVisibleDatasetMetas();\n    const axisID = this.axis + \"AxisID\";\n    const result = [];\n    let i, ilen;\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      const meta = metas[i];\n      if (meta[axisID] === this.id && (!type || meta.type === type)) {\n        result.push(meta);\n      }\n    }\n    return result;\n  }\n  _resolveTickFontOptions(index2) {\n    const opts = this.options.ticks.setContext(this.getContext(index2));\n    return toFont(opts.font);\n  }\n  _maxDigits() {\n    const fontSize = this._resolveTickFontOptions(0).lineHeight;\n    return (this.isHorizontal() ? this.width : this.height) / fontSize;\n  }\n};\nvar TypedRegistry = class {\n  constructor(type, scope, override) {\n    this.type = type;\n    this.scope = scope;\n    this.override = override;\n    this.items = /* @__PURE__ */ Object.create(null);\n  }\n  isForType(type) {\n    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n  }\n  register(item) {\n    const proto = Object.getPrototypeOf(item);\n    let parentScope;\n    if (isIChartComponent(proto)) {\n      parentScope = this.register(proto);\n    }\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope + \".\" + id;\n    if (!id) {\n      throw new Error(\"class does not have id: \" + item);\n    }\n    if (id in items) {\n      return scope;\n    }\n    items[id] = item;\n    registerDefaults(item, scope, parentScope);\n    if (this.override) {\n      defaults.override(item.id, item.overrides);\n    }\n    return scope;\n  }\n  get(id) {\n    return this.items[id];\n  }\n  unregister(item) {\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope;\n    if (id in items) {\n      delete items[id];\n    }\n    if (scope && id in defaults[scope]) {\n      delete defaults[scope][id];\n      if (this.override) {\n        delete overrides[id];\n      }\n    }\n  }\n};\nfunction registerDefaults(item, scope, parentScope) {\n  const itemDefaults = merge(/* @__PURE__ */ Object.create(null), [parentScope ? defaults.get(parentScope) : {}, defaults.get(scope), item.defaults]);\n  defaults.set(scope, itemDefaults);\n  if (item.defaultRoutes) {\n    routeDefaults(scope, item.defaultRoutes);\n  }\n  if (item.descriptors) {\n    defaults.describe(scope, item.descriptors);\n  }\n}\nfunction routeDefaults(scope, routes) {\n  Object.keys(routes).forEach((property) => {\n    const propertyParts = property.split(\".\");\n    const sourceName = propertyParts.pop();\n    const sourceScope = [scope].concat(propertyParts).join(\".\");\n    const parts = routes[property].split(\".\");\n    const targetName = parts.pop();\n    const targetScope = parts.join(\".\");\n    defaults.route(sourceScope, sourceName, targetScope, targetName);\n  });\n}\nfunction isIChartComponent(proto) {\n  return \"id\" in proto && \"defaults\" in proto;\n}\nvar Registry = class {\n  constructor() {\n    this.controllers = new TypedRegistry(DatasetController, \"datasets\", true);\n    this.elements = new TypedRegistry(Element, \"elements\");\n    this.plugins = new TypedRegistry(Object, \"plugins\");\n    this.scales = new TypedRegistry(Scale, \"scales\");\n    this._typedRegistries = [this.controllers, this.scales, this.elements];\n  }\n  add(...args) {\n    this._each(\"register\", args);\n  }\n  remove(...args) {\n    this._each(\"unregister\", args);\n  }\n  addControllers(...args) {\n    this._each(\"register\", args, this.controllers);\n  }\n  addElements(...args) {\n    this._each(\"register\", args, this.elements);\n  }\n  addPlugins(...args) {\n    this._each(\"register\", args, this.plugins);\n  }\n  addScales(...args) {\n    this._each(\"register\", args, this.scales);\n  }\n  getController(id) {\n    return this._get(id, this.controllers, \"controller\");\n  }\n  getElement(id) {\n    return this._get(id, this.elements, \"element\");\n  }\n  getPlugin(id) {\n    return this._get(id, this.plugins, \"plugin\");\n  }\n  getScale(id) {\n    return this._get(id, this.scales, \"scale\");\n  }\n  removeControllers(...args) {\n    this._each(\"unregister\", args, this.controllers);\n  }\n  removeElements(...args) {\n    this._each(\"unregister\", args, this.elements);\n  }\n  removePlugins(...args) {\n    this._each(\"unregister\", args, this.plugins);\n  }\n  removeScales(...args) {\n    this._each(\"unregister\", args, this.scales);\n  }\n  _each(method, args, typedRegistry) {\n    [...args].forEach((arg) => {\n      const reg = typedRegistry || this._getRegistryForType(arg);\n      if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) {\n        this._exec(method, reg, arg);\n      } else {\n        each(arg, (item) => {\n          const itemReg = typedRegistry || this._getRegistryForType(item);\n          this._exec(method, itemReg, item);\n        });\n      }\n    });\n  }\n  _exec(method, registry2, component) {\n    const camelMethod = _capitalize(method);\n    callback(component[\"before\" + camelMethod], [], component);\n    registry2[method](component);\n    callback(component[\"after\" + camelMethod], [], component);\n  }\n  _getRegistryForType(type) {\n    for (let i = 0; i < this._typedRegistries.length; i++) {\n      const reg = this._typedRegistries[i];\n      if (reg.isForType(type)) {\n        return reg;\n      }\n    }\n    return this.plugins;\n  }\n  _get(id, typedRegistry, type) {\n    const item = typedRegistry.get(id);\n    if (item === void 0) {\n      throw new Error('\"' + id + '\" is not a registered ' + type + \".\");\n    }\n    return item;\n  }\n};\nvar registry = new Registry();\nvar PluginService = class {\n  constructor() {\n    this._init = [];\n  }\n  notify(chart, hook, args, filter) {\n    if (hook === \"beforeInit\") {\n      this._init = this._createDescriptors(chart, true);\n      this._notify(this._init, chart, \"install\");\n    }\n    const descriptors2 = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n    const result = this._notify(descriptors2, chart, hook, args);\n    if (hook === \"afterDestroy\") {\n      this._notify(descriptors2, chart, \"stop\");\n      this._notify(this._init, chart, \"uninstall\");\n    }\n    return result;\n  }\n  _notify(descriptors2, chart, hook, args) {\n    args = args || {};\n    for (const descriptor of descriptors2) {\n      const plugin = descriptor.plugin;\n      const method = plugin[hook];\n      const params = [chart, args, descriptor.options];\n      if (callback(method, params, plugin) === false && args.cancelable) {\n        return false;\n      }\n    }\n    return true;\n  }\n  invalidate() {\n    if (!isNullOrUndef(this._cache)) {\n      this._oldCache = this._cache;\n      this._cache = void 0;\n    }\n  }\n  _descriptors(chart) {\n    if (this._cache) {\n      return this._cache;\n    }\n    const descriptors2 = this._cache = this._createDescriptors(chart);\n    this._notifyStateChanges(chart);\n    return descriptors2;\n  }\n  _createDescriptors(chart, all) {\n    const config = chart && chart.config;\n    const options = valueOrDefault(config.options && config.options.plugins, {});\n    const plugins2 = allPlugins(config);\n    return options === false && !all ? [] : createDescriptors(chart, plugins2, options, all);\n  }\n  _notifyStateChanges(chart) {\n    const previousDescriptors = this._oldCache || [];\n    const descriptors2 = this._cache;\n    const diff = (a, b) => a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));\n    this._notify(diff(previousDescriptors, descriptors2), chart, \"stop\");\n    this._notify(diff(descriptors2, previousDescriptors), chart, \"start\");\n  }\n};\nfunction allPlugins(config) {\n  const localIds = {};\n  const plugins2 = [];\n  const keys = Object.keys(registry.plugins.items);\n  for (let i = 0; i < keys.length; i++) {\n    plugins2.push(registry.getPlugin(keys[i]));\n  }\n  const local = config.plugins || [];\n  for (let i = 0; i < local.length; i++) {\n    const plugin = local[i];\n    if (plugins2.indexOf(plugin) === -1) {\n      plugins2.push(plugin);\n      localIds[plugin.id] = true;\n    }\n  }\n  return {\n    plugins: plugins2,\n    localIds\n  };\n}\nfunction getOpts(options, all) {\n  if (!all && options === false) {\n    return null;\n  }\n  if (options === true) {\n    return {};\n  }\n  return options;\n}\nfunction createDescriptors(chart, {\n  plugins: plugins2,\n  localIds\n}, options, all) {\n  const result = [];\n  const context = chart.getContext();\n  for (const plugin of plugins2) {\n    const id = plugin.id;\n    const opts = getOpts(options[id], all);\n    if (opts === null) {\n      continue;\n    }\n    result.push({\n      plugin,\n      options: pluginOpts(chart.config, {\n        plugin,\n        local: localIds[id]\n      }, opts, context)\n    });\n  }\n  return result;\n}\nfunction pluginOpts(config, {\n  plugin,\n  local\n}, opts, context) {\n  const keys = config.pluginScopeKeys(plugin);\n  const scopes = config.getOptionScopes(opts, keys);\n  if (local && plugin.defaults) {\n    scopes.push(plugin.defaults);\n  }\n  return config.createResolver(scopes, context, [\"\"], {\n    scriptable: false,\n    indexable: false,\n    allKeys: true\n  });\n}\nfunction getIndexAxis(type, options) {\n  const datasetDefaults = defaults.datasets[type] || {};\n  const datasetOptions = (options.datasets || {})[type] || {};\n  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || \"x\";\n}\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n  let axis = id;\n  if (id === \"_index_\") {\n    axis = indexAxis;\n  } else if (id === \"_value_\") {\n    axis = indexAxis === \"x\" ? \"y\" : \"x\";\n  }\n  return axis;\n}\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n  return axis === indexAxis ? \"_index_\" : \"_value_\";\n}\nfunction idMatchesAxis(id) {\n  if (id === \"x\" || id === \"y\" || id === \"r\") {\n    return id;\n  }\n}\nfunction axisFromPosition(position) {\n  if (position === \"top\" || position === \"bottom\") {\n    return \"x\";\n  }\n  if (position === \"left\" || position === \"right\") {\n    return \"y\";\n  }\n}\nfunction determineAxis(id, ...scaleOptions) {\n  if (idMatchesAxis(id)) {\n    return id;\n  }\n  for (const opts of scaleOptions) {\n    const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());\n    if (axis) {\n      return axis;\n    }\n  }\n  throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);\n}\nfunction getAxisFromDataset(id, axis, dataset) {\n  if (dataset[axis + \"AxisID\"] === id) {\n    return {\n      axis\n    };\n  }\n}\nfunction retrieveAxisFromDatasets(id, config) {\n  if (config.data && config.data.datasets) {\n    const boundDs = config.data.datasets.filter((d) => d.xAxisID === id || d.yAxisID === id);\n    if (boundDs.length) {\n      return getAxisFromDataset(id, \"x\", boundDs[0]) || getAxisFromDataset(id, \"y\", boundDs[0]);\n    }\n  }\n  return {};\n}\nfunction mergeScaleConfig(config, options) {\n  const chartDefaults = overrides[config.type] || {\n    scales: {}\n  };\n  const configScales = options.scales || {};\n  const chartIndexAxis = getIndexAxis(config.type, options);\n  const scales2 = /* @__PURE__ */ Object.create(null);\n  Object.keys(configScales).forEach((id) => {\n    const scaleConf = configScales[id];\n    if (!isObject(scaleConf)) {\n      return console.error(`Invalid scale configuration for scale: ${id}`);\n    }\n    if (scaleConf._proxy) {\n      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\n    }\n    const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);\n    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n    const defaultScaleOptions = chartDefaults.scales || {};\n    scales2[id] = mergeIf(/* @__PURE__ */ Object.create(null), [{\n      axis\n    }, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);\n  });\n  config.data.datasets.forEach((dataset) => {\n    const type = dataset.type || config.type;\n    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n    const datasetDefaults = overrides[type] || {};\n    const defaultScaleOptions = datasetDefaults.scales || {};\n    Object.keys(defaultScaleOptions).forEach((defaultID) => {\n      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n      const id = dataset[axis + \"AxisID\"] || axis;\n      scales2[id] = scales2[id] || /* @__PURE__ */ Object.create(null);\n      mergeIf(scales2[id], [{\n        axis\n      }, configScales[id], defaultScaleOptions[defaultID]]);\n    });\n  });\n  Object.keys(scales2).forEach((key) => {\n    const scale = scales2[key];\n    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);\n  });\n  return scales2;\n}\nfunction initOptions(config) {\n  const options = config.options || (config.options = {});\n  options.plugins = valueOrDefault(options.plugins, {});\n  options.scales = mergeScaleConfig(config, options);\n}\nfunction initData(data) {\n  data = data || {};\n  data.datasets = data.datasets || [];\n  data.labels = data.labels || [];\n  return data;\n}\nfunction initConfig(config) {\n  config = config || {};\n  config.data = initData(config.data);\n  initOptions(config);\n  return config;\n}\nvar keyCache = /* @__PURE__ */ new Map();\nvar keysCached = /* @__PURE__ */ new Set();\nfunction cachedKeys(cacheKey, generate) {\n  let keys = keyCache.get(cacheKey);\n  if (!keys) {\n    keys = generate();\n    keyCache.set(cacheKey, keys);\n    keysCached.add(keys);\n  }\n  return keys;\n}\nvar addIfFound = (set2, obj, key) => {\n  const opts = resolveObjectKey(obj, key);\n  if (opts !== void 0) {\n    set2.add(opts);\n  }\n};\nvar Config = class {\n  constructor(config) {\n    this._config = initConfig(config);\n    this._scopeCache = /* @__PURE__ */ new Map();\n    this._resolverCache = /* @__PURE__ */ new Map();\n  }\n  get platform() {\n    return this._config.platform;\n  }\n  get type() {\n    return this._config.type;\n  }\n  set type(type) {\n    this._config.type = type;\n  }\n  get data() {\n    return this._config.data;\n  }\n  set data(data) {\n    this._config.data = initData(data);\n  }\n  get options() {\n    return this._config.options;\n  }\n  set options(options) {\n    this._config.options = options;\n  }\n  get plugins() {\n    return this._config.plugins;\n  }\n  update() {\n    const config = this._config;\n    this.clearCache();\n    initOptions(config);\n  }\n  clearCache() {\n    this._scopeCache.clear();\n    this._resolverCache.clear();\n  }\n  datasetScopeKeys(datasetType) {\n    return cachedKeys(datasetType, () => [[`datasets.${datasetType}`, \"\"]]);\n  }\n  datasetAnimationScopeKeys(datasetType, transition) {\n    return cachedKeys(`${datasetType}.transition.${transition}`, () => [[`datasets.${datasetType}.transitions.${transition}`, `transitions.${transition}`], [`datasets.${datasetType}`, \"\"]]);\n  }\n  datasetElementScopeKeys(datasetType, elementType) {\n    return cachedKeys(`${datasetType}-${elementType}`, () => [[`datasets.${datasetType}.elements.${elementType}`, `datasets.${datasetType}`, `elements.${elementType}`, \"\"]]);\n  }\n  pluginScopeKeys(plugin) {\n    const id = plugin.id;\n    const type = this.type;\n    return cachedKeys(`${type}-plugin-${id}`, () => [[`plugins.${id}`, ...plugin.additionalOptionScopes || []]]);\n  }\n  _cachedScopes(mainScope, resetCache) {\n    const _scopeCache = this._scopeCache;\n    let cache = _scopeCache.get(mainScope);\n    if (!cache || resetCache) {\n      cache = /* @__PURE__ */ new Map();\n      _scopeCache.set(mainScope, cache);\n    }\n    return cache;\n  }\n  getOptionScopes(mainScope, keyLists, resetCache) {\n    const {\n      options,\n      type\n    } = this;\n    const cache = this._cachedScopes(mainScope, resetCache);\n    const cached = cache.get(keyLists);\n    if (cached) {\n      return cached;\n    }\n    const scopes = /* @__PURE__ */ new Set();\n    keyLists.forEach((keys) => {\n      if (mainScope) {\n        scopes.add(mainScope);\n        keys.forEach((key) => addIfFound(scopes, mainScope, key));\n      }\n      keys.forEach((key) => addIfFound(scopes, options, key));\n      keys.forEach((key) => addIfFound(scopes, overrides[type] || {}, key));\n      keys.forEach((key) => addIfFound(scopes, defaults, key));\n      keys.forEach((key) => addIfFound(scopes, descriptors, key));\n    });\n    const array = Array.from(scopes);\n    if (array.length === 0) {\n      array.push(/* @__PURE__ */ Object.create(null));\n    }\n    if (keysCached.has(keyLists)) {\n      cache.set(keyLists, array);\n    }\n    return array;\n  }\n  chartOptionScopes() {\n    const {\n      options,\n      type\n    } = this;\n    return [options, overrides[type] || {}, defaults.datasets[type] || {}, {\n      type\n    }, defaults, descriptors];\n  }\n  resolveNamedOptions(scopes, names2, context, prefixes = [\"\"]) {\n    const result = {\n      $shared: true\n    };\n    const {\n      resolver,\n      subPrefixes\n    } = getResolver(this._resolverCache, scopes, prefixes);\n    let options = resolver;\n    if (needContext(resolver, names2)) {\n      result.$shared = false;\n      context = isFunction(context) ? context() : context;\n      const subResolver = this.createResolver(scopes, context, subPrefixes);\n      options = _attachContext(resolver, context, subResolver);\n    }\n    for (const prop of names2) {\n      result[prop] = options[prop];\n    }\n    return result;\n  }\n  createResolver(scopes, context, prefixes = [\"\"], descriptorDefaults) {\n    const {\n      resolver\n    } = getResolver(this._resolverCache, scopes, prefixes);\n    return isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;\n  }\n};\nfunction getResolver(resolverCache, scopes, prefixes) {\n  let cache = resolverCache.get(scopes);\n  if (!cache) {\n    cache = /* @__PURE__ */ new Map();\n    resolverCache.set(scopes, cache);\n  }\n  const cacheKey = prefixes.join();\n  let cached = cache.get(cacheKey);\n  if (!cached) {\n    const resolver = _createResolver(scopes, prefixes);\n    cached = {\n      resolver,\n      subPrefixes: prefixes.filter((p) => !p.toLowerCase().includes(\"hover\"))\n    };\n    cache.set(cacheKey, cached);\n  }\n  return cached;\n}\nvar hasFunction = (value) => isObject(value) && Object.getOwnPropertyNames(value).some((key) => isFunction(value[key]));\nfunction needContext(proxy, names2) {\n  const {\n    isScriptable,\n    isIndexable\n  } = _descriptors(proxy);\n  for (const prop of names2) {\n    const scriptable = isScriptable(prop);\n    const indexable = isIndexable(prop);\n    const value = (indexable || scriptable) && proxy[prop];\n    if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) {\n      return true;\n    }\n  }\n  return false;\n}\nvar version = \"4.4.8\";\nvar KNOWN_POSITIONS = [\"top\", \"bottom\", \"left\", \"right\", \"chartArea\"];\nfunction positionIsHorizontal(position, axis) {\n  return position === \"top\" || position === \"bottom\" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === \"x\";\n}\nfunction compare2Level(l1, l2) {\n  return function(a, b) {\n    return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];\n  };\n}\nfunction onAnimationsComplete(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  chart.notifyPlugins(\"afterRender\");\n  callback(animationOptions && animationOptions.onComplete, [context], chart);\n}\nfunction onAnimationProgress(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  callback(animationOptions && animationOptions.onProgress, [context], chart);\n}\nfunction getCanvas(item) {\n  if (_isDomSupported() && typeof item === \"string\") {\n    item = document.getElementById(item);\n  } else if (item && item.length) {\n    item = item[0];\n  }\n  if (item && item.canvas) {\n    item = item.canvas;\n  }\n  return item;\n}\nvar instances = {};\nvar getChart = (key) => {\n  const canvas = getCanvas(key);\n  return Object.values(instances).filter((c) => c.canvas === canvas).pop();\n};\nfunction moveNumericKeys(obj, start, move) {\n  const keys = Object.keys(obj);\n  for (const key of keys) {\n    const intKey = +key;\n    if (intKey >= start) {\n      const value = obj[key];\n      delete obj[key];\n      if (move > 0 || intKey > start) {\n        obj[intKey + move] = value;\n      }\n    }\n  }\n}\nfunction determineLastEvent(e, lastEvent, inChartArea, isClick) {\n  if (!inChartArea || e.type === \"mouseout\") {\n    return null;\n  }\n  if (isClick) {\n    return lastEvent;\n  }\n  return e;\n}\nfunction getSizeForArea(scale, chartArea, field) {\n  return scale.options.clip ? scale[field] : chartArea[field];\n}\nfunction getDatasetArea(meta, chartArea) {\n  const {\n    xScale,\n    yScale\n  } = meta;\n  if (xScale && yScale) {\n    return {\n      left: getSizeForArea(xScale, chartArea, \"left\"),\n      right: getSizeForArea(xScale, chartArea, \"right\"),\n      top: getSizeForArea(yScale, chartArea, \"top\"),\n      bottom: getSizeForArea(yScale, chartArea, \"bottom\")\n    };\n  }\n  return chartArea;\n}\nvar Chart = class {\n  static defaults = defaults;\n  static instances = instances;\n  static overrides = overrides;\n  static registry = registry;\n  static version = version;\n  static getChart = getChart;\n  static register(...items) {\n    registry.add(...items);\n    invalidatePlugins();\n  }\n  static unregister(...items) {\n    registry.remove(...items);\n    invalidatePlugins();\n  }\n  constructor(item, userConfig) {\n    const config = this.config = new Config(userConfig);\n    const initialCanvas = getCanvas(item);\n    const existingChart = getChart(initialCanvas);\n    if (existingChart) {\n      throw new Error(\"Canvas is already in use. Chart with ID '\" + existingChart.id + \"' must be destroyed before the canvas with ID '\" + existingChart.canvas.id + \"' can be reused.\");\n    }\n    const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n    this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n    this.platform.updateConfig(config);\n    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n    const canvas = context && context.canvas;\n    const height = canvas && canvas.height;\n    const width = canvas && canvas.width;\n    this.id = uid();\n    this.ctx = context;\n    this.canvas = canvas;\n    this.width = width;\n    this.height = height;\n    this._options = options;\n    this._aspectRatio = this.aspectRatio;\n    this._layers = [];\n    this._metasets = [];\n    this._stacks = void 0;\n    this.boxes = [];\n    this.currentDevicePixelRatio = void 0;\n    this.chartArea = void 0;\n    this._active = [];\n    this._lastEvent = void 0;\n    this._listeners = {};\n    this._responsiveListeners = void 0;\n    this._sortedMetasets = [];\n    this.scales = {};\n    this._plugins = new PluginService();\n    this.$proxies = {};\n    this._hiddenIndices = {};\n    this.attached = false;\n    this._animationsDisabled = void 0;\n    this.$context = void 0;\n    this._doResize = debounce((mode) => this.update(mode), options.resizeDelay || 0);\n    this._dataChanges = [];\n    instances[this.id] = this;\n    if (!context || !canvas) {\n      console.error(\"Failed to create chart: can't acquire context from the given item\");\n      return;\n    }\n    animator.listen(this, \"complete\", onAnimationsComplete);\n    animator.listen(this, \"progress\", onAnimationProgress);\n    this._initialize();\n    if (this.attached) {\n      this.update();\n    }\n  }\n  get aspectRatio() {\n    const {\n      options: {\n        aspectRatio,\n        maintainAspectRatio\n      },\n      width,\n      height,\n      _aspectRatio\n    } = this;\n    if (!isNullOrUndef(aspectRatio)) {\n      return aspectRatio;\n    }\n    if (maintainAspectRatio && _aspectRatio) {\n      return _aspectRatio;\n    }\n    return height ? width / height : null;\n  }\n  get data() {\n    return this.config.data;\n  }\n  set data(data) {\n    this.config.data = data;\n  }\n  get options() {\n    return this._options;\n  }\n  set options(options) {\n    this.config.options = options;\n  }\n  get registry() {\n    return registry;\n  }\n  _initialize() {\n    this.notifyPlugins(\"beforeInit\");\n    if (this.options.responsive) {\n      this.resize();\n    } else {\n      retinaScale(this, this.options.devicePixelRatio);\n    }\n    this.bindEvents();\n    this.notifyPlugins(\"afterInit\");\n    return this;\n  }\n  clear() {\n    clearCanvas(this.canvas, this.ctx);\n    return this;\n  }\n  stop() {\n    animator.stop(this);\n    return this;\n  }\n  resize(width, height) {\n    if (!animator.running(this)) {\n      this._resize(width, height);\n    } else {\n      this._resizeBeforeDraw = {\n        width,\n        height\n      };\n    }\n  }\n  _resize(width, height) {\n    const options = this.options;\n    const canvas = this.canvas;\n    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n    const mode = this.width ? \"resize\" : \"attach\";\n    this.width = newSize.width;\n    this.height = newSize.height;\n    this._aspectRatio = this.aspectRatio;\n    if (!retinaScale(this, newRatio, true)) {\n      return;\n    }\n    this.notifyPlugins(\"resize\", {\n      size: newSize\n    });\n    callback(options.onResize, [this, newSize], this);\n    if (this.attached) {\n      if (this._doResize(mode)) {\n        this.render();\n      }\n    }\n  }\n  ensureScalesHaveIDs() {\n    const options = this.options;\n    const scalesOptions = options.scales || {};\n    each(scalesOptions, (axisOptions, axisID) => {\n      axisOptions.id = axisID;\n    });\n  }\n  buildOrUpdateScales() {\n    const options = this.options;\n    const scaleOpts = options.scales;\n    const scales2 = this.scales;\n    const updated = Object.keys(scales2).reduce((obj, id) => {\n      obj[id] = false;\n      return obj;\n    }, {});\n    let items = [];\n    if (scaleOpts) {\n      items = items.concat(Object.keys(scaleOpts).map((id) => {\n        const scaleOptions = scaleOpts[id];\n        const axis = determineAxis(id, scaleOptions);\n        const isRadial = axis === \"r\";\n        const isHorizontal = axis === \"x\";\n        return {\n          options: scaleOptions,\n          dposition: isRadial ? \"chartArea\" : isHorizontal ? \"bottom\" : \"left\",\n          dtype: isRadial ? \"radialLinear\" : isHorizontal ? \"category\" : \"linear\"\n        };\n      }));\n    }\n    each(items, (item) => {\n      const scaleOptions = item.options;\n      const id = scaleOptions.id;\n      const axis = determineAxis(id, scaleOptions);\n      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\n      if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n        scaleOptions.position = item.dposition;\n      }\n      updated[id] = true;\n      let scale = null;\n      if (id in scales2 && scales2[id].type === scaleType) {\n        scale = scales2[id];\n      } else {\n        const scaleClass = registry.getScale(scaleType);\n        scale = new scaleClass({\n          id,\n          type: scaleType,\n          ctx: this.ctx,\n          chart: this\n        });\n        scales2[scale.id] = scale;\n      }\n      scale.init(scaleOptions, options);\n    });\n    each(updated, (hasUpdated, id) => {\n      if (!hasUpdated) {\n        delete scales2[id];\n      }\n    });\n    each(scales2, (scale) => {\n      layouts.configure(this, scale, scale.options);\n      layouts.addBox(this, scale);\n    });\n  }\n  _updateMetasets() {\n    const metasets = this._metasets;\n    const numData = this.data.datasets.length;\n    const numMeta = metasets.length;\n    metasets.sort((a, b) => a.index - b.index);\n    if (numMeta > numData) {\n      for (let i = numData; i < numMeta; ++i) {\n        this._destroyDatasetMeta(i);\n      }\n      metasets.splice(numData, numMeta - numData);\n    }\n    this._sortedMetasets = metasets.slice(0).sort(compare2Level(\"order\", \"index\"));\n  }\n  _removeUnreferencedMetasets() {\n    const {\n      _metasets: metasets,\n      data: {\n        datasets\n      }\n    } = this;\n    if (metasets.length > datasets.length) {\n      delete this._stacks;\n    }\n    metasets.forEach((meta, index2) => {\n      if (datasets.filter((x) => x === meta._dataset).length === 0) {\n        this._destroyDatasetMeta(index2);\n      }\n    });\n  }\n  buildOrUpdateControllers() {\n    const newControllers = [];\n    const datasets = this.data.datasets;\n    let i, ilen;\n    this._removeUnreferencedMetasets();\n    for (i = 0, ilen = datasets.length; i < ilen; i++) {\n      const dataset = datasets[i];\n      let meta = this.getDatasetMeta(i);\n      const type = dataset.type || this.config.type;\n      if (meta.type && meta.type !== type) {\n        this._destroyDatasetMeta(i);\n        meta = this.getDatasetMeta(i);\n      }\n      meta.type = type;\n      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n      meta.order = dataset.order || 0;\n      meta.index = i;\n      meta.label = \"\" + dataset.label;\n      meta.visible = this.isDatasetVisible(i);\n      if (meta.controller) {\n        meta.controller.updateIndex(i);\n        meta.controller.linkScales();\n      } else {\n        const ControllerClass = registry.getController(type);\n        const {\n          datasetElementType,\n          dataElementType\n        } = defaults.datasets[type];\n        Object.assign(ControllerClass, {\n          dataElementType: registry.getElement(dataElementType),\n          datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n        });\n        meta.controller = new ControllerClass(this, i);\n        newControllers.push(meta.controller);\n      }\n    }\n    this._updateMetasets();\n    return newControllers;\n  }\n  _resetElements() {\n    each(this.data.datasets, (dataset, datasetIndex) => {\n      this.getDatasetMeta(datasetIndex).controller.reset();\n    }, this);\n  }\n  reset() {\n    this._resetElements();\n    this.notifyPlugins(\"reset\");\n  }\n  update(mode) {\n    const config = this.config;\n    config.update();\n    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n    const animsDisabled = this._animationsDisabled = !options.animation;\n    this._updateScales();\n    this._checkEventBindings();\n    this._updateHiddenIndices();\n    this._plugins.invalidate();\n    if (this.notifyPlugins(\"beforeUpdate\", {\n      mode,\n      cancelable: true\n    }) === false) {\n      return;\n    }\n    const newControllers = this.buildOrUpdateControllers();\n    this.notifyPlugins(\"beforeElementsUpdate\");\n    let minPadding = 0;\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {\n      const {\n        controller\n      } = this.getDatasetMeta(i);\n      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n      controller.buildOrUpdateElements(reset);\n      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n    }\n    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n    this._updateLayout(minPadding);\n    if (!animsDisabled) {\n      each(newControllers, (controller) => {\n        controller.reset();\n      });\n    }\n    this._updateDatasets(mode);\n    this.notifyPlugins(\"afterUpdate\", {\n      mode\n    });\n    this._layers.sort(compare2Level(\"z\", \"_idx\"));\n    const {\n      _active,\n      _lastEvent\n    } = this;\n    if (_lastEvent) {\n      this._eventHandler(_lastEvent, true);\n    } else if (_active.length) {\n      this._updateHoverStyles(_active, _active, true);\n    }\n    this.render();\n  }\n  _updateScales() {\n    each(this.scales, (scale) => {\n      layouts.removeBox(this, scale);\n    });\n    this.ensureScalesHaveIDs();\n    this.buildOrUpdateScales();\n  }\n  _checkEventBindings() {\n    const options = this.options;\n    const existingEvents = new Set(Object.keys(this._listeners));\n    const newEvents = new Set(options.events);\n    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n      this.unbindEvents();\n      this.bindEvents();\n    }\n  }\n  _updateHiddenIndices() {\n    const {\n      _hiddenIndices\n    } = this;\n    const changes = this._getUniformDataChanges() || [];\n    for (const {\n      method,\n      start,\n      count\n    } of changes) {\n      const move = method === \"_removeElements\" ? -count : count;\n      moveNumericKeys(_hiddenIndices, start, move);\n    }\n  }\n  _getUniformDataChanges() {\n    const _dataChanges = this._dataChanges;\n    if (!_dataChanges || !_dataChanges.length) {\n      return;\n    }\n    this._dataChanges = [];\n    const datasetCount = this.data.datasets.length;\n    const makeSet = (idx) => new Set(_dataChanges.filter((c) => c[0] === idx).map((c, i) => i + \",\" + c.splice(1).join(\",\")));\n    const changeSet = makeSet(0);\n    for (let i = 1; i < datasetCount; i++) {\n      if (!setsEqual(changeSet, makeSet(i))) {\n        return;\n      }\n    }\n    return Array.from(changeSet).map((c) => c.split(\",\")).map((a) => ({\n      method: a[1],\n      start: +a[2],\n      count: +a[3]\n    }));\n  }\n  _updateLayout(minPadding) {\n    if (this.notifyPlugins(\"beforeLayout\", {\n      cancelable: true\n    }) === false) {\n      return;\n    }\n    layouts.update(this, this.width, this.height, minPadding);\n    const area = this.chartArea;\n    const noArea = area.width <= 0 || area.height <= 0;\n    this._layers = [];\n    each(this.boxes, (box) => {\n      if (noArea && box.position === \"chartArea\") {\n        return;\n      }\n      if (box.configure) {\n        box.configure();\n      }\n      this._layers.push(...box._layers());\n    }, this);\n    this._layers.forEach((item, index2) => {\n      item._idx = index2;\n    });\n    this.notifyPlugins(\"afterLayout\");\n  }\n  _updateDatasets(mode) {\n    if (this.notifyPlugins(\"beforeDatasetsUpdate\", {\n      mode,\n      cancelable: true\n    }) === false) {\n      return;\n    }\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this.getDatasetMeta(i).controller.configure();\n    }\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._updateDataset(i, isFunction(mode) ? mode({\n        datasetIndex: i\n      }) : mode);\n    }\n    this.notifyPlugins(\"afterDatasetsUpdate\", {\n      mode\n    });\n  }\n  _updateDataset(index2, mode) {\n    const meta = this.getDatasetMeta(index2);\n    const args = {\n      meta,\n      index: index2,\n      mode,\n      cancelable: true\n    };\n    if (this.notifyPlugins(\"beforeDatasetUpdate\", args) === false) {\n      return;\n    }\n    meta.controller._update(mode);\n    args.cancelable = false;\n    this.notifyPlugins(\"afterDatasetUpdate\", args);\n  }\n  render() {\n    if (this.notifyPlugins(\"beforeRender\", {\n      cancelable: true\n    }) === false) {\n      return;\n    }\n    if (animator.has(this)) {\n      if (this.attached && !animator.running(this)) {\n        animator.start(this);\n      }\n    } else {\n      this.draw();\n      onAnimationsComplete({\n        chart: this\n      });\n    }\n  }\n  draw() {\n    let i;\n    if (this._resizeBeforeDraw) {\n      const {\n        width,\n        height\n      } = this._resizeBeforeDraw;\n      this._resizeBeforeDraw = null;\n      this._resize(width, height);\n    }\n    this.clear();\n    if (this.width <= 0 || this.height <= 0) {\n      return;\n    }\n    if (this.notifyPlugins(\"beforeDraw\", {\n      cancelable: true\n    }) === false) {\n      return;\n    }\n    const layers = this._layers;\n    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n    this._drawDatasets();\n    for (; i < layers.length; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n    this.notifyPlugins(\"afterDraw\");\n  }\n  _getSortedDatasetMetas(filterVisible) {\n    const metasets = this._sortedMetasets;\n    const result = [];\n    let i, ilen;\n    for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n      const meta = metasets[i];\n      if (!filterVisible || meta.visible) {\n        result.push(meta);\n      }\n    }\n    return result;\n  }\n  getSortedVisibleDatasetMetas() {\n    return this._getSortedDatasetMetas(true);\n  }\n  _drawDatasets() {\n    if (this.notifyPlugins(\"beforeDatasetsDraw\", {\n      cancelable: true\n    }) === false) {\n      return;\n    }\n    const metasets = this.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      this._drawDataset(metasets[i]);\n    }\n    this.notifyPlugins(\"afterDatasetsDraw\");\n  }\n  _drawDataset(meta) {\n    const ctx = this.ctx;\n    const clip = meta._clip;\n    const useClip = !clip.disabled;\n    const area = getDatasetArea(meta, this.chartArea);\n    const args = {\n      meta,\n      index: meta.index,\n      cancelable: true\n    };\n    if (this.notifyPlugins(\"beforeDatasetDraw\", args) === false) {\n      return;\n    }\n    if (useClip) {\n      clipArea(ctx, {\n        left: clip.left === false ? 0 : area.left - clip.left,\n        right: clip.right === false ? this.width : area.right + clip.right,\n        top: clip.top === false ? 0 : area.top - clip.top,\n        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom\n      });\n    }\n    meta.controller.draw();\n    if (useClip) {\n      unclipArea(ctx);\n    }\n    args.cancelable = false;\n    this.notifyPlugins(\"afterDatasetDraw\", args);\n  }\n  isPointInArea(point) {\n    return _isPointInArea(point, this.chartArea, this._minPadding);\n  }\n  getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n    const method = Interaction.modes[mode];\n    if (typeof method === \"function\") {\n      return method(this, e, options, useFinalPosition);\n    }\n    return [];\n  }\n  getDatasetMeta(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    const metasets = this._metasets;\n    let meta = metasets.filter((x) => x && x._dataset === dataset).pop();\n    if (!meta) {\n      meta = {\n        type: null,\n        data: [],\n        dataset: null,\n        controller: null,\n        hidden: null,\n        xAxisID: null,\n        yAxisID: null,\n        order: dataset && dataset.order || 0,\n        index: datasetIndex,\n        _dataset: dataset,\n        _parsed: [],\n        _sorted: false\n      };\n      metasets.push(meta);\n    }\n    return meta;\n  }\n  getContext() {\n    return this.$context || (this.$context = createContext(null, {\n      chart: this,\n      type: \"chart\"\n    }));\n  }\n  getVisibleDatasetCount() {\n    return this.getSortedVisibleDatasetMetas().length;\n  }\n  isDatasetVisible(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    if (!dataset) {\n      return false;\n    }\n    const meta = this.getDatasetMeta(datasetIndex);\n    return typeof meta.hidden === \"boolean\" ? !meta.hidden : !dataset.hidden;\n  }\n  setDatasetVisibility(datasetIndex, visible) {\n    const meta = this.getDatasetMeta(datasetIndex);\n    meta.hidden = !visible;\n  }\n  toggleDataVisibility(index2) {\n    this._hiddenIndices[index2] = !this._hiddenIndices[index2];\n  }\n  getDataVisibility(index2) {\n    return !this._hiddenIndices[index2];\n  }\n  _updateVisibility(datasetIndex, dataIndex, visible) {\n    const mode = visible ? \"show\" : \"hide\";\n    const meta = this.getDatasetMeta(datasetIndex);\n    const anims = meta.controller._resolveAnimations(void 0, mode);\n    if (defined(dataIndex)) {\n      meta.data[dataIndex].hidden = !visible;\n      this.update();\n    } else {\n      this.setDatasetVisibility(datasetIndex, visible);\n      anims.update(meta, {\n        visible\n      });\n      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : void 0);\n    }\n  }\n  hide(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, false);\n  }\n  show(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, true);\n  }\n  _destroyDatasetMeta(datasetIndex) {\n    const meta = this._metasets[datasetIndex];\n    if (meta && meta.controller) {\n      meta.controller._destroy();\n    }\n    delete this._metasets[datasetIndex];\n  }\n  _stop() {\n    let i, ilen;\n    this.stop();\n    animator.remove(this);\n    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._destroyDatasetMeta(i);\n    }\n  }\n  destroy() {\n    this.notifyPlugins(\"beforeDestroy\");\n    const {\n      canvas,\n      ctx\n    } = this;\n    this._stop();\n    this.config.clearCache();\n    if (canvas) {\n      this.unbindEvents();\n      clearCanvas(canvas, ctx);\n      this.platform.releaseContext(ctx);\n      this.canvas = null;\n      this.ctx = null;\n    }\n    delete instances[this.id];\n    this.notifyPlugins(\"afterDestroy\");\n  }\n  toBase64Image(...args) {\n    return this.canvas.toDataURL(...args);\n  }\n  bindEvents() {\n    this.bindUserEvents();\n    if (this.options.responsive) {\n      this.bindResponsiveEvents();\n    } else {\n      this.attached = true;\n    }\n  }\n  bindUserEvents() {\n    const listeners = this._listeners;\n    const platform = this.platform;\n    const _add = (type, listener2) => {\n      platform.addEventListener(this, type, listener2);\n      listeners[type] = listener2;\n    };\n    const listener = (e, x, y) => {\n      e.offsetX = x;\n      e.offsetY = y;\n      this._eventHandler(e);\n    };\n    each(this.options.events, (type) => _add(type, listener));\n  }\n  bindResponsiveEvents() {\n    if (!this._responsiveListeners) {\n      this._responsiveListeners = {};\n    }\n    const listeners = this._responsiveListeners;\n    const platform = this.platform;\n    const _add = (type, listener2) => {\n      platform.addEventListener(this, type, listener2);\n      listeners[type] = listener2;\n    };\n    const _remove = (type, listener2) => {\n      if (listeners[type]) {\n        platform.removeEventListener(this, type, listener2);\n        delete listeners[type];\n      }\n    };\n    const listener = (width, height) => {\n      if (this.canvas) {\n        this.resize(width, height);\n      }\n    };\n    let detached;\n    const attached = () => {\n      _remove(\"attach\", attached);\n      this.attached = true;\n      this.resize();\n      _add(\"resize\", listener);\n      _add(\"detach\", detached);\n    };\n    detached = () => {\n      this.attached = false;\n      _remove(\"resize\", listener);\n      this._stop();\n      this._resize(0, 0);\n      _add(\"attach\", attached);\n    };\n    if (platform.isAttached(this.canvas)) {\n      attached();\n    } else {\n      detached();\n    }\n  }\n  unbindEvents() {\n    each(this._listeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._listeners = {};\n    each(this._responsiveListeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._responsiveListeners = void 0;\n  }\n  updateHoverStyle(items, mode, enabled) {\n    const prefix = enabled ? \"set\" : \"remove\";\n    let meta, item, i, ilen;\n    if (mode === \"dataset\") {\n      meta = this.getDatasetMeta(items[0].datasetIndex);\n      meta.controller[\"_\" + prefix + \"DatasetHoverStyle\"]();\n    }\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      item = items[i];\n      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n      if (controller) {\n        controller[prefix + \"HoverStyle\"](item.element, item.datasetIndex, item.index);\n      }\n    }\n  }\n  getActiveElements() {\n    return this._active || [];\n  }\n  setActiveElements(activeElements) {\n    const lastActive = this._active || [];\n    const active = activeElements.map(({\n      datasetIndex,\n      index: index2\n    }) => {\n      const meta = this.getDatasetMeta(datasetIndex);\n      if (!meta) {\n        throw new Error(\"No dataset found at index \" + datasetIndex);\n      }\n      return {\n        datasetIndex,\n        element: meta.data[index2],\n        index: index2\n      };\n    });\n    const changed = !_elementsEqual(active, lastActive);\n    if (changed) {\n      this._active = active;\n      this._lastEvent = null;\n      this._updateHoverStyles(active, lastActive);\n    }\n  }\n  notifyPlugins(hook, args, filter) {\n    return this._plugins.notify(this, hook, args, filter);\n  }\n  isPluginEnabled(pluginId) {\n    return this._plugins._cache.filter((p) => p.plugin.id === pluginId).length === 1;\n  }\n  _updateHoverStyles(active, lastActive, replay) {\n    const hoverOptions = this.options.hover;\n    const diff = (a, b) => a.filter((x) => !b.some((y) => x.datasetIndex === y.datasetIndex && x.index === y.index));\n    const deactivated = diff(lastActive, active);\n    const activated = replay ? active : diff(active, lastActive);\n    if (deactivated.length) {\n      this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n    }\n    if (activated.length && hoverOptions.mode) {\n      this.updateHoverStyle(activated, hoverOptions.mode, true);\n    }\n  }\n  _eventHandler(e, replay) {\n    const args = {\n      event: e,\n      replay,\n      cancelable: true,\n      inChartArea: this.isPointInArea(e)\n    };\n    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);\n    if (this.notifyPlugins(\"beforeEvent\", args, eventFilter) === false) {\n      return;\n    }\n    const changed = this._handleEvent(e, replay, args.inChartArea);\n    args.cancelable = false;\n    this.notifyPlugins(\"afterEvent\", args, eventFilter);\n    if (changed || args.changed) {\n      this.render();\n    }\n    return this;\n  }\n  _handleEvent(e, replay, inChartArea) {\n    const {\n      _active: lastActive = [],\n      options\n    } = this;\n    const useFinalPosition = replay;\n    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n    const isClick = _isClickEvent(e);\n    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n    if (inChartArea) {\n      this._lastEvent = null;\n      callback(options.onHover, [e, active, this], this);\n      if (isClick) {\n        callback(options.onClick, [e, active, this], this);\n      }\n    }\n    const changed = !_elementsEqual(active, lastActive);\n    if (changed || replay) {\n      this._active = active;\n      this._updateHoverStyles(active, lastActive, replay);\n    }\n    this._lastEvent = lastEvent;\n    return changed;\n  }\n  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n    if (e.type === \"mouseout\") {\n      return [];\n    }\n    if (!inChartArea) {\n      return lastActive;\n    }\n    const hoverOptions = this.options.hover;\n    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n  }\n};\nfunction invalidatePlugins() {\n  return each(Chart.instances, (chart) => chart._plugins.invalidate());\n}\nfunction clipArc(ctx, element, endAngle) {\n  const {\n    startAngle,\n    pixelMargin,\n    x,\n    y,\n    outerRadius,\n    innerRadius\n  } = element;\n  let angleMargin = pixelMargin / outerRadius;\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n  if (innerRadius > pixelMargin) {\n    angleMargin = pixelMargin / innerRadius;\n    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n  } else {\n    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\n  }\n  ctx.closePath();\n  ctx.clip();\n}\nfunction toRadiusCorners(value) {\n  return _readValueToProps(value, [\"outerStart\", \"outerEnd\", \"innerStart\", \"innerEnd\"]);\n}\nfunction parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {\n  const o = toRadiusCorners(arc.options.borderRadius);\n  const halfThickness = (outerRadius - innerRadius) / 2;\n  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n  const computeOuterLimit = (val) => {\n    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\n  };\n  return {\n    outerStart: computeOuterLimit(o.outerStart),\n    outerEnd: computeOuterLimit(o.outerEnd),\n    innerStart: _limitValue(o.innerStart, 0, innerLimit),\n    innerEnd: _limitValue(o.innerEnd, 0, innerLimit)\n  };\n}\nfunction rThetaToXY(r, theta, x, y) {\n  return {\n    x: x + r * Math.cos(theta),\n    y: y + r * Math.sin(theta)\n  };\n}\nfunction pathArc(ctx, element, offset, spacing, end, circular) {\n  const {\n    x,\n    y,\n    startAngle: start,\n    pixelMargin,\n    innerRadius: innerR\n  } = element;\n  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n  let spacingOffset = 0;\n  const alpha2 = end - start;\n  if (spacing) {\n    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n    const adjustedAngle = avNogSpacingRadius !== 0 ? alpha2 * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha2;\n    spacingOffset = (alpha2 - adjustedAngle) / 2;\n  }\n  const beta = Math.max(1e-3, alpha2 * outerRadius - offset / PI) / outerRadius;\n  const angleOffset = (alpha2 - beta) / 2;\n  const startAngle = start + angleOffset + spacingOffset;\n  const endAngle = end - angleOffset - spacingOffset;\n  const {\n    outerStart,\n    outerEnd,\n    innerStart,\n    innerEnd\n  } = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);\n  const outerStartAdjustedRadius = outerRadius - outerStart;\n  const outerEndAdjustedRadius = outerRadius - outerEnd;\n  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n  const innerStartAdjustedRadius = innerRadius + innerStart;\n  const innerEndAdjustedRadius = innerRadius + innerEnd;\n  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n  ctx.beginPath();\n  if (circular) {\n    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;\n    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);\n    ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);\n    if (outerEnd > 0) {\n      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);\n    }\n    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n    ctx.lineTo(p4.x, p4.y);\n    if (innerEnd > 0) {\n      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);\n    }\n    const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;\n    ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);\n    ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);\n    if (innerStart > 0) {\n      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);\n    }\n    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n    ctx.lineTo(p8.x, p8.y);\n    if (outerStart > 0) {\n      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);\n    }\n  } else {\n    ctx.moveTo(x, y);\n    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\n    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerStartX, outerStartY);\n    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\n    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerEndX, outerEndY);\n  }\n  ctx.closePath();\n}\nfunction drawArc(ctx, element, offset, spacing, circular) {\n  const {\n    fullCircles,\n    startAngle,\n    circumference\n  } = element;\n  let endAngle = element.endAngle;\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.fill();\n    }\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + (circumference % TAU || TAU);\n    }\n  }\n  pathArc(ctx, element, offset, spacing, endAngle, circular);\n  ctx.fill();\n  return endAngle;\n}\nfunction drawBorder(ctx, element, offset, spacing, circular) {\n  const {\n    fullCircles,\n    startAngle,\n    circumference,\n    options\n  } = element;\n  const {\n    borderWidth,\n    borderJoinStyle,\n    borderDash,\n    borderDashOffset\n  } = options;\n  const inner = options.borderAlign === \"inner\";\n  if (!borderWidth) {\n    return;\n  }\n  ctx.setLineDash(borderDash || []);\n  ctx.lineDashOffset = borderDashOffset;\n  if (inner) {\n    ctx.lineWidth = borderWidth * 2;\n    ctx.lineJoin = borderJoinStyle || \"round\";\n  } else {\n    ctx.lineWidth = borderWidth;\n    ctx.lineJoin = borderJoinStyle || \"bevel\";\n  }\n  let endAngle = element.endAngle;\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.stroke();\n    }\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + (circumference % TAU || TAU);\n    }\n  }\n  if (inner) {\n    clipArc(ctx, element, endAngle);\n  }\n  if (!fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    ctx.stroke();\n  }\n}\nvar ArcElement = class extends Element {\n  static id = \"arc\";\n  static defaults = {\n    borderAlign: \"center\",\n    borderColor: \"#fff\",\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: void 0,\n    borderRadius: 0,\n    borderWidth: 2,\n    offset: 0,\n    spacing: 0,\n    angle: void 0,\n    circular: true\n  };\n  static defaultRoutes = {\n    backgroundColor: \"backgroundColor\"\n  };\n  static descriptors = {\n    _scriptable: true,\n    _indexable: (name) => name !== \"borderDash\"\n  };\n  circumference;\n  endAngle;\n  fullCircles;\n  innerRadius;\n  outerRadius;\n  pixelMargin;\n  startAngle;\n  constructor(cfg) {\n    super();\n    this.options = void 0;\n    this.circumference = void 0;\n    this.startAngle = void 0;\n    this.endAngle = void 0;\n    this.innerRadius = void 0;\n    this.outerRadius = void 0;\n    this.pixelMargin = 0;\n    this.fullCircles = 0;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  inRange(chartX, chartY, useFinalPosition) {\n    const point = this.getProps([\"x\", \"y\"], useFinalPosition);\n    const {\n      angle,\n      distance\n    } = getAngleFromPoint(point, {\n      x: chartX,\n      y: chartY\n    });\n    const {\n      startAngle,\n      endAngle,\n      innerRadius,\n      outerRadius,\n      circumference\n    } = this.getProps([\"startAngle\", \"endAngle\", \"innerRadius\", \"outerRadius\", \"circumference\"], useFinalPosition);\n    const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;\n    const _circumference = valueOrDefault(circumference, endAngle - startAngle);\n    const nonZeroBetween = _angleBetween(angle, startAngle, endAngle) && startAngle !== endAngle;\n    const betweenAngles = _circumference >= TAU || nonZeroBetween;\n    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n    return betweenAngles && withinRadius;\n  }\n  getCenterPoint(useFinalPosition) {\n    const {\n      x,\n      y,\n      startAngle,\n      endAngle,\n      innerRadius,\n      outerRadius\n    } = this.getProps([\"x\", \"y\", \"startAngle\", \"endAngle\", \"innerRadius\", \"outerRadius\"], useFinalPosition);\n    const {\n      offset,\n      spacing\n    } = this.options;\n    const halfAngle = (startAngle + endAngle) / 2;\n    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n    return {\n      x: x + Math.cos(halfAngle) * halfRadius,\n      y: y + Math.sin(halfAngle) * halfRadius\n    };\n  }\n  tooltipPosition(useFinalPosition) {\n    return this.getCenterPoint(useFinalPosition);\n  }\n  draw(ctx) {\n    const {\n      options,\n      circumference\n    } = this;\n    const offset = (options.offset || 0) / 4;\n    const spacing = (options.spacing || 0) / 2;\n    const circular = options.circular;\n    this.pixelMargin = options.borderAlign === \"inner\" ? 0.33 : 0;\n    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;\n    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n      return;\n    }\n    ctx.save();\n    const halfAngle = (this.startAngle + this.endAngle) / 2;\n    ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);\n    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));\n    const radiusOffset = offset * fix;\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    drawArc(ctx, this, radiusOffset, spacing, circular);\n    drawBorder(ctx, this, radiusOffset, spacing, circular);\n    ctx.restore();\n  }\n};\nfunction setStyle(ctx, options, style = options) {\n  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);\n  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));\n  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);\n  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\n  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);\n  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);\n}\nfunction lineTo(ctx, previous, target) {\n  ctx.lineTo(target.x, target.y);\n}\nfunction getLineMethod(options) {\n  if (options.stepped) {\n    return _steppedLineTo;\n  }\n  if (options.tension || options.cubicInterpolationMode === \"monotone\") {\n    return _bezierCurveTo;\n  }\n  return lineTo;\n}\nfunction pathVars(points, segment, params = {}) {\n  const count = points.length;\n  const {\n    start: paramsStart = 0,\n    end: paramsEnd = count - 1\n  } = params;\n  const {\n    start: segmentStart,\n    end: segmentEnd\n  } = segment;\n  const start = Math.max(paramsStart, segmentStart);\n  const end = Math.min(paramsEnd, segmentEnd);\n  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n  return {\n    count,\n    start,\n    loop: segment.loop,\n    ilen: end < start && !outside ? count + end - start : end - start\n  };\n}\nfunction pathSegment(ctx, line, segment, params) {\n  const {\n    points,\n    options\n  } = line;\n  const {\n    count,\n    start,\n    loop,\n    ilen\n  } = pathVars(points, segment, params);\n  const lineMethod = getLineMethod(options);\n  let {\n    move = true,\n    reverse\n  } = params || {};\n  let i, point, prev;\n  for (i = 0; i <= ilen; ++i) {\n    point = points[(start + (reverse ? ilen - i : i)) % count];\n    if (point.skip) {\n      continue;\n    } else if (move) {\n      ctx.moveTo(point.x, point.y);\n      move = false;\n    } else {\n      lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n    prev = point;\n  }\n  if (loop) {\n    point = points[(start + (reverse ? ilen : 0)) % count];\n    lineMethod(ctx, prev, point, reverse, options.stepped);\n  }\n  return !!loop;\n}\nfunction fastPathSegment(ctx, line, segment, params) {\n  const points = line.points;\n  const {\n    count,\n    start,\n    ilen\n  } = pathVars(points, segment, params);\n  const {\n    move = true,\n    reverse\n  } = params || {};\n  let avgX = 0;\n  let countX = 0;\n  let i, point, prevX, minY, maxY, lastY;\n  const pointIndex = (index2) => (start + (reverse ? ilen - index2 : index2)) % count;\n  const drawX = () => {\n    if (minY !== maxY) {\n      ctx.lineTo(avgX, maxY);\n      ctx.lineTo(avgX, minY);\n      ctx.lineTo(avgX, lastY);\n    }\n  };\n  if (move) {\n    point = points[pointIndex(0)];\n    ctx.moveTo(point.x, point.y);\n  }\n  for (i = 0; i <= ilen; ++i) {\n    point = points[pointIndex(i)];\n    if (point.skip) {\n      continue;\n    }\n    const x = point.x;\n    const y = point.y;\n    const truncX = x | 0;\n    if (truncX === prevX) {\n      if (y < minY) {\n        minY = y;\n      } else if (y > maxY) {\n        maxY = y;\n      }\n      avgX = (countX * avgX + x) / ++countX;\n    } else {\n      drawX();\n      ctx.lineTo(x, y);\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n    }\n    lastY = y;\n  }\n  drawX();\n}\nfunction _getSegmentMethod(line) {\n  const opts = line.options;\n  const borderDash = opts.borderDash && opts.borderDash.length;\n  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== \"monotone\" && !opts.stepped && !borderDash;\n  return useFastPath ? fastPathSegment : pathSegment;\n}\nfunction _getInterpolationMethod(options) {\n  if (options.stepped) {\n    return _steppedInterpolation;\n  }\n  if (options.tension || options.cubicInterpolationMode === \"monotone\") {\n    return _bezierInterpolation;\n  }\n  return _pointInLine;\n}\nfunction strokePathWithCache(ctx, line, start, count) {\n  let path = line._path;\n  if (!path) {\n    path = line._path = new Path2D();\n    if (line.path(path, start, count)) {\n      path.closePath();\n    }\n  }\n  setStyle(ctx, line.options);\n  ctx.stroke(path);\n}\nfunction strokePathDirect(ctx, line, start, count) {\n  const {\n    segments,\n    options\n  } = line;\n  const segmentMethod = _getSegmentMethod(line);\n  for (const segment of segments) {\n    setStyle(ctx, options, segment.style);\n    ctx.beginPath();\n    if (segmentMethod(ctx, line, segment, {\n      start,\n      end: start + count - 1\n    })) {\n      ctx.closePath();\n    }\n    ctx.stroke();\n  }\n}\nvar usePath2D = typeof Path2D === \"function\";\nfunction draw(ctx, line, start, count) {\n  if (usePath2D && !line.options.segment) {\n    strokePathWithCache(ctx, line, start, count);\n  } else {\n    strokePathDirect(ctx, line, start, count);\n  }\n}\nvar LineElement = class extends Element {\n  static id = \"line\";\n  static defaults = {\n    borderCapStyle: \"butt\",\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: \"miter\",\n    borderWidth: 3,\n    capBezierPoints: true,\n    cubicInterpolationMode: \"default\",\n    fill: false,\n    spanGaps: false,\n    stepped: false,\n    tension: 0\n  };\n  static defaultRoutes = {\n    backgroundColor: \"backgroundColor\",\n    borderColor: \"borderColor\"\n  };\n  static descriptors = {\n    _scriptable: true,\n    _indexable: (name) => name !== \"borderDash\" && name !== \"fill\"\n  };\n  constructor(cfg) {\n    super();\n    this.animated = true;\n    this.options = void 0;\n    this._chart = void 0;\n    this._loop = void 0;\n    this._fullLoop = void 0;\n    this._path = void 0;\n    this._points = void 0;\n    this._segments = void 0;\n    this._decimated = false;\n    this._pointsUpdated = false;\n    this._datasetIndex = void 0;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  updateControlPoints(chartArea, indexAxis) {\n    const options = this.options;\n    if ((options.tension || options.cubicInterpolationMode === \"monotone\") && !options.stepped && !this._pointsUpdated) {\n      const loop = options.spanGaps ? this._loop : this._fullLoop;\n      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);\n      this._pointsUpdated = true;\n    }\n  }\n  set points(points) {\n    this._points = points;\n    delete this._segments;\n    delete this._path;\n    this._pointsUpdated = false;\n  }\n  get points() {\n    return this._points;\n  }\n  get segments() {\n    return this._segments || (this._segments = _computeSegments(this, this.options.segment));\n  }\n  first() {\n    const segments = this.segments;\n    const points = this.points;\n    return segments.length && points[segments[0].start];\n  }\n  last() {\n    const segments = this.segments;\n    const points = this.points;\n    const count = segments.length;\n    return count && points[segments[count - 1].end];\n  }\n  interpolate(point, property) {\n    const options = this.options;\n    const value = point[property];\n    const points = this.points;\n    const segments = _boundSegments(this, {\n      property,\n      start: value,\n      end: value\n    });\n    if (!segments.length) {\n      return;\n    }\n    const result = [];\n    const _interpolate = _getInterpolationMethod(options);\n    let i, ilen;\n    for (i = 0, ilen = segments.length; i < ilen; ++i) {\n      const {\n        start,\n        end\n      } = segments[i];\n      const p1 = points[start];\n      const p2 = points[end];\n      if (p1 === p2) {\n        result.push(p1);\n        continue;\n      }\n      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n      const interpolated = _interpolate(p1, p2, t, options.stepped);\n      interpolated[property] = point[property];\n      result.push(interpolated);\n    }\n    return result.length === 1 ? result[0] : result;\n  }\n  pathSegment(ctx, segment, params) {\n    const segmentMethod = _getSegmentMethod(this);\n    return segmentMethod(ctx, this, segment, params);\n  }\n  path(ctx, start, count) {\n    const segments = this.segments;\n    const segmentMethod = _getSegmentMethod(this);\n    let loop = this._loop;\n    start = start || 0;\n    count = count || this.points.length - start;\n    for (const segment of segments) {\n      loop &= segmentMethod(ctx, this, segment, {\n        start,\n        end: start + count - 1\n      });\n    }\n    return !!loop;\n  }\n  draw(ctx, chartArea, start, count) {\n    const options = this.options || {};\n    const points = this.points || [];\n    if (points.length && options.borderWidth) {\n      ctx.save();\n      draw(ctx, this, start, count);\n      ctx.restore();\n    }\n    if (this.animated) {\n      this._pointsUpdated = false;\n      this._path = void 0;\n    }\n  }\n};\nfunction inRange$1(el, pos, axis, useFinalPosition) {\n  const options = el.options;\n  const {\n    [axis]: value\n  } = el.getProps([axis], useFinalPosition);\n  return Math.abs(pos - value) < options.radius + options.hitRadius;\n}\nvar PointElement = class extends Element {\n  static id = \"point\";\n  parsed;\n  skip;\n  stop;\n  /**\n  * @type {any}\n  */\n  static defaults = {\n    borderWidth: 1,\n    hitRadius: 1,\n    hoverBorderWidth: 1,\n    hoverRadius: 4,\n    pointStyle: \"circle\",\n    radius: 3,\n    rotation: 0\n  };\n  /**\n  * @type {any}\n  */\n  static defaultRoutes = {\n    backgroundColor: \"backgroundColor\",\n    borderColor: \"borderColor\"\n  };\n  constructor(cfg) {\n    super();\n    this.options = void 0;\n    this.parsed = void 0;\n    this.skip = void 0;\n    this.stop = void 0;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  inRange(mouseX, mouseY, useFinalPosition) {\n    const options = this.options;\n    const {\n      x,\n      y\n    } = this.getProps([\"x\", \"y\"], useFinalPosition);\n    return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);\n  }\n  inXRange(mouseX, useFinalPosition) {\n    return inRange$1(this, mouseX, \"x\", useFinalPosition);\n  }\n  inYRange(mouseY, useFinalPosition) {\n    return inRange$1(this, mouseY, \"y\", useFinalPosition);\n  }\n  getCenterPoint(useFinalPosition) {\n    const {\n      x,\n      y\n    } = this.getProps([\"x\", \"y\"], useFinalPosition);\n    return {\n      x,\n      y\n    };\n  }\n  size(options) {\n    options = options || this.options || {};\n    let radius = options.radius || 0;\n    radius = Math.max(radius, radius && options.hoverRadius || 0);\n    const borderWidth = radius && options.borderWidth || 0;\n    return (radius + borderWidth) * 2;\n  }\n  draw(ctx, area) {\n    const options = this.options;\n    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {\n      return;\n    }\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.fillStyle = options.backgroundColor;\n    drawPoint(ctx, options, this.x, this.y);\n  }\n  getRange() {\n    const options = this.options || {};\n    return options.radius + options.hitRadius;\n  }\n};\nfunction getBarBounds(bar, useFinalPosition) {\n  const {\n    x,\n    y,\n    base,\n    width,\n    height\n  } = bar.getProps([\"x\", \"y\", \"base\", \"width\", \"height\"], useFinalPosition);\n  let left, right, top, bottom, half;\n  if (bar.horizontal) {\n    half = height / 2;\n    left = Math.min(x, base);\n    right = Math.max(x, base);\n    top = y - half;\n    bottom = y + half;\n  } else {\n    half = width / 2;\n    left = x - half;\n    right = x + half;\n    top = Math.min(y, base);\n    bottom = Math.max(y, base);\n  }\n  return {\n    left,\n    top,\n    right,\n    bottom\n  };\n}\nfunction skipOrLimit(skip2, value, min, max) {\n  return skip2 ? 0 : _limitValue(value, min, max);\n}\nfunction parseBorderWidth(bar, maxW, maxH) {\n  const value = bar.options.borderWidth;\n  const skip2 = bar.borderSkipped;\n  const o = toTRBL(value);\n  return {\n    t: skipOrLimit(skip2.top, o.top, 0, maxH),\n    r: skipOrLimit(skip2.right, o.right, 0, maxW),\n    b: skipOrLimit(skip2.bottom, o.bottom, 0, maxH),\n    l: skipOrLimit(skip2.left, o.left, 0, maxW)\n  };\n}\nfunction parseBorderRadius(bar, maxW, maxH) {\n  const {\n    enableBorderRadius\n  } = bar.getProps([\"enableBorderRadius\"]);\n  const value = bar.options.borderRadius;\n  const o = toTRBLCorners(value);\n  const maxR = Math.min(maxW, maxH);\n  const skip2 = bar.borderSkipped;\n  const enableBorder = enableBorderRadius || isObject(value);\n  return {\n    topLeft: skipOrLimit(!enableBorder || skip2.top || skip2.left, o.topLeft, 0, maxR),\n    topRight: skipOrLimit(!enableBorder || skip2.top || skip2.right, o.topRight, 0, maxR),\n    bottomLeft: skipOrLimit(!enableBorder || skip2.bottom || skip2.left, o.bottomLeft, 0, maxR),\n    bottomRight: skipOrLimit(!enableBorder || skip2.bottom || skip2.right, o.bottomRight, 0, maxR)\n  };\n}\nfunction boundingRects(bar) {\n  const bounds = getBarBounds(bar);\n  const width = bounds.right - bounds.left;\n  const height = bounds.bottom - bounds.top;\n  const border = parseBorderWidth(bar, width / 2, height / 2);\n  const radius = parseBorderRadius(bar, width / 2, height / 2);\n  return {\n    outer: {\n      x: bounds.left,\n      y: bounds.top,\n      w: width,\n      h: height,\n      radius\n    },\n    inner: {\n      x: bounds.left + border.l,\n      y: bounds.top + border.t,\n      w: width - border.l - border.r,\n      h: height - border.t - border.b,\n      radius: {\n        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))\n      }\n    }\n  };\n}\nfunction inRange(bar, x, y, useFinalPosition) {\n  const skipX = x === null;\n  const skipY = y === null;\n  const skipBoth = skipX && skipY;\n  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n  return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));\n}\nfunction hasRadius(radius) {\n  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\nfunction addNormalRectPath(ctx, rect) {\n  ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\nfunction inflateRect(rect, amount, refRect = {}) {\n  const x = rect.x !== refRect.x ? -amount : 0;\n  const y = rect.y !== refRect.y ? -amount : 0;\n  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n  return {\n    x: rect.x + x,\n    y: rect.y + y,\n    w: rect.w + w,\n    h: rect.h + h,\n    radius: rect.radius\n  };\n}\nvar BarElement = class extends Element {\n  static id = \"bar\";\n  static defaults = {\n    borderSkipped: \"start\",\n    borderWidth: 0,\n    borderRadius: 0,\n    inflateAmount: \"auto\",\n    pointStyle: void 0\n  };\n  static defaultRoutes = {\n    backgroundColor: \"backgroundColor\",\n    borderColor: \"borderColor\"\n  };\n  constructor(cfg) {\n    super();\n    this.options = void 0;\n    this.horizontal = void 0;\n    this.base = void 0;\n    this.width = void 0;\n    this.height = void 0;\n    this.inflateAmount = void 0;\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n  draw(ctx) {\n    const {\n      inflateAmount,\n      options: {\n        borderColor,\n        backgroundColor\n      }\n    } = this;\n    const {\n      inner,\n      outer\n    } = boundingRects(this);\n    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\n    ctx.save();\n    if (outer.w !== inner.w || outer.h !== inner.h) {\n      ctx.beginPath();\n      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n      ctx.clip();\n      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n      ctx.fillStyle = borderColor;\n      ctx.fill(\"evenodd\");\n    }\n    ctx.beginPath();\n    addRectPath(ctx, inflateRect(inner, inflateAmount));\n    ctx.fillStyle = backgroundColor;\n    ctx.fill();\n    ctx.restore();\n  }\n  inRange(mouseX, mouseY, useFinalPosition) {\n    return inRange(this, mouseX, mouseY, useFinalPosition);\n  }\n  inXRange(mouseX, useFinalPosition) {\n    return inRange(this, mouseX, null, useFinalPosition);\n  }\n  inYRange(mouseY, useFinalPosition) {\n    return inRange(this, null, mouseY, useFinalPosition);\n  }\n  getCenterPoint(useFinalPosition) {\n    const {\n      x,\n      y,\n      base,\n      horizontal\n    } = this.getProps([\"x\", \"y\", \"base\", \"horizontal\"], useFinalPosition);\n    return {\n      x: horizontal ? (x + base) / 2 : x,\n      y: horizontal ? y : (y + base) / 2\n    };\n  }\n  getRange(axis) {\n    return axis === \"x\" ? this.width / 2 : this.height / 2;\n  }\n};\nvar elements = Object.freeze({\n  __proto__: null,\n  ArcElement,\n  BarElement,\n  LineElement,\n  PointElement\n});\nvar BORDER_COLORS = [\n  \"rgb(54, 162, 235)\",\n  \"rgb(255, 99, 132)\",\n  \"rgb(255, 159, 64)\",\n  \"rgb(255, 205, 86)\",\n  \"rgb(75, 192, 192)\",\n  \"rgb(153, 102, 255)\",\n  \"rgb(201, 203, 207)\"\n  // grey\n];\nvar BACKGROUND_COLORS = BORDER_COLORS.map((color2) => color2.replace(\"rgb(\", \"rgba(\").replace(\")\", \", 0.5)\"));\nfunction getBorderColor(i) {\n  return BORDER_COLORS[i % BORDER_COLORS.length];\n}\nfunction getBackgroundColor(i) {\n  return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];\n}\nfunction colorizeDefaultDataset(dataset, i) {\n  dataset.borderColor = getBorderColor(i);\n  dataset.backgroundColor = getBackgroundColor(i);\n  return ++i;\n}\nfunction colorizeDoughnutDataset(dataset, i) {\n  dataset.backgroundColor = dataset.data.map(() => getBorderColor(i++));\n  return i;\n}\nfunction colorizePolarAreaDataset(dataset, i) {\n  dataset.backgroundColor = dataset.data.map(() => getBackgroundColor(i++));\n  return i;\n}\nfunction getColorizer(chart) {\n  let i = 0;\n  return (dataset, datasetIndex) => {\n    const controller = chart.getDatasetMeta(datasetIndex).controller;\n    if (controller instanceof DoughnutController) {\n      i = colorizeDoughnutDataset(dataset, i);\n    } else if (controller instanceof PolarAreaController) {\n      i = colorizePolarAreaDataset(dataset, i);\n    } else if (controller) {\n      i = colorizeDefaultDataset(dataset, i);\n    }\n  };\n}\nfunction containsColorsDefinitions(descriptors2) {\n  let k;\n  for (k in descriptors2) {\n    if (descriptors2[k].borderColor || descriptors2[k].backgroundColor) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction containsColorsDefinition(descriptor) {\n  return descriptor && (descriptor.borderColor || descriptor.backgroundColor);\n}\nfunction containsDefaultColorsDefenitions() {\n  return defaults.borderColor !== \"rgba(0,0,0,0.1)\" || defaults.backgroundColor !== \"rgba(0,0,0,0.1)\";\n}\nvar plugin_colors = {\n  id: \"colors\",\n  defaults: {\n    enabled: true,\n    forceOverride: false\n  },\n  beforeLayout(chart, _args, options) {\n    if (!options.enabled) {\n      return;\n    }\n    const {\n      data: {\n        datasets\n      },\n      options: chartOptions\n    } = chart.config;\n    const {\n      elements: elements2\n    } = chartOptions;\n    const containsColorDefenition = containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements2 && containsColorsDefinitions(elements2) || containsDefaultColorsDefenitions();\n    if (!options.forceOverride && containsColorDefenition) {\n      return;\n    }\n    const colorizer = getColorizer(chart);\n    datasets.forEach(colorizer);\n  }\n};\nfunction lttbDecimation(data, start, count, availableWidth, options) {\n  const samples = options.samples || availableWidth;\n  if (samples >= count) {\n    return data.slice(start, start + count);\n  }\n  const decimated = [];\n  const bucketWidth = (count - 2) / (samples - 2);\n  let sampledIndex = 0;\n  const endIndex = start + count - 1;\n  let a = start;\n  let i, maxAreaPoint, maxArea, area, nextA;\n  decimated[sampledIndex++] = data[a];\n  for (i = 0; i < samples - 2; i++) {\n    let avgX = 0;\n    let avgY = 0;\n    let j;\n    const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;\n    const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;\n    const avgRangeLength = avgRangeEnd - avgRangeStart;\n    for (j = avgRangeStart; j < avgRangeEnd; j++) {\n      avgX += data[j].x;\n      avgY += data[j].y;\n    }\n    avgX /= avgRangeLength;\n    avgY /= avgRangeLength;\n    const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;\n    const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;\n    const {\n      x: pointAx,\n      y: pointAy\n    } = data[a];\n    maxArea = area = -1;\n    for (j = rangeOffs; j < rangeTo; j++) {\n      area = 0.5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));\n      if (area > maxArea) {\n        maxArea = area;\n        maxAreaPoint = data[j];\n        nextA = j;\n      }\n    }\n    decimated[sampledIndex++] = maxAreaPoint;\n    a = nextA;\n  }\n  decimated[sampledIndex++] = data[endIndex];\n  return decimated;\n}\nfunction minMaxDecimation(data, start, count, availableWidth) {\n  let avgX = 0;\n  let countX = 0;\n  let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;\n  const decimated = [];\n  const endIndex = start + count - 1;\n  const xMin = data[start].x;\n  const xMax = data[endIndex].x;\n  const dx = xMax - xMin;\n  for (i = start; i < start + count; ++i) {\n    point = data[i];\n    x = (point.x - xMin) / dx * availableWidth;\n    y = point.y;\n    const truncX = x | 0;\n    if (truncX === prevX) {\n      if (y < minY) {\n        minY = y;\n        minIndex = i;\n      } else if (y > maxY) {\n        maxY = y;\n        maxIndex = i;\n      }\n      avgX = (countX * avgX + point.x) / ++countX;\n    } else {\n      const lastIndex = i - 1;\n      if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {\n        const intermediateIndex1 = Math.min(minIndex, maxIndex);\n        const intermediateIndex2 = Math.max(minIndex, maxIndex);\n        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) {\n          decimated.push(__spreadProps(__spreadValues({}, data[intermediateIndex1]), {\n            x: avgX\n          }));\n        }\n        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) {\n          decimated.push(__spreadProps(__spreadValues({}, data[intermediateIndex2]), {\n            x: avgX\n          }));\n        }\n      }\n      if (i > 0 && lastIndex !== startIndex) {\n        decimated.push(data[lastIndex]);\n      }\n      decimated.push(point);\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n      minIndex = maxIndex = startIndex = i;\n    }\n  }\n  return decimated;\n}\nfunction cleanDecimatedDataset(dataset) {\n  if (dataset._decimated) {\n    const data = dataset._data;\n    delete dataset._decimated;\n    delete dataset._data;\n    Object.defineProperty(dataset, \"data\", {\n      configurable: true,\n      enumerable: true,\n      writable: true,\n      value: data\n    });\n  }\n}\nfunction cleanDecimatedData(chart) {\n  chart.data.datasets.forEach((dataset) => {\n    cleanDecimatedDataset(dataset);\n  });\n}\nfunction getStartAndCountOfVisiblePointsSimplified(meta, points) {\n  const pointCount = points.length;\n  let start = 0;\n  let count;\n  const {\n    iScale\n  } = meta;\n  const {\n    min,\n    max,\n    minDefined,\n    maxDefined\n  } = iScale.getUserBounds();\n  if (minDefined) {\n    start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);\n  }\n  if (maxDefined) {\n    count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start;\n  } else {\n    count = pointCount - start;\n  }\n  return {\n    start,\n    count\n  };\n}\nvar plugin_decimation = {\n  id: \"decimation\",\n  defaults: {\n    algorithm: \"min-max\",\n    enabled: false\n  },\n  beforeElementsUpdate: (chart, args, options) => {\n    if (!options.enabled) {\n      cleanDecimatedData(chart);\n      return;\n    }\n    const availableWidth = chart.width;\n    chart.data.datasets.forEach((dataset, datasetIndex) => {\n      const {\n        _data,\n        indexAxis\n      } = dataset;\n      const meta = chart.getDatasetMeta(datasetIndex);\n      const data = _data || dataset.data;\n      if (resolve([indexAxis, chart.options.indexAxis]) === \"y\") {\n        return;\n      }\n      if (!meta.controller.supportsDecimation) {\n        return;\n      }\n      const xAxis = chart.scales[meta.xAxisID];\n      if (xAxis.type !== \"linear\" && xAxis.type !== \"time\") {\n        return;\n      }\n      if (chart.options.parsing) {\n        return;\n      }\n      let {\n        start,\n        count\n      } = getStartAndCountOfVisiblePointsSimplified(meta, data);\n      const threshold = options.threshold || 4 * availableWidth;\n      if (count <= threshold) {\n        cleanDecimatedDataset(dataset);\n        return;\n      }\n      if (isNullOrUndef(_data)) {\n        dataset._data = data;\n        delete dataset.data;\n        Object.defineProperty(dataset, \"data\", {\n          configurable: true,\n          enumerable: true,\n          get: function() {\n            return this._decimated;\n          },\n          set: function(d) {\n            this._data = d;\n          }\n        });\n      }\n      let decimated;\n      switch (options.algorithm) {\n        case \"lttb\":\n          decimated = lttbDecimation(data, start, count, availableWidth, options);\n          break;\n        case \"min-max\":\n          decimated = minMaxDecimation(data, start, count, availableWidth);\n          break;\n        default:\n          throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);\n      }\n      dataset._decimated = decimated;\n    });\n  },\n  destroy(chart) {\n    cleanDecimatedData(chart);\n  }\n};\nfunction _segments(line, target, property) {\n  const segments = line.segments;\n  const points = line.points;\n  const tpoints = target.points;\n  const parts = [];\n  for (const segment of segments) {\n    let {\n      start,\n      end\n    } = segment;\n    end = _findSegmentEnd(start, end, points);\n    const bounds = _getBounds(property, points[start], points[end], segment.loop);\n    if (!target.segments) {\n      parts.push({\n        source: segment,\n        target: bounds,\n        start: points[start],\n        end: points[end]\n      });\n      continue;\n    }\n    const targetSegments = _boundSegments(target, bounds);\n    for (const tgt of targetSegments) {\n      const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);\n      const fillSources = _boundSegment(segment, points, subBounds);\n      for (const fillSource of fillSources) {\n        parts.push({\n          source: fillSource,\n          target: tgt,\n          start: {\n            [property]: _getEdge(bounds, subBounds, \"start\", Math.max)\n          },\n          end: {\n            [property]: _getEdge(bounds, subBounds, \"end\", Math.min)\n          }\n        });\n      }\n    }\n  }\n  return parts;\n}\nfunction _getBounds(property, first, last, loop) {\n  if (loop) {\n    return;\n  }\n  let start = first[property];\n  let end = last[property];\n  if (property === \"angle\") {\n    start = _normalizeAngle(start);\n    end = _normalizeAngle(end);\n  }\n  return {\n    property,\n    start,\n    end\n  };\n}\nfunction _pointsFromSegments(boundary, line) {\n  const {\n    x = null,\n    y = null\n  } = boundary || {};\n  const linePoints = line.points;\n  const points = [];\n  line.segments.forEach(({\n    start,\n    end\n  }) => {\n    end = _findSegmentEnd(start, end, linePoints);\n    const first = linePoints[start];\n    const last = linePoints[end];\n    if (y !== null) {\n      points.push({\n        x: first.x,\n        y\n      });\n      points.push({\n        x: last.x,\n        y\n      });\n    } else if (x !== null) {\n      points.push({\n        x,\n        y: first.y\n      });\n      points.push({\n        x,\n        y: last.y\n      });\n    }\n  });\n  return points;\n}\nfunction _findSegmentEnd(start, end, points) {\n  for (; end > start; end--) {\n    const point = points[end];\n    if (!isNaN(point.x) && !isNaN(point.y)) {\n      break;\n    }\n  }\n  return end;\n}\nfunction _getEdge(a, b, prop, fn) {\n  if (a && b) {\n    return fn(a[prop], b[prop]);\n  }\n  return a ? a[prop] : b ? b[prop] : 0;\n}\nfunction _createBoundaryLine(boundary, line) {\n  let points = [];\n  let _loop = false;\n  if (isArray(boundary)) {\n    _loop = true;\n    points = boundary;\n  } else {\n    points = _pointsFromSegments(boundary, line);\n  }\n  return points.length ? new LineElement({\n    points,\n    options: {\n      tension: 0\n    },\n    _loop,\n    _fullLoop: _loop\n  }) : null;\n}\nfunction _shouldApplyFill(source) {\n  return source && source.fill !== false;\n}\nfunction _resolveTarget(sources, index2, propagate) {\n  const source = sources[index2];\n  let fill2 = source.fill;\n  const visited = [index2];\n  let target;\n  if (!propagate) {\n    return fill2;\n  }\n  while (fill2 !== false && visited.indexOf(fill2) === -1) {\n    if (!isNumberFinite(fill2)) {\n      return fill2;\n    }\n    target = sources[fill2];\n    if (!target) {\n      return false;\n    }\n    if (target.visible) {\n      return fill2;\n    }\n    visited.push(fill2);\n    fill2 = target.fill;\n  }\n  return false;\n}\nfunction _decodeFill(line, index2, count) {\n  const fill2 = parseFillOption(line);\n  if (isObject(fill2)) {\n    return isNaN(fill2.value) ? false : fill2;\n  }\n  let target = parseFloat(fill2);\n  if (isNumberFinite(target) && Math.floor(target) === target) {\n    return decodeTargetIndex(fill2[0], index2, target, count);\n  }\n  return [\"origin\", \"start\", \"end\", \"stack\", \"shape\"].indexOf(fill2) >= 0 && fill2;\n}\nfunction decodeTargetIndex(firstCh, index2, target, count) {\n  if (firstCh === \"-\" || firstCh === \"+\") {\n    target = index2 + target;\n  }\n  if (target === index2 || target < 0 || target >= count) {\n    return false;\n  }\n  return target;\n}\nfunction _getTargetPixel(fill2, scale) {\n  let pixel = null;\n  if (fill2 === \"start\") {\n    pixel = scale.bottom;\n  } else if (fill2 === \"end\") {\n    pixel = scale.top;\n  } else if (isObject(fill2)) {\n    pixel = scale.getPixelForValue(fill2.value);\n  } else if (scale.getBasePixel) {\n    pixel = scale.getBasePixel();\n  }\n  return pixel;\n}\nfunction _getTargetValue(fill2, scale, startValue) {\n  let value;\n  if (fill2 === \"start\") {\n    value = startValue;\n  } else if (fill2 === \"end\") {\n    value = scale.options.reverse ? scale.min : scale.max;\n  } else if (isObject(fill2)) {\n    value = fill2.value;\n  } else {\n    value = scale.getBaseValue();\n  }\n  return value;\n}\nfunction parseFillOption(line) {\n  const options = line.options;\n  const fillOption = options.fill;\n  let fill2 = valueOrDefault(fillOption && fillOption.target, fillOption);\n  if (fill2 === void 0) {\n    fill2 = !!options.backgroundColor;\n  }\n  if (fill2 === false || fill2 === null) {\n    return false;\n  }\n  if (fill2 === true) {\n    return \"origin\";\n  }\n  return fill2;\n}\nfunction _buildStackLine(source) {\n  const {\n    scale,\n    index: index2,\n    line\n  } = source;\n  const points = [];\n  const segments = line.segments;\n  const sourcePoints = line.points;\n  const linesBelow = getLinesBelow(scale, index2);\n  linesBelow.push(_createBoundaryLine({\n    x: null,\n    y: scale.bottom\n  }, line));\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    for (let j = segment.start; j <= segment.end; j++) {\n      addPointsBelow(points, sourcePoints[j], linesBelow);\n    }\n  }\n  return new LineElement({\n    points,\n    options: {}\n  });\n}\nfunction getLinesBelow(scale, index2) {\n  const below = [];\n  const metas = scale.getMatchingVisibleMetas(\"line\");\n  for (let i = 0; i < metas.length; i++) {\n    const meta = metas[i];\n    if (meta.index === index2) {\n      break;\n    }\n    if (!meta.hidden) {\n      below.unshift(meta.dataset);\n    }\n  }\n  return below;\n}\nfunction addPointsBelow(points, sourcePoint, linesBelow) {\n  const postponed = [];\n  for (let j = 0; j < linesBelow.length; j++) {\n    const line = linesBelow[j];\n    const {\n      first,\n      last,\n      point\n    } = findPoint(line, sourcePoint, \"x\");\n    if (!point || first && last) {\n      continue;\n    }\n    if (first) {\n      postponed.unshift(point);\n    } else {\n      points.push(point);\n      if (!last) {\n        break;\n      }\n    }\n  }\n  points.push(...postponed);\n}\nfunction findPoint(line, sourcePoint, property) {\n  const point = line.interpolate(sourcePoint, property);\n  if (!point) {\n    return {};\n  }\n  const pointValue = point[property];\n  const segments = line.segments;\n  const linePoints = line.points;\n  let first = false;\n  let last = false;\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    const firstValue = linePoints[segment.start][property];\n    const lastValue = linePoints[segment.end][property];\n    if (_isBetween(pointValue, firstValue, lastValue)) {\n      first = pointValue === firstValue;\n      last = pointValue === lastValue;\n      break;\n    }\n  }\n  return {\n    first,\n    last,\n    point\n  };\n}\nvar simpleArc = class {\n  constructor(opts) {\n    this.x = opts.x;\n    this.y = opts.y;\n    this.radius = opts.radius;\n  }\n  pathSegment(ctx, bounds, opts) {\n    const {\n      x,\n      y,\n      radius\n    } = this;\n    bounds = bounds || {\n      start: 0,\n      end: TAU\n    };\n    ctx.arc(x, y, radius, bounds.end, bounds.start, true);\n    return !opts.bounds;\n  }\n  interpolate(point) {\n    const {\n      x,\n      y,\n      radius\n    } = this;\n    const angle = point.angle;\n    return {\n      x: x + Math.cos(angle) * radius,\n      y: y + Math.sin(angle) * radius,\n      angle\n    };\n  }\n};\nfunction _getTarget(source) {\n  const {\n    chart,\n    fill: fill2,\n    line\n  } = source;\n  if (isNumberFinite(fill2)) {\n    return getLineByIndex(chart, fill2);\n  }\n  if (fill2 === \"stack\") {\n    return _buildStackLine(source);\n  }\n  if (fill2 === \"shape\") {\n    return true;\n  }\n  const boundary = computeBoundary(source);\n  if (boundary instanceof simpleArc) {\n    return boundary;\n  }\n  return _createBoundaryLine(boundary, line);\n}\nfunction getLineByIndex(chart, index2) {\n  const meta = chart.getDatasetMeta(index2);\n  const visible = meta && chart.isDatasetVisible(index2);\n  return visible ? meta.dataset : null;\n}\nfunction computeBoundary(source) {\n  const scale = source.scale || {};\n  if (scale.getPointPositionForValue) {\n    return computeCircularBoundary(source);\n  }\n  return computeLinearBoundary(source);\n}\nfunction computeLinearBoundary(source) {\n  const {\n    scale = {},\n    fill: fill2\n  } = source;\n  const pixel = _getTargetPixel(fill2, scale);\n  if (isNumberFinite(pixel)) {\n    const horizontal = scale.isHorizontal();\n    return {\n      x: horizontal ? pixel : null,\n      y: horizontal ? null : pixel\n    };\n  }\n  return null;\n}\nfunction computeCircularBoundary(source) {\n  const {\n    scale,\n    fill: fill2\n  } = source;\n  const options = scale.options;\n  const length = scale.getLabels().length;\n  const start = options.reverse ? scale.max : scale.min;\n  const value = _getTargetValue(fill2, scale, start);\n  const target = [];\n  if (options.grid.circular) {\n    const center = scale.getPointPositionForValue(0, start);\n    return new simpleArc({\n      x: center.x,\n      y: center.y,\n      radius: scale.getDistanceFromCenterForValue(value)\n    });\n  }\n  for (let i = 0; i < length; ++i) {\n    target.push(scale.getPointPositionForValue(i, value));\n  }\n  return target;\n}\nfunction _drawfill(ctx, source, area) {\n  const target = _getTarget(source);\n  const {\n    line,\n    scale,\n    axis\n  } = source;\n  const lineOpts = line.options;\n  const fillOption = lineOpts.fill;\n  const color2 = lineOpts.backgroundColor;\n  const {\n    above = color2,\n    below = color2\n  } = fillOption || {};\n  if (target && line.points.length) {\n    clipArea(ctx, area);\n    doFill(ctx, {\n      line,\n      target,\n      above,\n      below,\n      area,\n      scale,\n      axis\n    });\n    unclipArea(ctx);\n  }\n}\nfunction doFill(ctx, cfg) {\n  const {\n    line,\n    target,\n    above,\n    below,\n    area,\n    scale\n  } = cfg;\n  const property = line._loop ? \"angle\" : cfg.axis;\n  ctx.save();\n  if (property === \"x\" && below !== above) {\n    clipVertical(ctx, target, area.top);\n    fill(ctx, {\n      line,\n      target,\n      color: above,\n      scale,\n      property\n    });\n    ctx.restore();\n    ctx.save();\n    clipVertical(ctx, target, area.bottom);\n  }\n  fill(ctx, {\n    line,\n    target,\n    color: below,\n    scale,\n    property\n  });\n  ctx.restore();\n}\nfunction clipVertical(ctx, target, clipY) {\n  const {\n    segments,\n    points\n  } = target;\n  let first = true;\n  let lineLoop = false;\n  ctx.beginPath();\n  for (const segment of segments) {\n    const {\n      start,\n      end\n    } = segment;\n    const firstPoint = points[start];\n    const lastPoint = points[_findSegmentEnd(start, end, points)];\n    if (first) {\n      ctx.moveTo(firstPoint.x, firstPoint.y);\n      first = false;\n    } else {\n      ctx.lineTo(firstPoint.x, clipY);\n      ctx.lineTo(firstPoint.x, firstPoint.y);\n    }\n    lineLoop = !!target.pathSegment(ctx, segment, {\n      move: lineLoop\n    });\n    if (lineLoop) {\n      ctx.closePath();\n    } else {\n      ctx.lineTo(lastPoint.x, clipY);\n    }\n  }\n  ctx.lineTo(target.first().x, clipY);\n  ctx.closePath();\n  ctx.clip();\n}\nfunction fill(ctx, cfg) {\n  const {\n    line,\n    target,\n    property,\n    color: color2,\n    scale\n  } = cfg;\n  const segments = _segments(line, target, property);\n  for (const {\n    source: src,\n    target: tgt,\n    start,\n    end\n  } of segments) {\n    const {\n      style: {\n        backgroundColor = color2\n      } = {}\n    } = src;\n    const notShape = target !== true;\n    ctx.save();\n    ctx.fillStyle = backgroundColor;\n    clipBounds(ctx, scale, notShape && _getBounds(property, start, end));\n    ctx.beginPath();\n    const lineLoop = !!line.pathSegment(ctx, src);\n    let loop;\n    if (notShape) {\n      if (lineLoop) {\n        ctx.closePath();\n      } else {\n        interpolatedLineTo(ctx, target, end, property);\n      }\n      const targetLoop = !!target.pathSegment(ctx, tgt, {\n        move: lineLoop,\n        reverse: true\n      });\n      loop = lineLoop && targetLoop;\n      if (!loop) {\n        interpolatedLineTo(ctx, target, start, property);\n      }\n    }\n    ctx.closePath();\n    ctx.fill(loop ? \"evenodd\" : \"nonzero\");\n    ctx.restore();\n  }\n}\nfunction clipBounds(ctx, scale, bounds) {\n  const {\n    top,\n    bottom\n  } = scale.chart.chartArea;\n  const {\n    property,\n    start,\n    end\n  } = bounds || {};\n  if (property === \"x\") {\n    ctx.beginPath();\n    ctx.rect(start, top, end - start, bottom - top);\n    ctx.clip();\n  }\n}\nfunction interpolatedLineTo(ctx, target, point, property) {\n  const interpolatedPoint = target.interpolate(point, property);\n  if (interpolatedPoint) {\n    ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);\n  }\n}\nvar index = {\n  id: \"filler\",\n  afterDatasetsUpdate(chart, _args, options) {\n    const count = (chart.data.datasets || []).length;\n    const sources = [];\n    let meta, i, line, source;\n    for (i = 0; i < count; ++i) {\n      meta = chart.getDatasetMeta(i);\n      line = meta.dataset;\n      source = null;\n      if (line && line.options && line instanceof LineElement) {\n        source = {\n          visible: chart.isDatasetVisible(i),\n          index: i,\n          fill: _decodeFill(line, i, count),\n          chart,\n          axis: meta.controller.options.indexAxis,\n          scale: meta.vScale,\n          line\n        };\n      }\n      meta.$filler = source;\n      sources.push(source);\n    }\n    for (i = 0; i < count; ++i) {\n      source = sources[i];\n      if (!source || source.fill === false) {\n        continue;\n      }\n      source.fill = _resolveTarget(sources, i, options.propagate);\n    }\n  },\n  beforeDraw(chart, _args, options) {\n    const draw2 = options.drawTime === \"beforeDraw\";\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    const area = chart.chartArea;\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n      if (!source) {\n        continue;\n      }\n      source.line.updateControlPoints(area, source.axis);\n      if (draw2 && source.fill) {\n        _drawfill(chart.ctx, source, area);\n      }\n    }\n  },\n  beforeDatasetsDraw(chart, _args, options) {\n    if (options.drawTime !== \"beforeDatasetsDraw\") {\n      return;\n    }\n    const metasets = chart.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      const source = metasets[i].$filler;\n      if (_shouldApplyFill(source)) {\n        _drawfill(chart.ctx, source, chart.chartArea);\n      }\n    }\n  },\n  beforeDatasetDraw(chart, args, options) {\n    const source = args.meta.$filler;\n    if (!_shouldApplyFill(source) || options.drawTime !== \"beforeDatasetDraw\") {\n      return;\n    }\n    _drawfill(chart.ctx, source, chart.chartArea);\n  },\n  defaults: {\n    propagate: true,\n    drawTime: \"beforeDatasetDraw\"\n  }\n};\nvar getBoxSize = (labelOpts, fontSize) => {\n  let {\n    boxHeight = fontSize,\n    boxWidth = fontSize\n  } = labelOpts;\n  if (labelOpts.usePointStyle) {\n    boxHeight = Math.min(boxHeight, fontSize);\n    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\n  }\n  return {\n    boxWidth,\n    boxHeight,\n    itemHeight: Math.max(fontSize, boxHeight)\n  };\n};\nvar itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\nvar Legend = class extends Element {\n  constructor(config) {\n    super();\n    this._added = false;\n    this.legendHitBoxes = [];\n    this._hoveredItem = null;\n    this.doughnutMode = false;\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this.legendItems = void 0;\n    this.columnSizes = void 0;\n    this.lineWidths = void 0;\n    this.maxHeight = void 0;\n    this.maxWidth = void 0;\n    this.top = void 0;\n    this.bottom = void 0;\n    this.left = void 0;\n    this.right = void 0;\n    this.height = void 0;\n    this.width = void 0;\n    this._margins = void 0;\n    this.position = void 0;\n    this.weight = void 0;\n    this.fullSize = void 0;\n  }\n  update(maxWidth, maxHeight, margins) {\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins;\n    this.setDimensions();\n    this.buildLabels();\n    this.fit();\n  }\n  setDimensions() {\n    if (this.isHorizontal()) {\n      this.width = this.maxWidth;\n      this.left = this._margins.left;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n      this.top = this._margins.top;\n      this.bottom = this.height;\n    }\n  }\n  buildLabels() {\n    const labelOpts = this.options.labels || {};\n    let legendItems = callback(labelOpts.generateLabels, [this.chart], this) || [];\n    if (labelOpts.filter) {\n      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));\n    }\n    if (labelOpts.sort) {\n      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));\n    }\n    if (this.options.reverse) {\n      legendItems.reverse();\n    }\n    this.legendItems = legendItems;\n  }\n  fit() {\n    const {\n      options,\n      ctx\n    } = this;\n    if (!options.display) {\n      this.width = this.height = 0;\n      return;\n    }\n    const labelOpts = options.labels;\n    const labelFont = toFont(labelOpts.font);\n    const fontSize = labelFont.size;\n    const titleHeight = this._computeTitleHeight();\n    const {\n      boxWidth,\n      itemHeight\n    } = getBoxSize(labelOpts, fontSize);\n    let width, height;\n    ctx.font = labelFont.string;\n    if (this.isHorizontal()) {\n      width = this.maxWidth;\n      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n    } else {\n      height = this.maxHeight;\n      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;\n    }\n    this.width = Math.min(width, options.maxWidth || this.maxWidth);\n    this.height = Math.min(height, options.maxHeight || this.maxHeight);\n  }\n  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n    const {\n      ctx,\n      maxWidth,\n      options: {\n        labels: {\n          padding\n        }\n      }\n    } = this;\n    const hitboxes = this.legendHitBoxes = [];\n    const lineWidths = this.lineWidths = [0];\n    const lineHeight = itemHeight + padding;\n    let totalHeight = titleHeight;\n    ctx.textAlign = \"left\";\n    ctx.textBaseline = \"middle\";\n    let row = -1;\n    let top = -lineHeight;\n    this.legendItems.forEach((legendItem, i) => {\n      const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n        totalHeight += lineHeight;\n        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n        top += lineHeight;\n        row++;\n      }\n      hitboxes[i] = {\n        left: 0,\n        top,\n        row,\n        width: itemWidth,\n        height: itemHeight\n      };\n      lineWidths[lineWidths.length - 1] += itemWidth + padding;\n    });\n    return totalHeight;\n  }\n  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {\n    const {\n      ctx,\n      maxHeight,\n      options: {\n        labels: {\n          padding\n        }\n      }\n    } = this;\n    const hitboxes = this.legendHitBoxes = [];\n    const columnSizes = this.columnSizes = [];\n    const heightLimit = maxHeight - titleHeight;\n    let totalWidth = padding;\n    let currentColWidth = 0;\n    let currentColHeight = 0;\n    let left = 0;\n    let col = 0;\n    this.legendItems.forEach((legendItem, i) => {\n      const {\n        itemWidth,\n        itemHeight\n      } = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);\n      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n        totalWidth += currentColWidth + padding;\n        columnSizes.push({\n          width: currentColWidth,\n          height: currentColHeight\n        });\n        left += currentColWidth + padding;\n        col++;\n        currentColWidth = currentColHeight = 0;\n      }\n      hitboxes[i] = {\n        left,\n        top: currentColHeight,\n        col,\n        width: itemWidth,\n        height: itemHeight\n      };\n      currentColWidth = Math.max(currentColWidth, itemWidth);\n      currentColHeight += itemHeight + padding;\n    });\n    totalWidth += currentColWidth;\n    columnSizes.push({\n      width: currentColWidth,\n      height: currentColHeight\n    });\n    return totalWidth;\n  }\n  adjustHitBoxes() {\n    if (!this.options.display) {\n      return;\n    }\n    const titleHeight = this._computeTitleHeight();\n    const {\n      legendHitBoxes: hitboxes,\n      options: {\n        align,\n        labels: {\n          padding\n        },\n        rtl\n      }\n    } = this;\n    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);\n    if (this.isHorizontal()) {\n      let row = 0;\n      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n      for (const hitbox of hitboxes) {\n        if (row !== hitbox.row) {\n          row = hitbox.row;\n          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n        }\n        hitbox.top += this.top + titleHeight + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n        left += hitbox.width + padding;\n      }\n    } else {\n      let col = 0;\n      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n      for (const hitbox of hitboxes) {\n        if (hitbox.col !== col) {\n          col = hitbox.col;\n          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n        }\n        hitbox.top = top;\n        hitbox.left += this.left + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n        top += hitbox.height + padding;\n      }\n    }\n  }\n  isHorizontal() {\n    return this.options.position === \"top\" || this.options.position === \"bottom\";\n  }\n  draw() {\n    if (this.options.display) {\n      const ctx = this.ctx;\n      clipArea(ctx, this);\n      this._draw();\n      unclipArea(ctx);\n    }\n  }\n  _draw() {\n    const {\n      options: opts,\n      columnSizes,\n      lineWidths,\n      ctx\n    } = this;\n    const {\n      align,\n      labels: labelOpts\n    } = opts;\n    const defaultColor = defaults.color;\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const labelFont = toFont(labelOpts.font);\n    const {\n      padding\n    } = labelOpts;\n    const fontSize = labelFont.size;\n    const halfFontSize = fontSize / 2;\n    let cursor;\n    this.drawTitle();\n    ctx.textAlign = rtlHelper.textAlign(\"left\");\n    ctx.textBaseline = \"middle\";\n    ctx.lineWidth = 0.5;\n    ctx.font = labelFont.string;\n    const {\n      boxWidth,\n      boxHeight,\n      itemHeight\n    } = getBoxSize(labelOpts, fontSize);\n    const drawLegendBox = function(x, y, legendItem) {\n      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n        return;\n      }\n      ctx.save();\n      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\n      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\n      ctx.lineCap = valueOrDefault(legendItem.lineCap, \"butt\");\n      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\n      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, \"miter\");\n      ctx.lineWidth = lineWidth;\n      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\n      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\n      if (labelOpts.usePointStyle) {\n        const drawOptions = {\n          radius: boxHeight * Math.SQRT2 / 2,\n          pointStyle: legendItem.pointStyle,\n          rotation: legendItem.rotation,\n          borderWidth: lineWidth\n        };\n        const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n        const centerY = y + halfFontSize;\n        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\n      } else {\n        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n        const borderRadius = toTRBLCorners(legendItem.borderRadius);\n        ctx.beginPath();\n        if (Object.values(borderRadius).some((v) => v !== 0)) {\n          addRoundedRectPath(ctx, {\n            x: xBoxLeft,\n            y: yBoxTop,\n            w: boxWidth,\n            h: boxHeight,\n            radius: borderRadius\n          });\n        } else {\n          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n        }\n        ctx.fill();\n        if (lineWidth !== 0) {\n          ctx.stroke();\n        }\n      }\n      ctx.restore();\n    };\n    const fillText = function(x, y, legendItem) {\n      renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {\n        strikethrough: legendItem.hidden,\n        textAlign: rtlHelper.textAlign(legendItem.textAlign)\n      });\n    };\n    const isHorizontal = this.isHorizontal();\n    const titleHeight = this._computeTitleHeight();\n    if (isHorizontal) {\n      cursor = {\n        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),\n        y: this.top + padding + titleHeight,\n        line: 0\n      };\n    } else {\n      cursor = {\n        x: this.left + padding,\n        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n        line: 0\n      };\n    }\n    overrideTextDirection(this.ctx, opts.textDirection);\n    const lineHeight = itemHeight + padding;\n    this.legendItems.forEach((legendItem, i) => {\n      ctx.strokeStyle = legendItem.fontColor;\n      ctx.fillStyle = legendItem.fontColor;\n      const textWidth = ctx.measureText(legendItem.text).width;\n      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n      const width = boxWidth + halfFontSize + textWidth;\n      let x = cursor.x;\n      let y = cursor.y;\n      rtlHelper.setWidth(this.width);\n      if (isHorizontal) {\n        if (i > 0 && x + width + padding > this.right) {\n          y = cursor.y += lineHeight;\n          cursor.line++;\n          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);\n        }\n      } else if (i > 0 && y + lineHeight > this.bottom) {\n        x = cursor.x = x + columnSizes[cursor.line].width + padding;\n        cursor.line++;\n        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n      }\n      const realX = rtlHelper.x(x);\n      drawLegendBox(realX, y, legendItem);\n      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n      fillText(rtlHelper.x(x), y, legendItem);\n      if (isHorizontal) {\n        cursor.x += width + padding;\n      } else if (typeof legendItem.text !== \"string\") {\n        const fontLineHeight = labelFont.lineHeight;\n        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;\n      } else {\n        cursor.y += lineHeight;\n      }\n    });\n    restoreTextDirection(this.ctx, opts.textDirection);\n  }\n  drawTitle() {\n    const opts = this.options;\n    const titleOpts = opts.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n    if (!titleOpts.display) {\n      return;\n    }\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const ctx = this.ctx;\n    const position = titleOpts.position;\n    const halfFontSize = titleFont.size / 2;\n    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n    let y;\n    let left = this.left;\n    let maxWidth = this.width;\n    if (this.isHorizontal()) {\n      maxWidth = Math.max(...this.lineWidths);\n      y = this.top + topPaddingPlusHalfFontSize;\n      left = _alignStartEnd(opts.align, left, this.right - maxWidth);\n    } else {\n      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);\n      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n    }\n    const x = _alignStartEnd(position, left, left + maxWidth);\n    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\n    ctx.textBaseline = \"middle\";\n    ctx.strokeStyle = titleOpts.color;\n    ctx.fillStyle = titleOpts.color;\n    ctx.font = titleFont.string;\n    renderText(ctx, titleOpts.text, x, y, titleFont);\n  }\n  _computeTitleHeight() {\n    const titleOpts = this.options.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n  }\n  _getLegendItemAt(x, y) {\n    let i, hitBox, lh;\n    if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {\n      lh = this.legendHitBoxes;\n      for (i = 0; i < lh.length; ++i) {\n        hitBox = lh[i];\n        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {\n          return this.legendItems[i];\n        }\n      }\n    }\n    return null;\n  }\n  handleEvent(e) {\n    const opts = this.options;\n    if (!isListened(e.type, opts)) {\n      return;\n    }\n    const hoveredItem = this._getLegendItemAt(e.x, e.y);\n    if (e.type === \"mousemove\" || e.type === \"mouseout\") {\n      const previous = this._hoveredItem;\n      const sameItem = itemsEqual(previous, hoveredItem);\n      if (previous && !sameItem) {\n        callback(opts.onLeave, [e, previous, this], this);\n      }\n      this._hoveredItem = hoveredItem;\n      if (hoveredItem && !sameItem) {\n        callback(opts.onHover, [e, hoveredItem, this], this);\n      }\n    } else if (hoveredItem) {\n      callback(opts.onClick, [e, hoveredItem, this], this);\n    }\n  }\n};\nfunction calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {\n  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);\n  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);\n  return {\n    itemWidth,\n    itemHeight\n  };\n}\nfunction calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {\n  let legendItemText = legendItem.text;\n  if (legendItemText && typeof legendItemText !== \"string\") {\n    legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);\n  }\n  return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;\n}\nfunction calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {\n  let itemHeight = _itemHeight;\n  if (typeof legendItem.text !== \"string\") {\n    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);\n  }\n  return itemHeight;\n}\nfunction calculateLegendItemHeight(legendItem, fontLineHeight) {\n  const labelHeight = legendItem.text ? legendItem.text.length : 0;\n  return fontLineHeight * labelHeight;\n}\nfunction isListened(type, opts) {\n  if ((type === \"mousemove\" || type === \"mouseout\") && (opts.onHover || opts.onLeave)) {\n    return true;\n  }\n  if (opts.onClick && (type === \"click\" || type === \"mouseup\")) {\n    return true;\n  }\n  return false;\n}\nvar plugin_legend = {\n  id: \"legend\",\n  _element: Legend,\n  start(chart, _args, options) {\n    const legend = chart.legend = new Legend({\n      ctx: chart.ctx,\n      options,\n      chart\n    });\n    layouts.configure(chart, legend, options);\n    layouts.addBox(chart, legend);\n  },\n  stop(chart) {\n    layouts.removeBox(chart, chart.legend);\n    delete chart.legend;\n  },\n  beforeUpdate(chart, _args, options) {\n    const legend = chart.legend;\n    layouts.configure(chart, legend, options);\n    legend.options = options;\n  },\n  afterUpdate(chart) {\n    const legend = chart.legend;\n    legend.buildLabels();\n    legend.adjustHitBoxes();\n  },\n  afterEvent(chart, args) {\n    if (!args.replay) {\n      chart.legend.handleEvent(args.event);\n    }\n  },\n  defaults: {\n    display: true,\n    position: \"top\",\n    align: \"center\",\n    fullSize: true,\n    reverse: false,\n    weight: 1e3,\n    onClick(e, legendItem, legend) {\n      const index2 = legendItem.datasetIndex;\n      const ci = legend.chart;\n      if (ci.isDatasetVisible(index2)) {\n        ci.hide(index2);\n        legendItem.hidden = true;\n      } else {\n        ci.show(index2);\n        legendItem.hidden = false;\n      }\n    },\n    onHover: null,\n    onLeave: null,\n    labels: {\n      color: (ctx) => ctx.chart.options.color,\n      boxWidth: 40,\n      padding: 10,\n      generateLabels(chart) {\n        const datasets = chart.data.datasets;\n        const {\n          labels: {\n            usePointStyle,\n            pointStyle,\n            textAlign,\n            color: color2,\n            useBorderRadius,\n            borderRadius\n          }\n        } = chart.legend.options;\n        return chart._getSortedDatasetMetas().map((meta) => {\n          const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);\n          const borderWidth = toPadding(style.borderWidth);\n          return {\n            text: datasets[meta.index].label,\n            fillStyle: style.backgroundColor,\n            fontColor: color2,\n            hidden: !meta.visible,\n            lineCap: style.borderCapStyle,\n            lineDash: style.borderDash,\n            lineDashOffset: style.borderDashOffset,\n            lineJoin: style.borderJoinStyle,\n            lineWidth: (borderWidth.width + borderWidth.height) / 4,\n            strokeStyle: style.borderColor,\n            pointStyle: pointStyle || style.pointStyle,\n            rotation: style.rotation,\n            textAlign: textAlign || style.textAlign,\n            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),\n            datasetIndex: meta.index\n          };\n        }, this);\n      }\n    },\n    title: {\n      color: (ctx) => ctx.chart.options.color,\n      display: false,\n      position: \"center\",\n      text: \"\"\n    }\n  },\n  descriptors: {\n    _scriptable: (name) => !name.startsWith(\"on\"),\n    labels: {\n      _scriptable: (name) => ![\"generateLabels\", \"filter\", \"sort\"].includes(name)\n    }\n  }\n};\nvar Title = class extends Element {\n  constructor(config) {\n    super();\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this._padding = void 0;\n    this.top = void 0;\n    this.bottom = void 0;\n    this.left = void 0;\n    this.right = void 0;\n    this.width = void 0;\n    this.height = void 0;\n    this.position = void 0;\n    this.weight = void 0;\n    this.fullSize = void 0;\n  }\n  update(maxWidth, maxHeight) {\n    const opts = this.options;\n    this.left = 0;\n    this.top = 0;\n    if (!opts.display) {\n      this.width = this.height = this.right = this.bottom = 0;\n      return;\n    }\n    this.width = this.right = maxWidth;\n    this.height = this.bottom = maxHeight;\n    const lineCount = isArray(opts.text) ? opts.text.length : 1;\n    this._padding = toPadding(opts.padding);\n    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;\n    if (this.isHorizontal()) {\n      this.height = textSize;\n    } else {\n      this.width = textSize;\n    }\n  }\n  isHorizontal() {\n    const pos = this.options.position;\n    return pos === \"top\" || pos === \"bottom\";\n  }\n  _drawArgs(offset) {\n    const {\n      top,\n      left,\n      bottom,\n      right,\n      options\n    } = this;\n    const align = options.align;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n    if (this.isHorizontal()) {\n      titleX = _alignStartEnd(align, left, right);\n      titleY = top + offset;\n      maxWidth = right - left;\n    } else {\n      if (options.position === \"left\") {\n        titleX = left + offset;\n        titleY = _alignStartEnd(align, bottom, top);\n        rotation = PI * -0.5;\n      } else {\n        titleX = right - offset;\n        titleY = _alignStartEnd(align, top, bottom);\n        rotation = PI * 0.5;\n      }\n      maxWidth = bottom - top;\n    }\n    return {\n      titleX,\n      titleY,\n      maxWidth,\n      rotation\n    };\n  }\n  draw() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    if (!opts.display) {\n      return;\n    }\n    const fontOpts = toFont(opts.font);\n    const lineHeight = fontOpts.lineHeight;\n    const offset = lineHeight / 2 + this._padding.top;\n    const {\n      titleX,\n      titleY,\n      maxWidth,\n      rotation\n    } = this._drawArgs(offset);\n    renderText(ctx, opts.text, 0, 0, fontOpts, {\n      color: opts.color,\n      maxWidth,\n      rotation,\n      textAlign: _toLeftRightCenter(opts.align),\n      textBaseline: \"middle\",\n      translation: [titleX, titleY]\n    });\n  }\n};\nfunction createTitle(chart, titleOpts) {\n  const title = new Title({\n    ctx: chart.ctx,\n    options: titleOpts,\n    chart\n  });\n  layouts.configure(chart, title, titleOpts);\n  layouts.addBox(chart, title);\n  chart.titleBlock = title;\n}\nvar plugin_title = {\n  id: \"title\",\n  _element: Title,\n  start(chart, _args, options) {\n    createTitle(chart, options);\n  },\n  stop(chart) {\n    const titleBlock = chart.titleBlock;\n    layouts.removeBox(chart, titleBlock);\n    delete chart.titleBlock;\n  },\n  beforeUpdate(chart, _args, options) {\n    const title = chart.titleBlock;\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n  defaults: {\n    align: \"center\",\n    display: false,\n    font: {\n      weight: \"bold\"\n    },\n    fullSize: true,\n    padding: 10,\n    position: \"top\",\n    text: \"\",\n    weight: 2e3\n  },\n  defaultRoutes: {\n    color: \"color\"\n  },\n  descriptors: {\n    _scriptable: true,\n    _indexable: false\n  }\n};\nvar map2 = /* @__PURE__ */ new WeakMap();\nvar plugin_subtitle = {\n  id: \"subtitle\",\n  start(chart, _args, options) {\n    const title = new Title({\n      ctx: chart.ctx,\n      options,\n      chart\n    });\n    layouts.configure(chart, title, options);\n    layouts.addBox(chart, title);\n    map2.set(chart, title);\n  },\n  stop(chart) {\n    layouts.removeBox(chart, map2.get(chart));\n    map2.delete(chart);\n  },\n  beforeUpdate(chart, _args, options) {\n    const title = map2.get(chart);\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n  defaults: {\n    align: \"center\",\n    display: false,\n    font: {\n      weight: \"normal\"\n    },\n    fullSize: true,\n    padding: 0,\n    position: \"top\",\n    text: \"\",\n    weight: 1500\n  },\n  defaultRoutes: {\n    color: \"color\"\n  },\n  descriptors: {\n    _scriptable: true,\n    _indexable: false\n  }\n};\nvar positioners = {\n  average(items) {\n    if (!items.length) {\n      return false;\n    }\n    let i, len;\n    let xSet = /* @__PURE__ */ new Set();\n    let y = 0;\n    let count = 0;\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const pos = el.tooltipPosition();\n        xSet.add(pos.x);\n        y += pos.y;\n        ++count;\n      }\n    }\n    if (count === 0 || xSet.size === 0) {\n      return false;\n    }\n    const xAverage = [...xSet].reduce((a, b) => a + b) / xSet.size;\n    return {\n      x: xAverage,\n      y: y / count\n    };\n  },\n  nearest(items, eventPosition) {\n    if (!items.length) {\n      return false;\n    }\n    let x = eventPosition.x;\n    let y = eventPosition.y;\n    let minDistance = Number.POSITIVE_INFINITY;\n    let i, len, nearestElement;\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const center = el.getCenterPoint();\n        const d = distanceBetweenPoints(eventPosition, center);\n        if (d < minDistance) {\n          minDistance = d;\n          nearestElement = el;\n        }\n      }\n    }\n    if (nearestElement) {\n      const tp = nearestElement.tooltipPosition();\n      x = tp.x;\n      y = tp.y;\n    }\n    return {\n      x,\n      y\n    };\n  }\n};\nfunction pushOrConcat(base, toPush) {\n  if (toPush) {\n    if (isArray(toPush)) {\n      Array.prototype.push.apply(base, toPush);\n    } else {\n      base.push(toPush);\n    }\n  }\n  return base;\n}\nfunction splitNewlines(str) {\n  if ((typeof str === \"string\" || str instanceof String) && str.indexOf(\"\\n\") > -1) {\n    return str.split(\"\\n\");\n  }\n  return str;\n}\nfunction createTooltipItem(chart, item) {\n  const {\n    element,\n    datasetIndex,\n    index: index2\n  } = item;\n  const controller = chart.getDatasetMeta(datasetIndex).controller;\n  const {\n    label,\n    value\n  } = controller.getLabelAndValue(index2);\n  return {\n    chart,\n    label,\n    parsed: controller.getParsed(index2),\n    raw: chart.data.datasets[datasetIndex].data[index2],\n    formattedValue: value,\n    dataset: controller.getDataset(),\n    dataIndex: index2,\n    datasetIndex,\n    element\n  };\n}\nfunction getTooltipSize(tooltip, options) {\n  const ctx = tooltip.chart.ctx;\n  const {\n    body,\n    footer,\n    title\n  } = tooltip;\n  const {\n    boxWidth,\n    boxHeight\n  } = options;\n  const bodyFont = toFont(options.bodyFont);\n  const titleFont = toFont(options.titleFont);\n  const footerFont = toFont(options.footerFont);\n  const titleLineCount = title.length;\n  const footerLineCount = footer.length;\n  const bodyLineItemCount = body.length;\n  const padding = toPadding(options.padding);\n  let height = padding.height;\n  let width = 0;\n  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n  if (titleLineCount) {\n    height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;\n  }\n  if (combinedBodyLength) {\n    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n    height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;\n  }\n  if (footerLineCount) {\n    height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;\n  }\n  let widthPadding = 0;\n  const maxLineWidth = function(line) {\n    width = Math.max(width, ctx.measureText(line).width + widthPadding);\n  };\n  ctx.save();\n  ctx.font = titleFont.string;\n  each(tooltip.title, maxLineWidth);\n  ctx.font = bodyFont.string;\n  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n  widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;\n  each(body, (bodyItem) => {\n    each(bodyItem.before, maxLineWidth);\n    each(bodyItem.lines, maxLineWidth);\n    each(bodyItem.after, maxLineWidth);\n  });\n  widthPadding = 0;\n  ctx.font = footerFont.string;\n  each(tooltip.footer, maxLineWidth);\n  ctx.restore();\n  width += padding.width;\n  return {\n    width,\n    height\n  };\n}\nfunction determineYAlign(chart, size) {\n  const {\n    y,\n    height\n  } = size;\n  if (y < height / 2) {\n    return \"top\";\n  } else if (y > chart.height - height / 2) {\n    return \"bottom\";\n  }\n  return \"center\";\n}\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n  const {\n    x,\n    width\n  } = size;\n  const caret = options.caretSize + options.caretPadding;\n  if (xAlign === \"left\" && x + width + caret > chart.width) {\n    return true;\n  }\n  if (xAlign === \"right\" && x - width - caret < 0) {\n    return true;\n  }\n}\nfunction determineXAlign(chart, options, size, yAlign) {\n  const {\n    x,\n    width\n  } = size;\n  const {\n    width: chartWidth,\n    chartArea: {\n      left,\n      right\n    }\n  } = chart;\n  let xAlign = \"center\";\n  if (yAlign === \"center\") {\n    xAlign = x <= (left + right) / 2 ? \"left\" : \"right\";\n  } else if (x <= width / 2) {\n    xAlign = \"left\";\n  } else if (x >= chartWidth - width / 2) {\n    xAlign = \"right\";\n  }\n  if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n    xAlign = \"center\";\n  }\n  return xAlign;\n}\nfunction determineAlignment(chart, options, size) {\n  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n  return {\n    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n    yAlign\n  };\n}\nfunction alignX(size, xAlign) {\n  let {\n    x,\n    width\n  } = size;\n  if (xAlign === \"right\") {\n    x -= width;\n  } else if (xAlign === \"center\") {\n    x -= width / 2;\n  }\n  return x;\n}\nfunction alignY(size, yAlign, paddingAndSize) {\n  let {\n    y,\n    height\n  } = size;\n  if (yAlign === \"top\") {\n    y += paddingAndSize;\n  } else if (yAlign === \"bottom\") {\n    y -= height + paddingAndSize;\n  } else {\n    y -= height / 2;\n  }\n  return y;\n}\nfunction getBackgroundPoint(options, size, alignment, chart) {\n  const {\n    caretSize,\n    caretPadding,\n    cornerRadius\n  } = options;\n  const {\n    xAlign,\n    yAlign\n  } = alignment;\n  const paddingAndSize = caretSize + caretPadding;\n  const {\n    topLeft,\n    topRight,\n    bottomLeft,\n    bottomRight\n  } = toTRBLCorners(cornerRadius);\n  let x = alignX(size, xAlign);\n  const y = alignY(size, yAlign, paddingAndSize);\n  if (yAlign === \"center\") {\n    if (xAlign === \"left\") {\n      x += paddingAndSize;\n    } else if (xAlign === \"right\") {\n      x -= paddingAndSize;\n    }\n  } else if (xAlign === \"left\") {\n    x -= Math.max(topLeft, bottomLeft) + caretSize;\n  } else if (xAlign === \"right\") {\n    x += Math.max(topRight, bottomRight) + caretSize;\n  }\n  return {\n    x: _limitValue(x, 0, chart.width - size.width),\n    y: _limitValue(y, 0, chart.height - size.height)\n  };\n}\nfunction getAlignedX(tooltip, align, options) {\n  const padding = toPadding(options.padding);\n  return align === \"center\" ? tooltip.x + tooltip.width / 2 : align === \"right\" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;\n}\nfunction getBeforeAfterBodyLines(callback2) {\n  return pushOrConcat([], splitNewlines(callback2));\n}\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n  return createContext(parent, {\n    tooltip,\n    tooltipItems,\n    type: \"tooltip\"\n  });\n}\nfunction overrideCallbacks(callbacks, context) {\n  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n  return override ? callbacks.override(override) : callbacks;\n}\nvar defaultCallbacks = {\n  beforeTitle: noop,\n  title(tooltipItems) {\n    if (tooltipItems.length > 0) {\n      const item = tooltipItems[0];\n      const labels = item.chart.data.labels;\n      const labelCount = labels ? labels.length : 0;\n      if (this && this.options && this.options.mode === \"dataset\") {\n        return item.dataset.label || \"\";\n      } else if (item.label) {\n        return item.label;\n      } else if (labelCount > 0 && item.dataIndex < labelCount) {\n        return labels[item.dataIndex];\n      }\n    }\n    return \"\";\n  },\n  afterTitle: noop,\n  beforeBody: noop,\n  beforeLabel: noop,\n  label(tooltipItem) {\n    if (this && this.options && this.options.mode === \"dataset\") {\n      return tooltipItem.label + \": \" + tooltipItem.formattedValue || tooltipItem.formattedValue;\n    }\n    let label = tooltipItem.dataset.label || \"\";\n    if (label) {\n      label += \": \";\n    }\n    const value = tooltipItem.formattedValue;\n    if (!isNullOrUndef(value)) {\n      label += value;\n    }\n    return label;\n  },\n  labelColor(tooltipItem) {\n    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n    const options = meta.controller.getStyle(tooltipItem.dataIndex);\n    return {\n      borderColor: options.borderColor,\n      backgroundColor: options.backgroundColor,\n      borderWidth: options.borderWidth,\n      borderDash: options.borderDash,\n      borderDashOffset: options.borderDashOffset,\n      borderRadius: 0\n    };\n  },\n  labelTextColor() {\n    return this.options.bodyColor;\n  },\n  labelPointStyle(tooltipItem) {\n    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n    const options = meta.controller.getStyle(tooltipItem.dataIndex);\n    return {\n      pointStyle: options.pointStyle,\n      rotation: options.rotation\n    };\n  },\n  afterLabel: noop,\n  afterBody: noop,\n  beforeFooter: noop,\n  footer: noop,\n  afterFooter: noop\n};\nfunction invokeCallbackWithFallback(callbacks, name, ctx, arg) {\n  const result = callbacks[name].call(ctx, arg);\n  if (typeof result === \"undefined\") {\n    return defaultCallbacks[name].call(ctx, arg);\n  }\n  return result;\n}\nvar Tooltip = class extends Element {\n  static positioners = positioners;\n  constructor(config) {\n    super();\n    this.opacity = 0;\n    this._active = [];\n    this._eventPosition = void 0;\n    this._size = void 0;\n    this._cachedAnimations = void 0;\n    this._tooltipItems = [];\n    this.$animations = void 0;\n    this.$context = void 0;\n    this.chart = config.chart;\n    this.options = config.options;\n    this.dataPoints = void 0;\n    this.title = void 0;\n    this.beforeBody = void 0;\n    this.body = void 0;\n    this.afterBody = void 0;\n    this.footer = void 0;\n    this.xAlign = void 0;\n    this.yAlign = void 0;\n    this.x = void 0;\n    this.y = void 0;\n    this.height = void 0;\n    this.width = void 0;\n    this.caretX = void 0;\n    this.caretY = void 0;\n    this.labelColors = void 0;\n    this.labelPointStyles = void 0;\n    this.labelTextColors = void 0;\n  }\n  initialize(options) {\n    this.options = options;\n    this._cachedAnimations = void 0;\n    this.$context = void 0;\n  }\n  _resolveAnimations() {\n    const cached = this._cachedAnimations;\n    if (cached) {\n      return cached;\n    }\n    const chart = this.chart;\n    const options = this.options.setContext(this.getContext());\n    const opts = options.enabled && chart.options.animation && options.animations;\n    const animations = new Animations(this.chart, opts);\n    if (opts._cacheable) {\n      this._cachedAnimations = Object.freeze(animations);\n    }\n    return animations;\n  }\n  getContext() {\n    return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n  }\n  getTitle(context, options) {\n    const {\n      callbacks\n    } = options;\n    const beforeTitle = invokeCallbackWithFallback(callbacks, \"beforeTitle\", this, context);\n    const title = invokeCallbackWithFallback(callbacks, \"title\", this, context);\n    const afterTitle = invokeCallbackWithFallback(callbacks, \"afterTitle\", this, context);\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n    lines = pushOrConcat(lines, splitNewlines(title));\n    lines = pushOrConcat(lines, splitNewlines(afterTitle));\n    return lines;\n  }\n  getBeforeBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, \"beforeBody\", this, tooltipItems));\n  }\n  getBody(tooltipItems, options) {\n    const {\n      callbacks\n    } = options;\n    const bodyItems = [];\n    each(tooltipItems, (context) => {\n      const bodyItem = {\n        before: [],\n        lines: [],\n        after: []\n      };\n      const scoped = overrideCallbacks(callbacks, context);\n      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, \"beforeLabel\", this, context)));\n      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, \"label\", this, context));\n      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, \"afterLabel\", this, context)));\n      bodyItems.push(bodyItem);\n    });\n    return bodyItems;\n  }\n  getAfterBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, \"afterBody\", this, tooltipItems));\n  }\n  getFooter(tooltipItems, options) {\n    const {\n      callbacks\n    } = options;\n    const beforeFooter = invokeCallbackWithFallback(callbacks, \"beforeFooter\", this, tooltipItems);\n    const footer = invokeCallbackWithFallback(callbacks, \"footer\", this, tooltipItems);\n    const afterFooter = invokeCallbackWithFallback(callbacks, \"afterFooter\", this, tooltipItems);\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n    lines = pushOrConcat(lines, splitNewlines(footer));\n    lines = pushOrConcat(lines, splitNewlines(afterFooter));\n    return lines;\n  }\n  _createItems(options) {\n    const active = this._active;\n    const data = this.chart.data;\n    const labelColors = [];\n    const labelPointStyles = [];\n    const labelTextColors = [];\n    let tooltipItems = [];\n    let i, len;\n    for (i = 0, len = active.length; i < len; ++i) {\n      tooltipItems.push(createTooltipItem(this.chart, active[i]));\n    }\n    if (options.filter) {\n      tooltipItems = tooltipItems.filter((element, index2, array) => options.filter(element, index2, array, data));\n    }\n    if (options.itemSort) {\n      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));\n    }\n    each(tooltipItems, (context) => {\n      const scoped = overrideCallbacks(options.callbacks, context);\n      labelColors.push(invokeCallbackWithFallback(scoped, \"labelColor\", this, context));\n      labelPointStyles.push(invokeCallbackWithFallback(scoped, \"labelPointStyle\", this, context));\n      labelTextColors.push(invokeCallbackWithFallback(scoped, \"labelTextColor\", this, context));\n    });\n    this.labelColors = labelColors;\n    this.labelPointStyles = labelPointStyles;\n    this.labelTextColors = labelTextColors;\n    this.dataPoints = tooltipItems;\n    return tooltipItems;\n  }\n  update(changed, replay) {\n    const options = this.options.setContext(this.getContext());\n    const active = this._active;\n    let properties;\n    let tooltipItems = [];\n    if (!active.length) {\n      if (this.opacity !== 0) {\n        properties = {\n          opacity: 0\n        };\n      }\n    } else {\n      const position = positioners[options.position].call(this, active, this._eventPosition);\n      tooltipItems = this._createItems(options);\n      this.title = this.getTitle(tooltipItems, options);\n      this.beforeBody = this.getBeforeBody(tooltipItems, options);\n      this.body = this.getBody(tooltipItems, options);\n      this.afterBody = this.getAfterBody(tooltipItems, options);\n      this.footer = this.getFooter(tooltipItems, options);\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, size);\n      const alignment = determineAlignment(this.chart, options, positionAndSize);\n      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n      this.xAlign = alignment.xAlign;\n      this.yAlign = alignment.yAlign;\n      properties = {\n        opacity: 1,\n        x: backgroundPoint.x,\n        y: backgroundPoint.y,\n        width: size.width,\n        height: size.height,\n        caretX: position.x,\n        caretY: position.y\n      };\n    }\n    this._tooltipItems = tooltipItems;\n    this.$context = void 0;\n    if (properties) {\n      this._resolveAnimations().update(this, properties);\n    }\n    if (changed && options.external) {\n      options.external.call(this, {\n        chart: this.chart,\n        tooltip: this,\n        replay\n      });\n    }\n  }\n  drawCaret(tooltipPoint, ctx, size, options) {\n    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n    ctx.lineTo(caretPosition.x1, caretPosition.y1);\n    ctx.lineTo(caretPosition.x2, caretPosition.y2);\n    ctx.lineTo(caretPosition.x3, caretPosition.y3);\n  }\n  getCaretPosition(tooltipPoint, size, options) {\n    const {\n      xAlign,\n      yAlign\n    } = this;\n    const {\n      caretSize,\n      cornerRadius\n    } = options;\n    const {\n      topLeft,\n      topRight,\n      bottomLeft,\n      bottomRight\n    } = toTRBLCorners(cornerRadius);\n    const {\n      x: ptX,\n      y: ptY\n    } = tooltipPoint;\n    const {\n      width,\n      height\n    } = size;\n    let x1, x2, x3, y1, y2, y3;\n    if (yAlign === \"center\") {\n      y2 = ptY + height / 2;\n      if (xAlign === \"left\") {\n        x1 = ptX;\n        x2 = x1 - caretSize;\n        y1 = y2 + caretSize;\n        y3 = y2 - caretSize;\n      } else {\n        x1 = ptX + width;\n        x2 = x1 + caretSize;\n        y1 = y2 - caretSize;\n        y3 = y2 + caretSize;\n      }\n      x3 = x1;\n    } else {\n      if (xAlign === \"left\") {\n        x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;\n      } else if (xAlign === \"right\") {\n        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n      } else {\n        x2 = this.caretX;\n      }\n      if (yAlign === \"top\") {\n        y1 = ptY;\n        y2 = y1 - caretSize;\n        x1 = x2 - caretSize;\n        x3 = x2 + caretSize;\n      } else {\n        y1 = ptY + height;\n        y2 = y1 + caretSize;\n        x1 = x2 + caretSize;\n        x3 = x2 - caretSize;\n      }\n      y3 = y1;\n    }\n    return {\n      x1,\n      x2,\n      x3,\n      y1,\n      y2,\n      y3\n    };\n  }\n  drawTitle(pt, ctx, options) {\n    const title = this.title;\n    const length = title.length;\n    let titleFont, titleSpacing, i;\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n      pt.x = getAlignedX(this, options.titleAlign, options);\n      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n      ctx.textBaseline = \"middle\";\n      titleFont = toFont(options.titleFont);\n      titleSpacing = options.titleSpacing;\n      ctx.fillStyle = options.titleColor;\n      ctx.font = titleFont.string;\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n        pt.y += titleFont.lineHeight + titleSpacing;\n        if (i + 1 === length) {\n          pt.y += options.titleMarginBottom - titleSpacing;\n        }\n      }\n    }\n  }\n  _drawColorBox(ctx, pt, i, rtlHelper, options) {\n    const labelColor = this.labelColors[i];\n    const labelPointStyle = this.labelPointStyles[i];\n    const {\n      boxHeight,\n      boxWidth\n    } = options;\n    const bodyFont = toFont(options.bodyFont);\n    const colorX = getAlignedX(this, \"left\", options);\n    const rtlColorX = rtlHelper.x(colorX);\n    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n    const colorY = pt.y + yOffSet;\n    if (options.usePointStyle) {\n      const drawOptions = {\n        radius: Math.min(boxWidth, boxHeight) / 2,\n        pointStyle: labelPointStyle.pointStyle,\n        rotation: labelPointStyle.rotation,\n        borderWidth: 1\n      };\n      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n      const centerY = colorY + boxHeight / 2;\n      ctx.strokeStyle = options.multiKeyBackground;\n      ctx.fillStyle = options.multiKeyBackground;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n      ctx.strokeStyle = labelColor.borderColor;\n      ctx.fillStyle = labelColor.backgroundColor;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n    } else {\n      ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;\n      ctx.strokeStyle = labelColor.borderColor;\n      ctx.setLineDash(labelColor.borderDash || []);\n      ctx.lineDashOffset = labelColor.borderDashOffset || 0;\n      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);\n      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);\n      const borderRadius = toTRBLCorners(labelColor.borderRadius);\n      if (Object.values(borderRadius).some((v) => v !== 0)) {\n        ctx.beginPath();\n        ctx.fillStyle = options.multiKeyBackground;\n        addRoundedRectPath(ctx, {\n          x: outerX,\n          y: colorY,\n          w: boxWidth,\n          h: boxHeight,\n          radius: borderRadius\n        });\n        ctx.fill();\n        ctx.stroke();\n        ctx.fillStyle = labelColor.backgroundColor;\n        ctx.beginPath();\n        addRoundedRectPath(ctx, {\n          x: innerX,\n          y: colorY + 1,\n          w: boxWidth - 2,\n          h: boxHeight - 2,\n          radius: borderRadius\n        });\n        ctx.fill();\n      } else {\n        ctx.fillStyle = options.multiKeyBackground;\n        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.fillStyle = labelColor.backgroundColor;\n        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n      }\n    }\n    ctx.fillStyle = this.labelTextColors[i];\n  }\n  drawBody(pt, ctx, options) {\n    const {\n      body\n    } = this;\n    const {\n      bodySpacing,\n      bodyAlign,\n      displayColors,\n      boxHeight,\n      boxWidth,\n      boxPadding\n    } = options;\n    const bodyFont = toFont(options.bodyFont);\n    let bodyLineHeight = bodyFont.lineHeight;\n    let xLinePadding = 0;\n    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n    const fillLineOfText = function(line) {\n      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n      pt.y += bodyLineHeight + bodySpacing;\n    };\n    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n    let bodyItem, textColor, lines, i, j, ilen, jlen;\n    ctx.textAlign = bodyAlign;\n    ctx.textBaseline = \"middle\";\n    ctx.font = bodyFont.string;\n    pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n    ctx.fillStyle = options.bodyColor;\n    each(this.beforeBody, fillLineOfText);\n    xLinePadding = displayColors && bodyAlignForCalculation !== \"right\" ? bodyAlign === \"center\" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;\n    for (i = 0, ilen = body.length; i < ilen; ++i) {\n      bodyItem = body[i];\n      textColor = this.labelTextColors[i];\n      ctx.fillStyle = textColor;\n      each(bodyItem.before, fillLineOfText);\n      lines = bodyItem.lines;\n      if (displayColors && lines.length) {\n        this._drawColorBox(ctx, pt, i, rtlHelper, options);\n        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n      }\n      for (j = 0, jlen = lines.length; j < jlen; ++j) {\n        fillLineOfText(lines[j]);\n        bodyLineHeight = bodyFont.lineHeight;\n      }\n      each(bodyItem.after, fillLineOfText);\n    }\n    xLinePadding = 0;\n    bodyLineHeight = bodyFont.lineHeight;\n    each(this.afterBody, fillLineOfText);\n    pt.y -= bodySpacing;\n  }\n  drawFooter(pt, ctx, options) {\n    const footer = this.footer;\n    const length = footer.length;\n    let footerFont, i;\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n      pt.x = getAlignedX(this, options.footerAlign, options);\n      pt.y += options.footerMarginTop;\n      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n      ctx.textBaseline = \"middle\";\n      footerFont = toFont(options.footerFont);\n      ctx.fillStyle = options.footerColor;\n      ctx.font = footerFont.string;\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n        pt.y += footerFont.lineHeight + options.footerSpacing;\n      }\n    }\n  }\n  drawBackground(pt, ctx, tooltipSize, options) {\n    const {\n      xAlign,\n      yAlign\n    } = this;\n    const {\n      x,\n      y\n    } = pt;\n    const {\n      width,\n      height\n    } = tooltipSize;\n    const {\n      topLeft,\n      topRight,\n      bottomLeft,\n      bottomRight\n    } = toTRBLCorners(options.cornerRadius);\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.beginPath();\n    ctx.moveTo(x + topLeft, y);\n    if (yAlign === \"top\") {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width - topRight, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n    if (yAlign === \"center\" && xAlign === \"right\") {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width, y + height - bottomRight);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n    if (yAlign === \"bottom\") {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + bottomLeft, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n    if (yAlign === \"center\" && xAlign === \"left\") {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x, y + topLeft);\n    ctx.quadraticCurveTo(x, y, x + topLeft, y);\n    ctx.closePath();\n    ctx.fill();\n    if (options.borderWidth > 0) {\n      ctx.stroke();\n    }\n  }\n  _updateAnimationTarget(options) {\n    const chart = this.chart;\n    const anims = this.$animations;\n    const animX = anims && anims.x;\n    const animY = anims && anims.y;\n    if (animX || animY) {\n      const position = positioners[options.position].call(this, this._active, this._eventPosition);\n      if (!position) {\n        return;\n      }\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, this._size);\n      const alignment = determineAlignment(chart, options, positionAndSize);\n      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n      if (animX._to !== point.x || animY._to !== point.y) {\n        this.xAlign = alignment.xAlign;\n        this.yAlign = alignment.yAlign;\n        this.width = size.width;\n        this.height = size.height;\n        this.caretX = position.x;\n        this.caretY = position.y;\n        this._resolveAnimations().update(this, point);\n      }\n    }\n  }\n  _willRender() {\n    return !!this.opacity;\n  }\n  draw(ctx) {\n    const options = this.options.setContext(this.getContext());\n    let opacity = this.opacity;\n    if (!opacity) {\n      return;\n    }\n    this._updateAnimationTarget(options);\n    const tooltipSize = {\n      width: this.width,\n      height: this.height\n    };\n    const pt = {\n      x: this.x,\n      y: this.y\n    };\n    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n    const padding = toPadding(options.padding);\n    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n    if (options.enabled && hasTooltipContent) {\n      ctx.save();\n      ctx.globalAlpha = opacity;\n      this.drawBackground(pt, ctx, tooltipSize, options);\n      overrideTextDirection(ctx, options.textDirection);\n      pt.y += padding.top;\n      this.drawTitle(pt, ctx, options);\n      this.drawBody(pt, ctx, options);\n      this.drawFooter(pt, ctx, options);\n      restoreTextDirection(ctx, options.textDirection);\n      ctx.restore();\n    }\n  }\n  getActiveElements() {\n    return this._active || [];\n  }\n  setActiveElements(activeElements, eventPosition) {\n    const lastActive = this._active;\n    const active = activeElements.map(({\n      datasetIndex,\n      index: index2\n    }) => {\n      const meta = this.chart.getDatasetMeta(datasetIndex);\n      if (!meta) {\n        throw new Error(\"Cannot find a dataset at index \" + datasetIndex);\n      }\n      return {\n        datasetIndex,\n        element: meta.data[index2],\n        index: index2\n      };\n    });\n    const changed = !_elementsEqual(lastActive, active);\n    const positionChanged = this._positionChanged(active, eventPosition);\n    if (changed || positionChanged) {\n      this._active = active;\n      this._eventPosition = eventPosition;\n      this._ignoreReplayEvents = true;\n      this.update(true);\n    }\n  }\n  handleEvent(e, replay, inChartArea = true) {\n    if (replay && this._ignoreReplayEvents) {\n      return false;\n    }\n    this._ignoreReplayEvents = false;\n    const options = this.options;\n    const lastActive = this._active || [];\n    const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n    const positionChanged = this._positionChanged(active, e);\n    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\n    if (changed) {\n      this._active = active;\n      if (options.enabled || options.external) {\n        this._eventPosition = {\n          x: e.x,\n          y: e.y\n        };\n        this.update(true, replay);\n      }\n    }\n    return changed;\n  }\n  _getActiveElements(e, lastActive, replay, inChartArea) {\n    const options = this.options;\n    if (e.type === \"mouseout\") {\n      return [];\n    }\n    if (!inChartArea) {\n      return lastActive.filter((i) => this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== void 0);\n    }\n    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n    if (options.reverse) {\n      active.reverse();\n    }\n    return active;\n  }\n  _positionChanged(active, e) {\n    const {\n      caretX,\n      caretY,\n      options\n    } = this;\n    const position = positioners[options.position].call(this, active, e);\n    return position !== false && (caretX !== position.x || caretY !== position.y);\n  }\n};\nvar plugin_tooltip = {\n  id: \"tooltip\",\n  _element: Tooltip,\n  positioners,\n  afterInit(chart, _args, options) {\n    if (options) {\n      chart.tooltip = new Tooltip({\n        chart,\n        options\n      });\n    }\n  },\n  beforeUpdate(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n  reset(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n  afterDraw(chart) {\n    const tooltip = chart.tooltip;\n    if (tooltip && tooltip._willRender()) {\n      const args = {\n        tooltip\n      };\n      if (chart.notifyPlugins(\"beforeTooltipDraw\", __spreadProps(__spreadValues({}, args), {\n        cancelable: true\n      })) === false) {\n        return;\n      }\n      tooltip.draw(chart.ctx);\n      chart.notifyPlugins(\"afterTooltipDraw\", args);\n    }\n  },\n  afterEvent(chart, args) {\n    if (chart.tooltip) {\n      const useFinalPosition = args.replay;\n      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n        args.changed = true;\n      }\n    }\n  },\n  defaults: {\n    enabled: true,\n    external: null,\n    position: \"average\",\n    backgroundColor: \"rgba(0,0,0,0.8)\",\n    titleColor: \"#fff\",\n    titleFont: {\n      weight: \"bold\"\n    },\n    titleSpacing: 2,\n    titleMarginBottom: 6,\n    titleAlign: \"left\",\n    bodyColor: \"#fff\",\n    bodySpacing: 2,\n    bodyFont: {},\n    bodyAlign: \"left\",\n    footerColor: \"#fff\",\n    footerSpacing: 2,\n    footerMarginTop: 6,\n    footerFont: {\n      weight: \"bold\"\n    },\n    footerAlign: \"left\",\n    padding: 6,\n    caretPadding: 2,\n    caretSize: 5,\n    cornerRadius: 6,\n    boxHeight: (ctx, opts) => opts.bodyFont.size,\n    boxWidth: (ctx, opts) => opts.bodyFont.size,\n    multiKeyBackground: \"#fff\",\n    displayColors: true,\n    boxPadding: 0,\n    borderColor: \"rgba(0,0,0,0)\",\n    borderWidth: 0,\n    animation: {\n      duration: 400,\n      easing: \"easeOutQuart\"\n    },\n    animations: {\n      numbers: {\n        type: \"number\",\n        properties: [\"x\", \"y\", \"width\", \"height\", \"caretX\", \"caretY\"]\n      },\n      opacity: {\n        easing: \"linear\",\n        duration: 200\n      }\n    },\n    callbacks: defaultCallbacks\n  },\n  defaultRoutes: {\n    bodyFont: \"font\",\n    footerFont: \"font\",\n    titleFont: \"font\"\n  },\n  descriptors: {\n    _scriptable: (name) => name !== \"filter\" && name !== \"itemSort\" && name !== \"external\",\n    _indexable: false,\n    callbacks: {\n      _scriptable: false,\n      _indexable: false\n    },\n    animation: {\n      _fallback: false\n    },\n    animations: {\n      _fallback: \"animation\"\n    }\n  },\n  additionalOptionScopes: [\"interaction\"]\n};\nvar plugins = Object.freeze({\n  __proto__: null,\n  Colors: plugin_colors,\n  Decimation: plugin_decimation,\n  Filler: index,\n  Legend: plugin_legend,\n  SubTitle: plugin_subtitle,\n  Title: plugin_title,\n  Tooltip: plugin_tooltip\n});\nvar addIfString = (labels, raw, index2, addedLabels) => {\n  if (typeof raw === \"string\") {\n    index2 = labels.push(raw) - 1;\n    addedLabels.unshift({\n      index: index2,\n      label: raw\n    });\n  } else if (isNaN(raw)) {\n    index2 = null;\n  }\n  return index2;\n};\nfunction findOrAddLabel(labels, raw, index2, addedLabels) {\n  const first = labels.indexOf(raw);\n  if (first === -1) {\n    return addIfString(labels, raw, index2, addedLabels);\n  }\n  const last = labels.lastIndexOf(raw);\n  return first !== last ? index2 : first;\n}\nvar validIndex = (index2, max) => index2 === null ? null : _limitValue(Math.round(index2), 0, max);\nfunction _getLabelForValue(value) {\n  const labels = this.getLabels();\n  if (value >= 0 && value < labels.length) {\n    return labels[value];\n  }\n  return value;\n}\nvar CategoryScale = class extends Scale {\n  static id = \"category\";\n  static defaults = {\n    ticks: {\n      callback: _getLabelForValue\n    }\n  };\n  constructor(cfg) {\n    super(cfg);\n    this._startValue = void 0;\n    this._valueRange = 0;\n    this._addedLabels = [];\n  }\n  init(scaleOptions) {\n    const added = this._addedLabels;\n    if (added.length) {\n      const labels = this.getLabels();\n      for (const {\n        index: index2,\n        label\n      } of added) {\n        if (labels[index2] === label) {\n          labels.splice(index2, 1);\n        }\n      }\n      this._addedLabels = [];\n    }\n    super.init(scaleOptions);\n  }\n  parse(raw, index2) {\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    const labels = this.getLabels();\n    index2 = isFinite(index2) && labels[index2] === raw ? index2 : findOrAddLabel(labels, raw, valueOrDefault(index2, raw), this._addedLabels);\n    return validIndex(index2, labels.length - 1);\n  }\n  determineDataLimits() {\n    const {\n      minDefined,\n      maxDefined\n    } = this.getUserBounds();\n    let {\n      min,\n      max\n    } = this.getMinMax(true);\n    if (this.options.bounds === \"ticks\") {\n      if (!minDefined) {\n        min = 0;\n      }\n      if (!maxDefined) {\n        max = this.getLabels().length - 1;\n      }\n    }\n    this.min = min;\n    this.max = max;\n  }\n  buildTicks() {\n    const min = this.min;\n    const max = this.max;\n    const offset = this.options.offset;\n    const ticks = [];\n    let labels = this.getLabels();\n    labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);\n    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n    this._startValue = this.min - (offset ? 0.5 : 0);\n    for (let value = min; value <= max; value++) {\n      ticks.push({\n        value\n      });\n    }\n    return ticks;\n  }\n  getLabelForValue(value) {\n    return _getLabelForValue.call(this, value);\n  }\n  configure() {\n    super.configure();\n    if (!this.isHorizontal()) {\n      this._reversePixels = !this._reversePixels;\n    }\n  }\n  getPixelForValue(value) {\n    if (typeof value !== \"number\") {\n      value = this.parse(value);\n    }\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n  getPixelForTick(index2) {\n    const ticks = this.ticks;\n    if (index2 < 0 || index2 > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index2].value);\n  }\n  getValueForPixel(pixel) {\n    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n  }\n  getBasePixel() {\n    return this.bottom;\n  }\n};\nfunction generateTicks$1(generationOptions, dataRange) {\n  const ticks = [];\n  const MIN_SPACING = 1e-14;\n  const {\n    bounds,\n    step,\n    min,\n    max,\n    precision,\n    count,\n    maxTicks,\n    maxDigits,\n    includeBounds\n  } = generationOptions;\n  const unit = step || 1;\n  const maxSpaces = maxTicks - 1;\n  const {\n    min: rmin,\n    max: rmax\n  } = dataRange;\n  const minDefined = !isNullOrUndef(min);\n  const maxDefined = !isNullOrUndef(max);\n  const countDefined = !isNullOrUndef(count);\n  const minSpacing = (rmax - rmin) / (maxDigits + 1);\n  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\n  let factor, niceMin, niceMax, numSpaces;\n  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n    return [{\n      value: rmin\n    }, {\n      value: rmax\n    }];\n  }\n  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n  if (numSpaces > maxSpaces) {\n    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\n  }\n  if (!isNullOrUndef(precision)) {\n    factor = Math.pow(10, precision);\n    spacing = Math.ceil(spacing * factor) / factor;\n  }\n  if (bounds === \"ticks\") {\n    niceMin = Math.floor(rmin / spacing) * spacing;\n    niceMax = Math.ceil(rmax / spacing) * spacing;\n  } else {\n    niceMin = rmin;\n    niceMax = rmax;\n  }\n  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {\n    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n    spacing = (max - min) / numSpaces;\n    niceMin = min;\n    niceMax = max;\n  } else if (countDefined) {\n    niceMin = minDefined ? min : niceMin;\n    niceMax = maxDefined ? max : niceMax;\n    numSpaces = count - 1;\n    spacing = (niceMax - niceMin) / numSpaces;\n  } else {\n    numSpaces = (niceMax - niceMin) / spacing;\n    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) {\n      numSpaces = Math.round(numSpaces);\n    } else {\n      numSpaces = Math.ceil(numSpaces);\n    }\n  }\n  const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));\n  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);\n  niceMin = Math.round(niceMin * factor) / factor;\n  niceMax = Math.round(niceMax * factor) / factor;\n  let j = 0;\n  if (minDefined) {\n    if (includeBounds && niceMin !== min) {\n      ticks.push({\n        value: min\n      });\n      if (niceMin < min) {\n        j++;\n      }\n      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n        j++;\n      }\n    } else if (niceMin < min) {\n      j++;\n    }\n  }\n  for (; j < numSpaces; ++j) {\n    const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;\n    if (maxDefined && tickValue > max) {\n      break;\n    }\n    ticks.push({\n      value: tickValue\n    });\n  }\n  if (maxDefined && includeBounds && niceMax !== max) {\n    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n      ticks[ticks.length - 1].value = max;\n    } else {\n      ticks.push({\n        value: max\n      });\n    }\n  } else if (!maxDefined || niceMax === max) {\n    ticks.push({\n      value: niceMax\n    });\n  }\n  return ticks;\n}\nfunction relativeLabelSize(value, minSpacing, {\n  horizontal,\n  minRotation\n}) {\n  const rad = toRadians(minRotation);\n  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 1e-3;\n  const length = 0.75 * minSpacing * (\"\" + value).length;\n  return Math.min(minSpacing / ratio, length);\n}\nvar LinearScaleBase = class extends Scale {\n  constructor(cfg) {\n    super(cfg);\n    this.start = void 0;\n    this.end = void 0;\n    this._startValue = void 0;\n    this._endValue = void 0;\n    this._valueRange = 0;\n  }\n  parse(raw, index2) {\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    if ((typeof raw === \"number\" || raw instanceof Number) && !isFinite(+raw)) {\n      return null;\n    }\n    return +raw;\n  }\n  handleTickRangeOptions() {\n    const {\n      beginAtZero\n    } = this.options;\n    const {\n      minDefined,\n      maxDefined\n    } = this.getUserBounds();\n    let {\n      min,\n      max\n    } = this;\n    const setMin = (v) => min = minDefined ? min : v;\n    const setMax = (v) => max = maxDefined ? max : v;\n    if (beginAtZero) {\n      const minSign = sign(min);\n      const maxSign = sign(max);\n      if (minSign < 0 && maxSign < 0) {\n        setMax(0);\n      } else if (minSign > 0 && maxSign > 0) {\n        setMin(0);\n      }\n    }\n    if (min === max) {\n      let offset = max === 0 ? 1 : Math.abs(max * 0.05);\n      setMax(max + offset);\n      if (!beginAtZero) {\n        setMin(min - offset);\n      }\n    }\n    this.min = min;\n    this.max = max;\n  }\n  getTickLimit() {\n    const tickOpts = this.options.ticks;\n    let {\n      maxTicksLimit,\n      stepSize\n    } = tickOpts;\n    let maxTicks;\n    if (stepSize) {\n      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n      if (maxTicks > 1e3) {\n        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\n        maxTicks = 1e3;\n      }\n    } else {\n      maxTicks = this.computeTickLimit();\n      maxTicksLimit = maxTicksLimit || 11;\n    }\n    if (maxTicksLimit) {\n      maxTicks = Math.min(maxTicksLimit, maxTicks);\n    }\n    return maxTicks;\n  }\n  computeTickLimit() {\n    return Number.POSITIVE_INFINITY;\n  }\n  buildTicks() {\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n    let maxTicks = this.getTickLimit();\n    maxTicks = Math.max(2, maxTicks);\n    const numericGeneratorOptions = {\n      maxTicks,\n      bounds: opts.bounds,\n      min: opts.min,\n      max: opts.max,\n      precision: tickOpts.precision,\n      step: tickOpts.stepSize,\n      count: tickOpts.count,\n      maxDigits: this._maxDigits(),\n      horizontal: this.isHorizontal(),\n      minRotation: tickOpts.minRotation || 0,\n      includeBounds: tickOpts.includeBounds !== false\n    };\n    const dataRange = this._range || this;\n    const ticks = generateTicks$1(numericGeneratorOptions, dataRange);\n    if (opts.bounds === \"ticks\") {\n      _setMinAndMaxByKey(ticks, this, \"value\");\n    }\n    if (opts.reverse) {\n      ticks.reverse();\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n    return ticks;\n  }\n  configure() {\n    const ticks = this.ticks;\n    let start = this.min;\n    let end = this.max;\n    super.configure();\n    if (this.options.offset && ticks.length) {\n      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n      start -= offset;\n      end += offset;\n    }\n    this._startValue = start;\n    this._endValue = end;\n    this._valueRange = end - start;\n  }\n  getLabelForValue(value) {\n    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n};\nvar LinearScale = class extends LinearScaleBase {\n  static id = \"linear\";\n  static defaults = {\n    ticks: {\n      callback: Ticks.formatters.numeric\n    }\n  };\n  determineDataLimits() {\n    const {\n      min,\n      max\n    } = this.getMinMax(true);\n    this.min = isNumberFinite(min) ? min : 0;\n    this.max = isNumberFinite(max) ? max : 1;\n    this.handleTickRangeOptions();\n  }\n  computeTickLimit() {\n    const horizontal = this.isHorizontal();\n    const length = horizontal ? this.width : this.height;\n    const minRotation = toRadians(this.options.ticks.minRotation);\n    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 1e-3;\n    const tickFont = this._resolveTickFontOptions(0);\n    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n  }\n  getPixelForValue(value) {\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n  getValueForPixel(pixel) {\n    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n  }\n};\nvar log10Floor = (v) => Math.floor(log10(v));\nvar changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);\nfunction isMajor(tickVal) {\n  const remain = tickVal / Math.pow(10, log10Floor(tickVal));\n  return remain === 1;\n}\nfunction steps(min, max, rangeExp) {\n  const rangeStep = Math.pow(10, rangeExp);\n  const start = Math.floor(min / rangeStep);\n  const end = Math.ceil(max / rangeStep);\n  return end - start;\n}\nfunction startExp(min, max) {\n  const range = max - min;\n  let rangeExp = log10Floor(range);\n  while (steps(min, max, rangeExp) > 10) {\n    rangeExp++;\n  }\n  while (steps(min, max, rangeExp) < 10) {\n    rangeExp--;\n  }\n  return Math.min(rangeExp, log10Floor(min));\n}\nfunction generateTicks(generationOptions, {\n  min,\n  max\n}) {\n  min = finiteOrDefault(generationOptions.min, min);\n  const ticks = [];\n  const minExp = log10Floor(min);\n  let exp = startExp(min, max);\n  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n  const stepSize = Math.pow(10, exp);\n  const base = minExp > exp ? Math.pow(10, minExp) : 0;\n  const start = Math.round((min - base) * precision) / precision;\n  const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;\n  let significand = Math.floor((start - offset) / Math.pow(10, exp));\n  let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);\n  while (value < max) {\n    ticks.push({\n      value,\n      major: isMajor(value),\n      significand\n    });\n    if (significand >= 10) {\n      significand = significand < 15 ? 15 : 20;\n    } else {\n      significand++;\n    }\n    if (significand >= 20) {\n      exp++;\n      significand = 2;\n      precision = exp >= 0 ? 1 : precision;\n    }\n    value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;\n  }\n  const lastTick = finiteOrDefault(generationOptions.max, value);\n  ticks.push({\n    value: lastTick,\n    major: isMajor(lastTick),\n    significand\n  });\n  return ticks;\n}\nvar LogarithmicScale = class extends Scale {\n  static id = \"logarithmic\";\n  static defaults = {\n    ticks: {\n      callback: Ticks.formatters.logarithmic,\n      major: {\n        enabled: true\n      }\n    }\n  };\n  constructor(cfg) {\n    super(cfg);\n    this.start = void 0;\n    this.end = void 0;\n    this._startValue = void 0;\n    this._valueRange = 0;\n  }\n  parse(raw, index2) {\n    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index2]);\n    if (value === 0) {\n      this._zero = true;\n      return void 0;\n    }\n    return isNumberFinite(value) && value > 0 ? value : null;\n  }\n  determineDataLimits() {\n    const {\n      min,\n      max\n    } = this.getMinMax(true);\n    this.min = isNumberFinite(min) ? Math.max(0, min) : null;\n    this.max = isNumberFinite(max) ? Math.max(0, max) : null;\n    if (this.options.beginAtZero) {\n      this._zero = true;\n    }\n    if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) {\n      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);\n    }\n    this.handleTickRangeOptions();\n  }\n  handleTickRangeOptions() {\n    const {\n      minDefined,\n      maxDefined\n    } = this.getUserBounds();\n    let min = this.min;\n    let max = this.max;\n    const setMin = (v) => min = minDefined ? min : v;\n    const setMax = (v) => max = maxDefined ? max : v;\n    if (min === max) {\n      if (min <= 0) {\n        setMin(1);\n        setMax(10);\n      } else {\n        setMin(changeExponent(min, -1));\n        setMax(changeExponent(max, 1));\n      }\n    }\n    if (min <= 0) {\n      setMin(changeExponent(max, -1));\n    }\n    if (max <= 0) {\n      setMax(changeExponent(min, 1));\n    }\n    this.min = min;\n    this.max = max;\n  }\n  buildTicks() {\n    const opts = this.options;\n    const generationOptions = {\n      min: this._userMin,\n      max: this._userMax\n    };\n    const ticks = generateTicks(generationOptions, this);\n    if (opts.bounds === \"ticks\") {\n      _setMinAndMaxByKey(ticks, this, \"value\");\n    }\n    if (opts.reverse) {\n      ticks.reverse();\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n    return ticks;\n  }\n  getLabelForValue(value) {\n    return value === void 0 ? \"0\" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n  configure() {\n    const start = this.min;\n    super.configure();\n    this._startValue = log10(start);\n    this._valueRange = log10(this.max) - log10(start);\n  }\n  getPixelForValue(value) {\n    if (value === void 0 || value === 0) {\n      value = this.min;\n    }\n    if (value === null || isNaN(value)) {\n      return NaN;\n    }\n    return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);\n  }\n  getValueForPixel(pixel) {\n    const decimal = this.getDecimalForPixel(pixel);\n    return Math.pow(10, this._startValue + decimal * this._valueRange);\n  }\n};\nfunction getTickBackdropHeight(opts) {\n  const tickOpts = opts.ticks;\n  if (tickOpts.display && opts.display) {\n    const padding = toPadding(tickOpts.backdropPadding);\n    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\n  }\n  return 0;\n}\nfunction measureLabelSize(ctx, font, label) {\n  label = isArray(label) ? label : [label];\n  return {\n    w: _longestText(ctx, font.string, label),\n    h: label.length * font.lineHeight\n  };\n}\nfunction determineLimits(angle, pos, size, min, max) {\n  if (angle === min || angle === max) {\n    return {\n      start: pos - size / 2,\n      end: pos + size / 2\n    };\n  } else if (angle < min || angle > max) {\n    return {\n      start: pos - size,\n      end: pos\n    };\n  }\n  return {\n    start: pos,\n    end: pos + size\n  };\n}\nfunction fitWithPointLabels(scale) {\n  const orig = {\n    l: scale.left + scale._padding.left,\n    r: scale.right - scale._padding.right,\n    t: scale.top + scale._padding.top,\n    b: scale.bottom - scale._padding.bottom\n  };\n  const limits = Object.assign({}, orig);\n  const labelSizes = [];\n  const padding = [];\n  const valueCount = scale._pointLabels.length;\n  const pointLabelOpts = scale.options.pointLabels;\n  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;\n  for (let i = 0; i < valueCount; i++) {\n    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n    padding[i] = opts.padding;\n    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n    const plFont = toFont(opts.font);\n    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n    labelSizes[i] = textSize;\n    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);\n    const angle = Math.round(toDegrees(angleRadians));\n    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n    updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n  }\n  scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);\n  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n  const sin = Math.abs(Math.sin(angle));\n  const cos = Math.abs(Math.cos(angle));\n  let x = 0;\n  let y = 0;\n  if (hLimits.start < orig.l) {\n    x = (orig.l - hLimits.start) / sin;\n    limits.l = Math.min(limits.l, orig.l - x);\n  } else if (hLimits.end > orig.r) {\n    x = (hLimits.end - orig.r) / sin;\n    limits.r = Math.max(limits.r, orig.r + x);\n  }\n  if (vLimits.start < orig.t) {\n    y = (orig.t - vLimits.start) / cos;\n    limits.t = Math.min(limits.t, orig.t - y);\n  } else if (vLimits.end > orig.b) {\n    y = (vLimits.end - orig.b) / cos;\n    limits.b = Math.max(limits.b, orig.b + y);\n  }\n}\nfunction createPointLabelItem(scale, index2, itemOpts) {\n  const outerDistance = scale.drawingArea;\n  const {\n    extra,\n    additionalAngle,\n    padding,\n    size\n  } = itemOpts;\n  const pointLabelPosition = scale.getPointPosition(index2, outerDistance + extra + padding, additionalAngle);\n  const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));\n  const y = yForAngle(pointLabelPosition.y, size.h, angle);\n  const textAlign = getTextAlignForAngle(angle);\n  const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n  return {\n    visible: true,\n    x: pointLabelPosition.x,\n    y,\n    textAlign,\n    left,\n    top: y,\n    right: left + size.w,\n    bottom: y + size.h\n  };\n}\nfunction isNotOverlapped(item, area) {\n  if (!area) {\n    return true;\n  }\n  const {\n    left,\n    top,\n    right,\n    bottom\n  } = item;\n  const apexesInArea = _isPointInArea({\n    x: left,\n    y: top\n  }, area) || _isPointInArea({\n    x: left,\n    y: bottom\n  }, area) || _isPointInArea({\n    x: right,\n    y: top\n  }, area) || _isPointInArea({\n    x: right,\n    y: bottom\n  }, area);\n  return !apexesInArea;\n}\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n  const items = [];\n  const valueCount = scale._pointLabels.length;\n  const opts = scale.options;\n  const {\n    centerPointLabels,\n    display\n  } = opts.pointLabels;\n  const itemOpts = {\n    extra: getTickBackdropHeight(opts) / 2,\n    additionalAngle: centerPointLabels ? PI / valueCount : 0\n  };\n  let area;\n  for (let i = 0; i < valueCount; i++) {\n    itemOpts.padding = padding[i];\n    itemOpts.size = labelSizes[i];\n    const item = createPointLabelItem(scale, i, itemOpts);\n    items.push(item);\n    if (display === \"auto\") {\n      item.visible = isNotOverlapped(item, area);\n      if (item.visible) {\n        area = item;\n      }\n    }\n  }\n  return items;\n}\nfunction getTextAlignForAngle(angle) {\n  if (angle === 0 || angle === 180) {\n    return \"center\";\n  } else if (angle < 180) {\n    return \"left\";\n  }\n  return \"right\";\n}\nfunction leftForTextAlign(x, w, align) {\n  if (align === \"right\") {\n    x -= w;\n  } else if (align === \"center\") {\n    x -= w / 2;\n  }\n  return x;\n}\nfunction yForAngle(y, h, angle) {\n  if (angle === 90 || angle === 270) {\n    y -= h / 2;\n  } else if (angle > 270 || angle < 90) {\n    y -= h;\n  }\n  return y;\n}\nfunction drawPointLabelBox(ctx, opts, item) {\n  const {\n    left,\n    top,\n    right,\n    bottom\n  } = item;\n  const {\n    backdropColor\n  } = opts;\n  if (!isNullOrUndef(backdropColor)) {\n    const borderRadius = toTRBLCorners(opts.borderRadius);\n    const padding = toPadding(opts.backdropPadding);\n    ctx.fillStyle = backdropColor;\n    const backdropLeft = left - padding.left;\n    const backdropTop = top - padding.top;\n    const backdropWidth = right - left + padding.width;\n    const backdropHeight = bottom - top + padding.height;\n    if (Object.values(borderRadius).some((v) => v !== 0)) {\n      ctx.beginPath();\n      addRoundedRectPath(ctx, {\n        x: backdropLeft,\n        y: backdropTop,\n        w: backdropWidth,\n        h: backdropHeight,\n        radius: borderRadius\n      });\n      ctx.fill();\n    } else {\n      ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\n    }\n  }\n}\nfunction drawPointLabels(scale, labelCount) {\n  const {\n    ctx,\n    options: {\n      pointLabels\n    }\n  } = scale;\n  for (let i = labelCount - 1; i >= 0; i--) {\n    const item = scale._pointLabelItems[i];\n    if (!item.visible) {\n      continue;\n    }\n    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n    drawPointLabelBox(ctx, optsAtIndex, item);\n    const plFont = toFont(optsAtIndex.font);\n    const {\n      x,\n      y,\n      textAlign\n    } = item;\n    renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {\n      color: optsAtIndex.color,\n      textAlign,\n      textBaseline: \"middle\"\n    });\n  }\n}\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n  const {\n    ctx\n  } = scale;\n  if (circular) {\n    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\n  } else {\n    let pointPosition = scale.getPointPosition(0, radius);\n    ctx.moveTo(pointPosition.x, pointPosition.y);\n    for (let i = 1; i < labelCount; i++) {\n      pointPosition = scale.getPointPosition(i, radius);\n      ctx.lineTo(pointPosition.x, pointPosition.y);\n    }\n  }\n}\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {\n  const ctx = scale.ctx;\n  const circular = gridLineOpts.circular;\n  const {\n    color: color2,\n    lineWidth\n  } = gridLineOpts;\n  if (!circular && !labelCount || !color2 || !lineWidth || radius < 0) {\n    return;\n  }\n  ctx.save();\n  ctx.strokeStyle = color2;\n  ctx.lineWidth = lineWidth;\n  ctx.setLineDash(borderOpts.dash || []);\n  ctx.lineDashOffset = borderOpts.dashOffset;\n  ctx.beginPath();\n  pathRadiusLine(scale, radius, circular, labelCount);\n  ctx.closePath();\n  ctx.stroke();\n  ctx.restore();\n}\nfunction createPointLabelContext(parent, index2, label) {\n  return createContext(parent, {\n    label,\n    index: index2,\n    type: \"pointLabel\"\n  });\n}\nvar RadialLinearScale = class extends LinearScaleBase {\n  static id = \"radialLinear\";\n  static defaults = {\n    display: true,\n    animate: true,\n    position: \"chartArea\",\n    angleLines: {\n      display: true,\n      lineWidth: 1,\n      borderDash: [],\n      borderDashOffset: 0\n    },\n    grid: {\n      circular: false\n    },\n    startAngle: 0,\n    ticks: {\n      showLabelBackdrop: true,\n      callback: Ticks.formatters.numeric\n    },\n    pointLabels: {\n      backdropColor: void 0,\n      backdropPadding: 2,\n      display: true,\n      font: {\n        size: 10\n      },\n      callback(label) {\n        return label;\n      },\n      padding: 5,\n      centerPointLabels: false\n    }\n  };\n  static defaultRoutes = {\n    \"angleLines.color\": \"borderColor\",\n    \"pointLabels.color\": \"color\",\n    \"ticks.color\": \"color\"\n  };\n  static descriptors = {\n    angleLines: {\n      _fallback: \"grid\"\n    }\n  };\n  constructor(cfg) {\n    super(cfg);\n    this.xCenter = void 0;\n    this.yCenter = void 0;\n    this.drawingArea = void 0;\n    this._pointLabels = [];\n    this._pointLabelItems = [];\n  }\n  setDimensions() {\n    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);\n    const w = this.width = this.maxWidth - padding.width;\n    const h = this.height = this.maxHeight - padding.height;\n    this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n    this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n    this.drawingArea = Math.floor(Math.min(w, h) / 2);\n  }\n  determineDataLimits() {\n    const {\n      min,\n      max\n    } = this.getMinMax(false);\n    this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;\n    this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;\n    this.handleTickRangeOptions();\n  }\n  computeTickLimit() {\n    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n  }\n  generateTickLabels(ticks) {\n    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n    this._pointLabels = this.getLabels().map((value, index2) => {\n      const label = callback(this.options.pointLabels.callback, [value, index2], this);\n      return label || label === 0 ? label : \"\";\n    }).filter((v, i) => this.chart.getDataVisibility(i));\n  }\n  fit() {\n    const opts = this.options;\n    if (opts.display && opts.pointLabels.display) {\n      fitWithPointLabels(this);\n    } else {\n      this.setCenterPoint(0, 0, 0, 0);\n    }\n  }\n  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n  }\n  getIndexAngle(index2) {\n    const angleMultiplier = TAU / (this._pointLabels.length || 1);\n    const startAngle = this.options.startAngle || 0;\n    return _normalizeAngle(index2 * angleMultiplier + toRadians(startAngle));\n  }\n  getDistanceFromCenterForValue(value) {\n    if (isNullOrUndef(value)) {\n      return NaN;\n    }\n    const scalingFactor = this.drawingArea / (this.max - this.min);\n    if (this.options.reverse) {\n      return (this.max - value) * scalingFactor;\n    }\n    return (value - this.min) * scalingFactor;\n  }\n  getValueForDistanceFromCenter(distance) {\n    if (isNullOrUndef(distance)) {\n      return NaN;\n    }\n    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n  }\n  getPointLabelContext(index2) {\n    const pointLabels = this._pointLabels || [];\n    if (index2 >= 0 && index2 < pointLabels.length) {\n      const pointLabel = pointLabels[index2];\n      return createPointLabelContext(this.getContext(), index2, pointLabel);\n    }\n  }\n  getPointPosition(index2, distanceFromCenter, additionalAngle = 0) {\n    const angle = this.getIndexAngle(index2) - HALF_PI + additionalAngle;\n    return {\n      x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n      y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n      angle\n    };\n  }\n  getPointPositionForValue(index2, value) {\n    return this.getPointPosition(index2, this.getDistanceFromCenterForValue(value));\n  }\n  getBasePosition(index2) {\n    return this.getPointPositionForValue(index2 || 0, this.getBaseValue());\n  }\n  getPointLabelPosition(index2) {\n    const {\n      left,\n      top,\n      right,\n      bottom\n    } = this._pointLabelItems[index2];\n    return {\n      left,\n      top,\n      right,\n      bottom\n    };\n  }\n  drawBackground() {\n    const {\n      backgroundColor,\n      grid: {\n        circular\n      }\n    } = this.options;\n    if (backgroundColor) {\n      const ctx = this.ctx;\n      ctx.save();\n      ctx.beginPath();\n      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n      ctx.closePath();\n      ctx.fillStyle = backgroundColor;\n      ctx.fill();\n      ctx.restore();\n    }\n  }\n  drawGrid() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const {\n      angleLines,\n      grid,\n      border\n    } = opts;\n    const labelCount = this._pointLabels.length;\n    let i, offset, position;\n    if (opts.pointLabels.display) {\n      drawPointLabels(this, labelCount);\n    }\n    if (grid.display) {\n      this.ticks.forEach((tick, index2) => {\n        if (index2 !== 0 || index2 === 0 && this.min < 0) {\n          offset = this.getDistanceFromCenterForValue(tick.value);\n          const context = this.getContext(index2);\n          const optsAtIndex = grid.setContext(context);\n          const optsAtIndexBorder = border.setContext(context);\n          drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);\n        }\n      });\n    }\n    if (angleLines.display) {\n      ctx.save();\n      for (i = labelCount - 1; i >= 0; i--) {\n        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n        const {\n          color: color2,\n          lineWidth\n        } = optsAtIndex;\n        if (!lineWidth || !color2) {\n          continue;\n        }\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = color2;\n        ctx.setLineDash(optsAtIndex.borderDash);\n        ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n        offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);\n        position = this.getPointPosition(i, offset);\n        ctx.beginPath();\n        ctx.moveTo(this.xCenter, this.yCenter);\n        ctx.lineTo(position.x, position.y);\n        ctx.stroke();\n      }\n      ctx.restore();\n    }\n  }\n  drawBorder() {\n  }\n  drawLabels() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n    if (!tickOpts.display) {\n      return;\n    }\n    const startAngle = this.getIndexAngle(0);\n    let offset, width;\n    ctx.save();\n    ctx.translate(this.xCenter, this.yCenter);\n    ctx.rotate(startAngle);\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    this.ticks.forEach((tick, index2) => {\n      if (index2 === 0 && this.min >= 0 && !opts.reverse) {\n        return;\n      }\n      const optsAtIndex = tickOpts.setContext(this.getContext(index2));\n      const tickFont = toFont(optsAtIndex.font);\n      offset = this.getDistanceFromCenterForValue(this.ticks[index2].value);\n      if (optsAtIndex.showLabelBackdrop) {\n        ctx.font = tickFont.string;\n        width = ctx.measureText(tick.label).width;\n        ctx.fillStyle = optsAtIndex.backdropColor;\n        const padding = toPadding(optsAtIndex.backdropPadding);\n        ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);\n      }\n      renderText(ctx, tick.label, 0, -offset, tickFont, {\n        color: optsAtIndex.color,\n        strokeColor: optsAtIndex.textStrokeColor,\n        strokeWidth: optsAtIndex.textStrokeWidth\n      });\n    });\n    ctx.restore();\n  }\n  drawTitle() {\n  }\n};\nvar INTERVALS = {\n  millisecond: {\n    common: true,\n    size: 1,\n    steps: 1e3\n  },\n  second: {\n    common: true,\n    size: 1e3,\n    steps: 60\n  },\n  minute: {\n    common: true,\n    size: 6e4,\n    steps: 60\n  },\n  hour: {\n    common: true,\n    size: 36e5,\n    steps: 24\n  },\n  day: {\n    common: true,\n    size: 864e5,\n    steps: 30\n  },\n  week: {\n    common: false,\n    size: 6048e5,\n    steps: 4\n  },\n  month: {\n    common: true,\n    size: 2628e6,\n    steps: 12\n  },\n  quarter: {\n    common: false,\n    size: 7884e6,\n    steps: 4\n  },\n  year: {\n    common: true,\n    size: 3154e7\n  }\n};\nvar UNITS = Object.keys(INTERVALS);\nfunction sorter(a, b) {\n  return a - b;\n}\nfunction parse(scale, input) {\n  if (isNullOrUndef(input)) {\n    return null;\n  }\n  const adapter = scale._adapter;\n  const {\n    parser,\n    round: round2,\n    isoWeekday\n  } = scale._parseOpts;\n  let value = input;\n  if (typeof parser === \"function\") {\n    value = parser(value);\n  }\n  if (!isNumberFinite(value)) {\n    value = typeof parser === \"string\" ? adapter.parse(value, parser) : adapter.parse(value);\n  }\n  if (value === null) {\n    return null;\n  }\n  if (round2) {\n    value = round2 === \"week\" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, \"isoWeek\", isoWeekday) : adapter.startOf(value, round2);\n  }\n  return +value;\n}\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  const ilen = UNITS.length;\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    const interval = INTERVALS[UNITS[i]];\n    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n  return UNITS[ilen - 1];\n}\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\n    const unit = UNITS[i];\n    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n      return unit;\n    }\n  }\n  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\nfunction determineMajorUnit(unit) {\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\nfunction addTick(ticks, time, timestamps) {\n  if (!timestamps) {\n    ticks[time] = true;\n  } else if (timestamps.length) {\n    const {\n      lo,\n      hi\n    } = _lookup(timestamps, time);\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n    ticks[timestamp] = true;\n  }\n}\nfunction setMajorTicks(scale, ticks, map3, majorUnit) {\n  const adapter = scale._adapter;\n  const first = +adapter.startOf(ticks[0].value, majorUnit);\n  const last = ticks[ticks.length - 1].value;\n  let major, index2;\n  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\n    index2 = map3[major];\n    if (index2 >= 0) {\n      ticks[index2].major = true;\n    }\n  }\n  return ticks;\n}\nfunction ticksFromTimestamps(scale, values, majorUnit) {\n  const ticks = [];\n  const map3 = {};\n  const ilen = values.length;\n  let i, value;\n  for (i = 0; i < ilen; ++i) {\n    value = values[i];\n    map3[value] = i;\n    ticks.push({\n      value,\n      major: false\n    });\n  }\n  return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map3, majorUnit);\n}\nvar TimeScale = class extends Scale {\n  static id = \"time\";\n  static defaults = {\n    bounds: \"data\",\n    adapters: {},\n    time: {\n      parser: false,\n      unit: false,\n      round: false,\n      isoWeekday: false,\n      minUnit: \"millisecond\",\n      displayFormats: {}\n    },\n    ticks: {\n      source: \"auto\",\n      callback: false,\n      major: {\n        enabled: false\n      }\n    }\n  };\n  constructor(props) {\n    super(props);\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n    this._unit = \"day\";\n    this._majorUnit = void 0;\n    this._offsets = {};\n    this._normalized = false;\n    this._parseOpts = void 0;\n  }\n  init(scaleOpts, opts = {}) {\n    const time = scaleOpts.time || (scaleOpts.time = {});\n    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n    adapter.init(opts);\n    mergeIf(time.displayFormats, adapter.formats());\n    this._parseOpts = {\n      parser: time.parser,\n      round: time.round,\n      isoWeekday: time.isoWeekday\n    };\n    super.init(scaleOpts);\n    this._normalized = opts.normalized;\n  }\n  parse(raw, index2) {\n    if (raw === void 0) {\n      return null;\n    }\n    return parse(this, raw);\n  }\n  beforeLayout() {\n    super.beforeLayout();\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n  }\n  determineDataLimits() {\n    const options = this.options;\n    const adapter = this._adapter;\n    const unit = options.time.unit || \"day\";\n    let {\n      min,\n      max,\n      minDefined,\n      maxDefined\n    } = this.getUserBounds();\n    function _applyBounds(bounds) {\n      if (!minDefined && !isNaN(bounds.min)) {\n        min = Math.min(min, bounds.min);\n      }\n      if (!maxDefined && !isNaN(bounds.max)) {\n        max = Math.max(max, bounds.max);\n      }\n    }\n    if (!minDefined || !maxDefined) {\n      _applyBounds(this._getLabelBounds());\n      if (options.bounds !== \"ticks\" || options.ticks.source !== \"labels\") {\n        _applyBounds(this.getMinMax(false));\n      }\n    }\n    min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n    max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n    this.min = Math.min(min, max - 1);\n    this.max = Math.max(min + 1, max);\n  }\n  _getLabelBounds() {\n    const arr = this.getLabelTimestamps();\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n    if (arr.length) {\n      min = arr[0];\n      max = arr[arr.length - 1];\n    }\n    return {\n      min,\n      max\n    };\n  }\n  buildTicks() {\n    const options = this.options;\n    const timeOpts = options.time;\n    const tickOpts = options.ticks;\n    const timestamps = tickOpts.source === \"labels\" ? this.getLabelTimestamps() : this._generate();\n    if (options.bounds === \"ticks\" && timestamps.length) {\n      this.min = this._userMin || timestamps[0];\n      this.max = this._userMax || timestamps[timestamps.length - 1];\n    }\n    const min = this.min;\n    const max = this.max;\n    const ticks = _filterBetween(timestamps, min, max);\n    this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n    this._majorUnit = !tickOpts.major.enabled || this._unit === \"year\" ? void 0 : determineMajorUnit(this._unit);\n    this.initOffsets(timestamps);\n    if (options.reverse) {\n      ticks.reverse();\n    }\n    return ticksFromTimestamps(this, ticks, this._majorUnit);\n  }\n  afterAutoSkip() {\n    if (this.options.offsetAfterAutoskip) {\n      this.initOffsets(this.ticks.map((tick) => +tick.value));\n    }\n  }\n  initOffsets(timestamps = []) {\n    let start = 0;\n    let end = 0;\n    let first, last;\n    if (this.options.offset && timestamps.length) {\n      first = this.getDecimalForValue(timestamps[0]);\n      if (timestamps.length === 1) {\n        start = 1 - first;\n      } else {\n        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n      }\n      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n      if (timestamps.length === 1) {\n        end = last;\n      } else {\n        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n      }\n    }\n    const limit = timestamps.length < 3 ? 0.5 : 0.25;\n    start = _limitValue(start, 0, limit);\n    end = _limitValue(end, 0, limit);\n    this._offsets = {\n      start,\n      end,\n      factor: 1 / (start + 1 + end)\n    };\n  }\n  _generate() {\n    const adapter = this._adapter;\n    const min = this.min;\n    const max = this.max;\n    const options = this.options;\n    const timeOpts = options.time;\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n    const stepSize = valueOrDefault(options.ticks.stepSize, 1);\n    const weekday = minor === \"week\" ? timeOpts.isoWeekday : false;\n    const hasWeekday = isNumber(weekday) || weekday === true;\n    const ticks = {};\n    let first = min;\n    let time, count;\n    if (hasWeekday) {\n      first = +adapter.startOf(first, \"isoWeek\", weekday);\n    }\n    first = +adapter.startOf(first, hasWeekday ? \"day\" : minor);\n    if (adapter.diff(max, min, minor) > 1e5 * stepSize) {\n      throw new Error(min + \" and \" + max + \" are too far apart with stepSize of \" + stepSize + \" \" + minor);\n    }\n    const timestamps = options.ticks.source === \"data\" && this.getDataTimestamps();\n    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {\n      addTick(ticks, time, timestamps);\n    }\n    if (time === max || options.bounds === \"ticks\" || count === 1) {\n      addTick(ticks, time, timestamps);\n    }\n    return Object.keys(ticks).sort(sorter).map((x) => +x);\n  }\n  getLabelForValue(value) {\n    const adapter = this._adapter;\n    const timeOpts = this.options.time;\n    if (timeOpts.tooltipFormat) {\n      return adapter.format(value, timeOpts.tooltipFormat);\n    }\n    return adapter.format(value, timeOpts.displayFormats.datetime);\n  }\n  format(value, format) {\n    const options = this.options;\n    const formats = options.time.displayFormats;\n    const unit = this._unit;\n    const fmt = format || formats[unit];\n    return this._adapter.format(value, fmt);\n  }\n  _tickFormatFunction(time, index2, ticks, format) {\n    const options = this.options;\n    const formatter = options.ticks.callback;\n    if (formatter) {\n      return callback(formatter, [time, index2, ticks], this);\n    }\n    const formats = options.time.displayFormats;\n    const unit = this._unit;\n    const majorUnit = this._majorUnit;\n    const minorFormat = unit && formats[unit];\n    const majorFormat = majorUnit && formats[majorUnit];\n    const tick = ticks[index2];\n    const major = majorUnit && majorFormat && tick && tick.major;\n    return this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n  }\n  generateTickLabels(ticks) {\n    let i, ilen, tick;\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      tick.label = this._tickFormatFunction(tick.value, i, ticks);\n    }\n  }\n  getDecimalForValue(value) {\n    return value === null ? NaN : (value - this.min) / (this.max - this.min);\n  }\n  getPixelForValue(value) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForValue(value);\n    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n  }\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return this.min + pos * (this.max - this.min);\n  }\n  _getLabelSize(label) {\n    const ticksOpts = this.options.ticks;\n    const tickLabelWidth = this.ctx.measureText(label).width;\n    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n    const cosRotation = Math.cos(angle);\n    const sinRotation = Math.sin(angle);\n    const tickFontSize = this._resolveTickFontOptions(0).size;\n    return {\n      w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,\n      h: tickLabelWidth * sinRotation + tickFontSize * cosRotation\n    };\n  }\n  _getLabelCapacity(exampleTime) {\n    const timeOpts = this.options.time;\n    const displayFormats = timeOpts.displayFormats;\n    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);\n    const size = this._getLabelSize(exampleLabel);\n    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n    return capacity > 0 ? capacity : 1;\n  }\n  getDataTimestamps() {\n    let timestamps = this._cache.data || [];\n    let i, ilen;\n    if (timestamps.length) {\n      return timestamps;\n    }\n    const metas = this.getMatchingVisibleMetas();\n    if (this._normalized && metas.length) {\n      return this._cache.data = metas[0].controller.getAllParsedValues(this);\n    }\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n    }\n    return this._cache.data = this.normalize(timestamps);\n  }\n  getLabelTimestamps() {\n    const timestamps = this._cache.labels || [];\n    let i, ilen;\n    if (timestamps.length) {\n      return timestamps;\n    }\n    const labels = this.getLabels();\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\n      timestamps.push(parse(this, labels[i]));\n    }\n    return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);\n  }\n  normalize(values) {\n    return _arrayUnique(values.sort(sorter));\n  }\n};\nfunction interpolate2(table, val, reverse) {\n  let lo = 0;\n  let hi = table.length - 1;\n  let prevSource, nextSource, prevTarget, nextTarget;\n  if (reverse) {\n    if (val >= table[lo].pos && val <= table[hi].pos) {\n      ({\n        lo,\n        hi\n      } = _lookupByKey(table, \"pos\", val));\n    }\n    ({\n      pos: prevSource,\n      time: prevTarget\n    } = table[lo]);\n    ({\n      pos: nextSource,\n      time: nextTarget\n    } = table[hi]);\n  } else {\n    if (val >= table[lo].time && val <= table[hi].time) {\n      ({\n        lo,\n        hi\n      } = _lookupByKey(table, \"time\", val));\n    }\n    ({\n      time: prevSource,\n      pos: prevTarget\n    } = table[lo]);\n    ({\n      time: nextSource,\n      pos: nextTarget\n    } = table[hi]);\n  }\n  const span = nextSource - prevSource;\n  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\nvar TimeSeriesScale = class extends TimeScale {\n  static id = \"timeseries\";\n  static defaults = TimeScale.defaults;\n  constructor(props) {\n    super(props);\n    this._table = [];\n    this._minPos = void 0;\n    this._tableRange = void 0;\n  }\n  initOffsets() {\n    const timestamps = this._getTimestampsForTable();\n    const table = this._table = this.buildLookupTable(timestamps);\n    this._minPos = interpolate2(table, this.min);\n    this._tableRange = interpolate2(table, this.max) - this._minPos;\n    super.initOffsets(timestamps);\n  }\n  buildLookupTable(timestamps) {\n    const {\n      min,\n      max\n    } = this;\n    const items = [];\n    const table = [];\n    let i, ilen, prev, curr, next;\n    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n      curr = timestamps[i];\n      if (curr >= min && curr <= max) {\n        items.push(curr);\n      }\n    }\n    if (items.length < 2) {\n      return [{\n        time: min,\n        pos: 0\n      }, {\n        time: max,\n        pos: 1\n      }];\n    }\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      next = items[i + 1];\n      prev = items[i - 1];\n      curr = items[i];\n      if (Math.round((next + prev) / 2) !== curr) {\n        table.push({\n          time: curr,\n          pos: i / (ilen - 1)\n        });\n      }\n    }\n    return table;\n  }\n  _generate() {\n    const min = this.min;\n    const max = this.max;\n    let timestamps = super.getDataTimestamps();\n    if (!timestamps.includes(min) || !timestamps.length) {\n      timestamps.splice(0, 0, min);\n    }\n    if (!timestamps.includes(max) || timestamps.length === 1) {\n      timestamps.push(max);\n    }\n    return timestamps.sort((a, b) => a - b);\n  }\n  _getTimestampsForTable() {\n    let timestamps = this._cache.all || [];\n    if (timestamps.length) {\n      return timestamps;\n    }\n    const data = this.getDataTimestamps();\n    const label = this.getLabelTimestamps();\n    if (data.length && label.length) {\n      timestamps = this.normalize(data.concat(label));\n    } else {\n      timestamps = data.length ? data : label;\n    }\n    timestamps = this._cache.all = timestamps;\n    return timestamps;\n  }\n  getDecimalForValue(value) {\n    return (interpolate2(this._table, value) - this._minPos) / this._tableRange;\n  }\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return interpolate2(this._table, decimal * this._tableRange + this._minPos, true);\n  }\n};\nvar scales = Object.freeze({\n  __proto__: null,\n  CategoryScale,\n  LinearScale,\n  LogarithmicScale,\n  RadialLinearScale,\n  TimeScale,\n  TimeSeriesScale\n});\nvar registerables = [controllers, elements, plugins, scales];\nexport {\n  Animation,\n  Animations,\n  ArcElement,\n  BarController,\n  BarElement,\n  BasePlatform,\n  BasicPlatform,\n  BubbleController,\n  CategoryScale,\n  Chart,\n  plugin_colors as Colors,\n  DatasetController,\n  plugin_decimation as Decimation,\n  DomPlatform,\n  DoughnutController,\n  Element,\n  index as Filler,\n  Interaction,\n  plugin_legend as Legend,\n  LineController,\n  LineElement,\n  LinearScale,\n  LogarithmicScale,\n  PieController,\n  PointElement,\n  PolarAreaController,\n  RadarController,\n  RadialLinearScale,\n  Scale,\n  ScatterController,\n  plugin_subtitle as SubTitle,\n  Ticks,\n  TimeScale,\n  TimeSeriesScale,\n  plugin_title as Title,\n  plugin_tooltip as Tooltip,\n  adapters as _adapters,\n  _detectPlatform,\n  animator,\n  controllers,\n  defaults,\n  elements,\n  layouts,\n  plugins,\n  registerables,\n  registry,\n  scales\n};\n/*! Bundled license information:\n\n@kurkle/color/dist/color.esm.js:\n  (*!\n   * @kurkle/color v0.3.4\n   * https://github.com/kurkle/color#readme\n   * (c) 2024 Jukka Kurkela\n   * Released under the MIT License\n   *)\n\nchart.js/dist/chunks/helpers.segment.js:\n  (*!\n   * Chart.js v4.4.8\n   * https://www.chartjs.org\n   * (c) 2025 Chart.js Contributors\n   * Released under the MIT License\n   *)\n\nchart.js/dist/chart.js:\n  (*!\n   * Chart.js v4.4.8\n   * https://www.chartjs.org\n   * (c) 2025 Chart.js Contributors\n   * Released under the MIT License\n   *)\n*/\n//# sourceMappingURL=chart__js.js.map\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\.angular\\cache\\19.2.5\\mortgage-app\\vite\\deps\\chunk-4S3KYZTJ.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\.angular\\cache\\19.2.5\\mortgage-app\\vite\\deps\\chunk-B4MA5VXV.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\.angular\\cache\\19.2.5\\mortgage-app\\vite\\deps\\chunk-D6ZLATY2.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\.angular\\cache\\19.2.5\\mortgage-app\\vite\\deps\\chunk-FRNU3IZH.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\.angular\\cache\\19.2.5\\mortgage-app\\vite\\deps\\chunk-LLD5PQMB.js","messages":[{"ruleId":"@angular-eslint/contextual-lifecycle","message":"Definition for rule '@angular-eslint/contextual-lifecycle' was not found.","line":1225,"column":3,"endLine":1225,"endColumn":67,"severity":2,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  DestroyRef,\n  ENVIRONMENT_INITIALIZER,\n  Inject,\n  Injectable,\n  InjectionToken,\n  Injector,\n  NgModule,\n  NgZone,\n  Optional,\n  RuntimeError,\n  assertInInjectionContext,\n  assertNotInReactiveContext,\n  computed,\n  effect,\n  inject,\n  isDevMode,\n  makeEnvironmentProviders,\n  setClassMetadata,\n  signal,\n  untracked,\n  ɵɵdefineInjectable,\n  ɵɵdefineInjector,\n  ɵɵdefineNgModule,\n  ɵɵgetInheritedFactory,\n  ɵɵinject\n} from \"./chunk-Z7RWVO2Z.js\";\nimport {\n  queueScheduler\n} from \"./chunk-WPM5VTLQ.js\";\nimport {\n  BehaviorSubject,\n  Observable,\n  Subject,\n  distinctUntilChanged,\n  map,\n  observeOn,\n  pluck,\n  scan,\n  withLatestFrom\n} from \"./chunk-4S3KYZTJ.js\";\nimport {\n  __spreadProps,\n  __spreadValues\n} from \"./chunk-WDMUDEB6.js\";\n\n// node_modules/@angular/core/fesm2022/rxjs-interop.mjs\nfunction toSignal(source, options) {\n  ngDevMode && assertNotInReactiveContext(toSignal, \"Invoking `toSignal` causes new subscriptions every time. Consider moving `toSignal` outside of the reactive context and read the signal value where needed.\");\n  const requiresCleanup = !options?.manualCleanup;\n  requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\n  const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;\n  const equal = makeToSignalEqual(options?.equal);\n  let state;\n  if (options?.requireSync) {\n    state = signal({\n      kind: 0\n      /* StateKind.NoValue */\n    }, {\n      equal\n    });\n  } else {\n    state = signal({\n      kind: 1,\n      value: options?.initialValue\n    }, {\n      equal\n    });\n  }\n  const sub = source.subscribe({\n    next: (value) => state.set({\n      kind: 1,\n      value\n    }),\n    error: (error) => {\n      if (options?.rejectErrors) {\n        throw error;\n      }\n      state.set({\n        kind: 2,\n        error\n      });\n    }\n    // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n    // \"complete\".\n  });\n  if (options?.requireSync && state().kind === 0) {\n    throw new RuntimeError(601, (typeof ngDevMode === \"undefined\" || ngDevMode) && \"`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.\");\n  }\n  cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n  return computed(() => {\n    const current = state();\n    switch (current.kind) {\n      case 1:\n        return current.value;\n      case 2:\n        throw current.error;\n      case 0:\n        throw new RuntimeError(601, (typeof ngDevMode === \"undefined\" || ngDevMode) && \"`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.\");\n    }\n  }, {\n    equal: options?.equal\n  });\n}\nfunction makeToSignalEqual(userEquality = Object.is) {\n  return (a, b) => a.kind === 1 && b.kind === 1 && userEquality(a.value, b.value);\n}\n\n// node_modules/@ngrx/store/fesm2022/ngrx-store.mjs\nvar REGISTERED_ACTION_TYPES = {};\nfunction createAction(type, config) {\n  REGISTERED_ACTION_TYPES[type] = (REGISTERED_ACTION_TYPES[type] || 0) + 1;\n  if (typeof config === \"function\") {\n    return defineType(type, (...args) => __spreadProps(__spreadValues({}, config(...args)), {\n      type\n    }));\n  }\n  const as = config ? config._as : \"empty\";\n  switch (as) {\n    case \"empty\":\n      return defineType(type, () => ({\n        type\n      }));\n    case \"props\":\n      return defineType(type, (props2) => __spreadProps(__spreadValues({}, props2), {\n        type\n      }));\n    default:\n      throw new Error(\"Unexpected config.\");\n  }\n}\nfunction props() {\n  return {\n    _as: \"props\",\n    _p: void 0\n  };\n}\nfunction union(creators) {\n  return void 0;\n}\nfunction defineType(type, creator) {\n  return Object.defineProperty(creator, \"type\", {\n    value: type,\n    writable: false\n  });\n}\nfunction capitalize(text) {\n  return text.charAt(0).toUpperCase() + text.substring(1);\n}\nfunction uncapitalize(text) {\n  return text.charAt(0).toLowerCase() + text.substring(1);\n}\nfunction assertDefined(value, name) {\n  if (value === null || value === void 0) {\n    throw new Error(`${name} must be defined.`);\n  }\n}\nfunction createActionGroup(config) {\n  const {\n    source,\n    events\n  } = config;\n  return Object.keys(events).reduce((actionGroup, eventName) => __spreadProps(__spreadValues({}, actionGroup), {\n    [toActionName(eventName)]: createAction(toActionType(source, eventName), events[eventName])\n  }), {});\n}\nfunction emptyProps() {\n  return props();\n}\nfunction toActionName(eventName) {\n  return eventName.trim().split(\" \").map((word, i) => i === 0 ? uncapitalize(word) : capitalize(word)).join(\"\");\n}\nfunction toActionType(source, eventName) {\n  return `[${source}] ${eventName}`;\n}\nvar INIT = \"@ngrx/store/init\";\nvar ActionsSubject = class _ActionsSubject extends BehaviorSubject {\n  constructor() {\n    super({\n      type: INIT\n    });\n  }\n  next(action) {\n    if (typeof action === \"function\") {\n      throw new TypeError(`\n        Dispatch expected an object, instead it received a function.\n        If you're using the createAction function, make sure to invoke the function\n        before dispatching the action. For example, someAction should be someAction().`);\n    } else if (typeof action === \"undefined\") {\n      throw new TypeError(`Actions must be objects`);\n    } else if (typeof action.type === \"undefined\") {\n      throw new TypeError(`Actions must have a type property`);\n    }\n    super.next(action);\n  }\n  complete() {\n  }\n  ngOnDestroy() {\n    super.complete();\n  }\n  static {\n    this.ɵfac = function ActionsSubject_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _ActionsSubject)();\n    };\n  }\n  static {\n    this.ɵprov = ɵɵdefineInjectable({\n      token: _ActionsSubject,\n      factory: _ActionsSubject.ɵfac\n    });\n  }\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(ActionsSubject, [{\n    type: Injectable\n  }], () => [], null);\n})();\nvar ACTIONS_SUBJECT_PROVIDERS = [ActionsSubject];\nvar _ROOT_STORE_GUARD = new InjectionToken(\"@ngrx/store Internal Root Guard\");\nvar _INITIAL_STATE = new InjectionToken(\"@ngrx/store Internal Initial State\");\nvar INITIAL_STATE = new InjectionToken(\"@ngrx/store Initial State\");\nvar REDUCER_FACTORY = new InjectionToken(\"@ngrx/store Reducer Factory\");\nvar _REDUCER_FACTORY = new InjectionToken(\"@ngrx/store Internal Reducer Factory Provider\");\nvar INITIAL_REDUCERS = new InjectionToken(\"@ngrx/store Initial Reducers\");\nvar _INITIAL_REDUCERS = new InjectionToken(\"@ngrx/store Internal Initial Reducers\");\nvar STORE_FEATURES = new InjectionToken(\"@ngrx/store Store Features\");\nvar _STORE_REDUCERS = new InjectionToken(\"@ngrx/store Internal Store Reducers\");\nvar _FEATURE_REDUCERS = new InjectionToken(\"@ngrx/store Internal Feature Reducers\");\nvar _FEATURE_CONFIGS = new InjectionToken(\"@ngrx/store Internal Feature Configs\");\nvar _STORE_FEATURES = new InjectionToken(\"@ngrx/store Internal Store Features\");\nvar _FEATURE_REDUCERS_TOKEN = new InjectionToken(\"@ngrx/store Internal Feature Reducers Token\");\nvar FEATURE_REDUCERS = new InjectionToken(\"@ngrx/store Feature Reducers\");\nvar USER_PROVIDED_META_REDUCERS = new InjectionToken(\"@ngrx/store User Provided Meta Reducers\");\nvar META_REDUCERS = new InjectionToken(\"@ngrx/store Meta Reducers\");\nvar _RESOLVED_META_REDUCERS = new InjectionToken(\"@ngrx/store Internal Resolved Meta Reducers\");\nvar USER_RUNTIME_CHECKS = new InjectionToken(\"@ngrx/store User Runtime Checks Config\");\nvar _USER_RUNTIME_CHECKS = new InjectionToken(\"@ngrx/store Internal User Runtime Checks Config\");\nvar ACTIVE_RUNTIME_CHECKS = new InjectionToken(\"@ngrx/store Internal Runtime Checks\");\nvar _ACTION_TYPE_UNIQUENESS_CHECK = new InjectionToken(\"@ngrx/store Check if Action types are unique\");\nvar ROOT_STORE_PROVIDER = new InjectionToken(\"@ngrx/store Root Store Provider\");\nvar FEATURE_STATE_PROVIDER = new InjectionToken(\"@ngrx/store Feature State Provider\");\nfunction combineReducers(reducers, initialState = {}) {\n  const reducerKeys = Object.keys(reducers);\n  const finalReducers = {};\n  for (let i = 0; i < reducerKeys.length; i++) {\n    const key = reducerKeys[i];\n    if (typeof reducers[key] === \"function\") {\n      finalReducers[key] = reducers[key];\n    }\n  }\n  const finalReducerKeys = Object.keys(finalReducers);\n  return function combination(state, action) {\n    state = state === void 0 ? initialState : state;\n    let hasChanged = false;\n    const nextState = {};\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i];\n      const reducer = finalReducers[key];\n      const previousStateForKey = state[key];\n      const nextStateForKey = reducer(previousStateForKey, action);\n      nextState[key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n    return hasChanged ? nextState : state;\n  };\n}\nfunction omit(object, keyToRemove) {\n  return Object.keys(object).filter((key) => key !== keyToRemove).reduce((result, key) => Object.assign(result, {\n    [key]: object[key]\n  }), {});\n}\nfunction compose(...functions) {\n  return function(arg) {\n    if (functions.length === 0) {\n      return arg;\n    }\n    const last = functions[functions.length - 1];\n    const rest = functions.slice(0, -1);\n    return rest.reduceRight((composed, fn) => fn(composed), last(arg));\n  };\n}\nfunction createReducerFactory(reducerFactory, metaReducers) {\n  if (Array.isArray(metaReducers) && metaReducers.length > 0) {\n    reducerFactory = compose.apply(null, [...metaReducers, reducerFactory]);\n  }\n  return (reducers, initialState) => {\n    const reducer = reducerFactory(reducers);\n    return (state, action) => {\n      state = state === void 0 ? initialState : state;\n      return reducer(state, action);\n    };\n  };\n}\nfunction createFeatureReducerFactory(metaReducers) {\n  const reducerFactory = Array.isArray(metaReducers) && metaReducers.length > 0 ? compose(...metaReducers) : (r) => r;\n  return (reducer, initialState) => {\n    reducer = reducerFactory(reducer);\n    return (state, action) => {\n      state = state === void 0 ? initialState : state;\n      return reducer(state, action);\n    };\n  };\n}\nvar ReducerObservable = class extends Observable {\n};\nvar ReducerManagerDispatcher = class extends ActionsSubject {\n};\nvar UPDATE = \"@ngrx/store/update-reducers\";\nvar ReducerManager = class _ReducerManager extends BehaviorSubject {\n  get currentReducers() {\n    return this.reducers;\n  }\n  constructor(dispatcher, initialState, reducers, reducerFactory) {\n    super(reducerFactory(reducers, initialState));\n    this.dispatcher = dispatcher;\n    this.initialState = initialState;\n    this.reducers = reducers;\n    this.reducerFactory = reducerFactory;\n  }\n  addFeature(feature) {\n    this.addFeatures([feature]);\n  }\n  addFeatures(features) {\n    const reducers = features.reduce((reducerDict, {\n      reducers: reducers2,\n      reducerFactory,\n      metaReducers,\n      initialState,\n      key\n    }) => {\n      const reducer = typeof reducers2 === \"function\" ? createFeatureReducerFactory(metaReducers)(reducers2, initialState) : createReducerFactory(reducerFactory, metaReducers)(reducers2, initialState);\n      reducerDict[key] = reducer;\n      return reducerDict;\n    }, {});\n    this.addReducers(reducers);\n  }\n  removeFeature(feature) {\n    this.removeFeatures([feature]);\n  }\n  removeFeatures(features) {\n    this.removeReducers(features.map((p) => p.key));\n  }\n  addReducer(key, reducer) {\n    this.addReducers({\n      [key]: reducer\n    });\n  }\n  addReducers(reducers) {\n    this.reducers = __spreadValues(__spreadValues({}, this.reducers), reducers);\n    this.updateReducers(Object.keys(reducers));\n  }\n  removeReducer(featureKey) {\n    this.removeReducers([featureKey]);\n  }\n  removeReducers(featureKeys) {\n    featureKeys.forEach((key) => {\n      this.reducers = omit(this.reducers, key);\n    });\n    this.updateReducers(featureKeys);\n  }\n  updateReducers(featureKeys) {\n    this.next(this.reducerFactory(this.reducers, this.initialState));\n    this.dispatcher.next({\n      type: UPDATE,\n      features: featureKeys\n    });\n  }\n  ngOnDestroy() {\n    this.complete();\n  }\n  static {\n    this.ɵfac = function ReducerManager_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _ReducerManager)(ɵɵinject(ReducerManagerDispatcher), ɵɵinject(INITIAL_STATE), ɵɵinject(INITIAL_REDUCERS), ɵɵinject(REDUCER_FACTORY));\n    };\n  }\n  static {\n    this.ɵprov = ɵɵdefineInjectable({\n      token: _ReducerManager,\n      factory: _ReducerManager.ɵfac\n    });\n  }\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(ReducerManager, [{\n    type: Injectable\n  }], () => [{\n    type: ReducerManagerDispatcher\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [INITIAL_STATE]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [INITIAL_REDUCERS]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [REDUCER_FACTORY]\n    }]\n  }], null);\n})();\nvar REDUCER_MANAGER_PROVIDERS = [ReducerManager, {\n  provide: ReducerObservable,\n  useExisting: ReducerManager\n}, {\n  provide: ReducerManagerDispatcher,\n  useExisting: ActionsSubject\n}];\nvar ScannedActionsSubject = class _ScannedActionsSubject extends Subject {\n  ngOnDestroy() {\n    this.complete();\n  }\n  static {\n    this.ɵfac = /* @__PURE__ */ (() => {\n      let ɵScannedActionsSubject_BaseFactory;\n      return function ScannedActionsSubject_Factory(__ngFactoryType__) {\n        return (ɵScannedActionsSubject_BaseFactory || (ɵScannedActionsSubject_BaseFactory = ɵɵgetInheritedFactory(_ScannedActionsSubject)))(__ngFactoryType__ || _ScannedActionsSubject);\n      };\n    })();\n  }\n  static {\n    this.ɵprov = ɵɵdefineInjectable({\n      token: _ScannedActionsSubject,\n      factory: _ScannedActionsSubject.ɵfac\n    });\n  }\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(ScannedActionsSubject, [{\n    type: Injectable\n  }], null, null);\n})();\nvar SCANNED_ACTIONS_SUBJECT_PROVIDERS = [ScannedActionsSubject];\nvar StateObservable = class extends Observable {\n};\nvar State = class _State extends BehaviorSubject {\n  static {\n    this.INIT = INIT;\n  }\n  constructor(actions$, reducer$, scannedActions, initialState) {\n    super(initialState);\n    const actionsOnQueue$ = actions$.pipe(observeOn(queueScheduler));\n    const withLatestReducer$ = actionsOnQueue$.pipe(withLatestFrom(reducer$));\n    const seed = {\n      state: initialState\n    };\n    const stateAndAction$ = withLatestReducer$.pipe(scan(reduceState, seed));\n    this.stateSubscription = stateAndAction$.subscribe(({\n      state,\n      action\n    }) => {\n      this.next(state);\n      scannedActions.next(action);\n    });\n    this.state = toSignal(this, {\n      manualCleanup: true,\n      requireSync: true\n    });\n  }\n  ngOnDestroy() {\n    this.stateSubscription.unsubscribe();\n    this.complete();\n  }\n  static {\n    this.ɵfac = function State_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _State)(ɵɵinject(ActionsSubject), ɵɵinject(ReducerObservable), ɵɵinject(ScannedActionsSubject), ɵɵinject(INITIAL_STATE));\n    };\n  }\n  static {\n    this.ɵprov = ɵɵdefineInjectable({\n      token: _State,\n      factory: _State.ɵfac\n    });\n  }\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(State, [{\n    type: Injectable\n  }], () => [{\n    type: ActionsSubject\n  }, {\n    type: ReducerObservable\n  }, {\n    type: ScannedActionsSubject\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [INITIAL_STATE]\n    }]\n  }], null);\n})();\nfunction reduceState(stateActionPair = {\n  state: void 0\n}, [action, reducer]) {\n  const {\n    state\n  } = stateActionPair;\n  return {\n    state: reducer(state, action),\n    action\n  };\n}\nvar STATE_PROVIDERS = [State, {\n  provide: StateObservable,\n  useExisting: State\n}];\nvar Store = class _Store extends Observable {\n  constructor(state$, actionsObserver, reducerManager, injector) {\n    super();\n    this.actionsObserver = actionsObserver;\n    this.reducerManager = reducerManager;\n    this.injector = injector;\n    this.source = state$;\n    this.state = state$.state;\n  }\n  select(pathOrMapFn, ...paths) {\n    return select.call(null, pathOrMapFn, ...paths)(this);\n  }\n  /**\n   * Returns a signal of the provided selector.\n   *\n   * @param selector selector function\n   * @param options select signal options\n   */\n  selectSignal(selector, options) {\n    return computed(() => selector(this.state()), options);\n  }\n  lift(operator) {\n    const store = new _Store(this, this.actionsObserver, this.reducerManager);\n    store.operator = operator;\n    return store;\n  }\n  dispatch(actionOrDispatchFn, config) {\n    if (typeof actionOrDispatchFn === \"function\") {\n      return this.processDispatchFn(actionOrDispatchFn, config);\n    }\n    this.actionsObserver.next(actionOrDispatchFn);\n  }\n  next(action) {\n    this.actionsObserver.next(action);\n  }\n  error(err) {\n    this.actionsObserver.error(err);\n  }\n  complete() {\n    this.actionsObserver.complete();\n  }\n  addReducer(key, reducer) {\n    this.reducerManager.addReducer(key, reducer);\n  }\n  removeReducer(key) {\n    this.reducerManager.removeReducer(key);\n  }\n  processDispatchFn(dispatchFn, config) {\n    assertDefined(this.injector, \"Store Injector\");\n    const effectInjector = config?.injector ?? getCallerInjector() ?? this.injector;\n    return effect(() => {\n      const action = dispatchFn();\n      untracked(() => this.dispatch(action));\n    }, {\n      injector: effectInjector\n    });\n  }\n  static {\n    this.ɵfac = function Store_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _Store)(ɵɵinject(StateObservable), ɵɵinject(ActionsSubject), ɵɵinject(ReducerManager), ɵɵinject(Injector));\n    };\n  }\n  static {\n    this.ɵprov = ɵɵdefineInjectable({\n      token: _Store,\n      factory: _Store.ɵfac\n    });\n  }\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(Store, [{\n    type: Injectable\n  }], () => [{\n    type: StateObservable\n  }, {\n    type: ActionsSubject\n  }, {\n    type: ReducerManager\n  }, {\n    type: Injector\n  }], null);\n})();\nvar STORE_PROVIDERS = [Store];\nfunction select(pathOrMapFn, propsOrPath, ...paths) {\n  return function selectOperator(source$) {\n    let mapped$;\n    if (typeof pathOrMapFn === \"string\") {\n      const pathSlices = [propsOrPath, ...paths].filter(Boolean);\n      mapped$ = source$.pipe(pluck(pathOrMapFn, ...pathSlices));\n    } else if (typeof pathOrMapFn === \"function\") {\n      mapped$ = source$.pipe(map((source) => pathOrMapFn(source, propsOrPath)));\n    } else {\n      throw new TypeError(`Unexpected type '${typeof pathOrMapFn}' in select operator, expected 'string' or 'function'`);\n    }\n    return mapped$.pipe(distinctUntilChanged());\n  };\n}\nfunction getCallerInjector() {\n  try {\n    return inject(Injector);\n  } catch (_) {\n    return void 0;\n  }\n}\nvar RUNTIME_CHECK_URL = \"https://ngrx.io/guide/store/configuration/runtime-checks\";\nfunction isUndefined(target) {\n  return target === void 0;\n}\nfunction isNull(target) {\n  return target === null;\n}\nfunction isArray(target) {\n  return Array.isArray(target);\n}\nfunction isString(target) {\n  return typeof target === \"string\";\n}\nfunction isBoolean(target) {\n  return typeof target === \"boolean\";\n}\nfunction isNumber(target) {\n  return typeof target === \"number\";\n}\nfunction isObjectLike(target) {\n  return typeof target === \"object\" && target !== null;\n}\nfunction isObject(target) {\n  return isObjectLike(target) && !isArray(target);\n}\nfunction isPlainObject(target) {\n  if (!isObject(target)) {\n    return false;\n  }\n  const targetPrototype = Object.getPrototypeOf(target);\n  return targetPrototype === Object.prototype || targetPrototype === null;\n}\nfunction isFunction(target) {\n  return typeof target === \"function\";\n}\nfunction isComponent(target) {\n  return isFunction(target) && target.hasOwnProperty(\"ɵcmp\");\n}\nfunction hasOwnProperty(target, propertyName) {\n  return Object.prototype.hasOwnProperty.call(target, propertyName);\n}\nvar _ngrxMockEnvironment = false;\nfunction setNgrxMockEnvironment(value) {\n  _ngrxMockEnvironment = value;\n}\nfunction isNgrxMockEnvironment() {\n  return _ngrxMockEnvironment;\n}\nfunction isEqualCheck(a, b) {\n  return a === b;\n}\nfunction isArgumentsChanged(args, lastArguments, comparator) {\n  for (let i = 0; i < args.length; i++) {\n    if (!comparator(args[i], lastArguments[i])) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction resultMemoize(projectionFn, isResultEqual) {\n  return defaultMemoize(projectionFn, isEqualCheck, isResultEqual);\n}\nfunction defaultMemoize(projectionFn, isArgumentsEqual = isEqualCheck, isResultEqual = isEqualCheck) {\n  let lastArguments = null;\n  let lastResult = null;\n  let overrideResult;\n  function reset() {\n    lastArguments = null;\n    lastResult = null;\n  }\n  function setResult(result = void 0) {\n    overrideResult = {\n      result\n    };\n  }\n  function clearResult() {\n    overrideResult = void 0;\n  }\n  function memoized() {\n    if (overrideResult !== void 0) {\n      return overrideResult.result;\n    }\n    if (!lastArguments) {\n      lastResult = projectionFn.apply(null, arguments);\n      lastArguments = arguments;\n      return lastResult;\n    }\n    if (!isArgumentsChanged(arguments, lastArguments, isArgumentsEqual)) {\n      return lastResult;\n    }\n    const newResult = projectionFn.apply(null, arguments);\n    lastArguments = arguments;\n    if (isResultEqual(lastResult, newResult)) {\n      return lastResult;\n    }\n    lastResult = newResult;\n    return newResult;\n  }\n  return {\n    memoized,\n    reset,\n    setResult,\n    clearResult\n  };\n}\nfunction createSelector(...input) {\n  return createSelectorFactory(defaultMemoize)(...input);\n}\nfunction defaultStateFn(state, selectors, props2, memoizedProjector) {\n  if (props2 === void 0) {\n    const args2 = selectors.map((fn) => fn(state));\n    return memoizedProjector.memoized.apply(null, args2);\n  }\n  const args = selectors.map((fn) => fn(state, props2));\n  return memoizedProjector.memoized.apply(null, [...args, props2]);\n}\nfunction createSelectorFactory(memoize, options = {\n  stateFn: defaultStateFn\n}) {\n  return function(...input) {\n    let args = input;\n    if (Array.isArray(args[0])) {\n      const [head, ...tail] = args;\n      args = [...head, ...tail];\n    } else if (args.length === 1 && isSelectorsDictionary(args[0])) {\n      args = extractArgsFromSelectorsDictionary(args[0]);\n    }\n    const selectors = args.slice(0, args.length - 1);\n    const projector = args[args.length - 1];\n    const memoizedSelectors = selectors.filter((selector) => selector.release && typeof selector.release === \"function\");\n    const memoizedProjector = memoize(function(...selectors2) {\n      return projector.apply(null, selectors2);\n    });\n    const memoizedState = defaultMemoize(function(state, props2) {\n      return options.stateFn.apply(null, [state, selectors, props2, memoizedProjector]);\n    });\n    function release() {\n      memoizedState.reset();\n      memoizedProjector.reset();\n      memoizedSelectors.forEach((selector) => selector.release());\n    }\n    return Object.assign(memoizedState.memoized, {\n      release,\n      projector: memoizedProjector.memoized,\n      setResult: memoizedState.setResult,\n      clearResult: memoizedState.clearResult\n    });\n  };\n}\nfunction createFeatureSelector(featureName) {\n  return createSelector((state) => {\n    const featureState = state[featureName];\n    if (!isNgrxMockEnvironment() && isDevMode() && !(featureName in state)) {\n      console.warn(`@ngrx/store: The feature name \"${featureName}\" does not exist in the state, therefore createFeatureSelector cannot access it.  Be sure it is imported in a loaded module using StoreModule.forRoot('${featureName}', ...) or StoreModule.forFeature('${featureName}', ...).  If the default state is intended to be undefined, as is the case with router state, this development-only warning message can be ignored.`);\n    }\n    return featureState;\n  }, (featureState) => featureState);\n}\nfunction isSelectorsDictionary(selectors) {\n  return !!selectors && typeof selectors === \"object\" && Object.values(selectors).every((selector) => typeof selector === \"function\");\n}\nfunction extractArgsFromSelectorsDictionary(selectorsDictionary) {\n  const selectors = Object.values(selectorsDictionary);\n  const resultKeys = Object.keys(selectorsDictionary);\n  const projector = (...selectorResults) => resultKeys.reduce((result, key, index) => __spreadProps(__spreadValues({}, result), {\n    [key]: selectorResults[index]\n  }), {});\n  return [...selectors, projector];\n}\nfunction createFeature(featureConfig) {\n  const {\n    name,\n    reducer,\n    extraSelectors: extraSelectorsFactory\n  } = featureConfig;\n  const featureSelector = createFeatureSelector(name);\n  const nestedSelectors = createNestedSelectors(featureSelector, reducer);\n  const baseSelectors = __spreadValues({\n    [`select${capitalize(name)}State`]: featureSelector\n  }, nestedSelectors);\n  const extraSelectors = extraSelectorsFactory ? extraSelectorsFactory(baseSelectors) : {};\n  return __spreadValues(__spreadValues({\n    name,\n    reducer\n  }, baseSelectors), extraSelectors);\n}\nfunction createNestedSelectors(featureSelector, reducer) {\n  const initialState = getInitialState(reducer);\n  const nestedKeys = isPlainObject(initialState) ? Object.keys(initialState) : [];\n  return nestedKeys.reduce((nestedSelectors, nestedKey) => __spreadProps(__spreadValues({}, nestedSelectors), {\n    [`select${capitalize(nestedKey)}`]: createSelector(featureSelector, (parentState) => parentState?.[nestedKey])\n  }), {});\n}\nfunction getInitialState(reducer) {\n  return reducer(void 0, {\n    type: \"@ngrx/feature/init\"\n  });\n}\nfunction _createStoreReducers(reducers) {\n  return reducers instanceof InjectionToken ? inject(reducers) : reducers;\n}\nfunction _createFeatureStore(configs, featureStores) {\n  return featureStores.map((feat, index) => {\n    if (configs[index] instanceof InjectionToken) {\n      const conf = inject(configs[index]);\n      return {\n        key: feat.key,\n        reducerFactory: conf.reducerFactory ? conf.reducerFactory : combineReducers,\n        metaReducers: conf.metaReducers ? conf.metaReducers : [],\n        initialState: conf.initialState\n      };\n    }\n    return feat;\n  });\n}\nfunction _createFeatureReducers(reducerCollection) {\n  return reducerCollection.map((reducer) => {\n    return reducer instanceof InjectionToken ? inject(reducer) : reducer;\n  });\n}\nfunction _initialStateFactory(initialState) {\n  if (typeof initialState === \"function\") {\n    return initialState();\n  }\n  return initialState;\n}\nfunction _concatMetaReducers(metaReducers, userProvidedMetaReducers) {\n  return metaReducers.concat(userProvidedMetaReducers);\n}\nfunction _provideForRootGuard() {\n  const store = inject(Store, {\n    optional: true,\n    skipSelf: true\n  });\n  if (store) {\n    throw new TypeError(`The root Store has been provided more than once. Feature modules should provide feature states instead.`);\n  }\n  return \"guarded\";\n}\nfunction immutabilityCheckMetaReducer(reducer, checks) {\n  return function(state, action) {\n    const act = checks.action(action) ? freeze(action) : action;\n    const nextState = reducer(state, act);\n    return checks.state() ? freeze(nextState) : nextState;\n  };\n}\nfunction freeze(target) {\n  Object.freeze(target);\n  const targetIsFunction = isFunction(target);\n  Object.getOwnPropertyNames(target).forEach((prop) => {\n    if (prop.startsWith(\"ɵ\")) {\n      return;\n    }\n    if (hasOwnProperty(target, prop) && (targetIsFunction ? prop !== \"caller\" && prop !== \"callee\" && prop !== \"arguments\" : true)) {\n      const propValue = target[prop];\n      if ((isObjectLike(propValue) || isFunction(propValue)) && !Object.isFrozen(propValue)) {\n        freeze(propValue);\n      }\n    }\n  });\n  return target;\n}\nfunction serializationCheckMetaReducer(reducer, checks) {\n  return function(state, action) {\n    if (checks.action(action)) {\n      const unserializableAction = getUnserializable(action);\n      throwIfUnserializable(unserializableAction, \"action\");\n    }\n    const nextState = reducer(state, action);\n    if (checks.state()) {\n      const unserializableState = getUnserializable(nextState);\n      throwIfUnserializable(unserializableState, \"state\");\n    }\n    return nextState;\n  };\n}\nfunction getUnserializable(target, path = []) {\n  if ((isUndefined(target) || isNull(target)) && path.length === 0) {\n    return {\n      path: [\"root\"],\n      value: target\n    };\n  }\n  const keys = Object.keys(target);\n  return keys.reduce((result, key) => {\n    if (result) {\n      return result;\n    }\n    const value = target[key];\n    if (isComponent(value)) {\n      return result;\n    }\n    if (isUndefined(value) || isNull(value) || isNumber(value) || isBoolean(value) || isString(value) || isArray(value)) {\n      return false;\n    }\n    if (isPlainObject(value)) {\n      return getUnserializable(value, [...path, key]);\n    }\n    return {\n      path: [...path, key],\n      value\n    };\n  }, false);\n}\nfunction throwIfUnserializable(unserializable, context) {\n  if (unserializable === false) {\n    return;\n  }\n  const unserializablePath = unserializable.path.join(\".\");\n  const error = new Error(`Detected unserializable ${context} at \"${unserializablePath}\". ${RUNTIME_CHECK_URL}#strict${context}serializability`);\n  error.value = unserializable.value;\n  error.unserializablePath = unserializablePath;\n  throw error;\n}\nfunction inNgZoneAssertMetaReducer(reducer, checks) {\n  return function(state, action) {\n    if (checks.action(action) && !NgZone.isInAngularZone()) {\n      throw new Error(`Action '${action.type}' running outside NgZone. ${RUNTIME_CHECK_URL}#strictactionwithinngzone`);\n    }\n    return reducer(state, action);\n  };\n}\nfunction createActiveRuntimeChecks(runtimeChecks) {\n  if (isDevMode()) {\n    return __spreadValues({\n      strictStateSerializability: false,\n      strictActionSerializability: false,\n      strictStateImmutability: true,\n      strictActionImmutability: true,\n      strictActionWithinNgZone: false,\n      strictActionTypeUniqueness: false\n    }, runtimeChecks);\n  }\n  return {\n    strictStateSerializability: false,\n    strictActionSerializability: false,\n    strictStateImmutability: false,\n    strictActionImmutability: false,\n    strictActionWithinNgZone: false,\n    strictActionTypeUniqueness: false\n  };\n}\nfunction createSerializationCheckMetaReducer({\n  strictActionSerializability,\n  strictStateSerializability\n}) {\n  return (reducer) => strictActionSerializability || strictStateSerializability ? serializationCheckMetaReducer(reducer, {\n    action: (action) => strictActionSerializability && !ignoreNgrxAction(action),\n    state: () => strictStateSerializability\n  }) : reducer;\n}\nfunction createImmutabilityCheckMetaReducer({\n  strictActionImmutability,\n  strictStateImmutability\n}) {\n  return (reducer) => strictActionImmutability || strictStateImmutability ? immutabilityCheckMetaReducer(reducer, {\n    action: (action) => strictActionImmutability && !ignoreNgrxAction(action),\n    state: () => strictStateImmutability\n  }) : reducer;\n}\nfunction ignoreNgrxAction(action) {\n  return action.type.startsWith(\"@ngrx\");\n}\nfunction createInNgZoneCheckMetaReducer({\n  strictActionWithinNgZone\n}) {\n  return (reducer) => strictActionWithinNgZone ? inNgZoneAssertMetaReducer(reducer, {\n    action: (action) => strictActionWithinNgZone && !ignoreNgrxAction(action)\n  }) : reducer;\n}\nfunction provideRuntimeChecks(runtimeChecks) {\n  return [{\n    provide: _USER_RUNTIME_CHECKS,\n    useValue: runtimeChecks\n  }, {\n    provide: USER_RUNTIME_CHECKS,\n    useFactory: _runtimeChecksFactory,\n    deps: [_USER_RUNTIME_CHECKS]\n  }, {\n    provide: ACTIVE_RUNTIME_CHECKS,\n    deps: [USER_RUNTIME_CHECKS],\n    useFactory: createActiveRuntimeChecks\n  }, {\n    provide: META_REDUCERS,\n    multi: true,\n    deps: [ACTIVE_RUNTIME_CHECKS],\n    useFactory: createImmutabilityCheckMetaReducer\n  }, {\n    provide: META_REDUCERS,\n    multi: true,\n    deps: [ACTIVE_RUNTIME_CHECKS],\n    useFactory: createSerializationCheckMetaReducer\n  }, {\n    provide: META_REDUCERS,\n    multi: true,\n    deps: [ACTIVE_RUNTIME_CHECKS],\n    useFactory: createInNgZoneCheckMetaReducer\n  }];\n}\nfunction checkForActionTypeUniqueness() {\n  return [{\n    provide: _ACTION_TYPE_UNIQUENESS_CHECK,\n    multi: true,\n    deps: [ACTIVE_RUNTIME_CHECKS],\n    useFactory: _actionTypeUniquenessCheck\n  }];\n}\nfunction _runtimeChecksFactory(runtimeChecks) {\n  return runtimeChecks;\n}\nfunction _actionTypeUniquenessCheck(config) {\n  if (!config.strictActionTypeUniqueness) {\n    return;\n  }\n  const duplicates = Object.entries(REGISTERED_ACTION_TYPES).filter(([, registrations]) => registrations > 1).map(([type]) => type);\n  if (duplicates.length) {\n    throw new Error(`Action types are registered more than once, ${duplicates.map((type) => `\"${type}\"`).join(\", \")}. ${RUNTIME_CHECK_URL}#strictactiontypeuniqueness`);\n  }\n}\nfunction provideState(featureNameOrSlice, reducers, config = {}) {\n  return makeEnvironmentProviders([..._provideState(featureNameOrSlice, reducers, config), ENVIRONMENT_STATE_PROVIDER]);\n}\nfunction _provideStore(reducers = {}, config = {}) {\n  return [{\n    provide: _ROOT_STORE_GUARD,\n    useFactory: _provideForRootGuard\n  }, {\n    provide: _INITIAL_STATE,\n    useValue: config.initialState\n  }, {\n    provide: INITIAL_STATE,\n    useFactory: _initialStateFactory,\n    deps: [_INITIAL_STATE]\n  }, {\n    provide: _INITIAL_REDUCERS,\n    useValue: reducers\n  }, {\n    provide: _STORE_REDUCERS,\n    useExisting: reducers instanceof InjectionToken ? reducers : _INITIAL_REDUCERS\n  }, {\n    provide: INITIAL_REDUCERS,\n    deps: [_INITIAL_REDUCERS, [new Inject(_STORE_REDUCERS)]],\n    useFactory: _createStoreReducers\n  }, {\n    provide: USER_PROVIDED_META_REDUCERS,\n    useValue: config.metaReducers ? config.metaReducers : []\n  }, {\n    provide: _RESOLVED_META_REDUCERS,\n    deps: [META_REDUCERS, USER_PROVIDED_META_REDUCERS],\n    useFactory: _concatMetaReducers\n  }, {\n    provide: _REDUCER_FACTORY,\n    useValue: config.reducerFactory ? config.reducerFactory : combineReducers\n  }, {\n    provide: REDUCER_FACTORY,\n    deps: [_REDUCER_FACTORY, _RESOLVED_META_REDUCERS],\n    useFactory: createReducerFactory\n  }, ACTIONS_SUBJECT_PROVIDERS, REDUCER_MANAGER_PROVIDERS, SCANNED_ACTIONS_SUBJECT_PROVIDERS, STATE_PROVIDERS, STORE_PROVIDERS, provideRuntimeChecks(config.runtimeChecks), checkForActionTypeUniqueness()];\n}\nfunction rootStoreProviderFactory() {\n  inject(ActionsSubject);\n  inject(ReducerObservable);\n  inject(ScannedActionsSubject);\n  inject(Store);\n  inject(_ROOT_STORE_GUARD, {\n    optional: true\n  });\n  inject(_ACTION_TYPE_UNIQUENESS_CHECK, {\n    optional: true\n  });\n}\nvar ENVIRONMENT_STORE_PROVIDER = [{\n  provide: ROOT_STORE_PROVIDER,\n  useFactory: rootStoreProviderFactory\n}, {\n  provide: ENVIRONMENT_INITIALIZER,\n  multi: true,\n  useFactory() {\n    return () => inject(ROOT_STORE_PROVIDER);\n  }\n}];\nfunction provideStore(reducers, config) {\n  return makeEnvironmentProviders([..._provideStore(reducers, config), ENVIRONMENT_STORE_PROVIDER]);\n}\nfunction featureStateProviderFactory() {\n  inject(ROOT_STORE_PROVIDER);\n  const features = inject(_STORE_FEATURES);\n  const featureReducers = inject(FEATURE_REDUCERS);\n  const reducerManager = inject(ReducerManager);\n  inject(_ACTION_TYPE_UNIQUENESS_CHECK, {\n    optional: true\n  });\n  const feats = features.map((feature, index) => {\n    const featureReducerCollection = featureReducers.shift();\n    const reducers = featureReducerCollection[index];\n    return __spreadProps(__spreadValues({}, feature), {\n      reducers,\n      initialState: _initialStateFactory(feature.initialState)\n    });\n  });\n  reducerManager.addFeatures(feats);\n}\nvar ENVIRONMENT_STATE_PROVIDER = [{\n  provide: FEATURE_STATE_PROVIDER,\n  useFactory: featureStateProviderFactory\n}, {\n  provide: ENVIRONMENT_INITIALIZER,\n  multi: true,\n  useFactory() {\n    return () => inject(FEATURE_STATE_PROVIDER);\n  }\n}];\nfunction _provideState(featureNameOrSlice, reducers, config = {}) {\n  return [{\n    provide: _FEATURE_CONFIGS,\n    multi: true,\n    useValue: featureNameOrSlice instanceof Object ? {} : config\n  }, {\n    provide: STORE_FEATURES,\n    multi: true,\n    useValue: {\n      key: featureNameOrSlice instanceof Object ? featureNameOrSlice.name : featureNameOrSlice,\n      reducerFactory: !(config instanceof InjectionToken) && config.reducerFactory ? config.reducerFactory : combineReducers,\n      metaReducers: !(config instanceof InjectionToken) && config.metaReducers ? config.metaReducers : [],\n      initialState: !(config instanceof InjectionToken) && config.initialState ? config.initialState : void 0\n    }\n  }, {\n    provide: _STORE_FEATURES,\n    deps: [_FEATURE_CONFIGS, STORE_FEATURES],\n    useFactory: _createFeatureStore\n  }, {\n    provide: _FEATURE_REDUCERS,\n    multi: true,\n    useValue: featureNameOrSlice instanceof Object ? featureNameOrSlice.reducer : reducers\n  }, {\n    provide: _FEATURE_REDUCERS_TOKEN,\n    multi: true,\n    useExisting: reducers instanceof InjectionToken ? reducers : _FEATURE_REDUCERS\n  }, {\n    provide: FEATURE_REDUCERS,\n    multi: true,\n    deps: [_FEATURE_REDUCERS, [new Inject(_FEATURE_REDUCERS_TOKEN)]],\n    useFactory: _createFeatureReducers\n  }, checkForActionTypeUniqueness()];\n}\nvar StoreRootModule = class _StoreRootModule {\n  constructor(actions$, reducer$, scannedActions$, store, guard, actionCheck) {\n  }\n  static {\n    this.ɵfac = function StoreRootModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _StoreRootModule)(ɵɵinject(ActionsSubject), ɵɵinject(ReducerObservable), ɵɵinject(ScannedActionsSubject), ɵɵinject(Store), ɵɵinject(_ROOT_STORE_GUARD, 8), ɵɵinject(_ACTION_TYPE_UNIQUENESS_CHECK, 8));\n    };\n  }\n  static {\n    this.ɵmod = ɵɵdefineNgModule({\n      type: _StoreRootModule\n    });\n  }\n  static {\n    this.ɵinj = ɵɵdefineInjector({});\n  }\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(StoreRootModule, [{\n    type: NgModule,\n    args: [{}]\n  }], () => [{\n    type: ActionsSubject\n  }, {\n    type: ReducerObservable\n  }, {\n    type: ScannedActionsSubject\n  }, {\n    type: Store\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [_ROOT_STORE_GUARD]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [_ACTION_TYPE_UNIQUENESS_CHECK]\n    }]\n  }], null);\n})();\nvar StoreFeatureModule = class _StoreFeatureModule {\n  constructor(features, featureReducers, reducerManager, root, actionCheck) {\n    this.features = features;\n    this.featureReducers = featureReducers;\n    this.reducerManager = reducerManager;\n    const feats = features.map((feature, index) => {\n      const featureReducerCollection = featureReducers.shift();\n      const reducers = featureReducerCollection[index];\n      return __spreadProps(__spreadValues({}, feature), {\n        reducers,\n        initialState: _initialStateFactory(feature.initialState)\n      });\n    });\n    reducerManager.addFeatures(feats);\n  }\n  // eslint-disable-next-line @angular-eslint/contextual-lifecycle\n  ngOnDestroy() {\n    this.reducerManager.removeFeatures(this.features);\n  }\n  static {\n    this.ɵfac = function StoreFeatureModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _StoreFeatureModule)(ɵɵinject(_STORE_FEATURES), ɵɵinject(FEATURE_REDUCERS), ɵɵinject(ReducerManager), ɵɵinject(StoreRootModule), ɵɵinject(_ACTION_TYPE_UNIQUENESS_CHECK, 8));\n    };\n  }\n  static {\n    this.ɵmod = ɵɵdefineNgModule({\n      type: _StoreFeatureModule\n    });\n  }\n  static {\n    this.ɵinj = ɵɵdefineInjector({});\n  }\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(StoreFeatureModule, [{\n    type: NgModule,\n    args: [{}]\n  }], () => [{\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [_STORE_FEATURES]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [FEATURE_REDUCERS]\n    }]\n  }, {\n    type: ReducerManager\n  }, {\n    type: StoreRootModule\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [_ACTION_TYPE_UNIQUENESS_CHECK]\n    }]\n  }], null);\n})();\nvar StoreModule = class _StoreModule {\n  static forRoot(reducers, config) {\n    return {\n      ngModule: StoreRootModule,\n      providers: [..._provideStore(reducers, config)]\n    };\n  }\n  static forFeature(featureNameOrSlice, reducers, config = {}) {\n    return {\n      ngModule: StoreFeatureModule,\n      providers: [..._provideState(featureNameOrSlice, reducers, config)]\n    };\n  }\n  static {\n    this.ɵfac = function StoreModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _StoreModule)();\n    };\n  }\n  static {\n    this.ɵmod = ɵɵdefineNgModule({\n      type: _StoreModule\n    });\n  }\n  static {\n    this.ɵinj = ɵɵdefineInjector({});\n  }\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(StoreModule, [{\n    type: NgModule,\n    args: [{}]\n  }], null, null);\n})();\nfunction on(...args) {\n  const reducer = args.pop();\n  const types = args.map((creator) => creator.type);\n  return {\n    reducer,\n    types\n  };\n}\nfunction createReducer(initialState, ...ons) {\n  const map2 = /* @__PURE__ */ new Map();\n  for (const on2 of ons) {\n    for (const type of on2.types) {\n      const existingReducer = map2.get(type);\n      if (existingReducer) {\n        const newReducer = (state, action) => on2.reducer(existingReducer(state, action), action);\n        map2.set(type, newReducer);\n      } else {\n        map2.set(type, on2.reducer);\n      }\n    }\n  }\n  return function(state = initialState, action) {\n    const reducer = map2.get(action.type);\n    return reducer ? reducer(state, action) : state;\n  };\n}\n\nexport {\n  createAction,\n  props,\n  union,\n  createActionGroup,\n  emptyProps,\n  INIT,\n  ActionsSubject,\n  INITIAL_STATE,\n  REDUCER_FACTORY,\n  INITIAL_REDUCERS,\n  STORE_FEATURES,\n  FEATURE_REDUCERS,\n  USER_PROVIDED_META_REDUCERS,\n  META_REDUCERS,\n  USER_RUNTIME_CHECKS,\n  ACTIVE_RUNTIME_CHECKS,\n  ROOT_STORE_PROVIDER,\n  FEATURE_STATE_PROVIDER,\n  combineReducers,\n  compose,\n  createReducerFactory,\n  ReducerObservable,\n  ReducerManagerDispatcher,\n  UPDATE,\n  ReducerManager,\n  ScannedActionsSubject,\n  StateObservable,\n  State,\n  reduceState,\n  Store,\n  select,\n  setNgrxMockEnvironment,\n  isNgrxMockEnvironment,\n  resultMemoize,\n  defaultMemoize,\n  createSelector,\n  defaultStateFn,\n  createSelectorFactory,\n  createFeatureSelector,\n  createFeature,\n  provideState,\n  provideStore,\n  StoreRootModule,\n  StoreFeatureModule,\n  StoreModule,\n  on,\n  createReducer\n};\n/*! Bundled license information:\n\n@angular/core/fesm2022/rxjs-interop.mjs:\n  (**\n   * @license Angular v19.2.4\n   * (c) 2010-2025 Google LLC. https://angular.io/\n   * License: MIT\n   *)\n*/\n//# sourceMappingURL=chunk-LLD5PQMB.js.map\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\.angular\\cache\\19.2.5\\mortgage-app\\vite\\deps\\chunk-PEBH6BBU.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\.angular\\cache\\19.2.5\\mortgage-app\\vite\\deps\\chunk-TVYTA5MQ.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\.angular\\cache\\19.2.5\\mortgage-app\\vite\\deps\\chunk-WDMUDEB6.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\.angular\\cache\\19.2.5\\mortgage-app\\vite\\deps\\chunk-WPM5VTLQ.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\.angular\\cache\\19.2.5\\mortgage-app\\vite\\deps\\chunk-Z7RWVO2Z.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\.angular\\cache\\19.2.5\\mortgage-app\\vite\\deps\\ngx-toastr.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\.angular\\cache\\19.2.5\\mortgage-app\\vite\\deps\\rxjs.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\.angular\\cache\\19.2.5\\mortgage-app\\vite\\deps\\rxjs_operators.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\codesmell\\eslint-report.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\block-navigation.js","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported).","line":1,"column":1,"severity":1,"nodeType":null,"fix":{"range":[0,20],"text":" "}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"/* eslint-disable */\nvar jumpToCode = (function init() {\n    // Classes of code we would like to highlight in the file view\n    var missingCoverageClasses = ['.cbranch-no', '.cstat-no', '.fstat-no'];\n\n    // Elements to highlight in the file listing view\n    var fileListingElements = ['td.pct.low'];\n\n    // We don't want to select elements that are direct descendants of another match\n    var notSelector = ':not(' + missingCoverageClasses.join('):not(') + ') > '; // becomes `:not(a):not(b) > `\n\n    // Selecter that finds elements on the page to which we can jump\n    var selector =\n        fileListingElements.join(', ') +\n        ', ' +\n        notSelector +\n        missingCoverageClasses.join(', ' + notSelector); // becomes `:not(a):not(b) > a, :not(a):not(b) > b`\n\n    // The NodeList of matching elements\n    var missingCoverageElements = document.querySelectorAll(selector);\n\n    var currentIndex;\n\n    function toggleClass(index) {\n        missingCoverageElements\n            .item(currentIndex)\n            .classList.remove('highlighted');\n        missingCoverageElements.item(index).classList.add('highlighted');\n    }\n\n    function makeCurrent(index) {\n        toggleClass(index);\n        currentIndex = index;\n        missingCoverageElements.item(index).scrollIntoView({\n            behavior: 'smooth',\n            block: 'center',\n            inline: 'center'\n        });\n    }\n\n    function goToPrevious() {\n        var nextIndex = 0;\n        if (typeof currentIndex !== 'number' || currentIndex === 0) {\n            nextIndex = missingCoverageElements.length - 1;\n        } else if (missingCoverageElements.length > 1) {\n            nextIndex = currentIndex - 1;\n        }\n\n        makeCurrent(nextIndex);\n    }\n\n    function goToNext() {\n        var nextIndex = 0;\n\n        if (\n            typeof currentIndex === 'number' &&\n            currentIndex < missingCoverageElements.length - 1\n        ) {\n            nextIndex = currentIndex + 1;\n        }\n\n        makeCurrent(nextIndex);\n    }\n\n    return function jump(event) {\n        if (\n            document.getElementById('fileSearch') === document.activeElement &&\n            document.activeElement != null\n        ) {\n            // if we're currently focused on the search input, we don't want to navigate\n            return;\n        }\n\n        switch (event.which) {\n            case 78: // n\n            case 74: // j\n                goToNext();\n                break;\n            case 66: // b\n            case 75: // k\n            case 80: // p\n                goToPrevious();\n                break;\n        }\n    };\n})();\nwindow.addEventListener('keydown', jumpToCode);\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\index.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\prettify.js","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported).","line":1,"column":1,"severity":1,"nodeType":null,"fix":{"range":[0,20],"text":" "}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"/* eslint-disable */\nwindow.PR_SHOULD_USE_CONTINUATION=true;(function(){var h=[\"break,continue,do,else,for,if,return,while\"];var u=[h,\"auto,case,char,const,default,double,enum,extern,float,goto,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile\"];var p=[u,\"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof\"];var l=[p,\"alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,dynamic_cast,explicit,export,friend,inline,late_check,mutable,namespace,nullptr,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where\"];var x=[p,\"abstract,boolean,byte,extends,final,finally,implements,import,instanceof,null,native,package,strictfp,super,synchronized,throws,transient\"];var R=[x,\"as,base,by,checked,decimal,delegate,descending,dynamic,event,fixed,foreach,from,group,implicit,in,interface,internal,into,is,lock,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var\"];var r=\"all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,true,try,unless,until,when,while,yes\";var w=[p,\"debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN\"];var s=\"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END\";var I=[h,\"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None\"];var f=[h,\"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END\"];var H=[h,\"case,done,elif,esac,eval,fi,function,in,local,set,then,until\"];var A=[l,R,w,s+I,f,H];var e=/^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\\d*)/;var C=\"str\";var z=\"kwd\";var j=\"com\";var O=\"typ\";var G=\"lit\";var L=\"pun\";var F=\"pln\";var m=\"tag\";var E=\"dec\";var J=\"src\";var P=\"atn\";var n=\"atv\";var N=\"nocode\";var M=\"(?:^^\\\\.?|[+-]|\\\\!|\\\\!=|\\\\!==|\\\\#|\\\\%|\\\\%=|&|&&|&&=|&=|\\\\(|\\\\*|\\\\*=|\\\\+=|\\\\,|\\\\-=|\\\\->|\\\\/|\\\\/=|:|::|\\\\;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\\\?|\\\\@|\\\\[|\\\\^|\\\\^=|\\\\^\\\\^|\\\\^\\\\^=|\\\\{|\\\\||\\\\|=|\\\\|\\\\||\\\\|\\\\|=|\\\\~|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\\\s*\";function k(Z){var ad=0;var S=false;var ac=false;for(var V=0,U=Z.length;V<U;++V){var ae=Z[V];if(ae.ignoreCase){ac=true}else{if(/[a-z]/i.test(ae.source.replace(/\\\\u[0-9a-f]{4}|\\\\x[0-9a-f]{2}|\\\\[^ux]/gi,\"\"))){S=true;ac=false;break}}}var Y={b:8,t:9,n:10,v:11,f:12,r:13};function ab(ah){var ag=ah.charCodeAt(0);if(ag!==92){return ag}var af=ah.charAt(1);ag=Y[af];if(ag){return ag}else{if(\"0\"<=af&&af<=\"7\"){return parseInt(ah.substring(1),8)}else{if(af===\"u\"||af===\"x\"){return parseInt(ah.substring(2),16)}else{return ah.charCodeAt(1)}}}}function T(af){if(af<32){return(af<16?\"\\\\x0\":\"\\\\x\")+af.toString(16)}var ag=String.fromCharCode(af);if(ag===\"\\\\\"||ag===\"-\"||ag===\"[\"||ag===\"]\"){ag=\"\\\\\"+ag}return ag}function X(am){var aq=am.substring(1,am.length-1).match(new RegExp(\"\\\\\\\\u[0-9A-Fa-f]{4}|\\\\\\\\x[0-9A-Fa-f]{2}|\\\\\\\\[0-3][0-7]{0,2}|\\\\\\\\[0-7]{1,2}|\\\\\\\\[\\\\s\\\\S]|-|[^-\\\\\\\\]\",\"g\"));var ak=[];var af=[];var ao=aq[0]===\"^\";for(var ar=ao?1:0,aj=aq.length;ar<aj;++ar){var ah=aq[ar];if(/\\\\[bdsw]/i.test(ah)){ak.push(ah)}else{var ag=ab(ah);var al;if(ar+2<aj&&\"-\"===aq[ar+1]){al=ab(aq[ar+2]);ar+=2}else{al=ag}af.push([ag,al]);if(!(al<65||ag>122)){if(!(al<65||ag>90)){af.push([Math.max(65,ag)|32,Math.min(al,90)|32])}if(!(al<97||ag>122)){af.push([Math.max(97,ag)&~32,Math.min(al,122)&~32])}}}}af.sort(function(av,au){return(av[0]-au[0])||(au[1]-av[1])});var ai=[];var ap=[NaN,NaN];for(var ar=0;ar<af.length;++ar){var at=af[ar];if(at[0]<=ap[1]+1){ap[1]=Math.max(ap[1],at[1])}else{ai.push(ap=at)}}var an=[\"[\"];if(ao){an.push(\"^\")}an.push.apply(an,ak);for(var ar=0;ar<ai.length;++ar){var at=ai[ar];an.push(T(at[0]));if(at[1]>at[0]){if(at[1]+1>at[0]){an.push(\"-\")}an.push(T(at[1]))}}an.push(\"]\");return an.join(\"\")}function W(al){var aj=al.source.match(new RegExp(\"(?:\\\\[(?:[^\\\\x5C\\\\x5D]|\\\\\\\\[\\\\s\\\\S])*\\\\]|\\\\\\\\u[A-Fa-f0-9]{4}|\\\\\\\\x[A-Fa-f0-9]{2}|\\\\\\\\[0-9]+|\\\\\\\\[^ux0-9]|\\\\(\\\\?[:!=]|[\\\\(\\\\)\\\\^]|[^\\\\x5B\\\\x5C\\\\(\\\\)\\\\^]+)\",\"g\"));var ah=aj.length;var an=[];for(var ak=0,am=0;ak<ah;++ak){var ag=aj[ak];if(ag===\"(\"){++am}else{if(\"\\\\\"===ag.charAt(0)){var af=+ag.substring(1);if(af&&af<=am){an[af]=-1}}}}for(var ak=1;ak<an.length;++ak){if(-1===an[ak]){an[ak]=++ad}}for(var ak=0,am=0;ak<ah;++ak){var ag=aj[ak];if(ag===\"(\"){++am;if(an[am]===undefined){aj[ak]=\"(?:\"}}else{if(\"\\\\\"===ag.charAt(0)){var af=+ag.substring(1);if(af&&af<=am){aj[ak]=\"\\\\\"+an[am]}}}}for(var ak=0,am=0;ak<ah;++ak){if(\"^\"===aj[ak]&&\"^\"!==aj[ak+1]){aj[ak]=\"\"}}if(al.ignoreCase&&S){for(var ak=0;ak<ah;++ak){var ag=aj[ak];var ai=ag.charAt(0);if(ag.length>=2&&ai===\"[\"){aj[ak]=X(ag)}else{if(ai!==\"\\\\\"){aj[ak]=ag.replace(/[a-zA-Z]/g,function(ao){var ap=ao.charCodeAt(0);return\"[\"+String.fromCharCode(ap&~32,ap|32)+\"]\"})}}}}return aj.join(\"\")}var aa=[];for(var V=0,U=Z.length;V<U;++V){var ae=Z[V];if(ae.global||ae.multiline){throw new Error(\"\"+ae)}aa.push(\"(?:\"+W(ae)+\")\")}return new RegExp(aa.join(\"|\"),ac?\"gi\":\"g\")}function a(V){var U=/(?:^|\\s)nocode(?:\\s|$)/;var X=[];var T=0;var Z=[];var W=0;var S;if(V.currentStyle){S=V.currentStyle.whiteSpace}else{if(window.getComputedStyle){S=document.defaultView.getComputedStyle(V,null).getPropertyValue(\"white-space\")}}var Y=S&&\"pre\"===S.substring(0,3);function aa(ab){switch(ab.nodeType){case 1:if(U.test(ab.className)){return}for(var ae=ab.firstChild;ae;ae=ae.nextSibling){aa(ae)}var ad=ab.nodeName;if(\"BR\"===ad||\"LI\"===ad){X[W]=\"\\n\";Z[W<<1]=T++;Z[(W++<<1)|1]=ab}break;case 3:case 4:var ac=ab.nodeValue;if(ac.length){if(!Y){ac=ac.replace(/[ \\t\\r\\n]+/g,\" \")}else{ac=ac.replace(/\\r\\n?/g,\"\\n\")}X[W]=ac;Z[W<<1]=T;T+=ac.length;Z[(W++<<1)|1]=ab}break}}aa(V);return{sourceCode:X.join(\"\").replace(/\\n$/,\"\"),spans:Z}}function B(S,U,W,T){if(!U){return}var V={sourceCode:U,basePos:S};W(V);T.push.apply(T,V.decorations)}var v=/\\S/;function o(S){var V=undefined;for(var U=S.firstChild;U;U=U.nextSibling){var T=U.nodeType;V=(T===1)?(V?S:U):(T===3)?(v.test(U.nodeValue)?S:V):V}return V===S?undefined:V}function g(U,T){var S={};var V;(function(){var ad=U.concat(T);var ah=[];var ag={};for(var ab=0,Z=ad.length;ab<Z;++ab){var Y=ad[ab];var ac=Y[3];if(ac){for(var ae=ac.length;--ae>=0;){S[ac.charAt(ae)]=Y}}var af=Y[1];var aa=\"\"+af;if(!ag.hasOwnProperty(aa)){ah.push(af);ag[aa]=null}}ah.push(/[\\0-\\uffff]/);V=k(ah)})();var X=T.length;var W=function(ah){var Z=ah.sourceCode,Y=ah.basePos;var ad=[Y,F];var af=0;var an=Z.match(V)||[];var aj={};for(var ae=0,aq=an.length;ae<aq;++ae){var ag=an[ae];var ap=aj[ag];var ai=void 0;var am;if(typeof ap===\"string\"){am=false}else{var aa=S[ag.charAt(0)];if(aa){ai=ag.match(aa[1]);ap=aa[0]}else{for(var ao=0;ao<X;++ao){aa=T[ao];ai=ag.match(aa[1]);if(ai){ap=aa[0];break}}if(!ai){ap=F}}am=ap.length>=5&&\"lang-\"===ap.substring(0,5);if(am&&!(ai&&typeof ai[1]===\"string\")){am=false;ap=J}if(!am){aj[ag]=ap}}var ab=af;af+=ag.length;if(!am){ad.push(Y+ab,ap)}else{var al=ai[1];var ak=ag.indexOf(al);var ac=ak+al.length;if(ai[2]){ac=ag.length-ai[2].length;ak=ac-al.length}var ar=ap.substring(5);B(Y+ab,ag.substring(0,ak),W,ad);B(Y+ab+ak,al,q(ar,al),ad);B(Y+ab+ac,ag.substring(ac),W,ad)}}ah.decorations=ad};return W}function i(T){var W=[],S=[];if(T.tripleQuotedStrings){W.push([C,/^(?:\\'\\'\\'(?:[^\\'\\\\]|\\\\[\\s\\S]|\\'{1,2}(?=[^\\']))*(?:\\'\\'\\'|$)|\\\"\\\"\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S]|\\\"{1,2}(?=[^\\\"]))*(?:\\\"\\\"\\\"|$)|\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$))/,null,\"'\\\"\"])}else{if(T.multiLineStrings){W.push([C,/^(?:\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$)|\\`(?:[^\\\\\\`]|\\\\[\\s\\S])*(?:\\`|$))/,null,\"'\\\"`\"])}else{W.push([C,/^(?:\\'(?:[^\\\\\\'\\r\\n]|\\\\.)*(?:\\'|$)|\\\"(?:[^\\\\\\\"\\r\\n]|\\\\.)*(?:\\\"|$))/,null,\"\\\"'\"])}}if(T.verbatimStrings){S.push([C,/^@\\\"(?:[^\\\"]|\\\"\\\")*(?:\\\"|$)/,null])}var Y=T.hashComments;if(Y){if(T.cStyleComments){if(Y>1){W.push([j,/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,null,\"#\"])}else{W.push([j,/^#(?:(?:define|elif|else|endif|error|ifdef|include|ifndef|line|pragma|undef|warning)\\b|[^\\r\\n]*)/,null,\"#\"])}S.push([C,/^<(?:(?:(?:\\.\\.\\/)*|\\/?)(?:[\\w-]+(?:\\/[\\w-]+)+)?[\\w-]+\\.h|[a-z]\\w*)>/,null])}else{W.push([j,/^#[^\\r\\n]*/,null,\"#\"])}}if(T.cStyleComments){S.push([j,/^\\/\\/[^\\r\\n]*/,null]);S.push([j,/^\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,null])}if(T.regexLiterals){var X=(\"/(?=[^/*])(?:[^/\\\\x5B\\\\x5C]|\\\\x5C[\\\\s\\\\S]|\\\\x5B(?:[^\\\\x5C\\\\x5D]|\\\\x5C[\\\\s\\\\S])*(?:\\\\x5D|$))+/\");S.push([\"lang-regex\",new RegExp(\"^\"+M+\"(\"+X+\")\")])}var V=T.types;if(V){S.push([O,V])}var U=(\"\"+T.keywords).replace(/^ | $/g,\"\");if(U.length){S.push([z,new RegExp(\"^(?:\"+U.replace(/[\\s,]+/g,\"|\")+\")\\\\b\"),null])}W.push([F,/^\\s+/,null,\" \\r\\n\\t\\xA0\"]);S.push([G,/^@[a-z_$][a-z_$@0-9]*/i,null],[O,/^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\\w+_t\\b)/,null],[F,/^[a-z_$][a-z_$@0-9]*/i,null],[G,new RegExp(\"^(?:0x[a-f0-9]+|(?:\\\\d(?:_\\\\d+)*\\\\d*(?:\\\\.\\\\d*)?|\\\\.\\\\d\\\\+)(?:e[+\\\\-]?\\\\d+)?)[a-z]*\",\"i\"),null,\"0123456789\"],[F,/^\\\\[\\s\\S]?/,null],[L,/^.[^\\s\\w\\.$@\\'\\\"\\`\\/\\#\\\\]*/,null]);return g(W,S)}var K=i({keywords:A,hashComments:true,cStyleComments:true,multiLineStrings:true,regexLiterals:true});function Q(V,ag){var U=/(?:^|\\s)nocode(?:\\s|$)/;var ab=/\\r\\n?|\\n/;var ac=V.ownerDocument;var S;if(V.currentStyle){S=V.currentStyle.whiteSpace}else{if(window.getComputedStyle){S=ac.defaultView.getComputedStyle(V,null).getPropertyValue(\"white-space\")}}var Z=S&&\"pre\"===S.substring(0,3);var af=ac.createElement(\"LI\");while(V.firstChild){af.appendChild(V.firstChild)}var W=[af];function ae(al){switch(al.nodeType){case 1:if(U.test(al.className)){break}if(\"BR\"===al.nodeName){ad(al);if(al.parentNode){al.parentNode.removeChild(al)}}else{for(var an=al.firstChild;an;an=an.nextSibling){ae(an)}}break;case 3:case 4:if(Z){var am=al.nodeValue;var aj=am.match(ab);if(aj){var ai=am.substring(0,aj.index);al.nodeValue=ai;var ah=am.substring(aj.index+aj[0].length);if(ah){var ak=al.parentNode;ak.insertBefore(ac.createTextNode(ah),al.nextSibling)}ad(al);if(!ai){al.parentNode.removeChild(al)}}}break}}function ad(ak){while(!ak.nextSibling){ak=ak.parentNode;if(!ak){return}}function ai(al,ar){var aq=ar?al.cloneNode(false):al;var ao=al.parentNode;if(ao){var ap=ai(ao,1);var an=al.nextSibling;ap.appendChild(aq);for(var am=an;am;am=an){an=am.nextSibling;ap.appendChild(am)}}return aq}var ah=ai(ak.nextSibling,0);for(var aj;(aj=ah.parentNode)&&aj.nodeType===1;){ah=aj}W.push(ah)}for(var Y=0;Y<W.length;++Y){ae(W[Y])}if(ag===(ag|0)){W[0].setAttribute(\"value\",ag)}var aa=ac.createElement(\"OL\");aa.className=\"linenums\";var X=Math.max(0,((ag-1))|0)||0;for(var Y=0,T=W.length;Y<T;++Y){af=W[Y];af.className=\"L\"+((Y+X)%10);if(!af.firstChild){af.appendChild(ac.createTextNode(\"\\xA0\"))}aa.appendChild(af)}V.appendChild(aa)}function D(ac){var aj=/\\bMSIE\\b/.test(navigator.userAgent);var am=/\\n/g;var al=ac.sourceCode;var an=al.length;var V=0;var aa=ac.spans;var T=aa.length;var ah=0;var X=ac.decorations;var Y=X.length;var Z=0;X[Y]=an;var ar,aq;for(aq=ar=0;aq<Y;){if(X[aq]!==X[aq+2]){X[ar++]=X[aq++];X[ar++]=X[aq++]}else{aq+=2}}Y=ar;for(aq=ar=0;aq<Y;){var at=X[aq];var ab=X[aq+1];var W=aq+2;while(W+2<=Y&&X[W+1]===ab){W+=2}X[ar++]=at;X[ar++]=ab;aq=W}Y=X.length=ar;var ae=null;while(ah<T){var af=aa[ah];var S=aa[ah+2]||an;var ag=X[Z];var ap=X[Z+2]||an;var W=Math.min(S,ap);var ak=aa[ah+1];var U;if(ak.nodeType!==1&&(U=al.substring(V,W))){if(aj){U=U.replace(am,\"\\r\")}ak.nodeValue=U;var ai=ak.ownerDocument;var ao=ai.createElement(\"SPAN\");ao.className=X[Z+1];var ad=ak.parentNode;ad.replaceChild(ao,ak);ao.appendChild(ak);if(V<S){aa[ah+1]=ak=ai.createTextNode(al.substring(W,S));ad.insertBefore(ak,ao.nextSibling)}}V=W;if(V>=S){ah+=2}if(V>=ap){Z+=2}}}var t={};function c(U,V){for(var S=V.length;--S>=0;){var T=V[S];if(!t.hasOwnProperty(T)){t[T]=U}else{if(window.console){console.warn(\"cannot override language handler %s\",T)}}}}function q(T,S){if(!(T&&t.hasOwnProperty(T))){T=/^\\s*</.test(S)?\"default-markup\":\"default-code\"}return t[T]}c(K,[\"default-code\"]);c(g([],[[F,/^[^<?]+/],[E,/^<!\\w[^>]*(?:>|$)/],[j,/^<\\!--[\\s\\S]*?(?:-\\->|$)/],[\"lang-\",/^<\\?([\\s\\S]+?)(?:\\?>|$)/],[\"lang-\",/^<%([\\s\\S]+?)(?:%>|$)/],[L,/^(?:<[%?]|[%?]>)/],[\"lang-\",/^<xmp\\b[^>]*>([\\s\\S]+?)<\\/xmp\\b[^>]*>/i],[\"lang-js\",/^<script\\b[^>]*>([\\s\\S]*?)(<\\/script\\b[^>]*>)/i],[\"lang-css\",/^<style\\b[^>]*>([\\s\\S]*?)(<\\/style\\b[^>]*>)/i],[\"lang-in.tag\",/^(<\\/?[a-z][^<>]*>)/i]]),[\"default-markup\",\"htm\",\"html\",\"mxml\",\"xhtml\",\"xml\",\"xsl\"]);c(g([[F,/^[\\s]+/,null,\" \\t\\r\\n\"],[n,/^(?:\\\"[^\\\"]*\\\"?|\\'[^\\']*\\'?)/,null,\"\\\"'\"]],[[m,/^^<\\/?[a-z](?:[\\w.:-]*\\w)?|\\/?>$/i],[P,/^(?!style[\\s=]|on)[a-z](?:[\\w:-]*\\w)?/i],[\"lang-uq.val\",/^=\\s*([^>\\'\\\"\\s]*(?:[^>\\'\\\"\\s\\/]|\\/(?=\\s)))/],[L,/^[=<>\\/]+/],[\"lang-js\",/^on\\w+\\s*=\\s*\\\"([^\\\"]+)\\\"/i],[\"lang-js\",/^on\\w+\\s*=\\s*\\'([^\\']+)\\'/i],[\"lang-js\",/^on\\w+\\s*=\\s*([^\\\"\\'>\\s]+)/i],[\"lang-css\",/^style\\s*=\\s*\\\"([^\\\"]+)\\\"/i],[\"lang-css\",/^style\\s*=\\s*\\'([^\\']+)\\'/i],[\"lang-css\",/^style\\s*=\\s*([^\\\"\\'>\\s]+)/i]]),[\"in.tag\"]);c(g([],[[n,/^[\\s\\S]+/]]),[\"uq.val\"]);c(i({keywords:l,hashComments:true,cStyleComments:true,types:e}),[\"c\",\"cc\",\"cpp\",\"cxx\",\"cyc\",\"m\"]);c(i({keywords:\"null,true,false\"}),[\"json\"]);c(i({keywords:R,hashComments:true,cStyleComments:true,verbatimStrings:true,types:e}),[\"cs\"]);c(i({keywords:x,cStyleComments:true}),[\"java\"]);c(i({keywords:H,hashComments:true,multiLineStrings:true}),[\"bsh\",\"csh\",\"sh\"]);c(i({keywords:I,hashComments:true,multiLineStrings:true,tripleQuotedStrings:true}),[\"cv\",\"py\"]);c(i({keywords:s,hashComments:true,multiLineStrings:true,regexLiterals:true}),[\"perl\",\"pl\",\"pm\"]);c(i({keywords:f,hashComments:true,multiLineStrings:true,regexLiterals:true}),[\"rb\"]);c(i({keywords:w,cStyleComments:true,regexLiterals:true}),[\"js\"]);c(i({keywords:r,hashComments:3,cStyleComments:true,multilineStrings:true,tripleQuotedStrings:true,regexLiterals:true}),[\"coffee\"]);c(g([],[[C,/^[\\s\\S]+/]]),[\"regex\"]);function d(V){var U=V.langExtension;try{var S=a(V.sourceNode);var T=S.sourceCode;V.sourceCode=T;V.spans=S.spans;V.basePos=0;q(U,T)(V);D(V)}catch(W){if(\"console\" in window){console.log(W&&W.stack?W.stack:W)}}}function y(W,V,U){var S=document.createElement(\"PRE\");S.innerHTML=W;if(U){Q(S,U)}var T={langExtension:V,numberLines:U,sourceNode:S};d(T);return S.innerHTML}function b(ad){function Y(af){return document.getElementsByTagName(af)}var ac=[Y(\"pre\"),Y(\"code\"),Y(\"xmp\")];var T=[];for(var aa=0;aa<ac.length;++aa){for(var Z=0,V=ac[aa].length;Z<V;++Z){T.push(ac[aa][Z])}}ac=null;var W=Date;if(!W.now){W={now:function(){return +(new Date)}}}var X=0;var S;var ab=/\\blang(?:uage)?-([\\w.]+)(?!\\S)/;var ae=/\\bprettyprint\\b/;function U(){var ag=(window.PR_SHOULD_USE_CONTINUATION?W.now()+250:Infinity);for(;X<T.length&&W.now()<ag;X++){var aj=T[X];var ai=aj.className;if(ai.indexOf(\"prettyprint\")>=0){var ah=ai.match(ab);var am;if(!ah&&(am=o(aj))&&\"CODE\"===am.tagName){ah=am.className.match(ab)}if(ah){ah=ah[1]}var al=false;for(var ak=aj.parentNode;ak;ak=ak.parentNode){if((ak.tagName===\"pre\"||ak.tagName===\"code\"||ak.tagName===\"xmp\")&&ak.className&&ak.className.indexOf(\"prettyprint\")>=0){al=true;break}}if(!al){var af=aj.className.match(/\\blinenums\\b(?::(\\d+))?/);af=af?af[1]&&af[1].length?+af[1]:true:false;if(af){Q(aj,af)}S={langExtension:ah,sourceNode:aj,numberLines:af};d(S)}}}if(X<T.length){setTimeout(U,250)}else{if(ad){ad()}}}U()}window.prettyPrintOne=y;window.prettyPrint=b;window.PR={createSimpleLexer:g,registerLangHandler:c,sourceDecorator:i,PR_ATTRIB_NAME:P,PR_ATTRIB_VALUE:n,PR_COMMENT:j,PR_DECLARATION:E,PR_KEYWORD:z,PR_LITERAL:G,PR_NOCODE:N,PR_PLAIN:F,PR_PUNCTUATION:L,PR_SOURCE:J,PR_STRING:C,PR_TAG:m,PR_TYPE:O}})();PR.registerLangHandler(PR.createSimpleLexer([],[[PR.PR_DECLARATION,/^<!\\w[^>]*(?:>|$)/],[PR.PR_COMMENT,/^<\\!--[\\s\\S]*?(?:-\\->|$)/],[PR.PR_PUNCTUATION,/^(?:<[%?]|[%?]>)/],[\"lang-\",/^<\\?([\\s\\S]+?)(?:\\?>|$)/],[\"lang-\",/^<%([\\s\\S]+?)(?:%>|$)/],[\"lang-\",/^<xmp\\b[^>]*>([\\s\\S]+?)<\\/xmp\\b[^>]*>/i],[\"lang-handlebars\",/^<script\\b[^>]*type\\s*=\\s*['\"]?text\\/x-handlebars-template['\"]?\\b[^>]*>([\\s\\S]*?)(<\\/script\\b[^>]*>)/i],[\"lang-js\",/^<script\\b[^>]*>([\\s\\S]*?)(<\\/script\\b[^>]*>)/i],[\"lang-css\",/^<style\\b[^>]*>([\\s\\S]*?)(<\\/style\\b[^>]*>)/i],[\"lang-in.tag\",/^(<\\/?[a-z][^<>]*>)/i],[PR.PR_DECLARATION,/^{{[#^>/]?\\s*[\\w.][^}]*}}/],[PR.PR_DECLARATION,/^{{&?\\s*[\\w.][^}]*}}/],[PR.PR_DECLARATION,/^{{{>?\\s*[\\w.][^}]*}}}/],[PR.PR_COMMENT,/^{{![^}]*}}/]]),[\"handlebars\",\"hbs\"]);PR.registerLangHandler(PR.createSimpleLexer([[PR.PR_PLAIN,/^[ \\t\\r\\n\\f]+/,null,\" \\t\\r\\n\\f\"]],[[PR.PR_STRING,/^\\\"(?:[^\\n\\r\\f\\\\\\\"]|\\\\(?:\\r\\n?|\\n|\\f)|\\\\[\\s\\S])*\\\"/,null],[PR.PR_STRING,/^\\'(?:[^\\n\\r\\f\\\\\\']|\\\\(?:\\r\\n?|\\n|\\f)|\\\\[\\s\\S])*\\'/,null],[\"lang-css-str\",/^url\\(([^\\)\\\"\\']*)\\)/i],[PR.PR_KEYWORD,/^(?:url|rgb|\\!important|@import|@page|@media|@charset|inherit)(?=[^\\-\\w]|$)/i,null],[\"lang-css-kw\",/^(-?(?:[_a-z]|(?:\\\\[0-9a-f]+ ?))(?:[_a-z0-9\\-]|\\\\(?:\\\\[0-9a-f]+ ?))*)\\s*:/i],[PR.PR_COMMENT,/^\\/\\*[^*]*\\*+(?:[^\\/*][^*]*\\*+)*\\//],[PR.PR_COMMENT,/^(?:<!--|-->)/],[PR.PR_LITERAL,/^(?:\\d+|\\d*\\.\\d+)(?:%|[a-z]+)?/i],[PR.PR_LITERAL,/^#(?:[0-9a-f]{3}){1,2}/i],[PR.PR_PLAIN,/^-?(?:[_a-z]|(?:\\\\[\\da-f]+ ?))(?:[_a-z\\d\\-]|\\\\(?:\\\\[\\da-f]+ ?))*/i],[PR.PR_PUNCTUATION,/^[^\\s\\w\\'\\\"]+/]]),[\"css\"]);PR.registerLangHandler(PR.createSimpleLexer([],[[PR.PR_KEYWORD,/^-?(?:[_a-z]|(?:\\\\[\\da-f]+ ?))(?:[_a-z\\d\\-]|\\\\(?:\\\\[\\da-f]+ ?))*/i]]),[\"css-kw\"]);PR.registerLangHandler(PR.createSimpleLexer([],[[PR.PR_STRING,/^[^\\)\\\"\\']+/]]),[\"css-str\"]);\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\sorter.js","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported).","line":1,"column":1,"severity":1,"nodeType":null,"fix":{"range":[0,20],"text":" "}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"/* eslint-disable */\nvar addSorting = (function() {\n    'use strict';\n    var cols,\n        currentSort = {\n            index: 0,\n            desc: false\n        };\n\n    // returns the summary table element\n    function getTable() {\n        return document.querySelector('.coverage-summary');\n    }\n    // returns the thead element of the summary table\n    function getTableHeader() {\n        return getTable().querySelector('thead tr');\n    }\n    // returns the tbody element of the summary table\n    function getTableBody() {\n        return getTable().querySelector('tbody');\n    }\n    // returns the th element for nth column\n    function getNthColumn(n) {\n        return getTableHeader().querySelectorAll('th')[n];\n    }\n\n    function onFilterInput() {\n        const searchValue = document.getElementById('fileSearch').value;\n        const rows = document.getElementsByTagName('tbody')[0].children;\n        for (let i = 0; i < rows.length; i++) {\n            const row = rows[i];\n            if (\n                row.textContent\n                    .toLowerCase()\n                    .includes(searchValue.toLowerCase())\n            ) {\n                row.style.display = '';\n            } else {\n                row.style.display = 'none';\n            }\n        }\n    }\n\n    // loads the search box\n    function addSearchBox() {\n        var template = document.getElementById('filterTemplate');\n        var templateClone = template.content.cloneNode(true);\n        templateClone.getElementById('fileSearch').oninput = onFilterInput;\n        template.parentElement.appendChild(templateClone);\n    }\n\n    // loads all columns\n    function loadColumns() {\n        var colNodes = getTableHeader().querySelectorAll('th'),\n            colNode,\n            cols = [],\n            col,\n            i;\n\n        for (i = 0; i < colNodes.length; i += 1) {\n            colNode = colNodes[i];\n            col = {\n                key: colNode.getAttribute('data-col'),\n                sortable: !colNode.getAttribute('data-nosort'),\n                type: colNode.getAttribute('data-type') || 'string'\n            };\n            cols.push(col);\n            if (col.sortable) {\n                col.defaultDescSort = col.type === 'number';\n                colNode.innerHTML =\n                    colNode.innerHTML + '<span class=\"sorter\"></span>';\n            }\n        }\n        return cols;\n    }\n    // attaches a data attribute to every tr element with an object\n    // of data values keyed by column name\n    function loadRowData(tableRow) {\n        var tableCols = tableRow.querySelectorAll('td'),\n            colNode,\n            col,\n            data = {},\n            i,\n            val;\n        for (i = 0; i < tableCols.length; i += 1) {\n            colNode = tableCols[i];\n            col = cols[i];\n            val = colNode.getAttribute('data-value');\n            if (col.type === 'number') {\n                val = Number(val);\n            }\n            data[col.key] = val;\n        }\n        return data;\n    }\n    // loads all row data\n    function loadData() {\n        var rows = getTableBody().querySelectorAll('tr'),\n            i;\n\n        for (i = 0; i < rows.length; i += 1) {\n            rows[i].data = loadRowData(rows[i]);\n        }\n    }\n    // sorts the table using the data for the ith column\n    function sortByIndex(index, desc) {\n        var key = cols[index].key,\n            sorter = function(a, b) {\n                a = a.data[key];\n                b = b.data[key];\n                return a < b ? -1 : a > b ? 1 : 0;\n            },\n            finalSorter = sorter,\n            tableBody = document.querySelector('.coverage-summary tbody'),\n            rowNodes = tableBody.querySelectorAll('tr'),\n            rows = [],\n            i;\n\n        if (desc) {\n            finalSorter = function(a, b) {\n                return -1 * sorter(a, b);\n            };\n        }\n\n        for (i = 0; i < rowNodes.length; i += 1) {\n            rows.push(rowNodes[i]);\n            tableBody.removeChild(rowNodes[i]);\n        }\n\n        rows.sort(finalSorter);\n\n        for (i = 0; i < rows.length; i += 1) {\n            tableBody.appendChild(rows[i]);\n        }\n    }\n    // removes sort indicators for current column being sorted\n    function removeSortIndicators() {\n        var col = getNthColumn(currentSort.index),\n            cls = col.className;\n\n        cls = cls.replace(/ sorted$/, '').replace(/ sorted-desc$/, '');\n        col.className = cls;\n    }\n    // adds sort indicators for current column being sorted\n    function addSortIndicators() {\n        getNthColumn(currentSort.index).className += currentSort.desc\n            ? ' sorted-desc'\n            : ' sorted';\n    }\n    // adds event listeners for all sorter widgets\n    function enableUI() {\n        var i,\n            el,\n            ithSorter = function ithSorter(i) {\n                var col = cols[i];\n\n                return function() {\n                    var desc = col.defaultDescSort;\n\n                    if (currentSort.index === i) {\n                        desc = !currentSort.desc;\n                    }\n                    sortByIndex(i, desc);\n                    removeSortIndicators();\n                    currentSort.index = i;\n                    currentSort.desc = desc;\n                    addSortIndicators();\n                };\n            };\n        for (i = 0; i < cols.length; i += 1) {\n            if (cols[i].sortable) {\n                // add the click event handler on the th so users\n                // dont have to click on those tiny arrows\n                el = getNthColumn(i).querySelector('.sorter').parentElement;\n                if (el.addEventListener) {\n                    el.addEventListener('click', ithSorter(i));\n                } else {\n                    el.attachEvent('onclick', ithSorter(i));\n                }\n            }\n        }\n    }\n    // adds sorting functionality to the UI\n    return function() {\n        if (!getTable()) {\n            return;\n        }\n        cols = loadColumns();\n        loadData();\n        addSearchBox();\n        addSortIndicators();\n        enableUI();\n    };\n})();\n\nwindow.addEventListener('load', addSorting);\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\animations.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\amortization\\amortization.component.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\amortization\\index.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\app.component.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\common\\navbar\\index.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\common\\navbar\\navbar.component.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\dashboard\\dashboard.component.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\dashboard\\index.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\environment\\environment.ts.html","messages":[{"ruleId":"@angular-eslint/template/elements-content","severity":2,"message":"<a> should have content","line":66,"column":34,"nodeType":null,"messageId":"elementsContent","endLine":66,"endColumn":51},{"ruleId":"@angular-eslint/template/elements-content","severity":2,"message":"<a> should have content","line":67,"column":1,"nodeType":null,"messageId":"elementsContent","endLine":67,"endColumn":18},{"ruleId":"@angular-eslint/template/elements-content","severity":2,"message":"<a> should have content","line":68,"column":1,"nodeType":null,"messageId":"elementsContent","endLine":68,"endColumn":18},{"ruleId":"@angular-eslint/template/elements-content","severity":2,"message":"<a> should have content","line":69,"column":1,"nodeType":null,"messageId":"elementsContent","endLine":69,"endColumn":18},{"ruleId":"@angular-eslint/template/elements-content","severity":2,"message":"<a> should have content","line":70,"column":1,"nodeType":null,"messageId":"elementsContent","endLine":70,"endColumn":18}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\n<!doctype html>\n<html lang=\"en\">\n\n<head>\n    <title>Code coverage report for src/app/environment/environment.ts</title>\n    <meta charset=\"utf-8\" />\n    <link rel=\"stylesheet\" href=\"../../../prettify.css\" />\n    <link rel=\"stylesheet\" href=\"../../../base.css\" />\n    <link rel=\"shortcut icon\" type=\"image/x-icon\" href=\"../../../favicon.png\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <style type='text/css'>\n        .coverage-summary .sorter {\n            background-image: url(../../../sort-arrow-sprite.png);\n        }\n    </style>\n</head>\n    \n<body>\n<div class='wrapper'>\n    <div class='pad1'>\n        <h1><a href=\"../../../index.html\">All files</a> / <a href=\"index.html\">src/app/environment</a> environment.ts</h1>\n        <div class='clearfix'>\n            \n            <div class='fl pad1y space-right2'>\n                <span class=\"strong\">100% </span>\n                <span class=\"quiet\">Statements</span>\n                <span class='fraction'>1/1</span>\n            </div>\n        \n            \n            <div class='fl pad1y space-right2'>\n                <span class=\"strong\">100% </span>\n                <span class=\"quiet\">Branches</span>\n                <span class='fraction'>0/0</span>\n            </div>\n        \n            \n            <div class='fl pad1y space-right2'>\n                <span class=\"strong\">100% </span>\n                <span class=\"quiet\">Functions</span>\n                <span class='fraction'>0/0</span>\n            </div>\n        \n            \n            <div class='fl pad1y space-right2'>\n                <span class=\"strong\">100% </span>\n                <span class=\"quiet\">Lines</span>\n                <span class='fraction'>1/1</span>\n            </div>\n        \n            \n        </div>\n        <p class=\"quiet\">\n            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.\n        </p>\n        <template id=\"filterTemplate\">\n            <div class=\"quiet\">\n                Filter:\n                <input type=\"search\" id=\"fileSearch\">\n            </div>\n        </template>\n    </div>\n    <div class='status-line high'></div>\n    <pre><table class=\"coverage\">\n<tr><td class=\"line-count quiet\"><a name='L1'></a><a href='#L1'>1</a>\n<a name='L2'></a><a href='#L2'>2</a>\n<a name='L3'></a><a href='#L3'>3</a>\n<a name='L4'></a><a href='#L4'>4</a>\n<a name='L5'></a><a href='#L5'>5</a></td><td class=\"line-coverage quiet\"><span class=\"cline-any cline-yes\">1x</span>\n<span class=\"cline-any cline-neutral\">&nbsp;</span>\n<span class=\"cline-any cline-neutral\">&nbsp;</span>\n<span class=\"cline-any cline-neutral\">&nbsp;</span>\n<span class=\"cline-any cline-neutral\">&nbsp;</span></td><td class=\"text\"><pre class=\"prettyprint lang-js\">export const environment = {\n  production: false,\n  apiUrl: `https://localhost:7194/api`,\n};\n&nbsp;</pre></td></tr></table></pre>\n\n                <div class='push'></div><!-- for sticky footer -->\n            </div><!-- /wrapper -->\n            <div class='footer quiet pad2 space-top1 center small'>\n                Code coverage generated by\n                <a href=\"https://istanbul.js.org/\" target=\"_blank\" rel=\"noopener noreferrer\">istanbul</a>\n                at 2025-04-15T17:29:34.163Z\n            </div>\n        <script src=\"../../../prettify.js\"></script>\n        <script>\n            window.onload = function () {\n                prettyPrint();\n            };\n        </script>\n        <script src=\"../../../sorter.js\"></script>\n        <script src=\"../../../block-navigation.js\"></script>\n    </body>\n</html>\n    ","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\environment\\index.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\index.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\loan-application\\index.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\loan-application\\loan-application.component.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\loan-details\\bar-chart.component.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\loan-details\\index.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\loan-details\\line-chart.component.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\loan-details\\loan-details.component.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\loan-details\\pie-chart.component.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\login\\index.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\login\\login.component.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\services\\amortization\\amortization.service.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\services\\amortization\\index.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\services\\auth\\auth.service.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\services\\auth\\index.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\services\\auth\\jwt.interceptor.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\services\\interestRate\\index.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\services\\interestRate\\interest-rate.service.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\services\\loan\\index.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\services\\loan\\loan.service.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\store\\amortization\\amortization.actions.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\store\\amortization\\amortization.effects.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\store\\amortization\\amortization.reducer.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\store\\amortization\\amortization.selectors.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\store\\amortization\\index.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\store\\auth\\auth.actions.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\store\\auth\\auth.effects.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\store\\auth\\auth.reducer.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\store\\auth\\auth.selectors.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\store\\auth\\index.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\store\\interest-rates\\index.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\store\\interest-rates\\interest-rate.actions.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\store\\interest-rates\\interest-rate.effects.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\store\\interest-rates\\interest-rate.reducer.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\store\\interest-rates\\interest-rate.selectors.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\store\\loan\\index.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\store\\loan\\loan.actions.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\store\\loan\\loan.reducer.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\store\\loan\\loan.selectors.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\app\\store\\loan\\loan.state.ts.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\coverage\\mortgage-app\\src\\index.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\dist\\mortgage-app\\browser\\index.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\dist\\mortgage-app\\browser\\main.js","messages":[{"ruleId":"@angular-eslint/contextual-lifecycle","message":"Definition for rule '@angular-eslint/contextual-lifecycle' was not found.","line":46634,"column":3,"endLine":46634,"endColumn":67,"severity":2,"nodeType":null}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b ||= {})\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n// node_modules/@angular/core/fesm2022/primitives/signals.mjs\nfunction defaultEquals(a, b) {\n  return Object.is(a, b);\n}\nvar activeConsumer = null;\nvar inNotificationPhase = false;\nvar epoch = 1;\nvar SIGNAL = /* @__PURE__ */ Symbol(\"SIGNAL\");\nfunction setActiveConsumer(consumer) {\n  const prev = activeConsumer;\n  activeConsumer = consumer;\n  return prev;\n}\nfunction getActiveConsumer() {\n  return activeConsumer;\n}\nfunction isInNotificationPhase() {\n  return inNotificationPhase;\n}\nvar REACTIVE_NODE = {\n  version: 0,\n  lastCleanEpoch: 0,\n  dirty: false,\n  producerNode: void 0,\n  producerLastReadVersion: void 0,\n  producerIndexOfThis: void 0,\n  nextProducerIndex: 0,\n  liveConsumerNode: void 0,\n  liveConsumerIndexOfThis: void 0,\n  consumerAllowSignalWrites: false,\n  consumerIsAlwaysLive: false,\n  kind: \"unknown\",\n  producerMustRecompute: () => false,\n  producerRecomputeValue: () => {\n  },\n  consumerMarkedDirty: () => {\n  },\n  consumerOnSignalRead: () => {\n  }\n};\nfunction producerAccessed(node) {\n  if (inNotificationPhase) {\n    throw new Error(typeof ngDevMode !== \"undefined\" && ngDevMode ? `Assertion error: signal read during notification phase` : \"\");\n  }\n  if (activeConsumer === null) {\n    return;\n  }\n  activeConsumer.consumerOnSignalRead(node);\n  const idx = activeConsumer.nextProducerIndex++;\n  assertConsumerNode(activeConsumer);\n  if (idx < activeConsumer.producerNode.length && activeConsumer.producerNode[idx] !== node) {\n    if (consumerIsLive(activeConsumer)) {\n      const staleProducer = activeConsumer.producerNode[idx];\n      producerRemoveLiveConsumerAtIndex(staleProducer, activeConsumer.producerIndexOfThis[idx]);\n    }\n  }\n  if (activeConsumer.producerNode[idx] !== node) {\n    activeConsumer.producerNode[idx] = node;\n    activeConsumer.producerIndexOfThis[idx] = consumerIsLive(activeConsumer) ? producerAddLiveConsumer(node, activeConsumer, idx) : 0;\n  }\n  activeConsumer.producerLastReadVersion[idx] = node.version;\n}\nfunction producerIncrementEpoch() {\n  epoch++;\n}\nfunction producerUpdateValueVersion(node) {\n  if (consumerIsLive(node) && !node.dirty) {\n    return;\n  }\n  if (!node.dirty && node.lastCleanEpoch === epoch) {\n    return;\n  }\n  if (!node.producerMustRecompute(node) && !consumerPollProducersForChange(node)) {\n    producerMarkClean(node);\n    return;\n  }\n  node.producerRecomputeValue(node);\n  producerMarkClean(node);\n}\nfunction producerNotifyConsumers(node) {\n  if (node.liveConsumerNode === void 0) {\n    return;\n  }\n  const prev = inNotificationPhase;\n  inNotificationPhase = true;\n  try {\n    for (const consumer of node.liveConsumerNode) {\n      if (!consumer.dirty) {\n        consumerMarkDirty(consumer);\n      }\n    }\n  } finally {\n    inNotificationPhase = prev;\n  }\n}\nfunction producerUpdatesAllowed() {\n  return activeConsumer?.consumerAllowSignalWrites !== false;\n}\nfunction consumerMarkDirty(node) {\n  node.dirty = true;\n  producerNotifyConsumers(node);\n  node.consumerMarkedDirty?.(node);\n}\nfunction producerMarkClean(node) {\n  node.dirty = false;\n  node.lastCleanEpoch = epoch;\n}\nfunction consumerBeforeComputation(node) {\n  node && (node.nextProducerIndex = 0);\n  return setActiveConsumer(node);\n}\nfunction consumerAfterComputation(node, prevConsumer) {\n  setActiveConsumer(prevConsumer);\n  if (!node || node.producerNode === void 0 || node.producerIndexOfThis === void 0 || node.producerLastReadVersion === void 0) {\n    return;\n  }\n  if (consumerIsLive(node)) {\n    for (let i = node.nextProducerIndex; i < node.producerNode.length; i++) {\n      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n    }\n  }\n  while (node.producerNode.length > node.nextProducerIndex) {\n    node.producerNode.pop();\n    node.producerLastReadVersion.pop();\n    node.producerIndexOfThis.pop();\n  }\n}\nfunction consumerPollProducersForChange(node) {\n  assertConsumerNode(node);\n  for (let i = 0; i < node.producerNode.length; i++) {\n    const producer = node.producerNode[i];\n    const seenVersion = node.producerLastReadVersion[i];\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n    producerUpdateValueVersion(producer);\n    if (seenVersion !== producer.version) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction consumerDestroy(node) {\n  assertConsumerNode(node);\n  if (consumerIsLive(node)) {\n    for (let i = 0; i < node.producerNode.length; i++) {\n      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n    }\n  }\n  node.producerNode.length = node.producerLastReadVersion.length = node.producerIndexOfThis.length = 0;\n  if (node.liveConsumerNode) {\n    node.liveConsumerNode.length = node.liveConsumerIndexOfThis.length = 0;\n  }\n}\nfunction producerAddLiveConsumer(node, consumer, indexOfThis) {\n  assertProducerNode(node);\n  if (node.liveConsumerNode.length === 0 && isConsumerNode(node)) {\n    for (let i = 0; i < node.producerNode.length; i++) {\n      node.producerIndexOfThis[i] = producerAddLiveConsumer(node.producerNode[i], node, i);\n    }\n  }\n  node.liveConsumerIndexOfThis.push(indexOfThis);\n  return node.liveConsumerNode.push(consumer) - 1;\n}\nfunction producerRemoveLiveConsumerAtIndex(node, idx) {\n  assertProducerNode(node);\n  if (typeof ngDevMode !== \"undefined\" && ngDevMode && idx >= node.liveConsumerNode.length) {\n    throw new Error(`Assertion error: active consumer index ${idx} is out of bounds of ${node.liveConsumerNode.length} consumers)`);\n  }\n  if (node.liveConsumerNode.length === 1 && isConsumerNode(node)) {\n    for (let i = 0; i < node.producerNode.length; i++) {\n      producerRemoveLiveConsumerAtIndex(node.producerNode[i], node.producerIndexOfThis[i]);\n    }\n  }\n  const lastIdx = node.liveConsumerNode.length - 1;\n  node.liveConsumerNode[idx] = node.liveConsumerNode[lastIdx];\n  node.liveConsumerIndexOfThis[idx] = node.liveConsumerIndexOfThis[lastIdx];\n  node.liveConsumerNode.length--;\n  node.liveConsumerIndexOfThis.length--;\n  if (idx < node.liveConsumerNode.length) {\n    const idxProducer = node.liveConsumerIndexOfThis[idx];\n    const consumer = node.liveConsumerNode[idx];\n    assertConsumerNode(consumer);\n    consumer.producerIndexOfThis[idxProducer] = idx;\n  }\n}\nfunction consumerIsLive(node) {\n  return node.consumerIsAlwaysLive || (node?.liveConsumerNode?.length ?? 0) > 0;\n}\nfunction assertConsumerNode(node) {\n  node.producerNode ??= [];\n  node.producerIndexOfThis ??= [];\n  node.producerLastReadVersion ??= [];\n}\nfunction assertProducerNode(node) {\n  node.liveConsumerNode ??= [];\n  node.liveConsumerIndexOfThis ??= [];\n}\nfunction isConsumerNode(node) {\n  return node.producerNode !== void 0;\n}\nfunction createComputed(computation, equal) {\n  const node = Object.create(COMPUTED_NODE);\n  node.computation = computation;\n  if (equal !== void 0) {\n    node.equal = equal;\n  }\n  const computed2 = () => {\n    producerUpdateValueVersion(node);\n    producerAccessed(node);\n    if (node.value === ERRORED) {\n      throw node.error;\n    }\n    return node.value;\n  };\n  computed2[SIGNAL] = node;\n  return computed2;\n}\nvar UNSET = /* @__PURE__ */ Symbol(\"UNSET\");\nvar COMPUTING = /* @__PURE__ */ Symbol(\"COMPUTING\");\nvar ERRORED = /* @__PURE__ */ Symbol(\"ERRORED\");\nvar COMPUTED_NODE = /* @__PURE__ */ (() => {\n  return __spreadProps(__spreadValues({}, REACTIVE_NODE), {\n    value: UNSET,\n    dirty: true,\n    error: null,\n    equal: defaultEquals,\n    kind: \"computed\",\n    producerMustRecompute(node) {\n      return node.value === UNSET || node.value === COMPUTING;\n    },\n    producerRecomputeValue(node) {\n      if (node.value === COMPUTING) {\n        throw new Error(\"Detected cycle in computations.\");\n      }\n      const oldValue = node.value;\n      node.value = COMPUTING;\n      const prevConsumer = consumerBeforeComputation(node);\n      let newValue;\n      let wasEqual = false;\n      try {\n        newValue = node.computation();\n        setActiveConsumer(null);\n        wasEqual = oldValue !== UNSET && oldValue !== ERRORED && newValue !== ERRORED && node.equal(oldValue, newValue);\n      } catch (err) {\n        newValue = ERRORED;\n        node.error = err;\n      } finally {\n        consumerAfterComputation(node, prevConsumer);\n      }\n      if (wasEqual) {\n        node.value = oldValue;\n        return;\n      }\n      node.value = newValue;\n      node.version++;\n    }\n  });\n})();\nfunction defaultThrowError() {\n  throw new Error();\n}\nvar throwInvalidWriteToSignalErrorFn = defaultThrowError;\nfunction throwInvalidWriteToSignalError(node) {\n  throwInvalidWriteToSignalErrorFn(node);\n}\nfunction setThrowInvalidWriteToSignalError(fn) {\n  throwInvalidWriteToSignalErrorFn = fn;\n}\nvar postSignalSetFn = null;\nfunction createSignal(initialValue, equal) {\n  const node = Object.create(SIGNAL_NODE);\n  node.value = initialValue;\n  if (equal !== void 0) {\n    node.equal = equal;\n  }\n  const getter = () => {\n    producerAccessed(node);\n    return node.value;\n  };\n  getter[SIGNAL] = node;\n  return getter;\n}\nfunction signalSetFn(node, newValue) {\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError(node);\n  }\n  if (!node.equal(node.value, newValue)) {\n    node.value = newValue;\n    signalValueChanged(node);\n  }\n}\nfunction signalUpdateFn(node, updater) {\n  if (!producerUpdatesAllowed()) {\n    throwInvalidWriteToSignalError(node);\n  }\n  signalSetFn(node, updater(node.value));\n}\nvar SIGNAL_NODE = /* @__PURE__ */ (() => {\n  return __spreadProps(__spreadValues({}, REACTIVE_NODE), {\n    equal: defaultEquals,\n    value: void 0,\n    kind: \"signal\"\n  });\n})();\nfunction signalValueChanged(node) {\n  node.version++;\n  producerIncrementEpoch();\n  producerNotifyConsumers(node);\n  postSignalSetFn?.();\n}\nfunction createLinkedSignal(sourceFn, computationFn, equalityFn) {\n  const node = Object.create(LINKED_SIGNAL_NODE);\n  node.source = sourceFn;\n  node.computation = computationFn;\n  if (equalityFn != void 0) {\n    node.equal = equalityFn;\n  }\n  const linkedSignalGetter = () => {\n    producerUpdateValueVersion(node);\n    producerAccessed(node);\n    if (node.value === ERRORED) {\n      throw node.error;\n    }\n    return node.value;\n  };\n  const getter = linkedSignalGetter;\n  getter[SIGNAL] = node;\n  return getter;\n}\nfunction linkedSignalSetFn(node, newValue) {\n  producerUpdateValueVersion(node);\n  signalSetFn(node, newValue);\n  producerMarkClean(node);\n}\nfunction linkedSignalUpdateFn(node, updater) {\n  producerUpdateValueVersion(node);\n  signalUpdateFn(node, updater);\n  producerMarkClean(node);\n}\nvar LINKED_SIGNAL_NODE = /* @__PURE__ */ (() => {\n  return __spreadProps(__spreadValues({}, REACTIVE_NODE), {\n    value: UNSET,\n    dirty: true,\n    error: null,\n    equal: defaultEquals,\n    producerMustRecompute(node) {\n      return node.value === UNSET || node.value === COMPUTING;\n    },\n    producerRecomputeValue(node) {\n      if (node.value === COMPUTING) {\n        throw new Error(\"Detected cycle in computations.\");\n      }\n      const oldValue = node.value;\n      node.value = COMPUTING;\n      const prevConsumer = consumerBeforeComputation(node);\n      let newValue;\n      try {\n        const newSourceValue = node.source();\n        const prev = oldValue === UNSET || oldValue === ERRORED ? void 0 : {\n          source: node.sourceValue,\n          value: oldValue\n        };\n        newValue = node.computation(newSourceValue, prev);\n        node.sourceValue = newSourceValue;\n      } catch (err) {\n        newValue = ERRORED;\n        node.error = err;\n      } finally {\n        consumerAfterComputation(node, prevConsumer);\n      }\n      if (oldValue !== UNSET && newValue !== ERRORED && node.equal(oldValue, newValue)) {\n        node.value = oldValue;\n        return;\n      }\n      node.value = newValue;\n      node.version++;\n    }\n  });\n})();\nfunction untracked(nonReactiveReadsFn) {\n  const prevConsumer = setActiveConsumer(null);\n  try {\n    return nonReactiveReadsFn();\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\n\n// node_modules/@angular/core/fesm2022/primitives/di.mjs\nvar _currentInjector = void 0;\nfunction getCurrentInjector() {\n  return _currentInjector;\n}\nfunction setCurrentInjector(injector) {\n  const former = _currentInjector;\n  _currentInjector = injector;\n  return former;\n}\nvar NOT_FOUND = Symbol(\"NotFound\");\n\n// node_modules/rxjs/dist/esm/internal/util/isFunction.js\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\n\n// node_modules/rxjs/dist/esm/internal/util/createErrorClass.js\nfunction createErrorClass(createImpl) {\n  const _super = (instance) => {\n    Error.call(instance);\n    instance.stack = new Error().stack;\n  };\n  const ctorFunc = createImpl(_super);\n  ctorFunc.prototype = Object.create(Error.prototype);\n  ctorFunc.prototype.constructor = ctorFunc;\n  return ctorFunc;\n}\n\n// node_modules/rxjs/dist/esm/internal/util/UnsubscriptionError.js\nvar UnsubscriptionError = createErrorClass((_super) => function UnsubscriptionErrorImpl(errors) {\n  _super(this);\n  this.message = errors ? `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join(\"\\n  \")}` : \"\";\n  this.name = \"UnsubscriptionError\";\n  this.errors = errors;\n});\n\n// node_modules/rxjs/dist/esm/internal/util/arrRemove.js\nfunction arrRemove(arr, item) {\n  if (arr) {\n    const index = arr.indexOf(item);\n    0 <= index && arr.splice(index, 1);\n  }\n}\n\n// node_modules/rxjs/dist/esm/internal/Subscription.js\nvar Subscription = class _Subscription {\n  constructor(initialTeardown) {\n    this.initialTeardown = initialTeardown;\n    this.closed = false;\n    this._parentage = null;\n    this._finalizers = null;\n  }\n  unsubscribe() {\n    let errors;\n    if (!this.closed) {\n      this.closed = true;\n      const {\n        _parentage\n      } = this;\n      if (_parentage) {\n        this._parentage = null;\n        if (Array.isArray(_parentage)) {\n          for (const parent of _parentage) {\n            parent.remove(this);\n          }\n        } else {\n          _parentage.remove(this);\n        }\n      }\n      const {\n        initialTeardown: initialFinalizer\n      } = this;\n      if (isFunction(initialFinalizer)) {\n        try {\n          initialFinalizer();\n        } catch (e) {\n          errors = e instanceof UnsubscriptionError ? e.errors : [e];\n        }\n      }\n      const {\n        _finalizers\n      } = this;\n      if (_finalizers) {\n        this._finalizers = null;\n        for (const finalizer of _finalizers) {\n          try {\n            execFinalizer(finalizer);\n          } catch (err) {\n            errors = errors !== null && errors !== void 0 ? errors : [];\n            if (err instanceof UnsubscriptionError) {\n              errors = [...errors, ...err.errors];\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n      if (errors) {\n        throw new UnsubscriptionError(errors);\n      }\n    }\n  }\n  add(teardown) {\n    var _a;\n    if (teardown && teardown !== this) {\n      if (this.closed) {\n        execFinalizer(teardown);\n      } else {\n        if (teardown instanceof _Subscription) {\n          if (teardown.closed || teardown._hasParent(this)) {\n            return;\n          }\n          teardown._addParent(this);\n        }\n        (this._finalizers = (_a = this._finalizers) !== null && _a !== void 0 ? _a : []).push(teardown);\n      }\n    }\n  }\n  _hasParent(parent) {\n    const {\n      _parentage\n    } = this;\n    return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);\n  }\n  _addParent(parent) {\n    const {\n      _parentage\n    } = this;\n    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;\n  }\n  _removeParent(parent) {\n    const {\n      _parentage\n    } = this;\n    if (_parentage === parent) {\n      this._parentage = null;\n    } else if (Array.isArray(_parentage)) {\n      arrRemove(_parentage, parent);\n    }\n  }\n  remove(teardown) {\n    const {\n      _finalizers\n    } = this;\n    _finalizers && arrRemove(_finalizers, teardown);\n    if (teardown instanceof _Subscription) {\n      teardown._removeParent(this);\n    }\n  }\n};\nSubscription.EMPTY = (() => {\n  const empty = new Subscription();\n  empty.closed = true;\n  return empty;\n})();\nvar EMPTY_SUBSCRIPTION = Subscription.EMPTY;\nfunction isSubscription(value) {\n  return value instanceof Subscription || value && \"closed\" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);\n}\nfunction execFinalizer(finalizer) {\n  if (isFunction(finalizer)) {\n    finalizer();\n  } else {\n    finalizer.unsubscribe();\n  }\n}\n\n// node_modules/rxjs/dist/esm/internal/config.js\nvar config = {\n  onUnhandledError: null,\n  onStoppedNotification: null,\n  Promise: void 0,\n  useDeprecatedSynchronousErrorHandling: false,\n  useDeprecatedNextContext: false\n};\n\n// node_modules/rxjs/dist/esm/internal/scheduler/timeoutProvider.js\nvar timeoutProvider = {\n  setTimeout(handler, timeout2, ...args) {\n    const {\n      delegate\n    } = timeoutProvider;\n    if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {\n      return delegate.setTimeout(handler, timeout2, ...args);\n    }\n    return setTimeout(handler, timeout2, ...args);\n  },\n  clearTimeout(handle) {\n    const {\n      delegate\n    } = timeoutProvider;\n    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);\n  },\n  delegate: void 0\n};\n\n// node_modules/rxjs/dist/esm/internal/util/reportUnhandledError.js\nfunction reportUnhandledError(err) {\n  timeoutProvider.setTimeout(() => {\n    const {\n      onUnhandledError\n    } = config;\n    if (onUnhandledError) {\n      onUnhandledError(err);\n    } else {\n      throw err;\n    }\n  });\n}\n\n// node_modules/rxjs/dist/esm/internal/util/noop.js\nfunction noop() {\n}\n\n// node_modules/rxjs/dist/esm/internal/NotificationFactories.js\nvar COMPLETE_NOTIFICATION = (() => createNotification(\"C\", void 0, void 0))();\nfunction errorNotification(error) {\n  return createNotification(\"E\", void 0, error);\n}\nfunction nextNotification(value) {\n  return createNotification(\"N\", value, void 0);\n}\nfunction createNotification(kind, value, error) {\n  return {\n    kind,\n    value,\n    error\n  };\n}\n\n// node_modules/rxjs/dist/esm/internal/util/errorContext.js\nvar context = null;\nfunction errorContext(cb) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    const isRoot = !context;\n    if (isRoot) {\n      context = {\n        errorThrown: false,\n        error: null\n      };\n    }\n    cb();\n    if (isRoot) {\n      const {\n        errorThrown,\n        error\n      } = context;\n      context = null;\n      if (errorThrown) {\n        throw error;\n      }\n    }\n  } else {\n    cb();\n  }\n}\nfunction captureError(err) {\n  if (config.useDeprecatedSynchronousErrorHandling && context) {\n    context.errorThrown = true;\n    context.error = err;\n  }\n}\n\n// node_modules/rxjs/dist/esm/internal/Subscriber.js\nvar Subscriber = class extends Subscription {\n  constructor(destination) {\n    super();\n    this.isStopped = false;\n    if (destination) {\n      this.destination = destination;\n      if (isSubscription(destination)) {\n        destination.add(this);\n      }\n    } else {\n      this.destination = EMPTY_OBSERVER;\n    }\n  }\n  static create(next, error, complete) {\n    return new SafeSubscriber(next, error, complete);\n  }\n  next(value) {\n    if (this.isStopped) {\n      handleStoppedNotification(nextNotification(value), this);\n    } else {\n      this._next(value);\n    }\n  }\n  error(err) {\n    if (this.isStopped) {\n      handleStoppedNotification(errorNotification(err), this);\n    } else {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n  complete() {\n    if (this.isStopped) {\n      handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n    } else {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n  unsubscribe() {\n    if (!this.closed) {\n      this.isStopped = true;\n      super.unsubscribe();\n      this.destination = null;\n    }\n  }\n  _next(value) {\n    this.destination.next(value);\n  }\n  _error(err) {\n    try {\n      this.destination.error(err);\n    } finally {\n      this.unsubscribe();\n    }\n  }\n  _complete() {\n    try {\n      this.destination.complete();\n    } finally {\n      this.unsubscribe();\n    }\n  }\n};\nvar _bind = Function.prototype.bind;\nfunction bind(fn, thisArg) {\n  return _bind.call(fn, thisArg);\n}\nvar ConsumerObserver = class {\n  constructor(partialObserver) {\n    this.partialObserver = partialObserver;\n  }\n  next(value) {\n    const {\n      partialObserver\n    } = this;\n    if (partialObserver.next) {\n      try {\n        partialObserver.next(value);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n  error(err) {\n    const {\n      partialObserver\n    } = this;\n    if (partialObserver.error) {\n      try {\n        partialObserver.error(err);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    } else {\n      handleUnhandledError(err);\n    }\n  }\n  complete() {\n    const {\n      partialObserver\n    } = this;\n    if (partialObserver.complete) {\n      try {\n        partialObserver.complete();\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n};\nvar SafeSubscriber = class extends Subscriber {\n  constructor(observerOrNext, error, complete) {\n    super();\n    let partialObserver;\n    if (isFunction(observerOrNext) || !observerOrNext) {\n      partialObserver = {\n        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,\n        error: error !== null && error !== void 0 ? error : void 0,\n        complete: complete !== null && complete !== void 0 ? complete : void 0\n      };\n    } else {\n      let context2;\n      if (this && config.useDeprecatedNextContext) {\n        context2 = Object.create(observerOrNext);\n        context2.unsubscribe = () => this.unsubscribe();\n        partialObserver = {\n          next: observerOrNext.next && bind(observerOrNext.next, context2),\n          error: observerOrNext.error && bind(observerOrNext.error, context2),\n          complete: observerOrNext.complete && bind(observerOrNext.complete, context2)\n        };\n      } else {\n        partialObserver = observerOrNext;\n      }\n    }\n    this.destination = new ConsumerObserver(partialObserver);\n  }\n};\nfunction handleUnhandledError(error) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    captureError(error);\n  } else {\n    reportUnhandledError(error);\n  }\n}\nfunction defaultErrorHandler(err) {\n  throw err;\n}\nfunction handleStoppedNotification(notification, subscriber) {\n  const {\n    onStoppedNotification\n  } = config;\n  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\n}\nvar EMPTY_OBSERVER = {\n  closed: true,\n  next: noop,\n  error: defaultErrorHandler,\n  complete: noop\n};\n\n// node_modules/rxjs/dist/esm/internal/symbol/observable.js\nvar observable = (() => typeof Symbol === \"function\" && Symbol.observable || \"@@observable\")();\n\n// node_modules/rxjs/dist/esm/internal/util/identity.js\nfunction identity(x) {\n  return x;\n}\n\n// node_modules/rxjs/dist/esm/internal/util/pipe.js\nfunction pipe(...fns) {\n  return pipeFromArray(fns);\n}\nfunction pipeFromArray(fns) {\n  if (fns.length === 0) {\n    return identity;\n  }\n  if (fns.length === 1) {\n    return fns[0];\n  }\n  return function piped(input2) {\n    return fns.reduce((prev, fn) => fn(prev), input2);\n  };\n}\n\n// node_modules/rxjs/dist/esm/internal/Observable.js\nvar Observable = class _Observable {\n  constructor(subscribe) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n  lift(operator) {\n    const observable2 = new _Observable();\n    observable2.source = this;\n    observable2.operator = operator;\n    return observable2;\n  }\n  subscribe(observerOrNext, error, complete) {\n    const subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);\n    errorContext(() => {\n      const {\n        operator,\n        source\n      } = this;\n      subscriber.add(operator ? operator.call(subscriber, source) : source ? this._subscribe(subscriber) : this._trySubscribe(subscriber));\n    });\n    return subscriber;\n  }\n  _trySubscribe(sink) {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      sink.error(err);\n    }\n  }\n  forEach(next, promiseCtor) {\n    promiseCtor = getPromiseCtor(promiseCtor);\n    return new promiseCtor((resolve, reject) => {\n      const subscriber = new SafeSubscriber({\n        next: (value) => {\n          try {\n            next(value);\n          } catch (err) {\n            reject(err);\n            subscriber.unsubscribe();\n          }\n        },\n        error: reject,\n        complete: resolve\n      });\n      this.subscribe(subscriber);\n    });\n  }\n  _subscribe(subscriber) {\n    var _a;\n    return (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber);\n  }\n  [observable]() {\n    return this;\n  }\n  pipe(...operations) {\n    return pipeFromArray(operations)(this);\n  }\n  toPromise(promiseCtor) {\n    promiseCtor = getPromiseCtor(promiseCtor);\n    return new promiseCtor((resolve, reject) => {\n      let value;\n      this.subscribe((x) => value = x, (err) => reject(err), () => resolve(value));\n    });\n  }\n};\nObservable.create = (subscribe) => {\n  return new Observable(subscribe);\n};\nfunction getPromiseCtor(promiseCtor) {\n  var _a;\n  return (_a = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a !== void 0 ? _a : Promise;\n}\nfunction isObserver(value) {\n  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);\n}\nfunction isSubscriber(value) {\n  return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);\n}\n\n// node_modules/rxjs/dist/esm/internal/util/lift.js\nfunction hasLift(source) {\n  return isFunction(source === null || source === void 0 ? void 0 : source.lift);\n}\nfunction operate(init) {\n  return (source) => {\n    if (hasLift(source)) {\n      return source.lift(function(liftedSource) {\n        try {\n          return init(liftedSource, this);\n        } catch (err) {\n          this.error(err);\n        }\n      });\n    }\n    throw new TypeError(\"Unable to lift unknown Observable type\");\n  };\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/OperatorSubscriber.js\nfunction createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {\n  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);\n}\nvar OperatorSubscriber = class extends Subscriber {\n  constructor(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {\n    super(destination);\n    this.onFinalize = onFinalize;\n    this.shouldUnsubscribe = shouldUnsubscribe;\n    this._next = onNext ? function(value) {\n      try {\n        onNext(value);\n      } catch (err) {\n        destination.error(err);\n      }\n    } : super._next;\n    this._error = onError ? function(err) {\n      try {\n        onError(err);\n      } catch (err2) {\n        destination.error(err2);\n      } finally {\n        this.unsubscribe();\n      }\n    } : super._error;\n    this._complete = onComplete ? function() {\n      try {\n        onComplete();\n      } catch (err) {\n        destination.error(err);\n      } finally {\n        this.unsubscribe();\n      }\n    } : super._complete;\n  }\n  unsubscribe() {\n    var _a;\n    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\n      const {\n        closed\n      } = this;\n      super.unsubscribe();\n      !closed && ((_a = this.onFinalize) === null || _a === void 0 ? void 0 : _a.call(this));\n    }\n  }\n};\n\n// node_modules/rxjs/dist/esm/internal/operators/refCount.js\nfunction refCount() {\n  return operate((source, subscriber) => {\n    let connection = null;\n    source._refCount++;\n    const refCounter = createOperatorSubscriber(subscriber, void 0, void 0, void 0, () => {\n      if (!source || source._refCount <= 0 || 0 < --source._refCount) {\n        connection = null;\n        return;\n      }\n      const sharedConnection = source._connection;\n      const conn = connection;\n      connection = null;\n      if (sharedConnection && (!conn || sharedConnection === conn)) {\n        sharedConnection.unsubscribe();\n      }\n      subscriber.unsubscribe();\n    });\n    source.subscribe(refCounter);\n    if (!refCounter.closed) {\n      connection = source.connect();\n    }\n  });\n}\n\n// node_modules/rxjs/dist/esm/internal/observable/ConnectableObservable.js\nvar ConnectableObservable = class extends Observable {\n  constructor(source, subjectFactory) {\n    super();\n    this.source = source;\n    this.subjectFactory = subjectFactory;\n    this._subject = null;\n    this._refCount = 0;\n    this._connection = null;\n    if (hasLift(source)) {\n      this.lift = source.lift;\n    }\n  }\n  _subscribe(subscriber) {\n    return this.getSubject().subscribe(subscriber);\n  }\n  getSubject() {\n    const subject = this._subject;\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n    return this._subject;\n  }\n  _teardown() {\n    this._refCount = 0;\n    const {\n      _connection\n    } = this;\n    this._subject = this._connection = null;\n    _connection === null || _connection === void 0 ? void 0 : _connection.unsubscribe();\n  }\n  connect() {\n    let connection = this._connection;\n    if (!connection) {\n      connection = this._connection = new Subscription();\n      const subject = this.getSubject();\n      connection.add(this.source.subscribe(createOperatorSubscriber(subject, void 0, () => {\n        this._teardown();\n        subject.complete();\n      }, (err) => {\n        this._teardown();\n        subject.error(err);\n      }, () => this._teardown())));\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      }\n    }\n    return connection;\n  }\n  refCount() {\n    return refCount()(this);\n  }\n};\n\n// node_modules/rxjs/dist/esm/internal/util/ObjectUnsubscribedError.js\nvar ObjectUnsubscribedError = createErrorClass((_super) => function ObjectUnsubscribedErrorImpl() {\n  _super(this);\n  this.name = \"ObjectUnsubscribedError\";\n  this.message = \"object unsubscribed\";\n});\n\n// node_modules/rxjs/dist/esm/internal/Subject.js\nvar Subject = class extends Observable {\n  constructor() {\n    super();\n    this.closed = false;\n    this.currentObservers = null;\n    this.observers = [];\n    this.isStopped = false;\n    this.hasError = false;\n    this.thrownError = null;\n  }\n  lift(operator) {\n    const subject = new AnonymousSubject(this, this);\n    subject.operator = operator;\n    return subject;\n  }\n  _throwIfClosed() {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n  }\n  next(value) {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        if (!this.currentObservers) {\n          this.currentObservers = Array.from(this.observers);\n        }\n        for (const observer of this.currentObservers) {\n          observer.next(value);\n        }\n      }\n    });\n  }\n  error(err) {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        this.hasError = this.isStopped = true;\n        this.thrownError = err;\n        const {\n          observers\n        } = this;\n        while (observers.length) {\n          observers.shift().error(err);\n        }\n      }\n    });\n  }\n  complete() {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        this.isStopped = true;\n        const {\n          observers\n        } = this;\n        while (observers.length) {\n          observers.shift().complete();\n        }\n      }\n    });\n  }\n  unsubscribe() {\n    this.isStopped = this.closed = true;\n    this.observers = this.currentObservers = null;\n  }\n  get observed() {\n    var _a;\n    return ((_a = this.observers) === null || _a === void 0 ? void 0 : _a.length) > 0;\n  }\n  _trySubscribe(subscriber) {\n    this._throwIfClosed();\n    return super._trySubscribe(subscriber);\n  }\n  _subscribe(subscriber) {\n    this._throwIfClosed();\n    this._checkFinalizedStatuses(subscriber);\n    return this._innerSubscribe(subscriber);\n  }\n  _innerSubscribe(subscriber) {\n    const {\n      hasError,\n      isStopped,\n      observers\n    } = this;\n    if (hasError || isStopped) {\n      return EMPTY_SUBSCRIPTION;\n    }\n    this.currentObservers = null;\n    observers.push(subscriber);\n    return new Subscription(() => {\n      this.currentObservers = null;\n      arrRemove(observers, subscriber);\n    });\n  }\n  _checkFinalizedStatuses(subscriber) {\n    const {\n      hasError,\n      thrownError,\n      isStopped\n    } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (isStopped) {\n      subscriber.complete();\n    }\n  }\n  asObservable() {\n    const observable2 = new Observable();\n    observable2.source = this;\n    return observable2;\n  }\n};\nSubject.create = (destination, source) => {\n  return new AnonymousSubject(destination, source);\n};\nvar AnonymousSubject = class extends Subject {\n  constructor(destination, source) {\n    super();\n    this.destination = destination;\n    this.source = source;\n  }\n  next(value) {\n    var _a, _b;\n    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.next) === null || _b === void 0 ? void 0 : _b.call(_a, value);\n  }\n  error(err) {\n    var _a, _b;\n    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.call(_a, err);\n  }\n  complete() {\n    var _a, _b;\n    (_b = (_a = this.destination) === null || _a === void 0 ? void 0 : _a.complete) === null || _b === void 0 ? void 0 : _b.call(_a);\n  }\n  _subscribe(subscriber) {\n    var _a, _b;\n    return (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.subscribe(subscriber)) !== null && _b !== void 0 ? _b : EMPTY_SUBSCRIPTION;\n  }\n};\n\n// node_modules/rxjs/dist/esm/internal/BehaviorSubject.js\nvar BehaviorSubject = class extends Subject {\n  constructor(_value) {\n    super();\n    this._value = _value;\n  }\n  get value() {\n    return this.getValue();\n  }\n  _subscribe(subscriber) {\n    const subscription = super._subscribe(subscriber);\n    !subscription.closed && subscriber.next(this._value);\n    return subscription;\n  }\n  getValue() {\n    const {\n      hasError,\n      thrownError,\n      _value\n    } = this;\n    if (hasError) {\n      throw thrownError;\n    }\n    this._throwIfClosed();\n    return _value;\n  }\n  next(value) {\n    super.next(this._value = value);\n  }\n};\n\n// node_modules/rxjs/dist/esm/internal/scheduler/dateTimestampProvider.js\nvar dateTimestampProvider = {\n  now() {\n    return (dateTimestampProvider.delegate || Date).now();\n  },\n  delegate: void 0\n};\n\n// node_modules/rxjs/dist/esm/internal/ReplaySubject.js\nvar ReplaySubject = class extends Subject {\n  constructor(_bufferSize = Infinity, _windowTime = Infinity, _timestampProvider = dateTimestampProvider) {\n    super();\n    this._bufferSize = _bufferSize;\n    this._windowTime = _windowTime;\n    this._timestampProvider = _timestampProvider;\n    this._buffer = [];\n    this._infiniteTimeWindow = true;\n    this._infiniteTimeWindow = _windowTime === Infinity;\n    this._bufferSize = Math.max(1, _bufferSize);\n    this._windowTime = Math.max(1, _windowTime);\n  }\n  next(value) {\n    const {\n      isStopped,\n      _buffer,\n      _infiniteTimeWindow,\n      _timestampProvider,\n      _windowTime\n    } = this;\n    if (!isStopped) {\n      _buffer.push(value);\n      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);\n    }\n    this._trimBuffer();\n    super.next(value);\n  }\n  _subscribe(subscriber) {\n    this._throwIfClosed();\n    this._trimBuffer();\n    const subscription = this._innerSubscribe(subscriber);\n    const {\n      _infiniteTimeWindow,\n      _buffer\n    } = this;\n    const copy = _buffer.slice();\n    for (let i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {\n      subscriber.next(copy[i]);\n    }\n    this._checkFinalizedStatuses(subscriber);\n    return subscription;\n  }\n  _trimBuffer() {\n    const {\n      _bufferSize,\n      _timestampProvider,\n      _buffer,\n      _infiniteTimeWindow\n    } = this;\n    const adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;\n    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);\n    if (!_infiniteTimeWindow) {\n      const now = _timestampProvider.now();\n      let last4 = 0;\n      for (let i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {\n        last4 = i;\n      }\n      last4 && _buffer.splice(0, last4 + 1);\n    }\n  }\n};\n\n// node_modules/rxjs/dist/esm/internal/scheduler/Action.js\nvar Action = class extends Subscription {\n  constructor(scheduler, work) {\n    super();\n  }\n  schedule(state, delay = 0) {\n    return this;\n  }\n};\n\n// node_modules/rxjs/dist/esm/internal/scheduler/intervalProvider.js\nvar intervalProvider = {\n  setInterval(handler, timeout2, ...args) {\n    const {\n      delegate\n    } = intervalProvider;\n    if (delegate === null || delegate === void 0 ? void 0 : delegate.setInterval) {\n      return delegate.setInterval(handler, timeout2, ...args);\n    }\n    return setInterval(handler, timeout2, ...args);\n  },\n  clearInterval(handle) {\n    const {\n      delegate\n    } = intervalProvider;\n    return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearInterval) || clearInterval)(handle);\n  },\n  delegate: void 0\n};\n\n// node_modules/rxjs/dist/esm/internal/scheduler/AsyncAction.js\nvar AsyncAction = class extends Action {\n  constructor(scheduler, work) {\n    super(scheduler, work);\n    this.scheduler = scheduler;\n    this.work = work;\n    this.pending = false;\n  }\n  schedule(state, delay = 0) {\n    var _a;\n    if (this.closed) {\n      return this;\n    }\n    this.state = state;\n    const id = this.id;\n    const scheduler = this.scheduler;\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n    this.pending = true;\n    this.delay = delay;\n    this.id = (_a = this.id) !== null && _a !== void 0 ? _a : this.requestAsyncId(scheduler, this.id, delay);\n    return this;\n  }\n  requestAsyncId(scheduler, _id, delay = 0) {\n    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);\n  }\n  recycleAsyncId(_scheduler, id, delay = 0) {\n    if (delay != null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    if (id != null) {\n      intervalProvider.clearInterval(id);\n    }\n    return void 0;\n  }\n  execute(state, delay) {\n    if (this.closed) {\n      return new Error(\"executing a cancelled action\");\n    }\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n  _execute(state, _delay) {\n    let errored = false;\n    let errorValue;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = e ? e : new Error(\"Scheduled action threw falsy error\");\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n  unsubscribe() {\n    if (!this.closed) {\n      const {\n        id,\n        scheduler\n      } = this;\n      const {\n        actions\n      } = scheduler;\n      this.work = this.state = this.scheduler = null;\n      this.pending = false;\n      arrRemove(actions, this);\n      if (id != null) {\n        this.id = this.recycleAsyncId(scheduler, id, null);\n      }\n      this.delay = null;\n      super.unsubscribe();\n    }\n  }\n};\n\n// node_modules/rxjs/dist/esm/internal/Scheduler.js\nvar Scheduler = class _Scheduler {\n  constructor(schedulerActionCtor, now = _Scheduler.now) {\n    this.schedulerActionCtor = schedulerActionCtor;\n    this.now = now;\n  }\n  schedule(work, delay = 0, state) {\n    return new this.schedulerActionCtor(this, work).schedule(state, delay);\n  }\n};\nScheduler.now = dateTimestampProvider.now;\n\n// node_modules/rxjs/dist/esm/internal/scheduler/AsyncScheduler.js\nvar AsyncScheduler = class extends Scheduler {\n  constructor(SchedulerAction, now = Scheduler.now) {\n    super(SchedulerAction, now);\n    this.actions = [];\n    this._active = false;\n  }\n  flush(action) {\n    const {\n      actions\n    } = this;\n    if (this._active) {\n      actions.push(action);\n      return;\n    }\n    let error;\n    this._active = true;\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (action = actions.shift());\n    this._active = false;\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n};\n\n// node_modules/rxjs/dist/esm/internal/scheduler/async.js\nvar asyncScheduler = new AsyncScheduler(AsyncAction);\n\n// node_modules/rxjs/dist/esm/internal/scheduler/QueueAction.js\nvar QueueAction = class extends AsyncAction {\n  constructor(scheduler, work) {\n    super(scheduler, work);\n    this.scheduler = scheduler;\n    this.work = work;\n  }\n  schedule(state, delay = 0) {\n    if (delay > 0) {\n      return super.schedule(state, delay);\n    }\n    this.delay = delay;\n    this.state = state;\n    this.scheduler.flush(this);\n    return this;\n  }\n  execute(state, delay) {\n    return delay > 0 || this.closed ? super.execute(state, delay) : this._execute(state, delay);\n  }\n  requestAsyncId(scheduler, id, delay = 0) {\n    if (delay != null && delay > 0 || delay == null && this.delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    scheduler.flush(this);\n    return 0;\n  }\n};\n\n// node_modules/rxjs/dist/esm/internal/scheduler/QueueScheduler.js\nvar QueueScheduler = class extends AsyncScheduler {\n};\n\n// node_modules/rxjs/dist/esm/internal/scheduler/queue.js\nvar queueScheduler = new QueueScheduler(QueueAction);\n\n// node_modules/rxjs/dist/esm/internal/observable/empty.js\nvar EMPTY = new Observable((subscriber) => subscriber.complete());\n\n// node_modules/rxjs/dist/esm/internal/util/isScheduler.js\nfunction isScheduler(value) {\n  return value && isFunction(value.schedule);\n}\n\n// node_modules/rxjs/dist/esm/internal/util/args.js\nfunction last(arr) {\n  return arr[arr.length - 1];\n}\nfunction popResultSelector(args) {\n  return isFunction(last(args)) ? args.pop() : void 0;\n}\nfunction popScheduler(args) {\n  return isScheduler(last(args)) ? args.pop() : void 0;\n}\nfunction popNumber(args, defaultValue) {\n  return typeof last(args) === \"number\" ? args.pop() : defaultValue;\n}\n\n// node_modules/tslib/tslib.es6.mjs\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function(resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function(resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\nfunction __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function() {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function() {\n    return this;\n  }, i;\n  function awaitReturn(f) {\n    return function(v) {\n      return Promise.resolve(v).then(f, reject);\n    };\n  }\n  function verb(n, f) {\n    if (g[n]) {\n      i[n] = function(v) {\n        return new Promise(function(a, b) {\n          q.push([n, v, a, b]) > 1 || resume(n, v);\n        });\n      };\n      if (f) i[n] = f(i[n]);\n    }\n  }\n  function resume(n, v) {\n    try {\n      step(g[n](v));\n    } catch (e) {\n      settle(q[0][3], e);\n    }\n  }\n  function step(r) {\n    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);\n  }\n  function fulfill(value) {\n    resume(\"next\", value);\n  }\n  function reject(value) {\n    resume(\"throw\", value);\n  }\n  function settle(f, v) {\n    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);\n  }\n}\nfunction __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n    return this;\n  }, i);\n  function verb(n) {\n    i[n] = o[n] && function(v) {\n      return new Promise(function(resolve, reject) {\n        v = o[n](v), settle(resolve, reject, v.done, v.value);\n      });\n    };\n  }\n  function settle(resolve, reject, d, v) {\n    Promise.resolve(v).then(function(v2) {\n      resolve({\n        value: v2,\n        done: d\n      });\n    }, reject);\n  }\n}\n\n// node_modules/rxjs/dist/esm/internal/util/isArrayLike.js\nvar isArrayLike = (x) => x && typeof x.length === \"number\" && typeof x !== \"function\";\n\n// node_modules/rxjs/dist/esm/internal/util/isPromise.js\nfunction isPromise(value) {\n  return isFunction(value === null || value === void 0 ? void 0 : value.then);\n}\n\n// node_modules/rxjs/dist/esm/internal/util/isInteropObservable.js\nfunction isInteropObservable(input2) {\n  return isFunction(input2[observable]);\n}\n\n// node_modules/rxjs/dist/esm/internal/util/isAsyncIterable.js\nfunction isAsyncIterable(obj) {\n  return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);\n}\n\n// node_modules/rxjs/dist/esm/internal/util/throwUnobservableError.js\nfunction createInvalidObservableTypeError(input2) {\n  return new TypeError(`You provided ${input2 !== null && typeof input2 === \"object\" ? \"an invalid object\" : `'${input2}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`);\n}\n\n// node_modules/rxjs/dist/esm/internal/symbol/iterator.js\nfunction getSymbolIterator() {\n  if (typeof Symbol !== \"function\" || !Symbol.iterator) {\n    return \"@@iterator\";\n  }\n  return Symbol.iterator;\n}\nvar iterator = getSymbolIterator();\n\n// node_modules/rxjs/dist/esm/internal/util/isIterable.js\nfunction isIterable(input2) {\n  return isFunction(input2 === null || input2 === void 0 ? void 0 : input2[iterator]);\n}\n\n// node_modules/rxjs/dist/esm/internal/util/isReadableStreamLike.js\nfunction readableStreamLikeToAsyncGenerator(readableStream) {\n  return __asyncGenerator(this, arguments, function* readableStreamLikeToAsyncGenerator_1() {\n    const reader = readableStream.getReader();\n    try {\n      while (true) {\n        const {\n          value,\n          done\n        } = yield __await(reader.read());\n        if (done) {\n          return yield __await(void 0);\n        }\n        yield yield __await(value);\n      }\n    } finally {\n      reader.releaseLock();\n    }\n  });\n}\nfunction isReadableStreamLike(obj) {\n  return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);\n}\n\n// node_modules/rxjs/dist/esm/internal/observable/innerFrom.js\nfunction innerFrom(input2) {\n  if (input2 instanceof Observable) {\n    return input2;\n  }\n  if (input2 != null) {\n    if (isInteropObservable(input2)) {\n      return fromInteropObservable(input2);\n    }\n    if (isArrayLike(input2)) {\n      return fromArrayLike(input2);\n    }\n    if (isPromise(input2)) {\n      return fromPromise(input2);\n    }\n    if (isAsyncIterable(input2)) {\n      return fromAsyncIterable(input2);\n    }\n    if (isIterable(input2)) {\n      return fromIterable(input2);\n    }\n    if (isReadableStreamLike(input2)) {\n      return fromReadableStreamLike(input2);\n    }\n  }\n  throw createInvalidObservableTypeError(input2);\n}\nfunction fromInteropObservable(obj) {\n  return new Observable((subscriber) => {\n    const obs = obj[observable]();\n    if (isFunction(obs.subscribe)) {\n      return obs.subscribe(subscriber);\n    }\n    throw new TypeError(\"Provided object does not correctly implement Symbol.observable\");\n  });\n}\nfunction fromArrayLike(array) {\n  return new Observable((subscriber) => {\n    for (let i = 0; i < array.length && !subscriber.closed; i++) {\n      subscriber.next(array[i]);\n    }\n    subscriber.complete();\n  });\n}\nfunction fromPromise(promise) {\n  return new Observable((subscriber) => {\n    promise.then((value) => {\n      if (!subscriber.closed) {\n        subscriber.next(value);\n        subscriber.complete();\n      }\n    }, (err) => subscriber.error(err)).then(null, reportUnhandledError);\n  });\n}\nfunction fromIterable(iterable) {\n  return new Observable((subscriber) => {\n    for (const value of iterable) {\n      subscriber.next(value);\n      if (subscriber.closed) {\n        return;\n      }\n    }\n    subscriber.complete();\n  });\n}\nfunction fromAsyncIterable(asyncIterable) {\n  return new Observable((subscriber) => {\n    process(asyncIterable, subscriber).catch((err) => subscriber.error(err));\n  });\n}\nfunction fromReadableStreamLike(readableStream) {\n  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));\n}\nfunction process(asyncIterable, subscriber) {\n  var asyncIterable_1, asyncIterable_1_1;\n  var e_1, _a;\n  return __awaiter(this, void 0, void 0, function* () {\n    try {\n      for (asyncIterable_1 = __asyncValues(asyncIterable); asyncIterable_1_1 = yield asyncIterable_1.next(), !asyncIterable_1_1.done; ) {\n        const value = asyncIterable_1_1.value;\n        subscriber.next(value);\n        if (subscriber.closed) {\n          return;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (asyncIterable_1_1 && !asyncIterable_1_1.done && (_a = asyncIterable_1.return)) yield _a.call(asyncIterable_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    subscriber.complete();\n  });\n}\n\n// node_modules/rxjs/dist/esm/internal/util/executeSchedule.js\nfunction executeSchedule(parentSubscription, scheduler, work, delay = 0, repeat = false) {\n  const scheduleSubscription = scheduler.schedule(function() {\n    work();\n    if (repeat) {\n      parentSubscription.add(this.schedule(null, delay));\n    } else {\n      this.unsubscribe();\n    }\n  }, delay);\n  parentSubscription.add(scheduleSubscription);\n  if (!repeat) {\n    return scheduleSubscription;\n  }\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/observeOn.js\nfunction observeOn(scheduler, delay = 0) {\n  return operate((source, subscriber) => {\n    source.subscribe(createOperatorSubscriber(subscriber, (value) => executeSchedule(subscriber, scheduler, () => subscriber.next(value), delay), () => executeSchedule(subscriber, scheduler, () => subscriber.complete(), delay), (err) => executeSchedule(subscriber, scheduler, () => subscriber.error(err), delay)));\n  });\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/subscribeOn.js\nfunction subscribeOn(scheduler, delay = 0) {\n  return operate((source, subscriber) => {\n    subscriber.add(scheduler.schedule(() => source.subscribe(subscriber), delay));\n  });\n}\n\n// node_modules/rxjs/dist/esm/internal/scheduled/scheduleObservable.js\nfunction scheduleObservable(input2, scheduler) {\n  return innerFrom(input2).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n\n// node_modules/rxjs/dist/esm/internal/scheduled/schedulePromise.js\nfunction schedulePromise(input2, scheduler) {\n  return innerFrom(input2).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n\n// node_modules/rxjs/dist/esm/internal/scheduled/scheduleArray.js\nfunction scheduleArray(input2, scheduler) {\n  return new Observable((subscriber) => {\n    let i = 0;\n    return scheduler.schedule(function() {\n      if (i === input2.length) {\n        subscriber.complete();\n      } else {\n        subscriber.next(input2[i++]);\n        if (!subscriber.closed) {\n          this.schedule();\n        }\n      }\n    });\n  });\n}\n\n// node_modules/rxjs/dist/esm/internal/scheduled/scheduleIterable.js\nfunction scheduleIterable(input2, scheduler) {\n  return new Observable((subscriber) => {\n    let iterator2;\n    executeSchedule(subscriber, scheduler, () => {\n      iterator2 = input2[iterator]();\n      executeSchedule(subscriber, scheduler, () => {\n        let value;\n        let done;\n        try {\n          ({\n            value,\n            done\n          } = iterator2.next());\n        } catch (err) {\n          subscriber.error(err);\n          return;\n        }\n        if (done) {\n          subscriber.complete();\n        } else {\n          subscriber.next(value);\n        }\n      }, 0, true);\n    });\n    return () => isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();\n  });\n}\n\n// node_modules/rxjs/dist/esm/internal/scheduled/scheduleAsyncIterable.js\nfunction scheduleAsyncIterable(input2, scheduler) {\n  if (!input2) {\n    throw new Error(\"Iterable cannot be null\");\n  }\n  return new Observable((subscriber) => {\n    executeSchedule(subscriber, scheduler, () => {\n      const iterator2 = input2[Symbol.asyncIterator]();\n      executeSchedule(subscriber, scheduler, () => {\n        iterator2.next().then((result) => {\n          if (result.done) {\n            subscriber.complete();\n          } else {\n            subscriber.next(result.value);\n          }\n        });\n      }, 0, true);\n    });\n  });\n}\n\n// node_modules/rxjs/dist/esm/internal/scheduled/scheduleReadableStreamLike.js\nfunction scheduleReadableStreamLike(input2, scheduler) {\n  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input2), scheduler);\n}\n\n// node_modules/rxjs/dist/esm/internal/scheduled/scheduled.js\nfunction scheduled(input2, scheduler) {\n  if (input2 != null) {\n    if (isInteropObservable(input2)) {\n      return scheduleObservable(input2, scheduler);\n    }\n    if (isArrayLike(input2)) {\n      return scheduleArray(input2, scheduler);\n    }\n    if (isPromise(input2)) {\n      return schedulePromise(input2, scheduler);\n    }\n    if (isAsyncIterable(input2)) {\n      return scheduleAsyncIterable(input2, scheduler);\n    }\n    if (isIterable(input2)) {\n      return scheduleIterable(input2, scheduler);\n    }\n    if (isReadableStreamLike(input2)) {\n      return scheduleReadableStreamLike(input2, scheduler);\n    }\n  }\n  throw createInvalidObservableTypeError(input2);\n}\n\n// node_modules/rxjs/dist/esm/internal/observable/from.js\nfunction from(input2, scheduler) {\n  return scheduler ? scheduled(input2, scheduler) : innerFrom(input2);\n}\n\n// node_modules/rxjs/dist/esm/internal/observable/of.js\nfunction of(...args) {\n  const scheduler = popScheduler(args);\n  return from(args, scheduler);\n}\n\n// node_modules/rxjs/dist/esm/internal/observable/throwError.js\nfunction throwError(errorOrErrorFactory, scheduler) {\n  const errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : () => errorOrErrorFactory;\n  const init = (subscriber) => subscriber.error(errorFactory());\n  return new Observable(scheduler ? (subscriber) => scheduler.schedule(init, 0, subscriber) : init);\n}\n\n// node_modules/rxjs/dist/esm/internal/util/isObservable.js\nfunction isObservable(obj) {\n  return !!obj && (obj instanceof Observable || isFunction(obj.lift) && isFunction(obj.subscribe));\n}\n\n// node_modules/rxjs/dist/esm/internal/util/EmptyError.js\nvar EmptyError = createErrorClass((_super) => function EmptyErrorImpl() {\n  _super(this);\n  this.name = \"EmptyError\";\n  this.message = \"no elements in sequence\";\n});\n\n// node_modules/rxjs/dist/esm/internal/util/isDate.js\nfunction isValidDate(value) {\n  return value instanceof Date && !isNaN(value);\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/timeout.js\nvar TimeoutError = createErrorClass((_super) => function TimeoutErrorImpl(info = null) {\n  _super(this);\n  this.message = \"Timeout has occurred\";\n  this.name = \"TimeoutError\";\n  this.info = info;\n});\nfunction timeout(config2, schedulerArg) {\n  const {\n    first: first2,\n    each,\n    with: _with = timeoutErrorFactory,\n    scheduler = schedulerArg !== null && schedulerArg !== void 0 ? schedulerArg : asyncScheduler,\n    meta = null\n  } = isValidDate(config2) ? {\n    first: config2\n  } : typeof config2 === \"number\" ? {\n    each: config2\n  } : config2;\n  if (first2 == null && each == null) {\n    throw new TypeError(\"No timeout provided.\");\n  }\n  return operate((source, subscriber) => {\n    let originalSourceSubscription;\n    let timerSubscription;\n    let lastValue = null;\n    let seen = 0;\n    const startTimer = (delay) => {\n      timerSubscription = executeSchedule(subscriber, scheduler, () => {\n        try {\n          originalSourceSubscription.unsubscribe();\n          innerFrom(_with({\n            meta,\n            lastValue,\n            seen\n          })).subscribe(subscriber);\n        } catch (err) {\n          subscriber.error(err);\n        }\n      }, delay);\n    };\n    originalSourceSubscription = source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n      timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();\n      seen++;\n      subscriber.next(lastValue = value);\n      each > 0 && startTimer(each);\n    }, void 0, void 0, () => {\n      if (!(timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.closed)) {\n        timerSubscription === null || timerSubscription === void 0 ? void 0 : timerSubscription.unsubscribe();\n      }\n      lastValue = null;\n    }));\n    !seen && startTimer(first2 != null ? typeof first2 === \"number\" ? first2 : +first2 - scheduler.now() : each);\n  });\n}\nfunction timeoutErrorFactory(info) {\n  throw new TimeoutError(info);\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/map.js\nfunction map(project, thisArg) {\n  return operate((source, subscriber) => {\n    let index = 0;\n    source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n      subscriber.next(project.call(thisArg, value, index++));\n    }));\n  });\n}\n\n// node_modules/rxjs/dist/esm/internal/util/mapOneOrManyArgs.js\nvar {\n  isArray\n} = Array;\nfunction callOrApply(fn, args) {\n  return isArray(args) ? fn(...args) : fn(args);\n}\nfunction mapOneOrManyArgs(fn) {\n  return map((args) => callOrApply(fn, args));\n}\n\n// node_modules/rxjs/dist/esm/internal/util/argsArgArrayOrObject.js\nvar {\n  isArray: isArray2\n} = Array;\nvar {\n  getPrototypeOf,\n  prototype: objectProto,\n  keys: getKeys\n} = Object;\nfunction argsArgArrayOrObject(args) {\n  if (args.length === 1) {\n    const first2 = args[0];\n    if (isArray2(first2)) {\n      return {\n        args: first2,\n        keys: null\n      };\n    }\n    if (isPOJO(first2)) {\n      const keys = getKeys(first2);\n      return {\n        args: keys.map((key) => first2[key]),\n        keys\n      };\n    }\n  }\n  return {\n    args,\n    keys: null\n  };\n}\nfunction isPOJO(obj) {\n  return obj && typeof obj === \"object\" && getPrototypeOf(obj) === objectProto;\n}\n\n// node_modules/rxjs/dist/esm/internal/util/createObject.js\nfunction createObject(keys, values) {\n  return keys.reduce((result, key, i) => (result[key] = values[i], result), {});\n}\n\n// node_modules/rxjs/dist/esm/internal/observable/combineLatest.js\nfunction combineLatest(...args) {\n  const scheduler = popScheduler(args);\n  const resultSelector = popResultSelector(args);\n  const {\n    args: observables,\n    keys\n  } = argsArgArrayOrObject(args);\n  if (observables.length === 0) {\n    return from([], scheduler);\n  }\n  const result = new Observable(combineLatestInit(observables, scheduler, keys ? (values) => createObject(keys, values) : identity));\n  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;\n}\nfunction combineLatestInit(observables, scheduler, valueTransform = identity) {\n  return (subscriber) => {\n    maybeSchedule(scheduler, () => {\n      const {\n        length\n      } = observables;\n      const values = new Array(length);\n      let active = length;\n      let remainingFirstValues = length;\n      for (let i = 0; i < length; i++) {\n        maybeSchedule(scheduler, () => {\n          const source = from(observables[i], scheduler);\n          let hasFirstValue = false;\n          source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n            values[i] = value;\n            if (!hasFirstValue) {\n              hasFirstValue = true;\n              remainingFirstValues--;\n            }\n            if (!remainingFirstValues) {\n              subscriber.next(valueTransform(values.slice()));\n            }\n          }, () => {\n            if (!--active) {\n              subscriber.complete();\n            }\n          }));\n        }, subscriber);\n      }\n    }, subscriber);\n  };\n}\nfunction maybeSchedule(scheduler, execute, subscription) {\n  if (scheduler) {\n    executeSchedule(subscription, scheduler, execute);\n  } else {\n    execute();\n  }\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/mergeInternals.js\nfunction mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {\n  const buffer = [];\n  let active = 0;\n  let index = 0;\n  let isComplete = false;\n  const checkComplete = () => {\n    if (isComplete && !buffer.length && !active) {\n      subscriber.complete();\n    }\n  };\n  const outerNext = (value) => active < concurrent ? doInnerSub(value) : buffer.push(value);\n  const doInnerSub = (value) => {\n    expand && subscriber.next(value);\n    active++;\n    let innerComplete = false;\n    innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, (innerValue) => {\n      onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);\n      if (expand) {\n        outerNext(innerValue);\n      } else {\n        subscriber.next(innerValue);\n      }\n    }, () => {\n      innerComplete = true;\n    }, void 0, () => {\n      if (innerComplete) {\n        try {\n          active--;\n          while (buffer.length && active < concurrent) {\n            const bufferedValue = buffer.shift();\n            if (innerSubScheduler) {\n              executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));\n            } else {\n              doInnerSub(bufferedValue);\n            }\n          }\n          checkComplete();\n        } catch (err) {\n          subscriber.error(err);\n        }\n      }\n    }));\n  };\n  source.subscribe(createOperatorSubscriber(subscriber, outerNext, () => {\n    isComplete = true;\n    checkComplete();\n  }));\n  return () => {\n    additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();\n  };\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/mergeMap.js\nfunction mergeMap(project, resultSelector, concurrent = Infinity) {\n  if (isFunction(resultSelector)) {\n    return mergeMap((a, i) => map((b, ii) => resultSelector(a, b, i, ii))(innerFrom(project(a, i))), concurrent);\n  } else if (typeof resultSelector === \"number\") {\n    concurrent = resultSelector;\n  }\n  return operate((source, subscriber) => mergeInternals(source, subscriber, project, concurrent));\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/mergeAll.js\nfunction mergeAll(concurrent = Infinity) {\n  return mergeMap(identity, concurrent);\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/concatAll.js\nfunction concatAll() {\n  return mergeAll(1);\n}\n\n// node_modules/rxjs/dist/esm/internal/observable/concat.js\nfunction concat(...args) {\n  return concatAll()(from(args, popScheduler(args)));\n}\n\n// node_modules/rxjs/dist/esm/internal/observable/defer.js\nfunction defer(observableFactory) {\n  return new Observable((subscriber) => {\n    innerFrom(observableFactory()).subscribe(subscriber);\n  });\n}\n\n// node_modules/rxjs/dist/esm/internal/observable/forkJoin.js\nfunction forkJoin(...args) {\n  const resultSelector = popResultSelector(args);\n  const {\n    args: sources,\n    keys\n  } = argsArgArrayOrObject(args);\n  const result = new Observable((subscriber) => {\n    const {\n      length\n    } = sources;\n    if (!length) {\n      subscriber.complete();\n      return;\n    }\n    const values = new Array(length);\n    let remainingCompletions = length;\n    let remainingEmissions = length;\n    for (let sourceIndex = 0; sourceIndex < length; sourceIndex++) {\n      let hasValue = false;\n      innerFrom(sources[sourceIndex]).subscribe(createOperatorSubscriber(subscriber, (value) => {\n        if (!hasValue) {\n          hasValue = true;\n          remainingEmissions--;\n        }\n        values[sourceIndex] = value;\n      }, () => remainingCompletions--, void 0, () => {\n        if (!remainingCompletions || !hasValue) {\n          if (!remainingEmissions) {\n            subscriber.next(keys ? createObject(keys, values) : values);\n          }\n          subscriber.complete();\n        }\n      }));\n    }\n  });\n  return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;\n}\n\n// node_modules/rxjs/dist/esm/internal/observable/merge.js\nfunction merge(...args) {\n  const scheduler = popScheduler(args);\n  const concurrent = popNumber(args, Infinity);\n  const sources = args;\n  return !sources.length ? EMPTY : sources.length === 1 ? innerFrom(sources[0]) : mergeAll(concurrent)(from(sources, scheduler));\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/filter.js\nfunction filter(predicate, thisArg) {\n  return operate((source, subscriber) => {\n    let index = 0;\n    source.subscribe(createOperatorSubscriber(subscriber, (value) => predicate.call(thisArg, value, index++) && subscriber.next(value)));\n  });\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/catchError.js\nfunction catchError(selector) {\n  return operate((source, subscriber) => {\n    let innerSub = null;\n    let syncUnsub = false;\n    let handledResult;\n    innerSub = source.subscribe(createOperatorSubscriber(subscriber, void 0, void 0, (err) => {\n      handledResult = innerFrom(selector(err, catchError(selector)(source)));\n      if (innerSub) {\n        innerSub.unsubscribe();\n        innerSub = null;\n        handledResult.subscribe(subscriber);\n      } else {\n        syncUnsub = true;\n      }\n    }));\n    if (syncUnsub) {\n      innerSub.unsubscribe();\n      innerSub = null;\n      handledResult.subscribe(subscriber);\n    }\n  });\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/scanInternals.js\nfunction scanInternals(accumulator, seed, hasSeed, emitOnNext, emitBeforeComplete) {\n  return (source, subscriber) => {\n    let hasState = hasSeed;\n    let state = seed;\n    let index = 0;\n    source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n      const i = index++;\n      state = hasState ? accumulator(state, value, i) : (hasState = true, value);\n      emitOnNext && subscriber.next(state);\n    }, emitBeforeComplete && (() => {\n      hasState && subscriber.next(state);\n      subscriber.complete();\n    })));\n  };\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/concatMap.js\nfunction concatMap(project, resultSelector) {\n  return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/debounceTime.js\nfunction debounceTime(dueTime, scheduler = asyncScheduler) {\n  return operate((source, subscriber) => {\n    let activeTask = null;\n    let lastValue = null;\n    let lastTime = null;\n    const emit = () => {\n      if (activeTask) {\n        activeTask.unsubscribe();\n        activeTask = null;\n        const value = lastValue;\n        lastValue = null;\n        subscriber.next(value);\n      }\n    };\n    function emitWhenIdle() {\n      const targetTime = lastTime + dueTime;\n      const now = scheduler.now();\n      if (now < targetTime) {\n        activeTask = this.schedule(void 0, targetTime - now);\n        subscriber.add(activeTask);\n        return;\n      }\n      emit();\n    }\n    source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n      lastValue = value;\n      lastTime = scheduler.now();\n      if (!activeTask) {\n        activeTask = scheduler.schedule(emitWhenIdle, dueTime);\n        subscriber.add(activeTask);\n      }\n    }, () => {\n      emit();\n      subscriber.complete();\n    }, void 0, () => {\n      lastValue = activeTask = null;\n    }));\n  });\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/defaultIfEmpty.js\nfunction defaultIfEmpty(defaultValue) {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n      hasValue = true;\n      subscriber.next(value);\n    }, () => {\n      if (!hasValue) {\n        subscriber.next(defaultValue);\n      }\n      subscriber.complete();\n    }));\n  });\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/take.js\nfunction take(count) {\n  return count <= 0 ? () => EMPTY : operate((source, subscriber) => {\n    let seen = 0;\n    source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n      if (++seen <= count) {\n        subscriber.next(value);\n        if (count <= seen) {\n          subscriber.complete();\n        }\n      }\n    }));\n  });\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/distinctUntilChanged.js\nfunction distinctUntilChanged(comparator, keySelector = identity) {\n  comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;\n  return operate((source, subscriber) => {\n    let previousKey;\n    let first2 = true;\n    source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n      const currentKey = keySelector(value);\n      if (first2 || !comparator(previousKey, currentKey)) {\n        first2 = false;\n        previousKey = currentKey;\n        subscriber.next(value);\n      }\n    }));\n  });\n}\nfunction defaultCompare(a, b) {\n  return a === b;\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/throwIfEmpty.js\nfunction throwIfEmpty(errorFactory = defaultErrorFactory) {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n      hasValue = true;\n      subscriber.next(value);\n    }, () => hasValue ? subscriber.complete() : subscriber.error(errorFactory())));\n  });\n}\nfunction defaultErrorFactory() {\n  return new EmptyError();\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/finalize.js\nfunction finalize(callback) {\n  return operate((source, subscriber) => {\n    try {\n      source.subscribe(subscriber);\n    } finally {\n      subscriber.add(callback);\n    }\n  });\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/first.js\nfunction first(predicate, defaultValue) {\n  const hasDefaultValue = arguments.length >= 2;\n  return (source) => source.pipe(predicate ? filter((v, i) => predicate(v, i, source)) : identity, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(() => new EmptyError()));\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/takeLast.js\nfunction takeLast(count) {\n  return count <= 0 ? () => EMPTY : operate((source, subscriber) => {\n    let buffer = [];\n    source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n      buffer.push(value);\n      count < buffer.length && buffer.shift();\n    }, () => {\n      for (const value of buffer) {\n        subscriber.next(value);\n      }\n      subscriber.complete();\n    }, void 0, () => {\n      buffer = null;\n    }));\n  });\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/last.js\nfunction last2(predicate, defaultValue) {\n  const hasDefaultValue = arguments.length >= 2;\n  return (source) => source.pipe(predicate ? filter((v, i) => predicate(v, i, source)) : identity, takeLast(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(() => new EmptyError()));\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/pluck.js\nfunction pluck(...properties) {\n  const length = properties.length;\n  if (length === 0) {\n    throw new Error(\"list of properties cannot be empty.\");\n  }\n  return map((x) => {\n    let currentProp = x;\n    for (let i = 0; i < length; i++) {\n      const p = currentProp === null || currentProp === void 0 ? void 0 : currentProp[properties[i]];\n      if (typeof p !== \"undefined\") {\n        currentProp = p;\n      } else {\n        return void 0;\n      }\n    }\n    return currentProp;\n  });\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/scan.js\nfunction scan(accumulator, seed) {\n  return operate(scanInternals(accumulator, seed, arguments.length >= 2, true));\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/share.js\nfunction share(options = {}) {\n  const {\n    connector = () => new Subject(),\n    resetOnError = true,\n    resetOnComplete = true,\n    resetOnRefCountZero = true\n  } = options;\n  return (wrapperSource) => {\n    let connection;\n    let resetConnection;\n    let subject;\n    let refCount2 = 0;\n    let hasCompleted = false;\n    let hasErrored = false;\n    const cancelReset = () => {\n      resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();\n      resetConnection = void 0;\n    };\n    const reset = () => {\n      cancelReset();\n      connection = subject = void 0;\n      hasCompleted = hasErrored = false;\n    };\n    const resetAndUnsubscribe = () => {\n      const conn = connection;\n      reset();\n      conn === null || conn === void 0 ? void 0 : conn.unsubscribe();\n    };\n    return operate((source, subscriber) => {\n      refCount2++;\n      if (!hasErrored && !hasCompleted) {\n        cancelReset();\n      }\n      const dest = subject = subject !== null && subject !== void 0 ? subject : connector();\n      subscriber.add(() => {\n        refCount2--;\n        if (refCount2 === 0 && !hasErrored && !hasCompleted) {\n          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);\n        }\n      });\n      dest.subscribe(subscriber);\n      if (!connection && refCount2 > 0) {\n        connection = new SafeSubscriber({\n          next: (value) => dest.next(value),\n          error: (err) => {\n            hasErrored = true;\n            cancelReset();\n            resetConnection = handleReset(reset, resetOnError, err);\n            dest.error(err);\n          },\n          complete: () => {\n            hasCompleted = true;\n            cancelReset();\n            resetConnection = handleReset(reset, resetOnComplete);\n            dest.complete();\n          }\n        });\n        innerFrom(source).subscribe(connection);\n      }\n    })(wrapperSource);\n  };\n}\nfunction handleReset(reset, on2, ...args) {\n  if (on2 === true) {\n    reset();\n    return;\n  }\n  if (on2 === false) {\n    return;\n  }\n  const onSubscriber = new SafeSubscriber({\n    next: () => {\n      onSubscriber.unsubscribe();\n      reset();\n    }\n  });\n  return innerFrom(on2(...args)).subscribe(onSubscriber);\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/skip.js\nfunction skip(count) {\n  return filter((_, index) => count <= index);\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/startWith.js\nfunction startWith(...values) {\n  const scheduler = popScheduler(values);\n  return operate((source, subscriber) => {\n    (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);\n  });\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/switchMap.js\nfunction switchMap(project, resultSelector) {\n  return operate((source, subscriber) => {\n    let innerSubscriber = null;\n    let index = 0;\n    let isComplete = false;\n    const checkComplete = () => isComplete && !innerSubscriber && subscriber.complete();\n    source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n      innerSubscriber === null || innerSubscriber === void 0 ? void 0 : innerSubscriber.unsubscribe();\n      let innerIndex = 0;\n      const outerIndex = index++;\n      innerFrom(project(value, outerIndex)).subscribe(innerSubscriber = createOperatorSubscriber(subscriber, (innerValue) => subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue), () => {\n        innerSubscriber = null;\n        checkComplete();\n      }));\n    }, () => {\n      isComplete = true;\n      checkComplete();\n    }));\n  });\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/takeUntil.js\nfunction takeUntil(notifier) {\n  return operate((source, subscriber) => {\n    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, () => subscriber.complete(), noop));\n    !subscriber.closed && source.subscribe(subscriber);\n  });\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/tap.js\nfunction tap(observerOrNext, error, complete) {\n  const tapObserver = isFunction(observerOrNext) || error || complete ? {\n    next: observerOrNext,\n    error,\n    complete\n  } : observerOrNext;\n  return tapObserver ? operate((source, subscriber) => {\n    var _a;\n    (_a = tapObserver.subscribe) === null || _a === void 0 ? void 0 : _a.call(tapObserver);\n    let isUnsub = true;\n    source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n      var _a2;\n      (_a2 = tapObserver.next) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, value);\n      subscriber.next(value);\n    }, () => {\n      var _a2;\n      isUnsub = false;\n      (_a2 = tapObserver.complete) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);\n      subscriber.complete();\n    }, (err) => {\n      var _a2;\n      isUnsub = false;\n      (_a2 = tapObserver.error) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver, err);\n      subscriber.error(err);\n    }, () => {\n      var _a2, _b;\n      if (isUnsub) {\n        (_a2 = tapObserver.unsubscribe) === null || _a2 === void 0 ? void 0 : _a2.call(tapObserver);\n      }\n      (_b = tapObserver.finalize) === null || _b === void 0 ? void 0 : _b.call(tapObserver);\n    }));\n  }) : identity;\n}\n\n// node_modules/rxjs/dist/esm/internal/operators/withLatestFrom.js\nfunction withLatestFrom(...inputs) {\n  const project = popResultSelector(inputs);\n  return operate((source, subscriber) => {\n    const len = inputs.length;\n    const otherValues = new Array(len);\n    let hasValue = inputs.map(() => false);\n    let ready = false;\n    for (let i = 0; i < len; i++) {\n      innerFrom(inputs[i]).subscribe(createOperatorSubscriber(subscriber, (value) => {\n        otherValues[i] = value;\n        if (!ready && !hasValue[i]) {\n          hasValue[i] = true;\n          (ready = hasValue.every(identity)) && (hasValue = null);\n        }\n      }, noop));\n    }\n    source.subscribe(createOperatorSubscriber(subscriber, (value) => {\n      if (ready) {\n        const values = [value, ...otherValues];\n        subscriber.next(project ? project(...values) : values);\n      }\n    }));\n  });\n}\n\n// node_modules/@angular/core/fesm2022/core.mjs\nvar ERROR_DETAILS_PAGE_BASE_URL = \"https://angular.dev/errors\";\nvar XSS_SECURITY_URL = \"https://angular.dev/best-practices/security#preventing-cross-site-scripting-xss\";\nvar RuntimeError = class extends Error {\n  code;\n  constructor(code, message) {\n    super(formatRuntimeError(code, message));\n    this.code = code;\n  }\n};\nfunction formatRuntimeError(code, message) {\n  const fullCode = `NG0${Math.abs(code)}`;\n  let errorMessage = `${fullCode}${message ? \": \" + message : \"\"}`;\n  if (ngDevMode && code < 0) {\n    const addPeriodSeparator = !errorMessage.match(/[.,;!?\\n]$/);\n    const separator = addPeriodSeparator ? \".\" : \"\";\n    errorMessage = `${errorMessage}${separator} Find more at ${ERROR_DETAILS_PAGE_BASE_URL}/${fullCode}`;\n  }\n  return errorMessage;\n}\nvar REQUIRED_UNSET_VALUE = /* @__PURE__ */ Symbol(\"InputSignalNode#UNSET\");\nvar INPUT_SIGNAL_NODE = /* @__PURE__ */ (() => {\n  return __spreadProps(__spreadValues({}, SIGNAL_NODE), {\n    transformFn: void 0,\n    applyValueToInputSignal(node, value) {\n      signalSetFn(node, value);\n    }\n  });\n})();\nfunction createInputSignal(initialValue, options) {\n  const node = Object.create(INPUT_SIGNAL_NODE);\n  node.value = initialValue;\n  node.transformFn = options?.transform;\n  function inputValueFn() {\n    producerAccessed(node);\n    if (node.value === REQUIRED_UNSET_VALUE) {\n      let message = null;\n      if (ngDevMode) {\n        const name = options?.debugName ?? options?.alias;\n        message = `Input${name ? ` \"${name}\"` : \"\"} is required but no value is available yet.`;\n      }\n      throw new RuntimeError(-950, message);\n    }\n    return node.value;\n  }\n  inputValueFn[SIGNAL] = node;\n  if (ngDevMode) {\n    inputValueFn.toString = () => `[Input Signal: ${inputValueFn()}]`;\n    node.debugName = options?.debugName;\n  }\n  return inputValueFn;\n}\nfunction noSideEffects(fn) {\n  return {\n    toString: fn\n  }.toString();\n}\nvar ANNOTATIONS = \"__annotations__\";\nvar PARAMETERS = \"__parameters__\";\nvar PROP_METADATA = \"__prop__metadata__\";\nfunction makeDecorator(name, props2, parentClass, additionalProcessing, typeFn) {\n  return noSideEffects(() => {\n    const metaCtor = makeMetadataCtor(props2);\n    function DecoratorFactory(...args) {\n      if (this instanceof DecoratorFactory) {\n        metaCtor.call(this, ...args);\n        return this;\n      }\n      const annotationInstance = new DecoratorFactory(...args);\n      return function TypeDecorator(cls) {\n        if (typeFn) typeFn(cls, ...args);\n        const annotations = cls.hasOwnProperty(ANNOTATIONS) ? cls[ANNOTATIONS] : Object.defineProperty(cls, ANNOTATIONS, {\n          value: []\n        })[ANNOTATIONS];\n        annotations.push(annotationInstance);\n        return cls;\n      };\n    }\n    if (parentClass) {\n      DecoratorFactory.prototype = Object.create(parentClass.prototype);\n    }\n    DecoratorFactory.prototype.ngMetadataName = name;\n    DecoratorFactory.annotationCls = DecoratorFactory;\n    return DecoratorFactory;\n  });\n}\nfunction makeMetadataCtor(props2) {\n  return function ctor(...args) {\n    if (props2) {\n      const values = props2(...args);\n      for (const propName in values) {\n        this[propName] = values[propName];\n      }\n    }\n  };\n}\nfunction makeParamDecorator(name, props2, parentClass) {\n  return noSideEffects(() => {\n    const metaCtor = makeMetadataCtor(props2);\n    function ParamDecoratorFactory(...args) {\n      if (this instanceof ParamDecoratorFactory) {\n        metaCtor.apply(this, args);\n        return this;\n      }\n      const annotationInstance = new ParamDecoratorFactory(...args);\n      ParamDecorator.annotation = annotationInstance;\n      return ParamDecorator;\n      function ParamDecorator(cls, unusedKey, index) {\n        const parameters = cls.hasOwnProperty(PARAMETERS) ? cls[PARAMETERS] : Object.defineProperty(cls, PARAMETERS, {\n          value: []\n        })[PARAMETERS];\n        while (parameters.length <= index) {\n          parameters.push(null);\n        }\n        (parameters[index] = parameters[index] || []).push(annotationInstance);\n        return cls;\n      }\n    }\n    ParamDecoratorFactory.prototype.ngMetadataName = name;\n    ParamDecoratorFactory.annotationCls = ParamDecoratorFactory;\n    return ParamDecoratorFactory;\n  });\n}\nfunction makePropDecorator(name, props2, parentClass, additionalProcessing) {\n  return noSideEffects(() => {\n    const metaCtor = makeMetadataCtor(props2);\n    function PropDecoratorFactory(...args) {\n      if (this instanceof PropDecoratorFactory) {\n        metaCtor.apply(this, args);\n        return this;\n      }\n      const decoratorInstance = new PropDecoratorFactory(...args);\n      function PropDecorator(target, name2) {\n        if (target === void 0) {\n          throw new Error(\"Standard Angular field decorators are not supported in JIT mode.\");\n        }\n        const constructor = target.constructor;\n        const meta = constructor.hasOwnProperty(PROP_METADATA) ? constructor[PROP_METADATA] : Object.defineProperty(constructor, PROP_METADATA, {\n          value: {}\n        })[PROP_METADATA];\n        meta[name2] = meta.hasOwnProperty(name2) && meta[name2] || [];\n        meta[name2].unshift(decoratorInstance);\n      }\n      return PropDecorator;\n    }\n    if (parentClass) {\n      PropDecoratorFactory.prototype = Object.create(parentClass.prototype);\n    }\n    PropDecoratorFactory.prototype.ngMetadataName = name;\n    PropDecoratorFactory.annotationCls = PropDecoratorFactory;\n    return PropDecoratorFactory;\n  });\n}\nvar _global = globalThis;\nfunction ngDevModeResetPerfCounters() {\n  const locationString = typeof location !== \"undefined\" ? location.toString() : \"\";\n  const newCounters = {\n    namedConstructors: locationString.indexOf(\"ngDevMode=namedConstructors\") != -1,\n    firstCreatePass: 0,\n    tNode: 0,\n    tView: 0,\n    rendererCreateTextNode: 0,\n    rendererSetText: 0,\n    rendererCreateElement: 0,\n    rendererAddEventListener: 0,\n    rendererSetAttribute: 0,\n    rendererRemoveAttribute: 0,\n    rendererSetProperty: 0,\n    rendererSetClassName: 0,\n    rendererAddClass: 0,\n    rendererRemoveClass: 0,\n    rendererSetStyle: 0,\n    rendererRemoveStyle: 0,\n    rendererDestroy: 0,\n    rendererDestroyNode: 0,\n    rendererMoveNode: 0,\n    rendererRemoveNode: 0,\n    rendererAppendChild: 0,\n    rendererInsertBefore: 0,\n    rendererCreateComment: 0,\n    hydratedNodes: 0,\n    hydratedComponents: 0,\n    dehydratedViewsRemoved: 0,\n    dehydratedViewsCleanupRuns: 0,\n    componentsSkippedHydration: 0,\n    deferBlocksWithIncrementalHydration: 0\n  };\n  const allowNgDevModeTrue = locationString.indexOf(\"ngDevMode=false\") === -1;\n  if (!allowNgDevModeTrue) {\n    _global[\"ngDevMode\"] = false;\n  } else {\n    if (typeof _global[\"ngDevMode\"] !== \"object\") {\n      _global[\"ngDevMode\"] = {};\n    }\n    Object.assign(_global[\"ngDevMode\"], newCounters);\n  }\n  return newCounters;\n}\nfunction initNgDevMode() {\n  if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n    if (typeof ngDevMode !== \"object\" || Object.keys(ngDevMode).length === 0) {\n      ngDevModeResetPerfCounters();\n    }\n    return typeof ngDevMode !== \"undefined\" && !!ngDevMode;\n  }\n  return false;\n}\nfunction getClosureSafeProperty(objWithPropertyToExtract) {\n  for (let key in objWithPropertyToExtract) {\n    if (objWithPropertyToExtract[key] === getClosureSafeProperty) {\n      return key;\n    }\n  }\n  throw Error(\"Could not find renamed property on target object.\");\n}\nfunction fillProperties(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\nfunction stringify(token) {\n  if (typeof token === \"string\") {\n    return token;\n  }\n  if (Array.isArray(token)) {\n    return `[${token.map(stringify).join(\", \")}]`;\n  }\n  if (token == null) {\n    return \"\" + token;\n  }\n  const name = token.overriddenName || token.name;\n  if (name) {\n    return `${name}`;\n  }\n  const result = token.toString();\n  if (result == null) {\n    return \"\" + result;\n  }\n  const newLineIndex = result.indexOf(\"\\n\");\n  return newLineIndex >= 0 ? result.slice(0, newLineIndex) : result;\n}\nfunction concatStringsWithSpace(before, after) {\n  if (!before) return after || \"\";\n  if (!after) return before;\n  return `${before} ${after}`;\n}\nvar __forward_ref__ = getClosureSafeProperty({\n  __forward_ref__: getClosureSafeProperty\n});\nfunction forwardRef(forwardRefFn) {\n  forwardRefFn.__forward_ref__ = forwardRef;\n  forwardRefFn.toString = function() {\n    return stringify(this());\n  };\n  return forwardRefFn;\n}\nfunction resolveForwardRef(type) {\n  return isForwardRef(type) ? type() : type;\n}\nfunction isForwardRef(fn) {\n  return typeof fn === \"function\" && fn.hasOwnProperty(__forward_ref__) && fn.__forward_ref__ === forwardRef;\n}\nfunction assertNumber(actual, msg) {\n  if (!(typeof actual === \"number\")) {\n    throwError2(msg, typeof actual, \"number\", \"===\");\n  }\n}\nfunction assertNumberInRange(actual, minInclusive, maxInclusive) {\n  assertNumber(actual, \"Expected a number\");\n  assertLessThanOrEqual(actual, maxInclusive, \"Expected number to be less than or equal to\");\n  assertGreaterThanOrEqual(actual, minInclusive, \"Expected number to be greater than or equal to\");\n}\nfunction assertString(actual, msg) {\n  if (!(typeof actual === \"string\")) {\n    throwError2(msg, actual === null ? \"null\" : typeof actual, \"string\", \"===\");\n  }\n}\nfunction assertFunction(actual, msg) {\n  if (!(typeof actual === \"function\")) {\n    throwError2(msg, actual === null ? \"null\" : typeof actual, \"function\", \"===\");\n  }\n}\nfunction assertEqual(actual, expected, msg) {\n  if (!(actual == expected)) {\n    throwError2(msg, actual, expected, \"==\");\n  }\n}\nfunction assertNotEqual(actual, expected, msg) {\n  if (!(actual != expected)) {\n    throwError2(msg, actual, expected, \"!=\");\n  }\n}\nfunction assertSame(actual, expected, msg) {\n  if (!(actual === expected)) {\n    throwError2(msg, actual, expected, \"===\");\n  }\n}\nfunction assertNotSame(actual, expected, msg) {\n  if (!(actual !== expected)) {\n    throwError2(msg, actual, expected, \"!==\");\n  }\n}\nfunction assertLessThan(actual, expected, msg) {\n  if (!(actual < expected)) {\n    throwError2(msg, actual, expected, \"<\");\n  }\n}\nfunction assertLessThanOrEqual(actual, expected, msg) {\n  if (!(actual <= expected)) {\n    throwError2(msg, actual, expected, \"<=\");\n  }\n}\nfunction assertGreaterThan(actual, expected, msg) {\n  if (!(actual > expected)) {\n    throwError2(msg, actual, expected, \">\");\n  }\n}\nfunction assertGreaterThanOrEqual(actual, expected, msg) {\n  if (!(actual >= expected)) {\n    throwError2(msg, actual, expected, \">=\");\n  }\n}\nfunction assertDefined(actual, msg) {\n  if (actual == null) {\n    throwError2(msg, actual, null, \"!=\");\n  }\n}\nfunction throwError2(msg, actual, expected, comparison) {\n  throw new Error(`ASSERTION ERROR: ${msg}` + (comparison == null ? \"\" : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));\n}\nfunction assertDomNode(node) {\n  if (!(node instanceof Node)) {\n    throwError2(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`);\n  }\n}\nfunction assertElement(node) {\n  if (!(node instanceof Element)) {\n    throwError2(`The provided value must be an element but got ${stringify(node)}`);\n  }\n}\nfunction assertIndexInRange(arr, index) {\n  assertDefined(arr, \"Array must be defined.\");\n  const maxLen = arr.length;\n  if (index < 0 || index >= maxLen) {\n    throwError2(`Index expected to be less than ${maxLen} but got ${index}`);\n  }\n}\nfunction assertOneOf(value, ...validValues) {\n  if (validValues.indexOf(value) !== -1) return true;\n  throwError2(`Expected value to be one of ${JSON.stringify(validValues)} but was ${JSON.stringify(value)}.`);\n}\nfunction assertNotReactive(fn) {\n  if (getActiveConsumer() !== null) {\n    throwError2(`${fn}() should never be called in a reactive context.`);\n  }\n}\nfunction \\u0275\\u0275defineInjectable(opts) {\n  return {\n    token: opts.token,\n    providedIn: opts.providedIn || null,\n    factory: opts.factory,\n    value: void 0\n  };\n}\nfunction \\u0275\\u0275defineInjector(options) {\n  return {\n    providers: options.providers || [],\n    imports: options.imports || []\n  };\n}\nfunction getInjectableDef(type) {\n  return getOwnDefinition(type, NG_PROV_DEF) || getOwnDefinition(type, NG_INJECTABLE_DEF);\n}\nfunction isInjectable(type) {\n  return getInjectableDef(type) !== null;\n}\nfunction getOwnDefinition(type, field) {\n  return type.hasOwnProperty(field) ? type[field] : null;\n}\nfunction getInheritedInjectableDef(type) {\n  const def = type && (type[NG_PROV_DEF] || type[NG_INJECTABLE_DEF]);\n  if (def) {\n    ngDevMode && console.warn(`DEPRECATED: DI is instantiating a token \"${type.name}\" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the \"${type.name}\" class.`);\n    return def;\n  } else {\n    return null;\n  }\n}\nfunction getInjectorDef(type) {\n  return type && (type.hasOwnProperty(NG_INJ_DEF) || type.hasOwnProperty(NG_INJECTOR_DEF)) ? type[NG_INJ_DEF] : null;\n}\nvar NG_PROV_DEF = getClosureSafeProperty({\n  \\u0275prov: getClosureSafeProperty\n});\nvar NG_INJ_DEF = getClosureSafeProperty({\n  \\u0275inj: getClosureSafeProperty\n});\nvar NG_INJECTABLE_DEF = getClosureSafeProperty({\n  ngInjectableDef: getClosureSafeProperty\n});\nvar NG_INJECTOR_DEF = getClosureSafeProperty({\n  ngInjectorDef: getClosureSafeProperty\n});\nvar InjectionToken = class {\n  _desc;\n  /** @internal */\n  ngMetadataName = \"InjectionToken\";\n  \\u0275prov;\n  /**\n   * @param _desc   Description for the token,\n   *                used only for debugging purposes,\n   *                it should but does not need to be unique\n   * @param options Options for the token's usage, as described above\n   */\n  constructor(_desc, options) {\n    this._desc = _desc;\n    this.\\u0275prov = void 0;\n    if (typeof options == \"number\") {\n      (typeof ngDevMode === \"undefined\" || ngDevMode) && assertLessThan(options, 0, \"Only negative numbers are supported here\");\n      this.__NG_ELEMENT_ID__ = options;\n    } else if (options !== void 0) {\n      this.\\u0275prov = \\u0275\\u0275defineInjectable({\n        token: this,\n        providedIn: options.providedIn || \"root\",\n        factory: options.factory\n      });\n    }\n  }\n  /**\n   * @internal\n   */\n  get multi() {\n    return this;\n  }\n  toString() {\n    return `InjectionToken ${this._desc}`;\n  }\n};\nvar _injectorProfilerContext;\nfunction getInjectorProfilerContext() {\n  !ngDevMode && throwError2(\"getInjectorProfilerContext should never be called in production mode\");\n  return _injectorProfilerContext;\n}\nfunction setInjectorProfilerContext(context2) {\n  !ngDevMode && throwError2(\"setInjectorProfilerContext should never be called in production mode\");\n  const previous = _injectorProfilerContext;\n  _injectorProfilerContext = context2;\n  return previous;\n}\nvar injectorProfilerCallback = null;\nvar setInjectorProfiler = (injectorProfiler2) => {\n  !ngDevMode && throwError2(\"setInjectorProfiler should never be called in production mode\");\n  injectorProfilerCallback = injectorProfiler2;\n};\nfunction injectorProfiler(event) {\n  !ngDevMode && throwError2(\"Injector profiler should never be called in production mode\");\n  if (injectorProfilerCallback != null) {\n    injectorProfilerCallback(event);\n  }\n}\nfunction emitProviderConfiguredEvent(eventProvider, isViewProvider = false) {\n  !ngDevMode && throwError2(\"Injector profiler should never be called in production mode\");\n  let token;\n  if (typeof eventProvider === \"function\") {\n    token = eventProvider;\n  } else if (eventProvider instanceof InjectionToken) {\n    token = eventProvider;\n  } else {\n    token = resolveForwardRef(eventProvider.provide);\n  }\n  let provider = eventProvider;\n  if (eventProvider instanceof InjectionToken) {\n    provider = eventProvider.\\u0275prov || eventProvider;\n  }\n  injectorProfiler({\n    type: 2,\n    context: getInjectorProfilerContext(),\n    providerRecord: {\n      token,\n      provider,\n      isViewProvider\n    }\n  });\n}\nfunction emitInstanceCreatedByInjectorEvent(instance) {\n  !ngDevMode && throwError2(\"Injector profiler should never be called in production mode\");\n  injectorProfiler({\n    type: 1,\n    context: getInjectorProfilerContext(),\n    instance: {\n      value: instance\n    }\n  });\n}\nfunction emitInjectEvent(token, value, flags) {\n  !ngDevMode && throwError2(\"Injector profiler should never be called in production mode\");\n  injectorProfiler({\n    type: 0,\n    context: getInjectorProfilerContext(),\n    service: {\n      token,\n      value,\n      flags\n    }\n  });\n}\nfunction emitEffectCreatedEvent(effect2) {\n  !ngDevMode && throwError2(\"Injector profiler should never be called in production mode\");\n  injectorProfiler({\n    type: 3,\n    context: getInjectorProfilerContext(),\n    effect: effect2\n  });\n}\nfunction runInInjectorProfilerContext(injector, token, callback) {\n  !ngDevMode && throwError2(\"runInInjectorProfilerContext should never be called in production mode\");\n  const prevInjectContext = setInjectorProfilerContext({\n    injector,\n    token\n  });\n  try {\n    callback();\n  } finally {\n    setInjectorProfilerContext(prevInjectContext);\n  }\n}\nfunction isEnvironmentProviders(value) {\n  return value && !!value.\\u0275providers;\n}\nvar NG_COMP_DEF = getClosureSafeProperty({\n  \\u0275cmp: getClosureSafeProperty\n});\nvar NG_DIR_DEF = getClosureSafeProperty({\n  \\u0275dir: getClosureSafeProperty\n});\nvar NG_PIPE_DEF = getClosureSafeProperty({\n  \\u0275pipe: getClosureSafeProperty\n});\nvar NG_MOD_DEF = getClosureSafeProperty({\n  \\u0275mod: getClosureSafeProperty\n});\nvar NG_FACTORY_DEF = getClosureSafeProperty({\n  \\u0275fac: getClosureSafeProperty\n});\nvar NG_ELEMENT_ID = getClosureSafeProperty({\n  __NG_ELEMENT_ID__: getClosureSafeProperty\n});\nvar NG_ENV_ID = getClosureSafeProperty({\n  __NG_ENV_ID__: getClosureSafeProperty\n});\nfunction renderStringify(value) {\n  if (typeof value === \"string\") return value;\n  if (value == null) return \"\";\n  return String(value);\n}\nfunction stringifyForError(value) {\n  if (typeof value === \"function\") return value.name || value.toString();\n  if (typeof value === \"object\" && value != null && typeof value.type === \"function\") {\n    return value.type.name || value.type.toString();\n  }\n  return renderStringify(value);\n}\nfunction throwCyclicDependencyError(token, path) {\n  throw new RuntimeError(-200, ngDevMode ? `Circular dependency in DI detected for ${token}${path ? `. Dependency path: ${path.join(\" > \")} > ${token}` : \"\"}` : token);\n}\nfunction throwMixedMultiProviderError() {\n  throw new Error(`Cannot mix multi providers and regular providers`);\n}\nfunction throwInvalidProviderError(ngModuleType, providers, provider) {\n  if (ngModuleType && providers) {\n    const providerDetail = providers.map((v) => v == provider ? \"?\" + provider + \"?\" : \"...\");\n    throw new Error(`Invalid provider for the NgModule '${stringify(ngModuleType)}' - only instances of Provider and Type are allowed, got: [${providerDetail.join(\", \")}]`);\n  } else if (isEnvironmentProviders(provider)) {\n    if (provider.\\u0275fromNgModule) {\n      throw new RuntimeError(207, `Invalid providers from 'importProvidersFrom' present in a non-environment injector. 'importProvidersFrom' can't be used for component providers.`);\n    } else {\n      throw new RuntimeError(207, `Invalid providers present in a non-environment injector. 'EnvironmentProviders' can't be used for component providers.`);\n    }\n  } else {\n    throw new Error(\"Invalid provider\");\n  }\n}\nfunction throwProviderNotFoundError(token, injectorName) {\n  const errorMessage = ngDevMode && `No provider for ${stringifyForError(token)} found${injectorName ? ` in ${injectorName}` : \"\"}`;\n  throw new RuntimeError(-201, errorMessage);\n}\nvar InjectFlags;\n(function(InjectFlags2) {\n  InjectFlags2[InjectFlags2[\"Default\"] = 0] = \"Default\";\n  InjectFlags2[InjectFlags2[\"Host\"] = 1] = \"Host\";\n  InjectFlags2[InjectFlags2[\"Self\"] = 2] = \"Self\";\n  InjectFlags2[InjectFlags2[\"SkipSelf\"] = 4] = \"SkipSelf\";\n  InjectFlags2[InjectFlags2[\"Optional\"] = 8] = \"Optional\";\n})(InjectFlags || (InjectFlags = {}));\nvar _injectImplementation;\nfunction getInjectImplementation() {\n  return _injectImplementation;\n}\nfunction setInjectImplementation(impl) {\n  const previous = _injectImplementation;\n  _injectImplementation = impl;\n  return previous;\n}\nfunction injectRootLimpMode(token, notFoundValue, flags) {\n  const injectableDef = getInjectableDef(token);\n  if (injectableDef && injectableDef.providedIn == \"root\") {\n    return injectableDef.value === void 0 ? injectableDef.value = injectableDef.factory() : injectableDef.value;\n  }\n  if (flags & InjectFlags.Optional) return null;\n  if (notFoundValue !== void 0) return notFoundValue;\n  throwProviderNotFoundError(token, \"Injector\");\n}\nfunction assertInjectImplementationNotEqual(fn) {\n  ngDevMode && assertNotEqual(_injectImplementation, fn, \"Calling \\u0275\\u0275inject would cause infinite recursion\");\n}\nvar _THROW_IF_NOT_FOUND = {};\nvar THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\nvar DI_DECORATOR_FLAG = \"__NG_DI_FLAG__\";\nvar RetrievingInjector = class {\n  injector;\n  constructor(injector) {\n    this.injector = injector;\n  }\n  retrieve(token, options) {\n    const ngOptions = options;\n    return this.injector.get(token, ngOptions.optional ? NOT_FOUND : THROW_IF_NOT_FOUND, ngOptions);\n  }\n};\nvar NG_TEMP_TOKEN_PATH = \"ngTempTokenPath\";\nvar NG_TOKEN_PATH = \"ngTokenPath\";\nvar NEW_LINE = /\\n/gm;\nvar NO_NEW_LINE = \"\\u0275\";\nvar SOURCE = \"__source\";\nfunction injectInjectorOnly(token, flags = InjectFlags.Default) {\n  if (getCurrentInjector() === void 0) {\n    throw new RuntimeError(-203, ngDevMode && `The \\`${stringify(token)}\\` token injection failed. \\`inject()\\` function must be called from an injection context such as a constructor, a factory function, a field initializer, or a function used with \\`runInInjectionContext\\`.`);\n  } else if (getCurrentInjector() === null) {\n    return injectRootLimpMode(token, void 0, flags);\n  } else {\n    const currentInjector = getCurrentInjector();\n    let injector;\n    if (currentInjector instanceof RetrievingInjector) {\n      injector = currentInjector.injector;\n    } else {\n      injector = currentInjector;\n    }\n    const value = injector.get(token, flags & InjectFlags.Optional ? null : void 0, flags);\n    ngDevMode && emitInjectEvent(token, value, flags);\n    return value;\n  }\n}\nfunction \\u0275\\u0275inject(token, flags = InjectFlags.Default) {\n  return (getInjectImplementation() || injectInjectorOnly)(resolveForwardRef(token), flags);\n}\nfunction \\u0275\\u0275invalidFactoryDep(index) {\n  throw new RuntimeError(202, ngDevMode && `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.\nThis can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.\n\nPlease check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.`);\n}\nfunction inject(token, flags = InjectFlags.Default) {\n  return \\u0275\\u0275inject(token, convertToBitFlags(flags));\n}\nfunction convertToBitFlags(flags) {\n  if (typeof flags === \"undefined\" || typeof flags === \"number\") {\n    return flags;\n  }\n  return 0 | // comment to force a line break in the formatter\n  (flags.optional && 8) | (flags.host && 1) | (flags.self && 2) | (flags.skipSelf && 4);\n}\nfunction injectArgs(types) {\n  const args = [];\n  for (let i = 0; i < types.length; i++) {\n    const arg = resolveForwardRef(types[i]);\n    if (Array.isArray(arg)) {\n      if (arg.length === 0) {\n        throw new RuntimeError(900, ngDevMode && \"Arguments array must have arguments.\");\n      }\n      let type = void 0;\n      let flags = InjectFlags.Default;\n      for (let j = 0; j < arg.length; j++) {\n        const meta = arg[j];\n        const flag = getInjectFlag(meta);\n        if (typeof flag === \"number\") {\n          if (flag === -1) {\n            type = meta.token;\n          } else {\n            flags |= flag;\n          }\n        } else {\n          type = meta;\n        }\n      }\n      args.push(\\u0275\\u0275inject(type, flags));\n    } else {\n      args.push(\\u0275\\u0275inject(arg));\n    }\n  }\n  return args;\n}\nfunction attachInjectFlag(decorator, flag) {\n  decorator[DI_DECORATOR_FLAG] = flag;\n  decorator.prototype[DI_DECORATOR_FLAG] = flag;\n  return decorator;\n}\nfunction getInjectFlag(token) {\n  return token[DI_DECORATOR_FLAG];\n}\nfunction catchInjectorError(e, token, injectorErrorName, source) {\n  const tokenPath = e[NG_TEMP_TOKEN_PATH];\n  if (token[SOURCE]) {\n    tokenPath.unshift(token[SOURCE]);\n  }\n  e.message = formatError(\"\\n\" + e.message, tokenPath, injectorErrorName, source);\n  e[NG_TOKEN_PATH] = tokenPath;\n  e[NG_TEMP_TOKEN_PATH] = null;\n  throw e;\n}\nfunction formatError(text, obj, injectorErrorName, source = null) {\n  text = text && text.charAt(0) === \"\\n\" && text.charAt(1) == NO_NEW_LINE ? text.slice(2) : text;\n  let context2 = stringify(obj);\n  if (Array.isArray(obj)) {\n    context2 = obj.map(stringify).join(\" -> \");\n  } else if (typeof obj === \"object\") {\n    let parts = [];\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        let value = obj[key];\n        parts.push(key + \":\" + (typeof value === \"string\" ? JSON.stringify(value) : stringify(value)));\n      }\n    }\n    context2 = `{${parts.join(\", \")}}`;\n  }\n  return `${injectorErrorName}${source ? \"(\" + source + \")\" : \"\"}[${context2}]: ${text.replace(NEW_LINE, \"\\n  \")}`;\n}\nvar Inject = attachInjectFlag(\n  // Disable tslint because `DecoratorFlags` is a const enum which gets inlined.\n  makeParamDecorator(\"Inject\", (token) => ({\n    token\n  })),\n  -1\n  /* DecoratorFlags.Inject */\n);\nvar Optional = (\n  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n  // tslint:disable-next-line: no-toplevel-property-access\n  attachInjectFlag(\n    makeParamDecorator(\"Optional\"),\n    8\n    /* InternalInjectFlags.Optional */\n  )\n);\nvar Self = (\n  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n  // tslint:disable-next-line: no-toplevel-property-access\n  attachInjectFlag(\n    makeParamDecorator(\"Self\"),\n    2\n    /* InternalInjectFlags.Self */\n  )\n);\nvar SkipSelf = (\n  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n  // tslint:disable-next-line: no-toplevel-property-access\n  attachInjectFlag(\n    makeParamDecorator(\"SkipSelf\"),\n    4\n    /* InternalInjectFlags.SkipSelf */\n  )\n);\nvar Host = (\n  // Disable tslint because `InternalInjectFlags` is a const enum which gets inlined.\n  // tslint:disable-next-line: no-toplevel-property-access\n  attachInjectFlag(\n    makeParamDecorator(\"Host\"),\n    1\n    /* InternalInjectFlags.Host */\n  )\n);\nfunction getFactoryDef(type, throwNotFound) {\n  const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);\n  if (!hasFactoryDef && throwNotFound === true && ngDevMode) {\n    throw new Error(`Type ${stringify(type)} does not have '\\u0275fac' property.`);\n  }\n  return hasFactoryDef ? type[NG_FACTORY_DEF] : null;\n}\nfunction arrayEquals(a, b, identityAccessor) {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; i++) {\n    let valueA = a[i];\n    let valueB = b[i];\n    if (identityAccessor) {\n      valueA = identityAccessor(valueA);\n      valueB = identityAccessor(valueB);\n    }\n    if (valueB !== valueA) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction flatten(list) {\n  return list.flat(Number.POSITIVE_INFINITY);\n}\nfunction deepForEach(input2, fn) {\n  input2.forEach((value) => Array.isArray(value) ? deepForEach(value, fn) : fn(value));\n}\nfunction addToArray(arr, index, value) {\n  if (index >= arr.length) {\n    arr.push(value);\n  } else {\n    arr.splice(index, 0, value);\n  }\n}\nfunction removeFromArray(arr, index) {\n  if (index >= arr.length - 1) {\n    return arr.pop();\n  } else {\n    return arr.splice(index, 1)[0];\n  }\n}\nfunction newArray(size, value) {\n  const list = [];\n  for (let i = 0; i < size; i++) {\n    list.push(value);\n  }\n  return list;\n}\nfunction arraySplice(array, index, count) {\n  const length = array.length - count;\n  while (index < length) {\n    array[index] = array[index + count];\n    index++;\n  }\n  while (count--) {\n    array.pop();\n  }\n}\nfunction arrayInsert2(array, index, value1, value2) {\n  ngDevMode && assertLessThanOrEqual(index, array.length, \"Can't insert past array end.\");\n  let end = array.length;\n  if (end == index) {\n    array.push(value1, value2);\n  } else if (end === 1) {\n    array.push(value2, array[0]);\n    array[0] = value1;\n  } else {\n    end--;\n    array.push(array[end - 1], array[end]);\n    while (end > index) {\n      const previousEnd = end - 2;\n      array[end] = array[previousEnd];\n      end--;\n    }\n    array[index] = value1;\n    array[index + 1] = value2;\n  }\n}\nfunction keyValueArraySet(keyValueArray, key, value) {\n  let index = keyValueArrayIndexOf(keyValueArray, key);\n  if (index >= 0) {\n    keyValueArray[index | 1] = value;\n  } else {\n    index = ~index;\n    arrayInsert2(keyValueArray, index, key, value);\n  }\n  return index;\n}\nfunction keyValueArrayGet(keyValueArray, key) {\n  const index = keyValueArrayIndexOf(keyValueArray, key);\n  if (index >= 0) {\n    return keyValueArray[index | 1];\n  }\n  return void 0;\n}\nfunction keyValueArrayIndexOf(keyValueArray, key) {\n  return _arrayIndexOfSorted(keyValueArray, key, 1);\n}\nfunction _arrayIndexOfSorted(array, value, shift) {\n  ngDevMode && assertEqual(Array.isArray(array), true, \"Expecting an array\");\n  let start = 0;\n  let end = array.length >> shift;\n  while (end !== start) {\n    const middle = start + (end - start >> 1);\n    const current = array[middle << shift];\n    if (value === current) {\n      return middle << shift;\n    } else if (current > value) {\n      end = middle;\n    } else {\n      start = middle + 1;\n    }\n  }\n  return ~(end << shift);\n}\nvar EMPTY_OBJ = {};\nvar EMPTY_ARRAY = [];\nif ((typeof ngDevMode === \"undefined\" || ngDevMode) && initNgDevMode()) {\n  Object.freeze(EMPTY_OBJ);\n  Object.freeze(EMPTY_ARRAY);\n}\nvar ENVIRONMENT_INITIALIZER = new InjectionToken(ngDevMode ? \"ENVIRONMENT_INITIALIZER\" : \"\");\nvar INJECTOR$1 = new InjectionToken(\n  ngDevMode ? \"INJECTOR\" : \"\",\n  // Disable tslint because this is const enum which gets inlined not top level prop access.\n  // tslint:disable-next-line: no-toplevel-property-access\n  -1\n  /* InjectorMarkers.Injector */\n);\nvar INJECTOR_DEF_TYPES = new InjectionToken(ngDevMode ? \"INJECTOR_DEF_TYPES\" : \"\");\nvar NullInjector = class {\n  get(token, notFoundValue = THROW_IF_NOT_FOUND) {\n    if (notFoundValue === THROW_IF_NOT_FOUND) {\n      const error = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);\n      error.name = \"NullInjectorError\";\n      throw error;\n    }\n    return notFoundValue;\n  }\n};\nfunction getNgModuleDef(type, throwNotFound) {\n  const ngModuleDef = type[NG_MOD_DEF] || null;\n  if (!ngModuleDef && throwNotFound === true) {\n    throw new Error(`Type ${stringify(type)} does not have '\\u0275mod' property.`);\n  }\n  return ngModuleDef;\n}\nfunction getComponentDef(type) {\n  return type[NG_COMP_DEF] || null;\n}\nfunction getDirectiveDef(type) {\n  return type[NG_DIR_DEF] || null;\n}\nfunction getPipeDef$1(type) {\n  return type[NG_PIPE_DEF] || null;\n}\nfunction isStandalone(type) {\n  const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef$1(type);\n  return def !== null && def.standalone;\n}\nfunction makeEnvironmentProviders(providers) {\n  return {\n    \\u0275providers: providers\n  };\n}\nfunction importProvidersFrom(...sources) {\n  return {\n    \\u0275providers: internalImportProvidersFrom(true, sources),\n    \\u0275fromNgModule: true\n  };\n}\nfunction internalImportProvidersFrom(checkForStandaloneCmp, ...sources) {\n  const providersOut = [];\n  const dedup = /* @__PURE__ */ new Set();\n  let injectorTypesWithProviders;\n  const collectProviders = (provider) => {\n    providersOut.push(provider);\n  };\n  deepForEach(sources, (source) => {\n    if ((typeof ngDevMode === \"undefined\" || ngDevMode) && checkForStandaloneCmp) {\n      const cmpDef = getComponentDef(source);\n      if (cmpDef?.standalone) {\n        throw new RuntimeError(800, `Importing providers supports NgModule or ModuleWithProviders but got a standalone component \"${stringifyForError(source)}\"`);\n      }\n    }\n    const internalSource = source;\n    if (walkProviderTree(internalSource, collectProviders, [], dedup)) {\n      injectorTypesWithProviders ||= [];\n      injectorTypesWithProviders.push(internalSource);\n    }\n  });\n  if (injectorTypesWithProviders !== void 0) {\n    processInjectorTypesWithProviders(injectorTypesWithProviders, collectProviders);\n  }\n  return providersOut;\n}\nfunction processInjectorTypesWithProviders(typesWithProviders, visitor) {\n  for (let i = 0; i < typesWithProviders.length; i++) {\n    const {\n      ngModule,\n      providers\n    } = typesWithProviders[i];\n    deepForEachProvider(providers, (provider) => {\n      ngDevMode && validateProvider(provider, providers || EMPTY_ARRAY, ngModule);\n      visitor(provider, ngModule);\n    });\n  }\n}\nfunction walkProviderTree(container, visitor, parents, dedup) {\n  container = resolveForwardRef(container);\n  if (!container) return false;\n  let defType = null;\n  let injDef = getInjectorDef(container);\n  const cmpDef = !injDef && getComponentDef(container);\n  if (!injDef && !cmpDef) {\n    const ngModule = container.ngModule;\n    injDef = getInjectorDef(ngModule);\n    if (injDef) {\n      defType = ngModule;\n    } else {\n      return false;\n    }\n  } else if (cmpDef && !cmpDef.standalone) {\n    return false;\n  } else {\n    defType = container;\n  }\n  if (ngDevMode && parents.indexOf(defType) !== -1) {\n    const defName = stringify(defType);\n    const path = parents.map(stringify);\n    throwCyclicDependencyError(defName, path);\n  }\n  const isDuplicate = dedup.has(defType);\n  if (cmpDef) {\n    if (isDuplicate) {\n      return false;\n    }\n    dedup.add(defType);\n    if (cmpDef.dependencies) {\n      const deps = typeof cmpDef.dependencies === \"function\" ? cmpDef.dependencies() : cmpDef.dependencies;\n      for (const dep of deps) {\n        walkProviderTree(dep, visitor, parents, dedup);\n      }\n    }\n  } else if (injDef) {\n    if (injDef.imports != null && !isDuplicate) {\n      ngDevMode && parents.push(defType);\n      dedup.add(defType);\n      let importTypesWithProviders;\n      try {\n        deepForEach(injDef.imports, (imported) => {\n          if (walkProviderTree(imported, visitor, parents, dedup)) {\n            importTypesWithProviders ||= [];\n            importTypesWithProviders.push(imported);\n          }\n        });\n      } finally {\n        ngDevMode && parents.pop();\n      }\n      if (importTypesWithProviders !== void 0) {\n        processInjectorTypesWithProviders(importTypesWithProviders, visitor);\n      }\n    }\n    if (!isDuplicate) {\n      const factory = getFactoryDef(defType) || (() => new defType());\n      visitor({\n        provide: defType,\n        useFactory: factory,\n        deps: EMPTY_ARRAY\n      }, defType);\n      visitor({\n        provide: INJECTOR_DEF_TYPES,\n        useValue: defType,\n        multi: true\n      }, defType);\n      visitor({\n        provide: ENVIRONMENT_INITIALIZER,\n        useValue: () => \\u0275\\u0275inject(defType),\n        multi: true\n      }, defType);\n    }\n    const defProviders = injDef.providers;\n    if (defProviders != null && !isDuplicate) {\n      const injectorType = container;\n      deepForEachProvider(defProviders, (provider) => {\n        ngDevMode && validateProvider(provider, defProviders, injectorType);\n        visitor(provider, injectorType);\n      });\n    }\n  } else {\n    return false;\n  }\n  return defType !== container && container.providers !== void 0;\n}\nfunction validateProvider(provider, providers, containerType) {\n  if (isTypeProvider(provider) || isValueProvider(provider) || isFactoryProvider(provider) || isExistingProvider(provider)) {\n    return;\n  }\n  const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));\n  if (!classRef) {\n    throwInvalidProviderError(containerType, providers, provider);\n  }\n}\nfunction deepForEachProvider(providers, fn) {\n  for (let provider of providers) {\n    if (isEnvironmentProviders(provider)) {\n      provider = provider.\\u0275providers;\n    }\n    if (Array.isArray(provider)) {\n      deepForEachProvider(provider, fn);\n    } else {\n      fn(provider);\n    }\n  }\n}\nvar USE_VALUE$1 = getClosureSafeProperty({\n  provide: String,\n  useValue: getClosureSafeProperty\n});\nfunction isValueProvider(value) {\n  return value !== null && typeof value == \"object\" && USE_VALUE$1 in value;\n}\nfunction isExistingProvider(value) {\n  return !!(value && value.useExisting);\n}\nfunction isFactoryProvider(value) {\n  return !!(value && value.useFactory);\n}\nfunction isTypeProvider(value) {\n  return typeof value === \"function\";\n}\nfunction isClassProvider(value) {\n  return !!value.useClass;\n}\nvar INJECTOR_SCOPE = new InjectionToken(ngDevMode ? \"Set Injector scope.\" : \"\");\nvar NOT_YET = {};\nvar CIRCULAR = {};\nvar NULL_INJECTOR = void 0;\nfunction getNullInjector() {\n  if (NULL_INJECTOR === void 0) {\n    NULL_INJECTOR = new NullInjector();\n  }\n  return NULL_INJECTOR;\n}\nvar EnvironmentInjector = class {\n};\nvar R3Injector = class extends EnvironmentInjector {\n  parent;\n  source;\n  scopes;\n  /**\n   * Map of tokens to records which contain the instances of those tokens.\n   * - `null` value implies that we don't have the record. Used by tree-shakable injectors\n   * to prevent further searches.\n   */\n  records = /* @__PURE__ */ new Map();\n  /**\n   * Set of values instantiated by this injector which contain `ngOnDestroy` lifecycle hooks.\n   */\n  _ngOnDestroyHooks = /* @__PURE__ */ new Set();\n  _onDestroyHooks = [];\n  /**\n   * Flag indicating that this injector was previously destroyed.\n   */\n  get destroyed() {\n    return this._destroyed;\n  }\n  _destroyed = false;\n  injectorDefTypes;\n  constructor(providers, parent, source, scopes) {\n    super();\n    this.parent = parent;\n    this.source = source;\n    this.scopes = scopes;\n    forEachSingleProvider(providers, (provider) => this.processProvider(provider));\n    this.records.set(INJECTOR$1, makeRecord(void 0, this));\n    if (scopes.has(\"environment\")) {\n      this.records.set(EnvironmentInjector, makeRecord(void 0, this));\n    }\n    const record = this.records.get(INJECTOR_SCOPE);\n    if (record != null && typeof record.value === \"string\") {\n      this.scopes.add(record.value);\n    }\n    this.injectorDefTypes = new Set(this.get(INJECTOR_DEF_TYPES, EMPTY_ARRAY, InjectFlags.Self));\n  }\n  retrieve(token, options) {\n    const ngOptions = options;\n    return this.get(token, ngOptions.optional ? NOT_FOUND : THROW_IF_NOT_FOUND, ngOptions);\n  }\n  /**\n   * Destroy the injector and release references to every instance or provider associated with it.\n   *\n   * Also calls the `OnDestroy` lifecycle hooks of every instance that was created for which a\n   * hook was found.\n   */\n  destroy() {\n    assertNotDestroyed(this);\n    this._destroyed = true;\n    const prevConsumer = setActiveConsumer(null);\n    try {\n      for (const service of this._ngOnDestroyHooks) {\n        service.ngOnDestroy();\n      }\n      const onDestroyHooks = this._onDestroyHooks;\n      this._onDestroyHooks = [];\n      for (const hook of onDestroyHooks) {\n        hook();\n      }\n    } finally {\n      this.records.clear();\n      this._ngOnDestroyHooks.clear();\n      this.injectorDefTypes.clear();\n      setActiveConsumer(prevConsumer);\n    }\n  }\n  onDestroy(callback) {\n    assertNotDestroyed(this);\n    this._onDestroyHooks.push(callback);\n    return () => this.removeOnDestroy(callback);\n  }\n  runInContext(fn) {\n    assertNotDestroyed(this);\n    const previousInjector = setCurrentInjector(this);\n    const previousInjectImplementation = setInjectImplementation(void 0);\n    let prevInjectContext;\n    if (ngDevMode) {\n      prevInjectContext = setInjectorProfilerContext({\n        injector: this,\n        token: null\n      });\n    }\n    try {\n      return fn();\n    } finally {\n      setCurrentInjector(previousInjector);\n      setInjectImplementation(previousInjectImplementation);\n      ngDevMode && setInjectorProfilerContext(prevInjectContext);\n    }\n  }\n  get(token, notFoundValue = THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n    assertNotDestroyed(this);\n    if (token.hasOwnProperty(NG_ENV_ID)) {\n      return token[NG_ENV_ID](this);\n    }\n    flags = convertToBitFlags(flags);\n    let prevInjectContext;\n    if (ngDevMode) {\n      prevInjectContext = setInjectorProfilerContext({\n        injector: this,\n        token\n      });\n    }\n    const previousInjector = setCurrentInjector(this);\n    const previousInjectImplementation = setInjectImplementation(void 0);\n    try {\n      if (!(flags & InjectFlags.SkipSelf)) {\n        let record = this.records.get(token);\n        if (record === void 0) {\n          const def = couldBeInjectableType(token) && getInjectableDef(token);\n          if (def && this.injectableDefInScope(def)) {\n            if (ngDevMode) {\n              runInInjectorProfilerContext(this, token, () => {\n                emitProviderConfiguredEvent(token);\n              });\n            }\n            record = makeRecord(injectableDefOrInjectorDefFactory(token), NOT_YET);\n          } else {\n            record = null;\n          }\n          this.records.set(token, record);\n        }\n        if (record != null) {\n          return this.hydrate(token, record);\n        }\n      }\n      const nextInjector = !(flags & InjectFlags.Self) ? this.parent : getNullInjector();\n      notFoundValue = flags & InjectFlags.Optional && notFoundValue === THROW_IF_NOT_FOUND ? null : notFoundValue;\n      return nextInjector.get(token, notFoundValue);\n    } catch (e) {\n      if (e.name === \"NullInjectorError\") {\n        const path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];\n        path.unshift(stringify(token));\n        if (previousInjector) {\n          throw e;\n        } else {\n          return catchInjectorError(e, token, \"R3InjectorError\", this.source);\n        }\n      } else {\n        throw e;\n      }\n    } finally {\n      setInjectImplementation(previousInjectImplementation);\n      setCurrentInjector(previousInjector);\n      ngDevMode && setInjectorProfilerContext(prevInjectContext);\n    }\n  }\n  /** @internal */\n  resolveInjectorInitializers() {\n    const prevConsumer = setActiveConsumer(null);\n    const previousInjector = setCurrentInjector(this);\n    const previousInjectImplementation = setInjectImplementation(void 0);\n    let prevInjectContext;\n    if (ngDevMode) {\n      prevInjectContext = setInjectorProfilerContext({\n        injector: this,\n        token: null\n      });\n    }\n    try {\n      const initializers = this.get(ENVIRONMENT_INITIALIZER, EMPTY_ARRAY, InjectFlags.Self);\n      if (ngDevMode && !Array.isArray(initializers)) {\n        throw new RuntimeError(-209, `Unexpected type of the \\`ENVIRONMENT_INITIALIZER\\` token value (expected an array, but got ${typeof initializers}). Please check that the \\`ENVIRONMENT_INITIALIZER\\` token is configured as a \\`multi: true\\` provider.`);\n      }\n      for (const initializer of initializers) {\n        initializer();\n      }\n    } finally {\n      setCurrentInjector(previousInjector);\n      setInjectImplementation(previousInjectImplementation);\n      ngDevMode && setInjectorProfilerContext(prevInjectContext);\n      setActiveConsumer(prevConsumer);\n    }\n  }\n  toString() {\n    const tokens = [];\n    const records = this.records;\n    for (const token of records.keys()) {\n      tokens.push(stringify(token));\n    }\n    return `R3Injector[${tokens.join(\", \")}]`;\n  }\n  /**\n   * Process a `SingleProvider` and add it.\n   */\n  processProvider(provider) {\n    provider = resolveForwardRef(provider);\n    let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider && provider.provide);\n    const record = providerToRecord(provider);\n    if (ngDevMode) {\n      runInInjectorProfilerContext(this, token, () => {\n        if (isValueProvider(provider)) {\n          emitInstanceCreatedByInjectorEvent(provider.useValue);\n        }\n        emitProviderConfiguredEvent(provider);\n      });\n    }\n    if (!isTypeProvider(provider) && provider.multi === true) {\n      let multiRecord = this.records.get(token);\n      if (multiRecord) {\n        if (ngDevMode && multiRecord.multi === void 0) {\n          throwMixedMultiProviderError();\n        }\n      } else {\n        multiRecord = makeRecord(void 0, NOT_YET, true);\n        multiRecord.factory = () => injectArgs(multiRecord.multi);\n        this.records.set(token, multiRecord);\n      }\n      token = provider;\n      multiRecord.multi.push(provider);\n    } else {\n      if (ngDevMode) {\n        const existing = this.records.get(token);\n        if (existing && existing.multi !== void 0) {\n          throwMixedMultiProviderError();\n        }\n      }\n    }\n    this.records.set(token, record);\n  }\n  hydrate(token, record) {\n    const prevConsumer = setActiveConsumer(null);\n    try {\n      if (record.value === CIRCULAR) {\n        throwCyclicDependencyError(stringify(token));\n      } else if (record.value === NOT_YET) {\n        record.value = CIRCULAR;\n        if (ngDevMode) {\n          runInInjectorProfilerContext(this, token, () => {\n            record.value = record.factory();\n            emitInstanceCreatedByInjectorEvent(record.value);\n          });\n        } else {\n          record.value = record.factory();\n        }\n      }\n      if (typeof record.value === \"object\" && record.value && hasOnDestroy(record.value)) {\n        this._ngOnDestroyHooks.add(record.value);\n      }\n      return record.value;\n    } finally {\n      setActiveConsumer(prevConsumer);\n    }\n  }\n  injectableDefInScope(def) {\n    if (!def.providedIn) {\n      return false;\n    }\n    const providedIn = resolveForwardRef(def.providedIn);\n    if (typeof providedIn === \"string\") {\n      return providedIn === \"any\" || this.scopes.has(providedIn);\n    } else {\n      return this.injectorDefTypes.has(providedIn);\n    }\n  }\n  removeOnDestroy(callback) {\n    const destroyCBIdx = this._onDestroyHooks.indexOf(callback);\n    if (destroyCBIdx !== -1) {\n      this._onDestroyHooks.splice(destroyCBIdx, 1);\n    }\n  }\n};\nfunction injectableDefOrInjectorDefFactory(token) {\n  const injectableDef = getInjectableDef(token);\n  const factory = injectableDef !== null ? injectableDef.factory : getFactoryDef(token);\n  if (factory !== null) {\n    return factory;\n  }\n  if (token instanceof InjectionToken) {\n    throw new RuntimeError(204, ngDevMode && `Token ${stringify(token)} is missing a \\u0275prov definition.`);\n  }\n  if (token instanceof Function) {\n    return getUndecoratedInjectableFactory(token);\n  }\n  throw new RuntimeError(204, ngDevMode && \"unreachable\");\n}\nfunction getUndecoratedInjectableFactory(token) {\n  const paramLength = token.length;\n  if (paramLength > 0) {\n    throw new RuntimeError(204, ngDevMode && `Can't resolve all parameters for ${stringify(token)}: (${newArray(paramLength, \"?\").join(\", \")}).`);\n  }\n  const inheritedInjectableDef = getInheritedInjectableDef(token);\n  if (inheritedInjectableDef !== null) {\n    return () => inheritedInjectableDef.factory(token);\n  } else {\n    return () => new token();\n  }\n}\nfunction providerToRecord(provider) {\n  if (isValueProvider(provider)) {\n    return makeRecord(void 0, provider.useValue);\n  } else {\n    const factory = providerToFactory(provider);\n    return makeRecord(factory, NOT_YET);\n  }\n}\nfunction providerToFactory(provider, ngModuleType, providers) {\n  let factory = void 0;\n  if (ngDevMode && isEnvironmentProviders(provider)) {\n    throwInvalidProviderError(void 0, providers, provider);\n  }\n  if (isTypeProvider(provider)) {\n    const unwrappedProvider = resolveForwardRef(provider);\n    return getFactoryDef(unwrappedProvider) || injectableDefOrInjectorDefFactory(unwrappedProvider);\n  } else {\n    if (isValueProvider(provider)) {\n      factory = () => resolveForwardRef(provider.useValue);\n    } else if (isFactoryProvider(provider)) {\n      factory = () => provider.useFactory(...injectArgs(provider.deps || []));\n    } else if (isExistingProvider(provider)) {\n      factory = () => \\u0275\\u0275inject(resolveForwardRef(provider.useExisting));\n    } else {\n      const classRef = resolveForwardRef(provider && (provider.useClass || provider.provide));\n      if (ngDevMode && !classRef) {\n        throwInvalidProviderError(ngModuleType, providers, provider);\n      }\n      if (hasDeps(provider)) {\n        factory = () => new classRef(...injectArgs(provider.deps));\n      } else {\n        return getFactoryDef(classRef) || injectableDefOrInjectorDefFactory(classRef);\n      }\n    }\n  }\n  return factory;\n}\nfunction assertNotDestroyed(injector) {\n  if (injector.destroyed) {\n    throw new RuntimeError(205, ngDevMode && \"Injector has already been destroyed.\");\n  }\n}\nfunction makeRecord(factory, value, multi = false) {\n  return {\n    factory,\n    value,\n    multi: multi ? [] : void 0\n  };\n}\nfunction hasDeps(value) {\n  return !!value.deps;\n}\nfunction hasOnDestroy(value) {\n  return value !== null && typeof value === \"object\" && typeof value.ngOnDestroy === \"function\";\n}\nfunction couldBeInjectableType(value) {\n  return typeof value === \"function\" || typeof value === \"object\" && value instanceof InjectionToken;\n}\nfunction forEachSingleProvider(providers, fn) {\n  for (const provider of providers) {\n    if (Array.isArray(provider)) {\n      forEachSingleProvider(provider, fn);\n    } else if (provider && isEnvironmentProviders(provider)) {\n      forEachSingleProvider(provider.\\u0275providers, fn);\n    } else {\n      fn(provider);\n    }\n  }\n}\nfunction runInInjectionContext(injector, fn) {\n  let internalInjector;\n  if (injector instanceof R3Injector) {\n    assertNotDestroyed(injector);\n    internalInjector = injector;\n  } else {\n    internalInjector = new RetrievingInjector(injector);\n  }\n  let prevInjectorProfilerContext;\n  if (ngDevMode) {\n    prevInjectorProfilerContext = setInjectorProfilerContext({\n      injector,\n      token: null\n    });\n  }\n  const prevInjector = setCurrentInjector(internalInjector);\n  const previousInjectImplementation = setInjectImplementation(void 0);\n  try {\n    return fn();\n  } finally {\n    setCurrentInjector(prevInjector);\n    ngDevMode && setInjectorProfilerContext(prevInjectorProfilerContext);\n    setInjectImplementation(previousInjectImplementation);\n  }\n}\nfunction isInInjectionContext() {\n  return getInjectImplementation() !== void 0 || getCurrentInjector() != null;\n}\nfunction assertInInjectionContext(debugFn) {\n  if (!isInInjectionContext()) {\n    throw new RuntimeError(-203, ngDevMode && debugFn.name + \"() can only be used within an injection context such as a constructor, a factory function, a field initializer, or a function used with `runInInjectionContext`\");\n  }\n}\nvar FactoryTarget;\n(function(FactoryTarget2) {\n  FactoryTarget2[FactoryTarget2[\"Directive\"] = 0] = \"Directive\";\n  FactoryTarget2[FactoryTarget2[\"Component\"] = 1] = \"Component\";\n  FactoryTarget2[FactoryTarget2[\"Injectable\"] = 2] = \"Injectable\";\n  FactoryTarget2[FactoryTarget2[\"Pipe\"] = 3] = \"Pipe\";\n  FactoryTarget2[FactoryTarget2[\"NgModule\"] = 4] = \"NgModule\";\n})(FactoryTarget || (FactoryTarget = {}));\nvar R3TemplateDependencyKind;\n(function(R3TemplateDependencyKind2) {\n  R3TemplateDependencyKind2[R3TemplateDependencyKind2[\"Directive\"] = 0] = \"Directive\";\n  R3TemplateDependencyKind2[R3TemplateDependencyKind2[\"Pipe\"] = 1] = \"Pipe\";\n  R3TemplateDependencyKind2[R3TemplateDependencyKind2[\"NgModule\"] = 2] = \"NgModule\";\n})(R3TemplateDependencyKind || (R3TemplateDependencyKind = {}));\nvar ViewEncapsulation$1;\n(function(ViewEncapsulation2) {\n  ViewEncapsulation2[ViewEncapsulation2[\"Emulated\"] = 0] = \"Emulated\";\n  ViewEncapsulation2[ViewEncapsulation2[\"None\"] = 2] = \"None\";\n  ViewEncapsulation2[ViewEncapsulation2[\"ShadowDom\"] = 3] = \"ShadowDom\";\n})(ViewEncapsulation$1 || (ViewEncapsulation$1 = {}));\nfunction getCompilerFacade(request) {\n  const globalNg = _global[\"ng\"];\n  if (globalNg && globalNg.\\u0275compilerFacade) {\n    return globalNg.\\u0275compilerFacade;\n  }\n  if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n    console.error(`JIT compilation failed for ${request.kind}`, request.type);\n    let message = `The ${request.kind} '${request.type.name}' needs to be compiled using the JIT compiler, but '@angular/compiler' is not available.\n\n`;\n    if (request.usage === 1) {\n      message += `The ${request.kind} is part of a library that has been partially compiled.\n`;\n      message += `However, the Angular Linker has not processed the library such that JIT compilation is used as fallback.\n`;\n      message += \"\\n\";\n      message += `Ideally, the library is processed using the Angular Linker to become fully AOT compiled.\n`;\n    } else {\n      message += `JIT compilation is discouraged for production use-cases! Consider using AOT mode instead.\n`;\n    }\n    message += `Alternatively, the JIT compiler should be loaded by bootstrapping using '@angular/platform-browser-dynamic' or '@angular/platform-server',\n`;\n    message += `or manually provide the compiler with 'import \"@angular/compiler\";' before bootstrapping.`;\n    throw new Error(message);\n  } else {\n    throw new Error(\"JIT compiler unavailable\");\n  }\n}\nvar angularCoreDiEnv = {\n  \"\\u0275\\u0275defineInjectable\": \\u0275\\u0275defineInjectable,\n  \"\\u0275\\u0275defineInjector\": \\u0275\\u0275defineInjector,\n  \"\\u0275\\u0275inject\": \\u0275\\u0275inject,\n  \"\\u0275\\u0275invalidFactoryDep\": \\u0275\\u0275invalidFactoryDep,\n  \"resolveForwardRef\": resolveForwardRef\n};\nvar Type = Function;\nfunction isType(v) {\n  return typeof v === \"function\";\n}\nvar ES5_DELEGATE_CTOR = /^function\\s+\\S+\\(\\)\\s*{[\\s\\S]+\\.apply\\(this,\\s*(arguments|(?:[^()]+\\(\\[\\],)?[^()]+\\(arguments\\).*)\\)/;\nvar ES2015_INHERITED_CLASS = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{/;\nvar ES2015_INHERITED_CLASS_WITH_CTOR = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(/;\nvar ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR = /^class\\s+[A-Za-z\\d$_]*\\s*extends\\s+[^{]+{[\\s\\S]*constructor\\s*\\(\\)\\s*{[^}]*super\\(\\.\\.\\.arguments\\)/;\nfunction isDelegateCtor(typeStr) {\n  return ES5_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr);\n}\nvar ReflectionCapabilities = class {\n  _reflect;\n  constructor(reflect) {\n    this._reflect = reflect || _global[\"Reflect\"];\n  }\n  factory(t) {\n    return (...args) => new t(...args);\n  }\n  /** @internal */\n  _zipTypesAndAnnotations(paramTypes, paramAnnotations) {\n    let result;\n    if (typeof paramTypes === \"undefined\") {\n      result = newArray(paramAnnotations.length);\n    } else {\n      result = newArray(paramTypes.length);\n    }\n    for (let i = 0; i < result.length; i++) {\n      if (typeof paramTypes === \"undefined\") {\n        result[i] = [];\n      } else if (paramTypes[i] && paramTypes[i] != Object) {\n        result[i] = [paramTypes[i]];\n      } else {\n        result[i] = [];\n      }\n      if (paramAnnotations && paramAnnotations[i] != null) {\n        result[i] = result[i].concat(paramAnnotations[i]);\n      }\n    }\n    return result;\n  }\n  _ownParameters(type, parentCtor) {\n    const typeStr = type.toString();\n    if (isDelegateCtor(typeStr)) {\n      return null;\n    }\n    if (type.parameters && type.parameters !== parentCtor.parameters) {\n      return type.parameters;\n    }\n    const tsickleCtorParams = type.ctorParameters;\n    if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {\n      const ctorParameters = typeof tsickleCtorParams === \"function\" ? tsickleCtorParams() : tsickleCtorParams;\n      const paramTypes2 = ctorParameters.map((ctorParam) => ctorParam && ctorParam.type);\n      const paramAnnotations2 = ctorParameters.map((ctorParam) => ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));\n      return this._zipTypesAndAnnotations(paramTypes2, paramAnnotations2);\n    }\n    const paramAnnotations = type.hasOwnProperty(PARAMETERS) && type[PARAMETERS];\n    const paramTypes = this._reflect && this._reflect.getOwnMetadata && this._reflect.getOwnMetadata(\"design:paramtypes\", type);\n    if (paramTypes || paramAnnotations) {\n      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n    }\n    return newArray(type.length);\n  }\n  parameters(type) {\n    if (!isType(type)) {\n      return [];\n    }\n    const parentCtor = getParentCtor(type);\n    let parameters = this._ownParameters(type, parentCtor);\n    if (!parameters && parentCtor !== Object) {\n      parameters = this.parameters(parentCtor);\n    }\n    return parameters || [];\n  }\n  _ownAnnotations(typeOrFunc, parentCtor) {\n    if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {\n      let annotations = typeOrFunc.annotations;\n      if (typeof annotations === \"function\" && annotations.annotations) {\n        annotations = annotations.annotations;\n      }\n      return annotations;\n    }\n    if (typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators) {\n      return convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators);\n    }\n    if (typeOrFunc.hasOwnProperty(ANNOTATIONS)) {\n      return typeOrFunc[ANNOTATIONS];\n    }\n    return null;\n  }\n  annotations(typeOrFunc) {\n    if (!isType(typeOrFunc)) {\n      return [];\n    }\n    const parentCtor = getParentCtor(typeOrFunc);\n    const ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];\n    const parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];\n    return parentAnnotations.concat(ownAnnotations);\n  }\n  _ownPropMetadata(typeOrFunc, parentCtor) {\n    if (typeOrFunc.propMetadata && typeOrFunc.propMetadata !== parentCtor.propMetadata) {\n      let propMetadata = typeOrFunc.propMetadata;\n      if (typeof propMetadata === \"function\" && propMetadata.propMetadata) {\n        propMetadata = propMetadata.propMetadata;\n      }\n      return propMetadata;\n    }\n    if (typeOrFunc.propDecorators && typeOrFunc.propDecorators !== parentCtor.propDecorators) {\n      const propDecorators = typeOrFunc.propDecorators;\n      const propMetadata = {};\n      Object.keys(propDecorators).forEach((prop) => {\n        propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);\n      });\n      return propMetadata;\n    }\n    if (typeOrFunc.hasOwnProperty(PROP_METADATA)) {\n      return typeOrFunc[PROP_METADATA];\n    }\n    return null;\n  }\n  propMetadata(typeOrFunc) {\n    if (!isType(typeOrFunc)) {\n      return {};\n    }\n    const parentCtor = getParentCtor(typeOrFunc);\n    const propMetadata = {};\n    if (parentCtor !== Object) {\n      const parentPropMetadata = this.propMetadata(parentCtor);\n      Object.keys(parentPropMetadata).forEach((propName) => {\n        propMetadata[propName] = parentPropMetadata[propName];\n      });\n    }\n    const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);\n    if (ownPropMetadata) {\n      Object.keys(ownPropMetadata).forEach((propName) => {\n        const decorators = [];\n        if (propMetadata.hasOwnProperty(propName)) {\n          decorators.push(...propMetadata[propName]);\n        }\n        decorators.push(...ownPropMetadata[propName]);\n        propMetadata[propName] = decorators;\n      });\n    }\n    return propMetadata;\n  }\n  ownPropMetadata(typeOrFunc) {\n    if (!isType(typeOrFunc)) {\n      return {};\n    }\n    return this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {};\n  }\n  hasLifecycleHook(type, lcProperty) {\n    return type instanceof Type && lcProperty in type.prototype;\n  }\n};\nfunction convertTsickleDecoratorIntoMetadata(decoratorInvocations) {\n  if (!decoratorInvocations) {\n    return [];\n  }\n  return decoratorInvocations.map((decoratorInvocation) => {\n    const decoratorType = decoratorInvocation.type;\n    const annotationCls = decoratorType.annotationCls;\n    const annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];\n    return new annotationCls(...annotationArgs);\n  });\n}\nfunction getParentCtor(ctor) {\n  const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;\n  const parentCtor = parentProto ? parentProto.constructor : null;\n  return parentCtor || Object;\n}\nvar HOST = 0;\nvar TVIEW = 1;\nvar FLAGS = 2;\nvar PARENT = 3;\nvar NEXT = 4;\nvar T_HOST = 5;\nvar HYDRATION = 6;\nvar CLEANUP = 7;\nvar CONTEXT = 8;\nvar INJECTOR = 9;\nvar ENVIRONMENT = 10;\nvar RENDERER = 11;\nvar CHILD_HEAD = 12;\nvar CHILD_TAIL = 13;\nvar DECLARATION_VIEW = 14;\nvar DECLARATION_COMPONENT_VIEW = 15;\nvar DECLARATION_LCONTAINER = 16;\nvar PREORDER_HOOK_FLAGS = 17;\nvar QUERIES = 18;\nvar ID = 19;\nvar EMBEDDED_VIEW_INJECTOR = 20;\nvar ON_DESTROY_HOOKS = 21;\nvar EFFECTS_TO_SCHEDULE = 22;\nvar EFFECTS = 23;\nvar REACTIVE_TEMPLATE_CONSUMER = 24;\nvar AFTER_RENDER_SEQUENCES_TO_ADD = 25;\nvar HEADER_OFFSET = 26;\nvar TYPE = 1;\nvar DEHYDRATED_VIEWS = 6;\nvar NATIVE = 7;\nvar VIEW_REFS = 8;\nvar MOVED_VIEWS = 9;\nvar CONTAINER_HEADER_OFFSET = 10;\nfunction isLView(value) {\n  return Array.isArray(value) && typeof value[TYPE] === \"object\";\n}\nfunction isLContainer(value) {\n  return Array.isArray(value) && value[TYPE] === true;\n}\nfunction isContentQueryHost(tNode) {\n  return (tNode.flags & 4) !== 0;\n}\nfunction isComponentHost(tNode) {\n  return tNode.componentOffset > -1;\n}\nfunction isDirectiveHost(tNode) {\n  return (tNode.flags & 1) === 1;\n}\nfunction isComponentDef(def) {\n  return !!def.template;\n}\nfunction isRootView(target) {\n  return (target[FLAGS] & 512) !== 0;\n}\nfunction isDestroyed(lView) {\n  return (lView[FLAGS] & 256) === 256;\n}\nfunction assertTNodeForLView(tNode, lView) {\n  assertTNodeForTView(tNode, lView[TVIEW]);\n}\nfunction assertTNodeForTView(tNode, tView) {\n  assertTNode(tNode);\n  const tData = tView.data;\n  for (let i = HEADER_OFFSET; i < tData.length; i++) {\n    if (tData[i] === tNode) {\n      return;\n    }\n  }\n  throwError2(\"This TNode does not belong to this TView.\");\n}\nfunction assertTNode(tNode) {\n  assertDefined(tNode, \"TNode must be defined\");\n  if (!(tNode && typeof tNode === \"object\" && tNode.hasOwnProperty(\"directiveStylingLast\"))) {\n    throwError2(\"Not of type TNode, got: \" + tNode);\n  }\n}\nfunction assertTIcu(tIcu) {\n  assertDefined(tIcu, \"Expected TIcu to be defined\");\n  if (!(typeof tIcu.currentCaseLViewIndex === \"number\")) {\n    throwError2(\"Object is not of TIcu type.\");\n  }\n}\nfunction assertComponentType(actual, msg = \"Type passed in is not ComponentType, it does not have '\\u0275cmp' property.\") {\n  if (!getComponentDef(actual)) {\n    throwError2(msg);\n  }\n}\nfunction assertNgModuleType(actual, msg = \"Type passed in is not NgModuleType, it does not have '\\u0275mod' property.\") {\n  if (!getNgModuleDef(actual)) {\n    throwError2(msg);\n  }\n}\nfunction assertHasParent(tNode) {\n  assertDefined(tNode, \"currentTNode should exist!\");\n  assertDefined(tNode.parent, \"currentTNode should have a parent\");\n}\nfunction assertLContainer(value) {\n  assertDefined(value, \"LContainer must be defined\");\n  assertEqual(isLContainer(value), true, \"Expecting LContainer\");\n}\nfunction assertLViewOrUndefined(value) {\n  value && assertEqual(isLView(value), true, \"Expecting LView or undefined or null\");\n}\nfunction assertLView(value) {\n  assertDefined(value, \"LView must be defined\");\n  assertEqual(isLView(value), true, \"Expecting LView\");\n}\nfunction assertFirstCreatePass(tView, errMessage) {\n  assertEqual(tView.firstCreatePass, true, errMessage || \"Should only be called in first create pass.\");\n}\nfunction assertFirstUpdatePass(tView, errMessage) {\n  assertEqual(tView.firstUpdatePass, true, \"Should only be called in first update pass.\");\n}\nfunction assertDirectiveDef(obj) {\n  if (obj.type === void 0 || obj.selectors == void 0 || obj.inputs === void 0) {\n    throwError2(`Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);\n  }\n}\nfunction assertIndexInDeclRange(tView, index) {\n  assertBetween(HEADER_OFFSET, tView.bindingStartIndex, index);\n}\nfunction assertIndexInExpandoRange(lView, index) {\n  const tView = lView[1];\n  assertBetween(tView.expandoStartIndex, lView.length, index);\n}\nfunction assertBetween(lower, upper, index) {\n  if (!(lower <= index && index < upper)) {\n    throwError2(`Index out of range (expecting ${lower} <= ${index} < ${upper})`);\n  }\n}\nfunction assertProjectionSlots(lView, errMessage) {\n  assertDefined(lView[DECLARATION_COMPONENT_VIEW], \"Component views should exist.\");\n  assertDefined(lView[DECLARATION_COMPONENT_VIEW][T_HOST].projection, \"Components with projection nodes (<ng-content>) must have projection slots defined.\");\n}\nfunction assertParentView(lView, errMessage) {\n  assertDefined(lView, \"Component views should always have a parent view (component's host view)\");\n}\nfunction assertNodeInjector(lView, injectorIndex) {\n  assertIndexInExpandoRange(lView, injectorIndex);\n  assertIndexInExpandoRange(\n    lView,\n    injectorIndex + 8\n    /* NodeInjectorOffset.PARENT */\n  );\n  assertNumber(lView[injectorIndex + 0], \"injectorIndex should point to a bloom filter\");\n  assertNumber(lView[injectorIndex + 1], \"injectorIndex should point to a bloom filter\");\n  assertNumber(lView[injectorIndex + 2], \"injectorIndex should point to a bloom filter\");\n  assertNumber(lView[injectorIndex + 3], \"injectorIndex should point to a bloom filter\");\n  assertNumber(lView[injectorIndex + 4], \"injectorIndex should point to a bloom filter\");\n  assertNumber(lView[injectorIndex + 5], \"injectorIndex should point to a bloom filter\");\n  assertNumber(lView[injectorIndex + 6], \"injectorIndex should point to a bloom filter\");\n  assertNumber(lView[injectorIndex + 7], \"injectorIndex should point to a bloom filter\");\n  assertNumber(lView[\n    injectorIndex + 8\n    /* NodeInjectorOffset.PARENT */\n  ], \"injectorIndex should point to parent injector\");\n}\nvar SimpleChange = class {\n  previousValue;\n  currentValue;\n  firstChange;\n  constructor(previousValue, currentValue, firstChange) {\n    this.previousValue = previousValue;\n    this.currentValue = currentValue;\n    this.firstChange = firstChange;\n  }\n  /**\n   * Check whether the new value is the first value assigned.\n   */\n  isFirstChange() {\n    return this.firstChange;\n  }\n};\nfunction applyValueToInputField(instance, inputSignalNode, privateName, value) {\n  if (inputSignalNode !== null) {\n    inputSignalNode.applyValueToInputSignal(inputSignalNode, value);\n  } else {\n    instance[privateName] = value;\n  }\n}\nvar \\u0275\\u0275NgOnChangesFeature = /* @__PURE__ */ (() => {\n  const \\u0275\\u0275NgOnChangesFeatureImpl = () => NgOnChangesFeatureImpl;\n  \\u0275\\u0275NgOnChangesFeatureImpl.ngInherit = true;\n  return \\u0275\\u0275NgOnChangesFeatureImpl;\n})();\nfunction NgOnChangesFeatureImpl(definition) {\n  if (definition.type.prototype.ngOnChanges) {\n    definition.setInput = ngOnChangesSetInput;\n  }\n  return rememberChangeHistoryAndInvokeOnChangesHook;\n}\nfunction rememberChangeHistoryAndInvokeOnChangesHook() {\n  const simpleChangesStore = getSimpleChangesStore(this);\n  const current = simpleChangesStore?.current;\n  if (current) {\n    const previous = simpleChangesStore.previous;\n    if (previous === EMPTY_OBJ) {\n      simpleChangesStore.previous = current;\n    } else {\n      for (let key in current) {\n        previous[key] = current[key];\n      }\n    }\n    simpleChangesStore.current = null;\n    this.ngOnChanges(current);\n  }\n}\nfunction ngOnChangesSetInput(instance, inputSignalNode, value, publicName, privateName) {\n  const declaredName = this.declaredInputs[publicName];\n  ngDevMode && assertString(declaredName, \"Name of input in ngOnChanges has to be a string\");\n  const simpleChangesStore = getSimpleChangesStore(instance) || setSimpleChangesStore(instance, {\n    previous: EMPTY_OBJ,\n    current: null\n  });\n  const current = simpleChangesStore.current || (simpleChangesStore.current = {});\n  const previous = simpleChangesStore.previous;\n  const previousChange = previous[declaredName];\n  current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ);\n  applyValueToInputField(instance, inputSignalNode, privateName, value);\n}\nvar SIMPLE_CHANGES_STORE = \"__ngSimpleChanges__\";\nfunction getSimpleChangesStore(instance) {\n  return instance[SIMPLE_CHANGES_STORE] || null;\n}\nfunction setSimpleChangesStore(instance, store2) {\n  return instance[SIMPLE_CHANGES_STORE] = store2;\n}\nvar profilerCallback = null;\nvar setProfiler = (profiler2) => {\n  profilerCallback = profiler2;\n};\nvar profiler = function(event, instance = null, hookOrListener) {\n  if (profilerCallback != null) {\n    profilerCallback(event, instance, hookOrListener);\n  }\n};\nvar SVG_NAMESPACE = \"svg\";\nvar MATH_ML_NAMESPACE = \"math\";\nfunction unwrapRNode(value) {\n  while (Array.isArray(value)) {\n    value = value[HOST];\n  }\n  return value;\n}\nfunction unwrapLView(value) {\n  while (Array.isArray(value)) {\n    if (typeof value[TYPE] === \"object\") return value;\n    value = value[HOST];\n  }\n  return null;\n}\nfunction getNativeByIndex(index, lView) {\n  ngDevMode && assertIndexInRange(lView, index);\n  ngDevMode && assertGreaterThanOrEqual(index, HEADER_OFFSET, \"Expected to be past HEADER_OFFSET\");\n  return unwrapRNode(lView[index]);\n}\nfunction getNativeByTNode(tNode, lView) {\n  ngDevMode && assertTNodeForLView(tNode, lView);\n  ngDevMode && assertIndexInRange(lView, tNode.index);\n  const node = unwrapRNode(lView[tNode.index]);\n  return node;\n}\nfunction getTNode(tView, index) {\n  ngDevMode && assertGreaterThan(index, -1, \"wrong index for TNode\");\n  ngDevMode && assertLessThan(index, tView.data.length, \"wrong index for TNode\");\n  const tNode = tView.data[index];\n  ngDevMode && tNode !== null && assertTNode(tNode);\n  return tNode;\n}\nfunction load(view, index) {\n  ngDevMode && assertIndexInRange(view, index);\n  return view[index];\n}\nfunction getComponentLViewByIndex(nodeIndex, hostView) {\n  ngDevMode && assertIndexInRange(hostView, nodeIndex);\n  const slotValue = hostView[nodeIndex];\n  const lView = isLView(slotValue) ? slotValue : slotValue[HOST];\n  return lView;\n}\nfunction isCreationMode(view) {\n  return (view[FLAGS] & 4) === 4;\n}\nfunction viewAttachedToChangeDetector(view) {\n  return (view[FLAGS] & 128) === 128;\n}\nfunction viewAttachedToContainer(view) {\n  return isLContainer(view[PARENT]);\n}\nfunction getConstant(consts, index) {\n  if (index === null || index === void 0) return null;\n  ngDevMode && assertIndexInRange(consts, index);\n  return consts[index];\n}\nfunction resetPreOrderHookFlags(lView) {\n  lView[PREORDER_HOOK_FLAGS] = 0;\n}\nfunction markViewForRefresh(lView) {\n  if (lView[FLAGS] & 1024) {\n    return;\n  }\n  lView[FLAGS] |= 1024;\n  if (viewAttachedToChangeDetector(lView)) {\n    markAncestorsForTraversal(lView);\n  }\n}\nfunction walkUpViews(nestingLevel, currentView) {\n  while (nestingLevel > 0) {\n    ngDevMode && assertDefined(currentView[DECLARATION_VIEW], \"Declaration view should be defined if nesting level is greater than 0.\");\n    currentView = currentView[DECLARATION_VIEW];\n    nestingLevel--;\n  }\n  return currentView;\n}\nfunction requiresRefreshOrTraversal(lView) {\n  return !!(lView[FLAGS] & (1024 | 8192) || lView[REACTIVE_TEMPLATE_CONSUMER]?.dirty);\n}\nfunction updateAncestorTraversalFlagsOnAttach(lView) {\n  lView[ENVIRONMENT].changeDetectionScheduler?.notify(\n    8\n    /* NotificationSource.ViewAttached */\n  );\n  if (lView[FLAGS] & 64) {\n    lView[FLAGS] |= 1024;\n  }\n  if (requiresRefreshOrTraversal(lView)) {\n    markAncestorsForTraversal(lView);\n  }\n}\nfunction markAncestorsForTraversal(lView) {\n  lView[ENVIRONMENT].changeDetectionScheduler?.notify(\n    0\n    /* NotificationSource.MarkAncestorsForTraversal */\n  );\n  let parent = getLViewParent(lView);\n  while (parent !== null) {\n    if (parent[FLAGS] & 8192) {\n      break;\n    }\n    parent[FLAGS] |= 8192;\n    if (!viewAttachedToChangeDetector(parent)) {\n      break;\n    }\n    parent = getLViewParent(parent);\n  }\n}\nfunction storeLViewOnDestroy(lView, onDestroyCallback) {\n  if (isDestroyed(lView)) {\n    throw new RuntimeError(911, ngDevMode && \"View has already been destroyed.\");\n  }\n  if (lView[ON_DESTROY_HOOKS] === null) {\n    lView[ON_DESTROY_HOOKS] = [];\n  }\n  lView[ON_DESTROY_HOOKS].push(onDestroyCallback);\n}\nfunction removeLViewOnDestroy(lView, onDestroyCallback) {\n  if (lView[ON_DESTROY_HOOKS] === null) return;\n  const destroyCBIdx = lView[ON_DESTROY_HOOKS].indexOf(onDestroyCallback);\n  if (destroyCBIdx !== -1) {\n    lView[ON_DESTROY_HOOKS].splice(destroyCBIdx, 1);\n  }\n}\nfunction getLViewParent(lView) {\n  ngDevMode && assertLView(lView);\n  const parent = lView[PARENT];\n  return isLContainer(parent) ? parent[PARENT] : parent;\n}\nfunction getOrCreateLViewCleanup(view) {\n  return view[CLEANUP] ??= [];\n}\nfunction getOrCreateTViewCleanup(tView) {\n  return tView.cleanup ??= [];\n}\nfunction storeCleanupWithContext(tView, lView, context2, cleanupFn) {\n  const lCleanup = getOrCreateLViewCleanup(lView);\n  ngDevMode && assertDefined(context2, \"Cleanup context is mandatory when registering framework-level destroy hooks\");\n  lCleanup.push(context2);\n  if (tView.firstCreatePass) {\n    getOrCreateTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);\n  } else {\n    if (ngDevMode) {\n      Object.freeze(getOrCreateTViewCleanup(tView));\n    }\n  }\n}\nvar instructionState = {\n  lFrame: createLFrame(null),\n  bindingsEnabled: true,\n  skipHydrationRootTNode: null\n};\nvar CheckNoChangesMode;\n(function(CheckNoChangesMode2) {\n  CheckNoChangesMode2[CheckNoChangesMode2[\"Off\"] = 0] = \"Off\";\n  CheckNoChangesMode2[CheckNoChangesMode2[\"Exhaustive\"] = 1] = \"Exhaustive\";\n  CheckNoChangesMode2[CheckNoChangesMode2[\"OnlyDirtyViews\"] = 2] = \"OnlyDirtyViews\";\n})(CheckNoChangesMode || (CheckNoChangesMode = {}));\nvar _checkNoChangesMode = 0;\nvar _isRefreshingViews = false;\nfunction getElementDepthCount() {\n  return instructionState.lFrame.elementDepthCount;\n}\nfunction increaseElementDepthCount() {\n  instructionState.lFrame.elementDepthCount++;\n}\nfunction decreaseElementDepthCount() {\n  instructionState.lFrame.elementDepthCount--;\n}\nfunction getBindingsEnabled() {\n  return instructionState.bindingsEnabled;\n}\nfunction isInSkipHydrationBlock$1() {\n  return instructionState.skipHydrationRootTNode !== null;\n}\nfunction isSkipHydrationRootTNode(tNode) {\n  return instructionState.skipHydrationRootTNode === tNode;\n}\nfunction \\u0275\\u0275enableBindings() {\n  instructionState.bindingsEnabled = true;\n}\nfunction \\u0275\\u0275disableBindings() {\n  instructionState.bindingsEnabled = false;\n}\nfunction leaveSkipHydrationBlock() {\n  instructionState.skipHydrationRootTNode = null;\n}\nfunction getLView() {\n  return instructionState.lFrame.lView;\n}\nfunction getTView() {\n  return instructionState.lFrame.tView;\n}\nfunction \\u0275\\u0275restoreView(viewToRestore) {\n  instructionState.lFrame.contextLView = viewToRestore;\n  return viewToRestore[CONTEXT];\n}\nfunction \\u0275\\u0275resetView(value) {\n  instructionState.lFrame.contextLView = null;\n  return value;\n}\nfunction getCurrentTNode() {\n  let currentTNode = getCurrentTNodePlaceholderOk();\n  while (currentTNode !== null && currentTNode.type === 64) {\n    currentTNode = currentTNode.parent;\n  }\n  return currentTNode;\n}\nfunction getCurrentTNodePlaceholderOk() {\n  return instructionState.lFrame.currentTNode;\n}\nfunction getCurrentParentTNode() {\n  const lFrame = instructionState.lFrame;\n  const currentTNode = lFrame.currentTNode;\n  return lFrame.isParent ? currentTNode : currentTNode.parent;\n}\nfunction setCurrentTNode(tNode, isParent) {\n  ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);\n  const lFrame = instructionState.lFrame;\n  lFrame.currentTNode = tNode;\n  lFrame.isParent = isParent;\n}\nfunction isCurrentTNodeParent() {\n  return instructionState.lFrame.isParent;\n}\nfunction setCurrentTNodeAsNotParent() {\n  instructionState.lFrame.isParent = false;\n}\nfunction getContextLView() {\n  const contextLView = instructionState.lFrame.contextLView;\n  ngDevMode && assertDefined(contextLView, \"contextLView must be defined.\");\n  return contextLView;\n}\nfunction isInCheckNoChangesMode() {\n  !ngDevMode && throwError2(\"Must never be called in production mode\");\n  return _checkNoChangesMode !== CheckNoChangesMode.Off;\n}\nfunction isExhaustiveCheckNoChanges() {\n  !ngDevMode && throwError2(\"Must never be called in production mode\");\n  return _checkNoChangesMode === CheckNoChangesMode.Exhaustive;\n}\nfunction setIsInCheckNoChangesMode(mode) {\n  !ngDevMode && throwError2(\"Must never be called in production mode\");\n  _checkNoChangesMode = mode;\n}\nfunction isRefreshingViews() {\n  return _isRefreshingViews;\n}\nfunction setIsRefreshingViews(mode) {\n  const prev = _isRefreshingViews;\n  _isRefreshingViews = mode;\n  return prev;\n}\nfunction getBindingRoot() {\n  const lFrame = instructionState.lFrame;\n  let index = lFrame.bindingRootIndex;\n  if (index === -1) {\n    index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;\n  }\n  return index;\n}\nfunction getBindingIndex() {\n  return instructionState.lFrame.bindingIndex;\n}\nfunction setBindingIndex(value) {\n  return instructionState.lFrame.bindingIndex = value;\n}\nfunction nextBindingIndex() {\n  return instructionState.lFrame.bindingIndex++;\n}\nfunction incrementBindingIndex(count) {\n  const lFrame = instructionState.lFrame;\n  const index = lFrame.bindingIndex;\n  lFrame.bindingIndex = lFrame.bindingIndex + count;\n  return index;\n}\nfunction isInI18nBlock() {\n  return instructionState.lFrame.inI18n;\n}\nfunction setInI18nBlock(isInI18nBlock2) {\n  instructionState.lFrame.inI18n = isInI18nBlock2;\n}\nfunction setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {\n  const lFrame = instructionState.lFrame;\n  lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;\n  setCurrentDirectiveIndex(currentDirectiveIndex);\n}\nfunction getCurrentDirectiveIndex() {\n  return instructionState.lFrame.currentDirectiveIndex;\n}\nfunction setCurrentDirectiveIndex(currentDirectiveIndex) {\n  instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex;\n}\nfunction getCurrentDirectiveDef(tData) {\n  const currentDirectiveIndex = instructionState.lFrame.currentDirectiveIndex;\n  return currentDirectiveIndex === -1 ? null : tData[currentDirectiveIndex];\n}\nfunction getCurrentQueryIndex() {\n  return instructionState.lFrame.currentQueryIndex;\n}\nfunction setCurrentQueryIndex(value) {\n  instructionState.lFrame.currentQueryIndex = value;\n}\nfunction getDeclarationTNode(lView) {\n  const tView = lView[TVIEW];\n  if (tView.type === 2) {\n    ngDevMode && assertDefined(tView.declTNode, \"Embedded TNodes should have declaration parents.\");\n    return tView.declTNode;\n  }\n  if (tView.type === 1) {\n    return lView[T_HOST];\n  }\n  return null;\n}\nfunction enterDI(lView, tNode, flags) {\n  ngDevMode && assertLViewOrUndefined(lView);\n  if (flags & InjectFlags.SkipSelf) {\n    ngDevMode && assertTNodeForTView(tNode, lView[TVIEW]);\n    let parentTNode = tNode;\n    let parentLView = lView;\n    while (true) {\n      ngDevMode && assertDefined(parentTNode, \"Parent TNode should be defined\");\n      parentTNode = parentTNode.parent;\n      if (parentTNode === null && !(flags & InjectFlags.Host)) {\n        parentTNode = getDeclarationTNode(parentLView);\n        if (parentTNode === null) break;\n        ngDevMode && assertDefined(parentLView, \"Parent LView should be defined\");\n        parentLView = parentLView[DECLARATION_VIEW];\n        if (parentTNode.type & (2 | 8)) {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n    if (parentTNode === null) {\n      return false;\n    } else {\n      tNode = parentTNode;\n      lView = parentLView;\n    }\n  }\n  ngDevMode && assertTNodeForLView(tNode, lView);\n  const lFrame = instructionState.lFrame = allocLFrame();\n  lFrame.currentTNode = tNode;\n  lFrame.lView = lView;\n  return true;\n}\nfunction enterView(newView) {\n  ngDevMode && assertNotEqual(newView[0], newView[1], \"????\");\n  ngDevMode && assertLViewOrUndefined(newView);\n  const newLFrame = allocLFrame();\n  if (ngDevMode) {\n    assertEqual(newLFrame.isParent, true, \"Expected clean LFrame\");\n    assertEqual(newLFrame.lView, null, \"Expected clean LFrame\");\n    assertEqual(newLFrame.tView, null, \"Expected clean LFrame\");\n    assertEqual(newLFrame.selectedIndex, -1, \"Expected clean LFrame\");\n    assertEqual(newLFrame.elementDepthCount, 0, \"Expected clean LFrame\");\n    assertEqual(newLFrame.currentDirectiveIndex, -1, \"Expected clean LFrame\");\n    assertEqual(newLFrame.currentNamespace, null, \"Expected clean LFrame\");\n    assertEqual(newLFrame.bindingRootIndex, -1, \"Expected clean LFrame\");\n    assertEqual(newLFrame.currentQueryIndex, 0, \"Expected clean LFrame\");\n  }\n  const tView = newView[TVIEW];\n  instructionState.lFrame = newLFrame;\n  ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView);\n  newLFrame.currentTNode = tView.firstChild;\n  newLFrame.lView = newView;\n  newLFrame.tView = tView;\n  newLFrame.contextLView = newView;\n  newLFrame.bindingIndex = tView.bindingStartIndex;\n  newLFrame.inI18n = false;\n}\nfunction allocLFrame() {\n  const currentLFrame = instructionState.lFrame;\n  const childLFrame = currentLFrame === null ? null : currentLFrame.child;\n  const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;\n  return newLFrame;\n}\nfunction createLFrame(parent) {\n  const lFrame = {\n    currentTNode: null,\n    isParent: true,\n    lView: null,\n    tView: null,\n    selectedIndex: -1,\n    contextLView: null,\n    elementDepthCount: 0,\n    currentNamespace: null,\n    currentDirectiveIndex: -1,\n    bindingRootIndex: -1,\n    bindingIndex: -1,\n    currentQueryIndex: 0,\n    parent,\n    child: null,\n    inI18n: false\n  };\n  parent !== null && (parent.child = lFrame);\n  return lFrame;\n}\nfunction leaveViewLight() {\n  const oldLFrame = instructionState.lFrame;\n  instructionState.lFrame = oldLFrame.parent;\n  oldLFrame.currentTNode = null;\n  oldLFrame.lView = null;\n  return oldLFrame;\n}\nvar leaveDI = leaveViewLight;\nfunction leaveView() {\n  const oldLFrame = leaveViewLight();\n  oldLFrame.isParent = true;\n  oldLFrame.tView = null;\n  oldLFrame.selectedIndex = -1;\n  oldLFrame.contextLView = null;\n  oldLFrame.elementDepthCount = 0;\n  oldLFrame.currentDirectiveIndex = -1;\n  oldLFrame.currentNamespace = null;\n  oldLFrame.bindingRootIndex = -1;\n  oldLFrame.bindingIndex = -1;\n  oldLFrame.currentQueryIndex = 0;\n}\nfunction nextContextImpl(level) {\n  const contextLView = instructionState.lFrame.contextLView = walkUpViews(level, instructionState.lFrame.contextLView);\n  return contextLView[CONTEXT];\n}\nfunction getSelectedIndex() {\n  return instructionState.lFrame.selectedIndex;\n}\nfunction setSelectedIndex(index) {\n  ngDevMode && index !== -1 && assertGreaterThanOrEqual(index, HEADER_OFFSET, \"Index must be past HEADER_OFFSET (or -1).\");\n  ngDevMode && assertLessThan(index, instructionState.lFrame.lView.length, \"Can't set index passed end of LView\");\n  instructionState.lFrame.selectedIndex = index;\n}\nfunction getSelectedTNode() {\n  const lFrame = instructionState.lFrame;\n  return getTNode(lFrame.tView, lFrame.selectedIndex);\n}\nfunction \\u0275\\u0275namespaceSVG() {\n  instructionState.lFrame.currentNamespace = SVG_NAMESPACE;\n}\nfunction \\u0275\\u0275namespaceMathML() {\n  instructionState.lFrame.currentNamespace = MATH_ML_NAMESPACE;\n}\nfunction \\u0275\\u0275namespaceHTML() {\n  namespaceHTMLInternal();\n}\nfunction namespaceHTMLInternal() {\n  instructionState.lFrame.currentNamespace = null;\n}\nfunction getNamespace() {\n  return instructionState.lFrame.currentNamespace;\n}\nvar _wasLastNodeCreated = true;\nfunction wasLastNodeCreated() {\n  return _wasLastNodeCreated;\n}\nfunction lastNodeWasCreated(flag) {\n  _wasLastNodeCreated = flag;\n}\nfunction registerPreOrderHooks(directiveIndex, directiveDef, tView) {\n  ngDevMode && assertFirstCreatePass(tView);\n  const {\n    ngOnChanges,\n    ngOnInit,\n    ngDoCheck\n  } = directiveDef.type.prototype;\n  if (ngOnChanges) {\n    const wrappedOnChanges = NgOnChangesFeatureImpl(directiveDef);\n    (tView.preOrderHooks ??= []).push(directiveIndex, wrappedOnChanges);\n    (tView.preOrderCheckHooks ??= []).push(directiveIndex, wrappedOnChanges);\n  }\n  if (ngOnInit) {\n    (tView.preOrderHooks ??= []).push(0 - directiveIndex, ngOnInit);\n  }\n  if (ngDoCheck) {\n    (tView.preOrderHooks ??= []).push(directiveIndex, ngDoCheck);\n    (tView.preOrderCheckHooks ??= []).push(directiveIndex, ngDoCheck);\n  }\n}\nfunction registerPostOrderHooks(tView, tNode) {\n  ngDevMode && assertFirstCreatePass(tView);\n  for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {\n    const directiveDef = tView.data[i];\n    ngDevMode && assertDefined(directiveDef, \"Expecting DirectiveDef\");\n    const lifecycleHooks = directiveDef.type.prototype;\n    const {\n      ngAfterContentInit,\n      ngAfterContentChecked,\n      ngAfterViewInit,\n      ngAfterViewChecked,\n      ngOnDestroy\n    } = lifecycleHooks;\n    if (ngAfterContentInit) {\n      (tView.contentHooks ??= []).push(-i, ngAfterContentInit);\n    }\n    if (ngAfterContentChecked) {\n      (tView.contentHooks ??= []).push(i, ngAfterContentChecked);\n      (tView.contentCheckHooks ??= []).push(i, ngAfterContentChecked);\n    }\n    if (ngAfterViewInit) {\n      (tView.viewHooks ??= []).push(-i, ngAfterViewInit);\n    }\n    if (ngAfterViewChecked) {\n      (tView.viewHooks ??= []).push(i, ngAfterViewChecked);\n      (tView.viewCheckHooks ??= []).push(i, ngAfterViewChecked);\n    }\n    if (ngOnDestroy != null) {\n      (tView.destroyHooks ??= []).push(i, ngOnDestroy);\n    }\n  }\n}\nfunction executeCheckHooks(lView, hooks, nodeIndex) {\n  callHooks(lView, hooks, 3, nodeIndex);\n}\nfunction executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {\n  ngDevMode && assertNotEqual(initPhase, 3, \"Init pre-order hooks should not be called more than once\");\n  if ((lView[FLAGS] & 3) === initPhase) {\n    callHooks(lView, hooks, initPhase, nodeIndex);\n  }\n}\nfunction incrementInitPhaseFlags(lView, initPhase) {\n  ngDevMode && assertNotEqual(initPhase, 3, \"Init hooks phase should not be incremented after all init hooks have been run.\");\n  let flags = lView[FLAGS];\n  if ((flags & 3) === initPhase) {\n    flags &= 16383;\n    flags += 1;\n    lView[FLAGS] = flags;\n  }\n}\nfunction callHooks(currentView, arr, initPhase, currentNodeIndex) {\n  ngDevMode && assertEqual(isInCheckNoChangesMode(), false, \"Hooks should never be run when in check no changes mode.\");\n  const startIndex = currentNodeIndex !== void 0 ? currentView[PREORDER_HOOK_FLAGS] & 65535 : 0;\n  const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;\n  const max = arr.length - 1;\n  let lastNodeIndexFound = 0;\n  for (let i = startIndex; i < max; i++) {\n    const hook = arr[i + 1];\n    if (typeof hook === \"number\") {\n      lastNodeIndexFound = arr[i];\n      if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {\n        break;\n      }\n    } else {\n      const isInitHook = arr[i] < 0;\n      if (isInitHook) {\n        currentView[PREORDER_HOOK_FLAGS] += 65536;\n      }\n      if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {\n        callHook(currentView, initPhase, arr, i);\n        currentView[PREORDER_HOOK_FLAGS] = (currentView[PREORDER_HOOK_FLAGS] & 4294901760) + i + 2;\n      }\n      i++;\n    }\n  }\n}\nfunction callHookInternal(directive, hook) {\n  profiler(4, directive, hook);\n  const prevConsumer = setActiveConsumer(null);\n  try {\n    hook.call(directive);\n  } finally {\n    setActiveConsumer(prevConsumer);\n    profiler(5, directive, hook);\n  }\n}\nfunction callHook(currentView, initPhase, arr, i) {\n  const isInitHook = arr[i] < 0;\n  const hook = arr[i + 1];\n  const directiveIndex = isInitHook ? -arr[i] : arr[i];\n  const directive = currentView[directiveIndex];\n  if (isInitHook) {\n    const indexWithintInitPhase = currentView[FLAGS] >> 14;\n    if (indexWithintInitPhase < currentView[PREORDER_HOOK_FLAGS] >> 16 && (currentView[FLAGS] & 3) === initPhase) {\n      currentView[FLAGS] += 16384;\n      callHookInternal(directive, hook);\n    }\n  } else {\n    callHookInternal(directive, hook);\n  }\n}\nvar NO_PARENT_INJECTOR = -1;\nvar NodeInjectorFactory = class {\n  factory;\n  /**\n   * The inject implementation to be activated when using the factory.\n   */\n  injectImpl;\n  /**\n   * Marker set to true during factory invocation to see if we get into recursive loop.\n   * Recursive loop causes an error to be displayed.\n   */\n  resolving = false;\n  /**\n   * Marks that the token can see other Tokens declared in `viewProviders` on the same node.\n   */\n  canSeeViewProviders;\n  /**\n   * An array of factories to use in case of `multi` provider.\n   */\n  multi;\n  /**\n   * Number of `multi`-providers which belong to the component.\n   *\n   * This is needed because when multiple components and directives declare the `multi` provider\n   * they have to be concatenated in the correct order.\n   *\n   * Example:\n   *\n   * If we have a component and directive active an a single element as declared here\n   * ```ts\n   * component:\n   *   providers: [ {provide: String, useValue: 'component', multi: true} ],\n   *   viewProviders: [ {provide: String, useValue: 'componentView', multi: true} ],\n   *\n   * directive:\n   *   providers: [ {provide: String, useValue: 'directive', multi: true} ],\n   * ```\n   *\n   * Then the expected results are:\n   *\n   * ```ts\n   * providers: ['component', 'directive']\n   * viewProviders: ['component', 'componentView', 'directive']\n   * ```\n   *\n   * The way to think about it is that the `viewProviders` have been inserted after the component\n   * but before the directives, which is why we need to know how many `multi`s have been declared by\n   * the component.\n   */\n  componentProviders;\n  /**\n   * Current index of the Factory in the `data`. Needed for `viewProviders` and `providers` merging.\n   * See `providerFactory`.\n   */\n  index;\n  /**\n   * Because the same `multi` provider can be declared in `providers` and `viewProviders` it is\n   * possible for `viewProviders` to shadow the `providers`. For this reason we store the\n   * `provideFactory` of the `providers` so that `providers` can be extended with `viewProviders`.\n   *\n   * Example:\n   *\n   * Given:\n   * ```ts\n   * providers: [ {provide: String, useValue: 'all', multi: true} ],\n   * viewProviders: [ {provide: String, useValue: 'viewOnly', multi: true} ],\n   * ```\n   *\n   * We have to return `['all']` in case of content injection, but `['all', 'viewOnly']` in case\n   * of view injection. We further have to make sure that the shared instances (in our case\n   * `all`) are the exact same instance in both the content as well as the view injection. (We\n   * have to make sure that we don't double instantiate.) For this reason the `viewProviders`\n   * `Factory` has a pointer to the shadowed `providers` factory so that it can instantiate the\n   * `providers` (`['all']`) and then extend it with `viewProviders` (`['all'] + ['viewOnly'] =\n   * ['all', 'viewOnly']`).\n   */\n  providerFactory;\n  constructor(factory, isViewProvider, injectImplementation) {\n    this.factory = factory;\n    ngDevMode && assertDefined(factory, \"Factory not specified\");\n    ngDevMode && assertEqual(typeof factory, \"function\", \"Expected factory function.\");\n    this.canSeeViewProviders = isViewProvider;\n    this.injectImpl = injectImplementation;\n  }\n};\nfunction toTNodeTypeAsString(tNodeType) {\n  let text = \"\";\n  tNodeType & 1 && (text += \"|Text\");\n  tNodeType & 2 && (text += \"|Element\");\n  tNodeType & 4 && (text += \"|Container\");\n  tNodeType & 8 && (text += \"|ElementContainer\");\n  tNodeType & 16 && (text += \"|Projection\");\n  tNodeType & 32 && (text += \"|IcuContainer\");\n  tNodeType & 64 && (text += \"|Placeholder\");\n  tNodeType & 128 && (text += \"|LetDeclaration\");\n  return text.length > 0 ? text.substring(1) : text;\n}\nfunction isTNodeShape(value) {\n  return value != null && typeof value === \"object\" && (value.insertBeforeIndex === null || typeof value.insertBeforeIndex === \"number\" || Array.isArray(value.insertBeforeIndex));\n}\nfunction hasClassInput(tNode) {\n  return (tNode.flags & 8) !== 0;\n}\nfunction hasStyleInput(tNode) {\n  return (tNode.flags & 16) !== 0;\n}\nfunction assertTNodeType(tNode, expectedTypes, message) {\n  assertDefined(tNode, \"should be called with a TNode\");\n  if ((tNode.type & expectedTypes) === 0) {\n    throwError2(message || `Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`);\n  }\n}\nfunction assertPureTNodeType(type) {\n  if (!(type === 2 || type === 1 || type === 4 || type === 8 || type === 32 || type === 16 || type === 64 || type === 128)) {\n    throwError2(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type)}.`);\n  }\n}\nfunction setUpAttributes(renderer, native, attrs) {\n  let i = 0;\n  while (i < attrs.length) {\n    const value = attrs[i];\n    if (typeof value === \"number\") {\n      if (value !== 0) {\n        break;\n      }\n      i++;\n      const namespaceURI = attrs[i++];\n      const attrName = attrs[i++];\n      const attrVal = attrs[i++];\n      ngDevMode && ngDevMode.rendererSetAttribute++;\n      renderer.setAttribute(native, attrName, attrVal, namespaceURI);\n    } else {\n      const attrName = value;\n      const attrVal = attrs[++i];\n      ngDevMode && ngDevMode.rendererSetAttribute++;\n      if (isAnimationProp(attrName)) {\n        renderer.setProperty(native, attrName, attrVal);\n      } else {\n        renderer.setAttribute(native, attrName, attrVal);\n      }\n      i++;\n    }\n  }\n  return i;\n}\nfunction isNameOnlyAttributeMarker(marker) {\n  return marker === 3 || marker === 4 || marker === 6;\n}\nfunction isAnimationProp(name) {\n  return name.charCodeAt(0) === 64;\n}\nfunction mergeHostAttrs(dst, src) {\n  if (src === null || src.length === 0) ;\n  else if (dst === null || dst.length === 0) {\n    dst = src.slice();\n  } else {\n    let srcMarker = -1;\n    for (let i = 0; i < src.length; i++) {\n      const item = src[i];\n      if (typeof item === \"number\") {\n        srcMarker = item;\n      } else {\n        if (srcMarker === 0) ;\n        else if (srcMarker === -1 || srcMarker === 2) {\n          mergeHostAttribute(dst, srcMarker, item, null, src[++i]);\n        } else {\n          mergeHostAttribute(dst, srcMarker, item, null, null);\n        }\n      }\n    }\n  }\n  return dst;\n}\nfunction mergeHostAttribute(dst, marker, key1, key2, value) {\n  let i = 0;\n  let markerInsertPosition = dst.length;\n  if (marker === -1) {\n    markerInsertPosition = -1;\n  } else {\n    while (i < dst.length) {\n      const dstValue = dst[i++];\n      if (typeof dstValue === \"number\") {\n        if (dstValue === marker) {\n          markerInsertPosition = -1;\n          break;\n        } else if (dstValue > marker) {\n          markerInsertPosition = i - 1;\n          break;\n        }\n      }\n    }\n  }\n  while (i < dst.length) {\n    const item = dst[i];\n    if (typeof item === \"number\") {\n      break;\n    } else if (item === key1) {\n      {\n        if (value !== null) {\n          dst[i + 1] = value;\n        }\n        return;\n      }\n    }\n    i++;\n    if (value !== null) i++;\n  }\n  if (markerInsertPosition !== -1) {\n    dst.splice(markerInsertPosition, 0, marker);\n    i = markerInsertPosition + 1;\n  }\n  dst.splice(i++, 0, key1);\n  if (value !== null) {\n    dst.splice(i++, 0, value);\n  }\n}\nvar NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};\nvar ChainedInjector = class {\n  injector;\n  parentInjector;\n  constructor(injector, parentInjector) {\n    this.injector = injector;\n    this.parentInjector = parentInjector;\n  }\n  get(token, notFoundValue, flags) {\n    flags = convertToBitFlags(flags);\n    const value = this.injector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, flags);\n    if (value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR || notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR) {\n      return value;\n    }\n    return this.parentInjector.get(token, notFoundValue, flags);\n  }\n};\nfunction hasParentInjector(parentLocation) {\n  return parentLocation !== NO_PARENT_INJECTOR;\n}\nfunction getParentInjectorIndex(parentLocation) {\n  if (ngDevMode) {\n    assertNumber(parentLocation, \"Number expected\");\n    assertNotEqual(parentLocation, -1, \"Not a valid state.\");\n    const parentInjectorIndex = parentLocation & 32767;\n    assertGreaterThan(parentInjectorIndex, HEADER_OFFSET, \"Parent injector must be pointing past HEADER_OFFSET.\");\n  }\n  return parentLocation & 32767;\n}\nfunction getParentInjectorViewOffset(parentLocation) {\n  return parentLocation >> 16;\n}\nfunction getParentInjectorView(location2, startView) {\n  let viewOffset = getParentInjectorViewOffset(location2);\n  let parentView = startView;\n  while (viewOffset > 0) {\n    parentView = parentView[DECLARATION_VIEW];\n    viewOffset--;\n  }\n  return parentView;\n}\nfunction isRouterOutletInjector(currentInjector) {\n  return currentInjector instanceof ChainedInjector && typeof currentInjector.injector.__ngOutletInjector === \"function\";\n}\nvar includeViewProviders = true;\nfunction setIncludeViewProviders(v) {\n  const oldValue = includeViewProviders;\n  includeViewProviders = v;\n  return oldValue;\n}\nvar BLOOM_SIZE = 256;\nvar BLOOM_MASK = BLOOM_SIZE - 1;\nvar BLOOM_BUCKET_BITS = 5;\nvar nextNgElementId = 0;\nvar NOT_FOUND2 = {};\nfunction bloomAdd(injectorIndex, tView, type) {\n  ngDevMode && assertEqual(tView.firstCreatePass, true, \"expected firstCreatePass to be true\");\n  let id;\n  if (typeof type === \"string\") {\n    id = type.charCodeAt(0) || 0;\n  } else if (type.hasOwnProperty(NG_ELEMENT_ID)) {\n    id = type[NG_ELEMENT_ID];\n  }\n  if (id == null) {\n    id = type[NG_ELEMENT_ID] = nextNgElementId++;\n  }\n  const bloomHash = id & BLOOM_MASK;\n  const mask = 1 << bloomHash;\n  tView.data[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)] |= mask;\n}\nfunction getOrCreateNodeInjectorForNode(tNode, lView) {\n  const existingInjectorIndex = getInjectorIndex(tNode, lView);\n  if (existingInjectorIndex !== -1) {\n    return existingInjectorIndex;\n  }\n  const tView = lView[TVIEW];\n  if (tView.firstCreatePass) {\n    tNode.injectorIndex = lView.length;\n    insertBloom(tView.data, tNode);\n    insertBloom(lView, null);\n    insertBloom(tView.blueprint, null);\n  }\n  const parentLoc = getParentInjectorLocation(tNode, lView);\n  const injectorIndex = tNode.injectorIndex;\n  if (hasParentInjector(parentLoc)) {\n    const parentIndex = getParentInjectorIndex(parentLoc);\n    const parentLView = getParentInjectorView(parentLoc, lView);\n    const parentData = parentLView[TVIEW].data;\n    for (let i = 0; i < 8; i++) {\n      lView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];\n    }\n  }\n  lView[\n    injectorIndex + 8\n    /* NodeInjectorOffset.PARENT */\n  ] = parentLoc;\n  return injectorIndex;\n}\nfunction insertBloom(arr, footer) {\n  arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);\n}\nfunction getInjectorIndex(tNode, lView) {\n  if (tNode.injectorIndex === -1 || // If the injector index is the same as its parent's injector index, then the index has been\n  // copied down from the parent node. No injector has been created yet on this node.\n  tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex || // After the first template pass, the injector index might exist but the parent values\n  // might not have been calculated yet for this instance\n  lView[\n    tNode.injectorIndex + 8\n    /* NodeInjectorOffset.PARENT */\n  ] === null) {\n    return -1;\n  } else {\n    ngDevMode && assertIndexInRange(lView, tNode.injectorIndex);\n    return tNode.injectorIndex;\n  }\n}\nfunction getParentInjectorLocation(tNode, lView) {\n  if (tNode.parent && tNode.parent.injectorIndex !== -1) {\n    return tNode.parent.injectorIndex;\n  }\n  let declarationViewOffset = 0;\n  let parentTNode = null;\n  let lViewCursor = lView;\n  while (lViewCursor !== null) {\n    parentTNode = getTNodeFromLView(lViewCursor);\n    if (parentTNode === null) {\n      return NO_PARENT_INJECTOR;\n    }\n    ngDevMode && parentTNode && assertTNodeForLView(parentTNode, lViewCursor[DECLARATION_VIEW]);\n    declarationViewOffset++;\n    lViewCursor = lViewCursor[DECLARATION_VIEW];\n    if (parentTNode.injectorIndex !== -1) {\n      return parentTNode.injectorIndex | declarationViewOffset << 16;\n    }\n  }\n  return NO_PARENT_INJECTOR;\n}\nfunction diPublicInInjector(injectorIndex, tView, token) {\n  bloomAdd(injectorIndex, tView, token);\n}\nfunction injectAttributeImpl(tNode, attrNameToInject) {\n  ngDevMode && assertTNodeType(\n    tNode,\n    12 | 3\n    /* TNodeType.AnyRNode */\n  );\n  ngDevMode && assertDefined(tNode, \"expecting tNode\");\n  if (attrNameToInject === \"class\") {\n    return tNode.classes;\n  }\n  if (attrNameToInject === \"style\") {\n    return tNode.styles;\n  }\n  const attrs = tNode.attrs;\n  if (attrs) {\n    const attrsLength = attrs.length;\n    let i = 0;\n    while (i < attrsLength) {\n      const value = attrs[i];\n      if (isNameOnlyAttributeMarker(value)) break;\n      if (value === 0) {\n        i = i + 2;\n      } else if (typeof value === \"number\") {\n        i++;\n        while (i < attrsLength && typeof attrs[i] === \"string\") {\n          i++;\n        }\n      } else if (value === attrNameToInject) {\n        return attrs[i + 1];\n      } else {\n        i = i + 2;\n      }\n    }\n  }\n  return null;\n}\nfunction notFoundValueOrThrow(notFoundValue, token, flags) {\n  if (flags & InjectFlags.Optional || notFoundValue !== void 0) {\n    return notFoundValue;\n  } else {\n    throwProviderNotFoundError(token, \"NodeInjector\");\n  }\n}\nfunction lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue) {\n  if (flags & InjectFlags.Optional && notFoundValue === void 0) {\n    notFoundValue = null;\n  }\n  if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {\n    const moduleInjector = lView[INJECTOR];\n    const previousInjectImplementation = setInjectImplementation(void 0);\n    try {\n      if (moduleInjector) {\n        return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);\n      } else {\n        return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);\n      }\n    } finally {\n      setInjectImplementation(previousInjectImplementation);\n    }\n  }\n  return notFoundValueOrThrow(notFoundValue, token, flags);\n}\nfunction getOrCreateInjectable(tNode, lView, token, flags = InjectFlags.Default, notFoundValue) {\n  if (tNode !== null) {\n    if (lView[FLAGS] & 2048 && // The token must be present on the current node injector when the `Self`\n    // flag is set, so the lookup on embedded view injector(s) can be skipped.\n    !(flags & InjectFlags.Self)) {\n      const embeddedInjectorValue = lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, NOT_FOUND2);\n      if (embeddedInjectorValue !== NOT_FOUND2) {\n        return embeddedInjectorValue;\n      }\n    }\n    const value = lookupTokenUsingNodeInjector(tNode, lView, token, flags, NOT_FOUND2);\n    if (value !== NOT_FOUND2) {\n      return value;\n    }\n  }\n  return lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);\n}\nfunction lookupTokenUsingNodeInjector(tNode, lView, token, flags, notFoundValue) {\n  const bloomHash = bloomHashBitOrFactory(token);\n  if (typeof bloomHash === \"function\") {\n    if (!enterDI(lView, tNode, flags)) {\n      return flags & InjectFlags.Host ? notFoundValueOrThrow(notFoundValue, token, flags) : lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);\n    }\n    try {\n      let value;\n      if (ngDevMode) {\n        runInInjectorProfilerContext(new NodeInjector(getCurrentTNode(), getLView()), token, () => {\n          value = bloomHash(flags);\n          if (value != null) {\n            emitInstanceCreatedByInjectorEvent(value);\n          }\n        });\n      } else {\n        value = bloomHash(flags);\n      }\n      if (value == null && !(flags & InjectFlags.Optional)) {\n        throwProviderNotFoundError(token);\n      } else {\n        return value;\n      }\n    } finally {\n      leaveDI();\n    }\n  } else if (typeof bloomHash === \"number\") {\n    let previousTView = null;\n    let injectorIndex = getInjectorIndex(tNode, lView);\n    let parentLocation = NO_PARENT_INJECTOR;\n    let hostTElementNode = flags & InjectFlags.Host ? lView[DECLARATION_COMPONENT_VIEW][T_HOST] : null;\n    if (injectorIndex === -1 || flags & InjectFlags.SkipSelf) {\n      parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) : lView[\n        injectorIndex + 8\n        /* NodeInjectorOffset.PARENT */\n      ];\n      if (parentLocation === NO_PARENT_INJECTOR || !shouldSearchParent(flags, false)) {\n        injectorIndex = -1;\n      } else {\n        previousTView = lView[TVIEW];\n        injectorIndex = getParentInjectorIndex(parentLocation);\n        lView = getParentInjectorView(parentLocation, lView);\n      }\n    }\n    while (injectorIndex !== -1) {\n      ngDevMode && assertNodeInjector(lView, injectorIndex);\n      const tView = lView[TVIEW];\n      ngDevMode && assertTNodeForLView(tView.data[\n        injectorIndex + 8\n        /* NodeInjectorOffset.TNODE */\n      ], lView);\n      if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {\n        const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);\n        if (instance !== NOT_FOUND2) {\n          return instance;\n        }\n      }\n      parentLocation = lView[\n        injectorIndex + 8\n        /* NodeInjectorOffset.PARENT */\n      ];\n      if (parentLocation !== NO_PARENT_INJECTOR && shouldSearchParent(flags, lView[TVIEW].data[\n        injectorIndex + 8\n        /* NodeInjectorOffset.TNODE */\n      ] === hostTElementNode) && bloomHasToken(bloomHash, injectorIndex, lView)) {\n        previousTView = tView;\n        injectorIndex = getParentInjectorIndex(parentLocation);\n        lView = getParentInjectorView(parentLocation, lView);\n      } else {\n        injectorIndex = -1;\n      }\n    }\n  }\n  return notFoundValue;\n}\nfunction searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {\n  const currentTView = lView[TVIEW];\n  const tNode = currentTView.data[\n    injectorIndex + 8\n    /* NodeInjectorOffset.TNODE */\n  ];\n  const canAccessViewProviders = previousTView == null ? (\n    // 1) This is the first invocation `previousTView == null` which means that we are at the\n    // `TNode` of where injector is starting to look. In such a case the only time we are allowed\n    // to look into the ViewProviders is if:\n    // - we are on a component\n    // - AND the injector set `includeViewProviders` to true (implying that the token can see\n    // ViewProviders because it is the Component or a Service which itself was declared in\n    // ViewProviders)\n    isComponentHost(tNode) && includeViewProviders\n  ) : (\n    // 2) `previousTView != null` which means that we are now walking across the parent nodes.\n    // In such a case we are only allowed to look into the ViewProviders if:\n    // - We just crossed from child View to Parent View `previousTView != currentTView`\n    // - AND the parent TNode is an Element.\n    // This means that we just came from the Component's View and therefore are allowed to see\n    // into the ViewProviders.\n    previousTView != currentTView && (tNode.type & 3) !== 0\n  );\n  const isHostSpecialCase = flags & InjectFlags.Host && hostTElementNode === tNode;\n  const injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);\n  if (injectableIdx !== null) {\n    return getNodeInjectable(lView, currentTView, injectableIdx, tNode);\n  } else {\n    return NOT_FOUND2;\n  }\n}\nfunction locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {\n  const nodeProviderIndexes = tNode.providerIndexes;\n  const tInjectables = tView.data;\n  const injectablesStart = nodeProviderIndexes & 1048575;\n  const directivesStart = tNode.directiveStart;\n  const directiveEnd = tNode.directiveEnd;\n  const cptViewProvidersCount = nodeProviderIndexes >> 20;\n  const startingIndex = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;\n  const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;\n  for (let i = startingIndex; i < endIndex; i++) {\n    const providerTokenOrDef = tInjectables[i];\n    if (i < directivesStart && token === providerTokenOrDef || i >= directivesStart && providerTokenOrDef.type === token) {\n      return i;\n    }\n  }\n  if (isHostSpecialCase) {\n    const dirDef = tInjectables[directivesStart];\n    if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {\n      return directivesStart;\n    }\n  }\n  return null;\n}\nfunction getNodeInjectable(lView, tView, index, tNode) {\n  let value = lView[index];\n  const tData = tView.data;\n  if (value instanceof NodeInjectorFactory) {\n    const factory = value;\n    if (factory.resolving) {\n      throwCyclicDependencyError(stringifyForError(tData[index]));\n    }\n    const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);\n    factory.resolving = true;\n    let prevInjectContext;\n    if (ngDevMode) {\n      const token = tData[index].type || tData[index];\n      const injector = new NodeInjector(tNode, lView);\n      prevInjectContext = setInjectorProfilerContext({\n        injector,\n        token\n      });\n    }\n    const previousInjectImplementation = factory.injectImpl ? setInjectImplementation(factory.injectImpl) : null;\n    const success = enterDI(lView, tNode, InjectFlags.Default);\n    ngDevMode && assertEqual(success, true, \"Because flags do not contain `SkipSelf' we expect this to always succeed.\");\n    try {\n      value = lView[index] = factory.factory(void 0, tData, lView, tNode);\n      ngDevMode && emitInstanceCreatedByInjectorEvent(value);\n      if (tView.firstCreatePass && index >= tNode.directiveStart) {\n        ngDevMode && assertDirectiveDef(tData[index]);\n        registerPreOrderHooks(index, tData[index], tView);\n      }\n    } finally {\n      ngDevMode && setInjectorProfilerContext(prevInjectContext);\n      previousInjectImplementation !== null && setInjectImplementation(previousInjectImplementation);\n      setIncludeViewProviders(previousIncludeViewProviders);\n      factory.resolving = false;\n      leaveDI();\n    }\n  }\n  return value;\n}\nfunction bloomHashBitOrFactory(token) {\n  ngDevMode && assertDefined(token, \"token must be defined\");\n  if (typeof token === \"string\") {\n    return token.charCodeAt(0) || 0;\n  }\n  const tokenId = (\n    // First check with `hasOwnProperty` so we don't get an inherited ID.\n    token.hasOwnProperty(NG_ELEMENT_ID) ? token[NG_ELEMENT_ID] : void 0\n  );\n  if (typeof tokenId === \"number\") {\n    if (tokenId >= 0) {\n      return tokenId & BLOOM_MASK;\n    } else {\n      ngDevMode && assertEqual(tokenId, -1, \"Expecting to get Special Injector Id\");\n      return createNodeInjector;\n    }\n  } else {\n    return tokenId;\n  }\n}\nfunction bloomHasToken(bloomHash, injectorIndex, injectorView) {\n  const mask = 1 << bloomHash;\n  const value = injectorView[injectorIndex + (bloomHash >> BLOOM_BUCKET_BITS)];\n  return !!(value & mask);\n}\nfunction shouldSearchParent(flags, isFirstHostTNode) {\n  return !(flags & InjectFlags.Self) && !(flags & InjectFlags.Host && isFirstHostTNode);\n}\nfunction getNodeInjectorLView(nodeInjector) {\n  return nodeInjector._lView;\n}\nfunction getNodeInjectorTNode(nodeInjector) {\n  return nodeInjector._tNode;\n}\nvar NodeInjector = class {\n  _tNode;\n  _lView;\n  constructor(_tNode, _lView) {\n    this._tNode = _tNode;\n    this._lView = _lView;\n  }\n  get(token, notFoundValue, flags) {\n    return getOrCreateInjectable(this._tNode, this._lView, token, convertToBitFlags(flags), notFoundValue);\n  }\n};\nfunction createNodeInjector() {\n  return new NodeInjector(getCurrentTNode(), getLView());\n}\nfunction \\u0275\\u0275getInheritedFactory(type) {\n  return noSideEffects(() => {\n    const ownConstructor = type.prototype.constructor;\n    const ownFactory = ownConstructor[NG_FACTORY_DEF] || getFactoryOf(ownConstructor);\n    const objectPrototype = Object.prototype;\n    let parent = Object.getPrototypeOf(type.prototype).constructor;\n    while (parent && parent !== objectPrototype) {\n      const factory = parent[NG_FACTORY_DEF] || getFactoryOf(parent);\n      if (factory && factory !== ownFactory) {\n        return factory;\n      }\n      parent = Object.getPrototypeOf(parent);\n    }\n    return (t) => new t();\n  });\n}\nfunction getFactoryOf(type) {\n  if (isForwardRef(type)) {\n    return () => {\n      const factory = getFactoryOf(resolveForwardRef(type));\n      return factory && factory();\n    };\n  }\n  return getFactoryDef(type);\n}\nfunction lookupTokenUsingEmbeddedInjector(tNode, lView, token, flags, notFoundValue) {\n  let currentTNode = tNode;\n  let currentLView = lView;\n  while (currentTNode !== null && currentLView !== null && currentLView[FLAGS] & 2048 && !isRootView(currentLView)) {\n    ngDevMode && assertTNodeForLView(currentTNode, currentLView);\n    const nodeInjectorValue = lookupTokenUsingNodeInjector(currentTNode, currentLView, token, flags | InjectFlags.Self, NOT_FOUND2);\n    if (nodeInjectorValue !== NOT_FOUND2) {\n      return nodeInjectorValue;\n    }\n    let parentTNode = currentTNode.parent;\n    if (!parentTNode) {\n      const embeddedViewInjector = currentLView[EMBEDDED_VIEW_INJECTOR];\n      if (embeddedViewInjector) {\n        const embeddedViewInjectorValue = embeddedViewInjector.get(token, NOT_FOUND2, flags);\n        if (embeddedViewInjectorValue !== NOT_FOUND2) {\n          return embeddedViewInjectorValue;\n        }\n      }\n      parentTNode = getTNodeFromLView(currentLView);\n      currentLView = currentLView[DECLARATION_VIEW];\n    }\n    currentTNode = parentTNode;\n  }\n  return notFoundValue;\n}\nfunction getTNodeFromLView(lView) {\n  const tView = lView[TVIEW];\n  const tViewType = tView.type;\n  if (tViewType === 2) {\n    ngDevMode && assertDefined(tView.declTNode, \"Embedded TNodes should have declaration parents.\");\n    return tView.declTNode;\n  } else if (tViewType === 1) {\n    return lView[T_HOST];\n  }\n  return null;\n}\nfunction \\u0275\\u0275injectAttribute(attrNameToInject) {\n  return injectAttributeImpl(getCurrentTNode(), attrNameToInject);\n}\nvar Attribute = makeParamDecorator(\"Attribute\", (attributeName) => ({\n  attributeName,\n  __NG_ELEMENT_ID__: () => \\u0275\\u0275injectAttribute(attributeName)\n}));\nvar _reflect = null;\nfunction getReflect() {\n  return _reflect = _reflect || new ReflectionCapabilities();\n}\nfunction reflectDependencies(type) {\n  return convertDependencies(getReflect().parameters(type));\n}\nfunction convertDependencies(deps) {\n  return deps.map((dep) => reflectDependency(dep));\n}\nfunction reflectDependency(dep) {\n  const meta = {\n    token: null,\n    attribute: null,\n    host: false,\n    optional: false,\n    self: false,\n    skipSelf: false\n  };\n  if (Array.isArray(dep) && dep.length > 0) {\n    for (let j = 0; j < dep.length; j++) {\n      const param = dep[j];\n      if (param === void 0) {\n        continue;\n      }\n      const proto = Object.getPrototypeOf(param);\n      if (param instanceof Optional || proto.ngMetadataName === \"Optional\") {\n        meta.optional = true;\n      } else if (param instanceof SkipSelf || proto.ngMetadataName === \"SkipSelf\") {\n        meta.skipSelf = true;\n      } else if (param instanceof Self || proto.ngMetadataName === \"Self\") {\n        meta.self = true;\n      } else if (param instanceof Host || proto.ngMetadataName === \"Host\") {\n        meta.host = true;\n      } else if (param instanceof Inject) {\n        meta.token = param.token;\n      } else if (param instanceof Attribute) {\n        if (param.attributeName === void 0) {\n          throw new RuntimeError(204, ngDevMode && `Attribute name must be defined.`);\n        }\n        meta.attribute = param.attributeName;\n      } else {\n        meta.token = param;\n      }\n    }\n  } else if (dep === void 0 || Array.isArray(dep) && dep.length === 0) {\n    meta.token = null;\n  } else {\n    meta.token = dep;\n  }\n  return meta;\n}\nfunction compileInjectable(type, meta) {\n  let ngInjectableDef = null;\n  let ngFactoryDef = null;\n  if (!type.hasOwnProperty(NG_PROV_DEF)) {\n    Object.defineProperty(type, NG_PROV_DEF, {\n      get: () => {\n        if (ngInjectableDef === null) {\n          const compiler = getCompilerFacade({\n            usage: 0,\n            kind: \"injectable\",\n            type\n          });\n          ngInjectableDef = compiler.compileInjectable(angularCoreDiEnv, `ng:///${type.name}/\\u0275prov.js`, getInjectableMetadata(type, meta));\n        }\n        return ngInjectableDef;\n      }\n    });\n  }\n  if (!type.hasOwnProperty(NG_FACTORY_DEF)) {\n    Object.defineProperty(type, NG_FACTORY_DEF, {\n      get: () => {\n        if (ngFactoryDef === null) {\n          const compiler = getCompilerFacade({\n            usage: 0,\n            kind: \"injectable\",\n            type\n          });\n          ngFactoryDef = compiler.compileFactory(angularCoreDiEnv, `ng:///${type.name}/\\u0275fac.js`, {\n            name: type.name,\n            type,\n            typeArgumentCount: 0,\n            // In JIT mode types are not available nor used.\n            deps: reflectDependencies(type),\n            target: compiler.FactoryTarget.Injectable\n          });\n        }\n        return ngFactoryDef;\n      },\n      // Leave this configurable so that the factories from directives or pipes can take precedence.\n      configurable: true\n    });\n  }\n}\nvar USE_VALUE = getClosureSafeProperty({\n  provide: String,\n  useValue: getClosureSafeProperty\n});\nfunction isUseClassProvider(meta) {\n  return meta.useClass !== void 0;\n}\nfunction isUseValueProvider(meta) {\n  return USE_VALUE in meta;\n}\nfunction isUseFactoryProvider(meta) {\n  return meta.useFactory !== void 0;\n}\nfunction isUseExistingProvider(meta) {\n  return meta.useExisting !== void 0;\n}\nfunction getInjectableMetadata(type, srcMeta) {\n  const meta = srcMeta || {\n    providedIn: null\n  };\n  const compilerMeta = {\n    name: type.name,\n    type,\n    typeArgumentCount: 0,\n    providedIn: meta.providedIn\n  };\n  if ((isUseClassProvider(meta) || isUseFactoryProvider(meta)) && meta.deps !== void 0) {\n    compilerMeta.deps = convertDependencies(meta.deps);\n  }\n  if (isUseClassProvider(meta)) {\n    compilerMeta.useClass = meta.useClass;\n  } else if (isUseValueProvider(meta)) {\n    compilerMeta.useValue = meta.useValue;\n  } else if (isUseFactoryProvider(meta)) {\n    compilerMeta.useFactory = meta.useFactory;\n  } else if (isUseExistingProvider(meta)) {\n    compilerMeta.useExisting = meta.useExisting;\n  }\n  return compilerMeta;\n}\nvar Injectable = makeDecorator(\"Injectable\", void 0, void 0, void 0, (type, meta) => compileInjectable(type, meta));\nfunction createInjector(defType, parent = null, additionalProviders = null, name) {\n  const injector = createInjectorWithoutInjectorInstances(defType, parent, additionalProviders, name);\n  injector.resolveInjectorInitializers();\n  return injector;\n}\nfunction createInjectorWithoutInjectorInstances(defType, parent = null, additionalProviders = null, name, scopes = /* @__PURE__ */ new Set()) {\n  const providers = [additionalProviders || EMPTY_ARRAY, importProvidersFrom(defType)];\n  name = name || (typeof defType === \"object\" ? void 0 : stringify(defType));\n  return new R3Injector(providers, parent || getNullInjector(), name || null, scopes);\n}\nvar Injector = class _Injector {\n  static THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;\n  static NULL = new NullInjector();\n  static create(options, parent) {\n    if (Array.isArray(options)) {\n      return createInjector({\n        name: \"\"\n      }, parent, options, \"\");\n    } else {\n      const name = options.name ?? \"\";\n      return createInjector({\n        name\n      }, options.parent, options.providers, name);\n    }\n  }\n  /** @nocollapse */\n  static \\u0275prov = (\n    /** @pureOrBreakMyCode */\n    /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n      token: _Injector,\n      providedIn: \"any\",\n      factory: () => \\u0275\\u0275inject(INJECTOR$1)\n    })\n  );\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ELEMENT_ID__ = -1;\n};\nvar HOST_TAG_NAME = new InjectionToken(ngDevMode ? \"HOST_TAG_NAME\" : \"\");\nHOST_TAG_NAME.__NG_ELEMENT_ID__ = (flags) => {\n  const tNode = getCurrentTNode();\n  if (tNode === null) {\n    throw new RuntimeError(204, ngDevMode && \"HOST_TAG_NAME can only be injected in directives and components during construction time (in a class constructor or as a class field initializer)\");\n  }\n  if (tNode.type & 2) {\n    return tNode.value;\n  }\n  if (flags & InjectFlags.Optional) {\n    return null;\n  }\n  throw new RuntimeError(204, ngDevMode && `HOST_TAG_NAME was used on ${getDevModeNodeName(tNode)} which doesn't have an underlying element in the DOM. This is invalid, and so the dependency should be marked as optional.`);\n};\nfunction getDevModeNodeName(tNode) {\n  if (tNode.type & 8) {\n    return \"an <ng-container>\";\n  } else if (tNode.type & 4) {\n    return \"an <ng-template>\";\n  } else if (tNode.type & 128) {\n    return \"an @let declaration\";\n  } else {\n    return \"a node\";\n  }\n}\nvar SCHEDULE_IN_ROOT_ZONE_DEFAULT = false;\nvar DestroyRef = class {\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ELEMENT_ID__ = injectDestroyRef;\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ENV_ID__ = (injector) => injector;\n};\nvar NodeInjectorDestroyRef = class extends DestroyRef {\n  _lView;\n  constructor(_lView) {\n    super();\n    this._lView = _lView;\n  }\n  onDestroy(callback) {\n    storeLViewOnDestroy(this._lView, callback);\n    return () => removeLViewOnDestroy(this._lView, callback);\n  }\n};\nfunction injectDestroyRef() {\n  return new NodeInjectorDestroyRef(getLView());\n}\nvar ChangeDetectionScheduler = class {\n};\nvar ZONELESS_ENABLED = new InjectionToken(typeof ngDevMode === \"undefined\" || ngDevMode ? \"Zoneless enabled\" : \"\", {\n  providedIn: \"root\",\n  factory: () => false\n});\nvar PROVIDED_ZONELESS = new InjectionToken(typeof ngDevMode === \"undefined\" || ngDevMode ? \"Zoneless provided\" : \"\", {\n  providedIn: \"root\",\n  factory: () => false\n});\nvar ZONELESS_SCHEDULER_DISABLED = new InjectionToken(typeof ngDevMode === \"undefined\" || ngDevMode ? \"scheduler disabled\" : \"\");\nvar SCHEDULE_IN_ROOT_ZONE = new InjectionToken(typeof ngDevMode === \"undefined\" || ngDevMode ? \"run changes outside zone in root\" : \"\");\nvar PendingTasksInternal = class _PendingTasksInternal {\n  taskId = 0;\n  pendingTasks = /* @__PURE__ */ new Set();\n  get _hasPendingTasks() {\n    return this.hasPendingTasks.value;\n  }\n  hasPendingTasks = new BehaviorSubject(false);\n  add() {\n    if (!this._hasPendingTasks) {\n      this.hasPendingTasks.next(true);\n    }\n    const taskId = this.taskId++;\n    this.pendingTasks.add(taskId);\n    return taskId;\n  }\n  has(taskId) {\n    return this.pendingTasks.has(taskId);\n  }\n  remove(taskId) {\n    this.pendingTasks.delete(taskId);\n    if (this.pendingTasks.size === 0 && this._hasPendingTasks) {\n      this.hasPendingTasks.next(false);\n    }\n  }\n  ngOnDestroy() {\n    this.pendingTasks.clear();\n    if (this._hasPendingTasks) {\n      this.hasPendingTasks.next(false);\n    }\n  }\n  /** @nocollapse */\n  static \\u0275prov = (\n    /** @pureOrBreakMyCode */\n    /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n      token: _PendingTasksInternal,\n      providedIn: \"root\",\n      factory: () => new _PendingTasksInternal()\n    })\n  );\n};\nvar PendingTasks = class _PendingTasks {\n  internalPendingTasks = inject(PendingTasksInternal);\n  scheduler = inject(ChangeDetectionScheduler);\n  /**\n   * Adds a new task that should block application's stability.\n   * @returns A cleanup function that removes a task when called.\n   */\n  add() {\n    const taskId = this.internalPendingTasks.add();\n    return () => {\n      if (!this.internalPendingTasks.has(taskId)) {\n        return;\n      }\n      this.scheduler.notify(\n        11\n        /* NotificationSource.PendingTaskRemoved */\n      );\n      this.internalPendingTasks.remove(taskId);\n    };\n  }\n  /**\n   * Runs an asynchronous function and blocks the application's stability until the function completes.\n   *\n   * ```ts\n   * pendingTasks.run(async () => {\n   *   const userData = await fetch('/api/user');\n   *   this.userData.set(userData);\n   * });\n   * ```\n   *\n   * Application stability is at least delayed until the next tick after the `run` method resolves\n   * so it is safe to make additional updates to application state that would require UI synchronization:\n   *\n   * ```ts\n   * const userData = await pendingTasks.run(() => fetch('/api/user'));\n   * this.userData.set(userData);\n   * ```\n   *\n   * @param fn The asynchronous function to execute\n   */\n  run(fn) {\n    return __async(this, null, function* () {\n      const removeTask = this.add();\n      try {\n        return yield fn();\n      } finally {\n        removeTask();\n      }\n    });\n  }\n  /** @nocollapse */\n  static \\u0275prov = (\n    /** @pureOrBreakMyCode */\n    /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n      token: _PendingTasks,\n      providedIn: \"root\",\n      factory: () => new _PendingTasks()\n    })\n  );\n};\nvar EventEmitter_ = class extends Subject {\n  // tslint:disable-next-line:require-internal-with-underscore\n  __isAsync;\n  destroyRef = void 0;\n  pendingTasks = void 0;\n  constructor(isAsync = false) {\n    super();\n    this.__isAsync = isAsync;\n    if (isInInjectionContext()) {\n      this.destroyRef = inject(DestroyRef, {\n        optional: true\n      }) ?? void 0;\n      this.pendingTasks = inject(PendingTasksInternal, {\n        optional: true\n      }) ?? void 0;\n    }\n  }\n  emit(value) {\n    const prevConsumer = setActiveConsumer(null);\n    try {\n      super.next(value);\n    } finally {\n      setActiveConsumer(prevConsumer);\n    }\n  }\n  subscribe(observerOrNext, error, complete) {\n    let nextFn = observerOrNext;\n    let errorFn = error || (() => null);\n    let completeFn = complete;\n    if (observerOrNext && typeof observerOrNext === \"object\") {\n      const observer = observerOrNext;\n      nextFn = observer.next?.bind(observer);\n      errorFn = observer.error?.bind(observer);\n      completeFn = observer.complete?.bind(observer);\n    }\n    if (this.__isAsync) {\n      errorFn = this.wrapInTimeout(errorFn);\n      if (nextFn) {\n        nextFn = this.wrapInTimeout(nextFn);\n      }\n      if (completeFn) {\n        completeFn = this.wrapInTimeout(completeFn);\n      }\n    }\n    const sink = super.subscribe({\n      next: nextFn,\n      error: errorFn,\n      complete: completeFn\n    });\n    if (observerOrNext instanceof Subscription) {\n      observerOrNext.add(sink);\n    }\n    return sink;\n  }\n  wrapInTimeout(fn) {\n    return (value) => {\n      const taskId = this.pendingTasks?.add();\n      setTimeout(() => {\n        fn(value);\n        if (taskId !== void 0) {\n          this.pendingTasks?.remove(taskId);\n        }\n      });\n    };\n  }\n};\nvar EventEmitter = EventEmitter_;\nfunction noop2(...args) {\n}\nfunction scheduleCallbackWithRafRace(callback) {\n  let timeoutId;\n  let animationFrameId;\n  function cleanup() {\n    callback = noop2;\n    try {\n      if (animationFrameId !== void 0 && typeof cancelAnimationFrame === \"function\") {\n        cancelAnimationFrame(animationFrameId);\n      }\n      if (timeoutId !== void 0) {\n        clearTimeout(timeoutId);\n      }\n    } catch {\n    }\n  }\n  timeoutId = setTimeout(() => {\n    callback();\n    cleanup();\n  });\n  if (typeof requestAnimationFrame === \"function\") {\n    animationFrameId = requestAnimationFrame(() => {\n      callback();\n      cleanup();\n    });\n  }\n  return () => cleanup();\n}\nfunction scheduleCallbackWithMicrotask(callback) {\n  queueMicrotask(() => callback());\n  return () => {\n    callback = noop2;\n  };\n}\nvar AsyncStackTaggingZoneSpec = class {\n  createTask;\n  constructor(namePrefix, consoleAsyncStackTaggingImpl = console) {\n    this.name = \"asyncStackTagging for \" + namePrefix;\n    this.createTask = consoleAsyncStackTaggingImpl?.createTask ?? (() => null);\n  }\n  // ZoneSpec implementation below.\n  name;\n  onScheduleTask(delegate, _current, target, task) {\n    task.consoleTask = this.createTask(`Zone - ${task.source || task.type}`);\n    return delegate.scheduleTask(target, task);\n  }\n  onInvokeTask(delegate, _currentZone, targetZone, task, applyThis, applyArgs) {\n    let ret;\n    if (task.consoleTask) {\n      ret = task.consoleTask.run(() => delegate.invokeTask(targetZone, task, applyThis, applyArgs));\n    } else {\n      ret = delegate.invokeTask(targetZone, task, applyThis, applyArgs);\n    }\n    return ret;\n  }\n};\nvar isAngularZoneProperty = \"isAngularZone\";\nvar angularZoneInstanceIdProperty = isAngularZoneProperty + \"_ID\";\nvar ngZoneInstanceId = 0;\nvar NgZone = class _NgZone {\n  hasPendingMacrotasks = false;\n  hasPendingMicrotasks = false;\n  /**\n   * Whether there are no outstanding microtasks or macrotasks.\n   */\n  isStable = true;\n  /**\n   * Notifies when code enters Angular Zone. This gets fired first on VM Turn.\n   */\n  onUnstable = new EventEmitter(false);\n  /**\n   * Notifies when there is no more microtasks enqueued in the current VM Turn.\n   * This is a hint for Angular to do change detection, which may enqueue more microtasks.\n   * For this reason this event can fire multiple times per VM Turn.\n   */\n  onMicrotaskEmpty = new EventEmitter(false);\n  /**\n   * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which\n   * implies we are about to relinquish VM turn.\n   * This event gets called just once.\n   */\n  onStable = new EventEmitter(false);\n  /**\n   * Notifies that an error has been delivered.\n   */\n  onError = new EventEmitter(false);\n  constructor(options) {\n    const {\n      enableLongStackTrace = false,\n      shouldCoalesceEventChangeDetection = false,\n      shouldCoalesceRunChangeDetection = false,\n      scheduleInRootZone = SCHEDULE_IN_ROOT_ZONE_DEFAULT\n    } = options;\n    if (typeof Zone == \"undefined\") {\n      throw new RuntimeError(908, ngDevMode && `In this configuration Angular requires Zone.js`);\n    }\n    Zone.assertZonePatched();\n    const self = this;\n    self._nesting = 0;\n    self._outer = self._inner = Zone.current;\n    if (ngDevMode) {\n      self._inner = self._inner.fork(new AsyncStackTaggingZoneSpec(\"Angular\"));\n    }\n    if (Zone[\"TaskTrackingZoneSpec\"]) {\n      self._inner = self._inner.fork(new Zone[\"TaskTrackingZoneSpec\"]());\n    }\n    if (enableLongStackTrace && Zone[\"longStackTraceZoneSpec\"]) {\n      self._inner = self._inner.fork(Zone[\"longStackTraceZoneSpec\"]);\n    }\n    self.shouldCoalesceEventChangeDetection = !shouldCoalesceRunChangeDetection && shouldCoalesceEventChangeDetection;\n    self.shouldCoalesceRunChangeDetection = shouldCoalesceRunChangeDetection;\n    self.callbackScheduled = false;\n    self.scheduleInRootZone = scheduleInRootZone;\n    forkInnerZoneWithAngularBehavior(self);\n  }\n  /**\n    This method checks whether the method call happens within an Angular Zone instance.\n  */\n  static isInAngularZone() {\n    return typeof Zone !== \"undefined\" && Zone.current.get(isAngularZoneProperty) === true;\n  }\n  /**\n    Assures that the method is called within the Angular Zone, otherwise throws an error.\n  */\n  static assertInAngularZone() {\n    if (!_NgZone.isInAngularZone()) {\n      throw new RuntimeError(909, ngDevMode && \"Expected to be in Angular Zone, but it is not!\");\n    }\n  }\n  /**\n    Assures that the method is called outside of the Angular Zone, otherwise throws an error.\n  */\n  static assertNotInAngularZone() {\n    if (_NgZone.isInAngularZone()) {\n      throw new RuntimeError(909, ngDevMode && \"Expected to not be in Angular Zone, but it is!\");\n    }\n  }\n  /**\n   * Executes the `fn` function synchronously within the Angular zone and returns value returned by\n   * the function.\n   *\n   * Running functions via `run` allows you to reenter Angular zone from a task that was executed\n   * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * within the Angular zone.\n   *\n   * If a synchronous error happens it will be rethrown and not reported via `onError`.\n   */\n  run(fn, applyThis, applyArgs) {\n    return this._inner.run(fn, applyThis, applyArgs);\n  }\n  /**\n   * Executes the `fn` function synchronously within the Angular zone as a task and returns value\n   * returned by the function.\n   *\n   * Running functions via `runTask` allows you to reenter Angular zone from a task that was executed\n   * outside of the Angular zone (typically started via {@link #runOutsideAngular}).\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * within the Angular zone.\n   *\n   * If a synchronous error happens it will be rethrown and not reported via `onError`.\n   */\n  runTask(fn, applyThis, applyArgs, name) {\n    const zone = this._inner;\n    const task = zone.scheduleEventTask(\"NgZoneEvent: \" + name, fn, EMPTY_PAYLOAD, noop2, noop2);\n    try {\n      return zone.runTask(task, applyThis, applyArgs);\n    } finally {\n      zone.cancelTask(task);\n    }\n  }\n  /**\n   * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not\n   * rethrown.\n   */\n  runGuarded(fn, applyThis, applyArgs) {\n    return this._inner.runGuarded(fn, applyThis, applyArgs);\n  }\n  /**\n   * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by\n   * the function.\n   *\n   * Running functions via {@link #runOutsideAngular} allows you to escape Angular's zone and do\n   * work that\n   * doesn't trigger Angular change-detection or is subject to Angular's error handling.\n   *\n   * Any future tasks or microtasks scheduled from within this function will continue executing from\n   * outside of the Angular zone.\n   *\n   * Use {@link #run} to reenter the Angular zone and do work that updates the application model.\n   */\n  runOutsideAngular(fn) {\n    return this._outer.run(fn);\n  }\n};\nvar EMPTY_PAYLOAD = {};\nfunction checkStable(zone) {\n  if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {\n    try {\n      zone._nesting++;\n      zone.onMicrotaskEmpty.emit(null);\n    } finally {\n      zone._nesting--;\n      if (!zone.hasPendingMicrotasks) {\n        try {\n          zone.runOutsideAngular(() => zone.onStable.emit(null));\n        } finally {\n          zone.isStable = true;\n        }\n      }\n    }\n  }\n}\nfunction delayChangeDetectionForEvents(zone) {\n  if (zone.isCheckStableRunning || zone.callbackScheduled) {\n    return;\n  }\n  zone.callbackScheduled = true;\n  function scheduleCheckStable() {\n    scheduleCallbackWithRafRace(() => {\n      zone.callbackScheduled = false;\n      updateMicroTaskStatus(zone);\n      zone.isCheckStableRunning = true;\n      checkStable(zone);\n      zone.isCheckStableRunning = false;\n    });\n  }\n  if (zone.scheduleInRootZone) {\n    Zone.root.run(() => {\n      scheduleCheckStable();\n    });\n  } else {\n    zone._outer.run(() => {\n      scheduleCheckStable();\n    });\n  }\n  updateMicroTaskStatus(zone);\n}\nfunction forkInnerZoneWithAngularBehavior(zone) {\n  const delayChangeDetectionForEventsDelegate = () => {\n    delayChangeDetectionForEvents(zone);\n  };\n  const instanceId = ngZoneInstanceId++;\n  zone._inner = zone._inner.fork({\n    name: \"angular\",\n    properties: {\n      [isAngularZoneProperty]: true,\n      [angularZoneInstanceIdProperty]: instanceId,\n      [angularZoneInstanceIdProperty + instanceId]: true\n    },\n    onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {\n      if (shouldBeIgnoredByZone(applyArgs)) {\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n      }\n      try {\n        onEnter(zone);\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n      } finally {\n        if (zone.shouldCoalesceEventChangeDetection && task.type === \"eventTask\" || zone.shouldCoalesceRunChangeDetection) {\n          delayChangeDetectionForEventsDelegate();\n        }\n        onLeave(zone);\n      }\n    },\n    onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source) => {\n      try {\n        onEnter(zone);\n        return delegate.invoke(target, callback, applyThis, applyArgs, source);\n      } finally {\n        if (zone.shouldCoalesceRunChangeDetection && // Do not delay change detection when the task is the scheduler's tick.\n        // We need to synchronously trigger the stability logic so that the\n        // zone-based scheduler can prevent a duplicate ApplicationRef.tick\n        // by first checking if the scheduler tick is running. This does seem a bit roundabout,\n        // but we _do_ still want to trigger all the correct events when we exit the zone.run\n        // (`onMicrotaskEmpty` and `onStable` _should_ emit; developers can have code which\n        // relies on these events happening after change detection runs).\n        // Note: `zone.callbackScheduled` is already in delayChangeDetectionForEventsDelegate\n        // but is added here as well to prevent reads of applyArgs when not necessary\n        !zone.callbackScheduled && !isSchedulerTick(applyArgs)) {\n          delayChangeDetectionForEventsDelegate();\n        }\n        onLeave(zone);\n      }\n    },\n    onHasTask: (delegate, current, target, hasTaskState) => {\n      delegate.hasTask(target, hasTaskState);\n      if (current === target) {\n        if (hasTaskState.change == \"microTask\") {\n          zone._hasPendingMicrotasks = hasTaskState.microTask;\n          updateMicroTaskStatus(zone);\n          checkStable(zone);\n        } else if (hasTaskState.change == \"macroTask\") {\n          zone.hasPendingMacrotasks = hasTaskState.macroTask;\n        }\n      }\n    },\n    onHandleError: (delegate, current, target, error) => {\n      delegate.handleError(target, error);\n      zone.runOutsideAngular(() => zone.onError.emit(error));\n      return false;\n    }\n  });\n}\nfunction updateMicroTaskStatus(zone) {\n  if (zone._hasPendingMicrotasks || (zone.shouldCoalesceEventChangeDetection || zone.shouldCoalesceRunChangeDetection) && zone.callbackScheduled === true) {\n    zone.hasPendingMicrotasks = true;\n  } else {\n    zone.hasPendingMicrotasks = false;\n  }\n}\nfunction onEnter(zone) {\n  zone._nesting++;\n  if (zone.isStable) {\n    zone.isStable = false;\n    zone.onUnstable.emit(null);\n  }\n}\nfunction onLeave(zone) {\n  zone._nesting--;\n  checkStable(zone);\n}\nvar NoopNgZone = class {\n  hasPendingMicrotasks = false;\n  hasPendingMacrotasks = false;\n  isStable = true;\n  onUnstable = new EventEmitter();\n  onMicrotaskEmpty = new EventEmitter();\n  onStable = new EventEmitter();\n  onError = new EventEmitter();\n  run(fn, applyThis, applyArgs) {\n    return fn.apply(applyThis, applyArgs);\n  }\n  runGuarded(fn, applyThis, applyArgs) {\n    return fn.apply(applyThis, applyArgs);\n  }\n  runOutsideAngular(fn) {\n    return fn();\n  }\n  runTask(fn, applyThis, applyArgs, name) {\n    return fn.apply(applyThis, applyArgs);\n  }\n};\nfunction shouldBeIgnoredByZone(applyArgs) {\n  return hasApplyArgsData(applyArgs, \"__ignore_ng_zone__\");\n}\nfunction isSchedulerTick(applyArgs) {\n  return hasApplyArgsData(applyArgs, \"__scheduler_tick__\");\n}\nfunction hasApplyArgsData(applyArgs, key) {\n  if (!Array.isArray(applyArgs)) {\n    return false;\n  }\n  if (applyArgs.length !== 1) {\n    return false;\n  }\n  return applyArgs[0]?.data?.[key] === true;\n}\nfunction getNgZone(ngZoneToUse = \"zone.js\", options) {\n  if (ngZoneToUse === \"noop\") {\n    return new NoopNgZone();\n  }\n  if (ngZoneToUse === \"zone.js\") {\n    return new NgZone(options);\n  }\n  return ngZoneToUse;\n}\nvar ErrorHandler = class {\n  /**\n   * @internal\n   */\n  _console = console;\n  handleError(error) {\n    this._console.error(\"ERROR\", error);\n  }\n};\nvar INTERNAL_APPLICATION_ERROR_HANDLER = new InjectionToken(typeof ngDevMode === \"undefined\" || ngDevMode ? \"internal error handler\" : \"\", {\n  providedIn: \"root\",\n  factory: () => {\n    const zone = inject(NgZone);\n    const userErrorHandler = inject(ErrorHandler);\n    return (e) => zone.runOutsideAngular(() => userErrorHandler.handleError(e));\n  }\n});\nvar OutputEmitterRef = class {\n  destroyed = false;\n  listeners = null;\n  errorHandler = inject(ErrorHandler, {\n    optional: true\n  });\n  /** @internal */\n  destroyRef = inject(DestroyRef);\n  constructor() {\n    this.destroyRef.onDestroy(() => {\n      this.destroyed = true;\n      this.listeners = null;\n    });\n  }\n  subscribe(callback) {\n    if (this.destroyed) {\n      throw new RuntimeError(953, ngDevMode && \"Unexpected subscription to destroyed `OutputRef`. The owning directive/component is destroyed.\");\n    }\n    (this.listeners ??= []).push(callback);\n    return {\n      unsubscribe: () => {\n        const idx = this.listeners?.indexOf(callback);\n        if (idx !== void 0 && idx !== -1) {\n          this.listeners?.splice(idx, 1);\n        }\n      }\n    };\n  }\n  /** Emits a new value to the output. */\n  emit(value) {\n    if (this.destroyed) {\n      console.warn(formatRuntimeError(953, ngDevMode && \"Unexpected emit for destroyed `OutputRef`. The owning directive/component is destroyed.\"));\n      return;\n    }\n    if (this.listeners === null) {\n      return;\n    }\n    const previousConsumer = setActiveConsumer(null);\n    try {\n      for (const listenerFn of this.listeners) {\n        try {\n          listenerFn(value);\n        } catch (err) {\n          this.errorHandler?.handleError(err);\n        }\n      }\n    } finally {\n      setActiveConsumer(previousConsumer);\n    }\n  }\n};\nfunction inputFunction(initialValue, opts) {\n  ngDevMode && assertInInjectionContext(input);\n  return createInputSignal(initialValue, opts);\n}\nfunction inputRequiredFunction(opts) {\n  ngDevMode && assertInInjectionContext(input);\n  return createInputSignal(REQUIRED_UNSET_VALUE, opts);\n}\nvar input = (() => {\n  inputFunction.required = inputRequiredFunction;\n  return inputFunction;\n})();\nfunction injectElementRef() {\n  return createElementRef(getCurrentTNode(), getLView());\n}\nfunction createElementRef(tNode, lView) {\n  return new ElementRef(getNativeByTNode(tNode, lView));\n}\nvar ElementRef = class {\n  /**\n   * <div class=\"callout is-critical\">\n   *   <header>Use with caution</header>\n   *   <p>\n   *    Use this API as the last resort when direct access to DOM is needed. Use templating and\n   *    data-binding provided by Angular instead. Alternatively you can take a look at\n   *    {@link Renderer2} which provides an API that can be safely used.\n   *   </p>\n   * </div>\n   */\n  nativeElement;\n  constructor(nativeElement) {\n    this.nativeElement = nativeElement;\n  }\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ELEMENT_ID__ = injectElementRef;\n};\nfunction unwrapElementRef(value) {\n  return value instanceof ElementRef ? value.nativeElement : value;\n}\nfunction isSignal(value) {\n  return typeof value === \"function\" && value[SIGNAL] !== void 0;\n}\nfunction signal(initialValue, options) {\n  const signalFn = createSignal(initialValue, options?.equal);\n  const node = signalFn[SIGNAL];\n  signalFn.set = (newValue) => signalSetFn(node, newValue);\n  signalFn.update = (updateFn) => signalUpdateFn(node, updateFn);\n  signalFn.asReadonly = signalAsReadonlyFn.bind(signalFn);\n  if (ngDevMode) {\n    signalFn.toString = () => `[Signal: ${signalFn()}]`;\n    node.debugName = options?.debugName;\n  }\n  return signalFn;\n}\nfunction signalAsReadonlyFn() {\n  const node = this[SIGNAL];\n  if (node.readonlyFn === void 0) {\n    const readonlyFn = () => this();\n    readonlyFn[SIGNAL] = node;\n    node.readonlyFn = readonlyFn;\n  }\n  return node.readonlyFn;\n}\nfunction isWritableSignal(value) {\n  return isSignal(value) && typeof value.set === \"function\";\n}\nfunction symbolIterator() {\n  return this._results[Symbol.iterator]();\n}\nvar QueryList = class {\n  _emitDistinctChangesOnly;\n  dirty = true;\n  _onDirty = void 0;\n  _results = [];\n  _changesDetected = false;\n  _changes = void 0;\n  length = 0;\n  first = void 0;\n  last = void 0;\n  /**\n   * Returns `Observable` of `QueryList` notifying the subscriber of changes.\n   */\n  get changes() {\n    return this._changes ??= new Subject();\n  }\n  /**\n   * @param emitDistinctChangesOnly Whether `QueryList.changes` should fire only when actual change\n   *     has occurred. Or if it should fire when query is recomputed. (recomputing could resolve in\n   *     the same result)\n   */\n  constructor(_emitDistinctChangesOnly = false) {\n    this._emitDistinctChangesOnly = _emitDistinctChangesOnly;\n  }\n  /**\n   * Returns the QueryList entry at `index`.\n   */\n  get(index) {\n    return this._results[index];\n  }\n  /**\n   * See\n   * [Array.map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)\n   */\n  map(fn) {\n    return this._results.map(fn);\n  }\n  filter(fn) {\n    return this._results.filter(fn);\n  }\n  /**\n   * See\n   * [Array.find](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find)\n   */\n  find(fn) {\n    return this._results.find(fn);\n  }\n  /**\n   * See\n   * [Array.reduce](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)\n   */\n  reduce(fn, init) {\n    return this._results.reduce(fn, init);\n  }\n  /**\n   * See\n   * [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)\n   */\n  forEach(fn) {\n    this._results.forEach(fn);\n  }\n  /**\n   * See\n   * [Array.some](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some)\n   */\n  some(fn) {\n    return this._results.some(fn);\n  }\n  /**\n   * Returns a copy of the internal results list as an Array.\n   */\n  toArray() {\n    return this._results.slice();\n  }\n  toString() {\n    return this._results.toString();\n  }\n  /**\n   * Updates the stored data of the query list, and resets the `dirty` flag to `false`, so that\n   * on change detection, it will not notify of changes to the queries, unless a new change\n   * occurs.\n   *\n   * @param resultsTree The query results to store\n   * @param identityAccessor Optional function for extracting stable object identity from a value\n   *    in the array. This function is executed for each element of the query result list while\n   *    comparing current query list with the new one (provided as a first argument of the `reset`\n   *    function) to detect if the lists are different. If the function is not provided, elements\n   *    are compared as is (without any pre-processing).\n   */\n  reset(resultsTree, identityAccessor) {\n    this.dirty = false;\n    const newResultFlat = flatten(resultsTree);\n    if (this._changesDetected = !arrayEquals(this._results, newResultFlat, identityAccessor)) {\n      this._results = newResultFlat;\n      this.length = newResultFlat.length;\n      this.last = newResultFlat[this.length - 1];\n      this.first = newResultFlat[0];\n    }\n  }\n  /**\n   * Triggers a change event by emitting on the `changes` {@link EventEmitter}.\n   */\n  notifyOnChanges() {\n    if (this._changes !== void 0 && (this._changesDetected || !this._emitDistinctChangesOnly)) this._changes.next(this);\n  }\n  /** @internal */\n  onDirty(cb) {\n    this._onDirty = cb;\n  }\n  /** internal */\n  setDirty() {\n    this.dirty = true;\n    this._onDirty?.();\n  }\n  /** internal */\n  destroy() {\n    if (this._changes !== void 0) {\n      this._changes.complete();\n      this._changes.unsubscribe();\n    }\n  }\n  [Symbol.iterator] = /* @__PURE__ */ (() => symbolIterator)();\n};\nfunction hasInSkipHydrationBlockFlag(tNode) {\n  return (tNode.flags & 128) === 128;\n}\nvar ChangeDetectionStrategy;\n(function(ChangeDetectionStrategy2) {\n  ChangeDetectionStrategy2[ChangeDetectionStrategy2[\"OnPush\"] = 0] = \"OnPush\";\n  ChangeDetectionStrategy2[ChangeDetectionStrategy2[\"Default\"] = 1] = \"Default\";\n})(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));\nvar TRACKED_LVIEWS = /* @__PURE__ */ new Map();\nvar uniqueIdCounter = 0;\nfunction getUniqueLViewId() {\n  return uniqueIdCounter++;\n}\nfunction registerLView(lView) {\n  ngDevMode && assertNumber(lView[ID], \"LView must have an ID in order to be registered\");\n  TRACKED_LVIEWS.set(lView[ID], lView);\n}\nfunction getLViewById(id) {\n  ngDevMode && assertNumber(id, \"ID used for LView lookup must be a number\");\n  return TRACKED_LVIEWS.get(id) || null;\n}\nfunction unregisterLView(lView) {\n  ngDevMode && assertNumber(lView[ID], \"Cannot stop tracking an LView that does not have an ID\");\n  TRACKED_LVIEWS.delete(lView[ID]);\n}\nfunction getTrackedLViews() {\n  return TRACKED_LVIEWS;\n}\nvar LContext = class {\n  lViewId;\n  nodeIndex;\n  native;\n  /**\n   * The instance of the Component node.\n   */\n  component;\n  /**\n   * The list of active directives that exist on this element.\n   */\n  directives;\n  /**\n   * The map of local references (local reference name => element or directive instance) that\n   * exist on this element.\n   */\n  localRefs;\n  /** Component's parent view data. */\n  get lView() {\n    return getLViewById(this.lViewId);\n  }\n  constructor(lViewId, nodeIndex, native) {\n    this.lViewId = lViewId;\n    this.nodeIndex = nodeIndex;\n    this.native = native;\n  }\n};\nfunction getLContext(target) {\n  let mpValue = readPatchedData(target);\n  if (mpValue) {\n    if (isLView(mpValue)) {\n      const lView = mpValue;\n      let nodeIndex;\n      let component = void 0;\n      let directives = void 0;\n      if (isComponentInstance(target)) {\n        nodeIndex = findViaComponent(lView, target);\n        if (nodeIndex == -1) {\n          throw new Error(\"The provided component was not found in the application\");\n        }\n        component = target;\n      } else if (isDirectiveInstance(target)) {\n        nodeIndex = findViaDirective(lView, target);\n        if (nodeIndex == -1) {\n          throw new Error(\"The provided directive was not found in the application\");\n        }\n        directives = getDirectivesAtNodeIndex(nodeIndex, lView);\n      } else {\n        nodeIndex = findViaNativeElement(lView, target);\n        if (nodeIndex == -1) {\n          return null;\n        }\n      }\n      const native = unwrapRNode(lView[nodeIndex]);\n      const existingCtx = readPatchedData(native);\n      const context2 = existingCtx && !Array.isArray(existingCtx) ? existingCtx : createLContext(lView, nodeIndex, native);\n      if (component && context2.component === void 0) {\n        context2.component = component;\n        attachPatchData(context2.component, context2);\n      }\n      if (directives && context2.directives === void 0) {\n        context2.directives = directives;\n        for (let i = 0; i < directives.length; i++) {\n          attachPatchData(directives[i], context2);\n        }\n      }\n      attachPatchData(context2.native, context2);\n      mpValue = context2;\n    }\n  } else {\n    const rElement = target;\n    ngDevMode && assertDomNode(rElement);\n    let parent = rElement;\n    while (parent = parent.parentNode) {\n      const parentContext = readPatchedData(parent);\n      if (parentContext) {\n        const lView = Array.isArray(parentContext) ? parentContext : parentContext.lView;\n        if (!lView) {\n          return null;\n        }\n        const index = findViaNativeElement(lView, rElement);\n        if (index >= 0) {\n          const native = unwrapRNode(lView[index]);\n          const context2 = createLContext(lView, index, native);\n          attachPatchData(native, context2);\n          mpValue = context2;\n          break;\n        }\n      }\n    }\n  }\n  return mpValue || null;\n}\nfunction createLContext(lView, nodeIndex, native) {\n  return new LContext(lView[ID], nodeIndex, native);\n}\nfunction getComponentViewByInstance(componentInstance) {\n  let patchedData = readPatchedData(componentInstance);\n  let lView;\n  if (isLView(patchedData)) {\n    const contextLView = patchedData;\n    const nodeIndex = findViaComponent(contextLView, componentInstance);\n    lView = getComponentLViewByIndex(nodeIndex, contextLView);\n    const context2 = createLContext(contextLView, nodeIndex, lView[HOST]);\n    context2.component = componentInstance;\n    attachPatchData(componentInstance, context2);\n    attachPatchData(context2.native, context2);\n  } else {\n    const context2 = patchedData;\n    const contextLView = context2.lView;\n    ngDevMode && assertLView(contextLView);\n    lView = getComponentLViewByIndex(context2.nodeIndex, contextLView);\n  }\n  return lView;\n}\nvar MONKEY_PATCH_KEY_NAME = \"__ngContext__\";\nfunction attachPatchData(target, data) {\n  ngDevMode && assertDefined(target, \"Target expected\");\n  if (isLView(data)) {\n    target[MONKEY_PATCH_KEY_NAME] = data[ID];\n    registerLView(data);\n  } else {\n    target[MONKEY_PATCH_KEY_NAME] = data;\n  }\n}\nfunction readPatchedData(target) {\n  ngDevMode && assertDefined(target, \"Target expected\");\n  const data = target[MONKEY_PATCH_KEY_NAME];\n  return typeof data === \"number\" ? getLViewById(data) : data || null;\n}\nfunction readPatchedLView(target) {\n  const value = readPatchedData(target);\n  if (value) {\n    return isLView(value) ? value : value.lView;\n  }\n  return null;\n}\nfunction isComponentInstance(instance) {\n  return instance && instance.constructor && instance.constructor.\\u0275cmp;\n}\nfunction isDirectiveInstance(instance) {\n  return instance && instance.constructor && instance.constructor.\\u0275dir;\n}\nfunction findViaNativeElement(lView, target) {\n  const tView = lView[TVIEW];\n  for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {\n    if (unwrapRNode(lView[i]) === target) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction traverseNextElement(tNode) {\n  if (tNode.child) {\n    return tNode.child;\n  } else if (tNode.next) {\n    return tNode.next;\n  } else {\n    while (tNode.parent && !tNode.parent.next) {\n      tNode = tNode.parent;\n    }\n    return tNode.parent && tNode.parent.next;\n  }\n}\nfunction findViaComponent(lView, componentInstance) {\n  const componentIndices = lView[TVIEW].components;\n  if (componentIndices) {\n    for (let i = 0; i < componentIndices.length; i++) {\n      const elementComponentIndex = componentIndices[i];\n      const componentView = getComponentLViewByIndex(elementComponentIndex, lView);\n      if (componentView[CONTEXT] === componentInstance) {\n        return elementComponentIndex;\n      }\n    }\n  } else {\n    const rootComponentView = getComponentLViewByIndex(HEADER_OFFSET, lView);\n    const rootComponent = rootComponentView[CONTEXT];\n    if (rootComponent === componentInstance) {\n      return HEADER_OFFSET;\n    }\n  }\n  return -1;\n}\nfunction findViaDirective(lView, directiveInstance) {\n  let tNode = lView[TVIEW].firstChild;\n  while (tNode) {\n    const directiveIndexStart = tNode.directiveStart;\n    const directiveIndexEnd = tNode.directiveEnd;\n    for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {\n      if (lView[i] === directiveInstance) {\n        return tNode.index;\n      }\n    }\n    tNode = traverseNextElement(tNode);\n  }\n  return -1;\n}\nfunction getDirectivesAtNodeIndex(nodeIndex, lView) {\n  const tNode = lView[TVIEW].data[nodeIndex];\n  if (tNode.directiveStart === 0) return EMPTY_ARRAY;\n  const results = [];\n  for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {\n    const directiveInstance = lView[i];\n    if (!isComponentInstance(directiveInstance)) {\n      results.push(directiveInstance);\n    }\n  }\n  return results;\n}\nfunction getComponentAtNodeIndex(nodeIndex, lView) {\n  const tNode = lView[TVIEW].data[nodeIndex];\n  return isComponentHost(tNode) ? lView[tNode.directiveStart + tNode.componentOffset] : null;\n}\nfunction getRootView(componentOrLView) {\n  ngDevMode && assertDefined(componentOrLView, \"component\");\n  let lView = isLView(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView);\n  while (lView && !isRootView(lView)) {\n    lView = getLViewParent(lView);\n  }\n  ngDevMode && assertLView(lView);\n  return lView;\n}\nfunction getRootContext(viewOrComponent) {\n  const rootView = getRootView(viewOrComponent);\n  ngDevMode && assertDefined(rootView[CONTEXT], \"Root view has no context. Perhaps it is disconnected?\");\n  return rootView[CONTEXT];\n}\nfunction getFirstLContainer(lView) {\n  return getNearestLContainer(lView[CHILD_HEAD]);\n}\nfunction getNextLContainer(container) {\n  return getNearestLContainer(container[NEXT]);\n}\nfunction getNearestLContainer(viewOrContainer) {\n  while (viewOrContainer !== null && !isLContainer(viewOrContainer)) {\n    viewOrContainer = viewOrContainer[NEXT];\n  }\n  return viewOrContainer;\n}\nfunction getComponent(element) {\n  ngDevMode && assertDomElement(element);\n  const context2 = getLContext(element);\n  if (context2 === null) return null;\n  if (context2.component === void 0) {\n    const lView = context2.lView;\n    if (lView === null) {\n      return null;\n    }\n    context2.component = getComponentAtNodeIndex(context2.nodeIndex, lView);\n  }\n  return context2.component;\n}\nfunction getContext(element) {\n  assertDomElement(element);\n  const context2 = getLContext(element);\n  const lView = context2 ? context2.lView : null;\n  return lView === null ? null : lView[CONTEXT];\n}\nfunction getOwningComponent(elementOrDir) {\n  const context2 = getLContext(elementOrDir);\n  let lView = context2 ? context2.lView : null;\n  if (lView === null) return null;\n  let parent;\n  while (lView[TVIEW].type === 2 && (parent = getLViewParent(lView))) {\n    lView = parent;\n  }\n  return isRootView(lView) ? null : lView[CONTEXT];\n}\nfunction getRootComponents(elementOrDir) {\n  const lView = readPatchedLView(elementOrDir);\n  return lView !== null ? [getRootContext(lView)] : [];\n}\nfunction getInjector(elementOrDir) {\n  const context2 = getLContext(elementOrDir);\n  const lView = context2 ? context2.lView : null;\n  if (lView === null) return Injector.NULL;\n  const tNode = lView[TVIEW].data[context2.nodeIndex];\n  return new NodeInjector(tNode, lView);\n}\nfunction getDirectives(node) {\n  if (node instanceof Text) {\n    return [];\n  }\n  const context2 = getLContext(node);\n  const lView = context2 ? context2.lView : null;\n  if (lView === null) {\n    return [];\n  }\n  const tView = lView[TVIEW];\n  const nodeIndex = context2.nodeIndex;\n  if (!tView?.data[nodeIndex]) {\n    return [];\n  }\n  if (context2.directives === void 0) {\n    context2.directives = getDirectivesAtNodeIndex(nodeIndex, lView);\n  }\n  return context2.directives === null ? [] : [...context2.directives];\n}\nfunction getDirectiveMetadata$1(directiveOrComponentInstance) {\n  const {\n    constructor\n  } = directiveOrComponentInstance;\n  if (!constructor) {\n    throw new Error(\"Unable to find the instance constructor\");\n  }\n  const componentDef = getComponentDef(constructor);\n  if (componentDef) {\n    const inputs = extractInputDebugMetadata(componentDef.inputs);\n    return {\n      inputs,\n      outputs: componentDef.outputs,\n      encapsulation: componentDef.encapsulation,\n      changeDetection: componentDef.onPush ? ChangeDetectionStrategy.OnPush : ChangeDetectionStrategy.Default\n    };\n  }\n  const directiveDef = getDirectiveDef(constructor);\n  if (directiveDef) {\n    const inputs = extractInputDebugMetadata(directiveDef.inputs);\n    return {\n      inputs,\n      outputs: directiveDef.outputs\n    };\n  }\n  return null;\n}\nfunction getHostElement(componentOrDirective) {\n  return getLContext(componentOrDirective).native;\n}\nfunction getListeners(element) {\n  ngDevMode && assertDomElement(element);\n  const lContext = getLContext(element);\n  const lView = lContext === null ? null : lContext.lView;\n  if (lView === null) return [];\n  const tView = lView[TVIEW];\n  const lCleanup = lView[CLEANUP];\n  const tCleanup = tView.cleanup;\n  const listeners = [];\n  if (tCleanup && lCleanup) {\n    for (let i = 0; i < tCleanup.length; ) {\n      const firstParam = tCleanup[i++];\n      const secondParam = tCleanup[i++];\n      if (typeof firstParam === \"string\") {\n        const name = firstParam;\n        const listenerElement = unwrapRNode(lView[secondParam]);\n        const callback = lCleanup[tCleanup[i++]];\n        const useCaptureOrIndx = tCleanup[i++];\n        const type = typeof useCaptureOrIndx === \"boolean\" || useCaptureOrIndx >= 0 ? \"dom\" : \"output\";\n        const useCapture = typeof useCaptureOrIndx === \"boolean\" ? useCaptureOrIndx : false;\n        if (element == listenerElement) {\n          listeners.push({\n            element,\n            name,\n            callback,\n            useCapture,\n            type\n          });\n        }\n      }\n    }\n  }\n  listeners.sort(sortListeners);\n  return listeners;\n}\nfunction sortListeners(a, b) {\n  if (a.name == b.name) return 0;\n  return a.name < b.name ? -1 : 1;\n}\nfunction assertDomElement(value) {\n  if (typeof Element !== \"undefined\" && !(value instanceof Element)) {\n    throw new Error(\"Expecting instance of DOM Element\");\n  }\n}\nfunction extractInputDebugMetadata(inputs) {\n  const res = {};\n  for (const key in inputs) {\n    if (inputs.hasOwnProperty(key)) {\n      const value = inputs[key];\n      if (value !== void 0) {\n        res[key] = value[0];\n      }\n    }\n  }\n  return res;\n}\nvar DOCUMENT = void 0;\nfunction setDocument(document2) {\n  DOCUMENT = document2;\n}\nfunction getDocument() {\n  if (DOCUMENT !== void 0) {\n    return DOCUMENT;\n  } else if (typeof document !== \"undefined\") {\n    return document;\n  }\n  throw new RuntimeError(210, (typeof ngDevMode === \"undefined\" || ngDevMode) && `The document object is not available in this context. Make sure the DOCUMENT injection token is provided.`);\n}\nvar APP_ID = new InjectionToken(ngDevMode ? \"AppId\" : \"\", {\n  providedIn: \"root\",\n  factory: () => DEFAULT_APP_ID\n});\nvar DEFAULT_APP_ID = \"ng\";\nvar PLATFORM_INITIALIZER = new InjectionToken(ngDevMode ? \"Platform Initializer\" : \"\");\nvar PLATFORM_ID = new InjectionToken(ngDevMode ? \"Platform ID\" : \"\", {\n  providedIn: \"platform\",\n  factory: () => \"unknown\"\n  // set a default platform name, when none set explicitly\n});\nvar PACKAGE_ROOT_URL = new InjectionToken(ngDevMode ? \"Application Packages Root URL\" : \"\");\nvar ANIMATION_MODULE_TYPE = new InjectionToken(ngDevMode ? \"AnimationModuleType\" : \"\");\nvar CSP_NONCE = new InjectionToken(ngDevMode ? \"CSP nonce\" : \"\", {\n  providedIn: \"root\",\n  factory: () => {\n    return getDocument().body?.querySelector(\"[ngCspNonce]\")?.getAttribute(\"ngCspNonce\") || null;\n  }\n});\nvar IMAGE_CONFIG_DEFAULTS = {\n  breakpoints: [16, 32, 48, 64, 96, 128, 256, 384, 640, 750, 828, 1080, 1200, 1920, 2048, 3840],\n  placeholderResolution: 30,\n  disableImageSizeWarning: false,\n  disableImageLazyLoadWarning: false\n};\nvar IMAGE_CONFIG = new InjectionToken(ngDevMode ? \"ImageConfig\" : \"\", {\n  providedIn: \"root\",\n  factory: () => IMAGE_CONFIG_DEFAULTS\n});\nfunction makeStateKey(key) {\n  return key;\n}\nfunction initTransferState() {\n  const transferState = new TransferState();\n  if (true) {\n    transferState.store = retrieveTransferredState(getDocument(), inject(APP_ID));\n  }\n  return transferState;\n}\nvar TransferState = class _TransferState {\n  /** @nocollapse */\n  static \\u0275prov = (\n    /** @pureOrBreakMyCode */\n    /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n      token: _TransferState,\n      providedIn: \"root\",\n      factory: initTransferState\n    })\n  );\n  /** @internal */\n  store = {};\n  onSerializeCallbacks = {};\n  /**\n   * Get the value corresponding to a key. Return `defaultValue` if key is not found.\n   */\n  get(key, defaultValue) {\n    return this.store[key] !== void 0 ? this.store[key] : defaultValue;\n  }\n  /**\n   * Set the value corresponding to a key.\n   */\n  set(key, value) {\n    this.store[key] = value;\n  }\n  /**\n   * Remove a key from the store.\n   */\n  remove(key) {\n    delete this.store[key];\n  }\n  /**\n   * Test whether a key exists in the store.\n   */\n  hasKey(key) {\n    return this.store.hasOwnProperty(key);\n  }\n  /**\n   * Indicates whether the state is empty.\n   */\n  get isEmpty() {\n    return Object.keys(this.store).length === 0;\n  }\n  /**\n   * Register a callback to provide the value for a key when `toJson` is called.\n   */\n  onSerialize(key, callback) {\n    this.onSerializeCallbacks[key] = callback;\n  }\n  /**\n   * Serialize the current state of the store to JSON.\n   */\n  toJson() {\n    for (const key in this.onSerializeCallbacks) {\n      if (this.onSerializeCallbacks.hasOwnProperty(key)) {\n        try {\n          this.store[key] = this.onSerializeCallbacks[key]();\n        } catch (e) {\n          console.warn(\"Exception in onSerialize callback: \", e);\n        }\n      }\n    }\n    return JSON.stringify(this.store).replace(/</g, \"\\\\u003C\");\n  }\n};\nfunction retrieveTransferredState(doc, appId) {\n  const script = doc.getElementById(appId + \"-state\");\n  if (script?.textContent) {\n    try {\n      return JSON.parse(script.textContent);\n    } catch (e) {\n      console.warn(\"Exception while restoring TransferState for app \" + appId, e);\n    }\n  }\n  return {};\n}\nvar REFERENCE_NODE_HOST = \"h\";\nvar REFERENCE_NODE_BODY = \"b\";\nvar NUM_ROOT_NODES = \"r\";\nvar DEFER_BLOCK_ID = \"di\";\nvar DEFER_BLOCK_STATE$1 = \"s\";\nvar DEFER_PARENT_BLOCK_ID = \"p\";\nvar IS_HYDRATION_DOM_REUSE_ENABLED = new InjectionToken(typeof ngDevMode === \"undefined\" || !!ngDevMode ? \"IS_HYDRATION_DOM_REUSE_ENABLED\" : \"\");\nvar PRESERVE_HOST_CONTENT_DEFAULT = false;\nvar PRESERVE_HOST_CONTENT = new InjectionToken(typeof ngDevMode === \"undefined\" || !!ngDevMode ? \"PRESERVE_HOST_CONTENT\" : \"\", {\n  providedIn: \"root\",\n  factory: () => PRESERVE_HOST_CONTENT_DEFAULT\n});\nvar IS_I18N_HYDRATION_ENABLED = new InjectionToken(typeof ngDevMode === \"undefined\" || !!ngDevMode ? \"IS_I18N_HYDRATION_ENABLED\" : \"\");\nvar IS_EVENT_REPLAY_ENABLED = new InjectionToken(typeof ngDevMode === \"undefined\" || !!ngDevMode ? \"IS_EVENT_REPLAY_ENABLED\" : \"\");\nvar IS_INCREMENTAL_HYDRATION_ENABLED = new InjectionToken(typeof ngDevMode === \"undefined\" || !!ngDevMode ? \"IS_INCREMENTAL_HYDRATION_ENABLED\" : \"\");\nvar JSACTION_BLOCK_ELEMENT_MAP = new InjectionToken(ngDevMode ? \"JSACTION_BLOCK_ELEMENT_MAP\" : \"\", {\n  providedIn: \"root\",\n  factory: () => /* @__PURE__ */ new Map()\n});\nvar TracingAction;\n(function(TracingAction2) {\n  TracingAction2[TracingAction2[\"CHANGE_DETECTION\"] = 0] = \"CHANGE_DETECTION\";\n  TracingAction2[TracingAction2[\"AFTER_NEXT_RENDER\"] = 1] = \"AFTER_NEXT_RENDER\";\n})(TracingAction || (TracingAction = {}));\nvar TracingService = new InjectionToken(ngDevMode ? \"TracingService\" : \"\");\nvar markedFeatures = /* @__PURE__ */ new Set();\nfunction performanceMarkFeature(feature) {\n  if (markedFeatures.has(feature)) {\n    return;\n  }\n  markedFeatures.add(feature);\n  performance?.mark?.(\"mark_feature_usage\", {\n    detail: {\n      feature\n    }\n  });\n}\nfunction assertNotInReactiveContext(debugFn, extraContext) {\n  if (getActiveConsumer() !== null) {\n    throw new RuntimeError(-602, ngDevMode && `${debugFn.name}() cannot be called from within a reactive context.${extraContext ? ` ${extraContext}` : \"\"}`);\n  }\n}\nvar ViewContext = class {\n  view;\n  node;\n  constructor(view, node) {\n    this.view = view;\n    this.node = node;\n  }\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ELEMENT_ID__ = injectViewContext;\n};\nfunction injectViewContext() {\n  return new ViewContext(getLView(), getCurrentTNode());\n}\nvar AfterRenderPhase;\n(function(AfterRenderPhase2) {\n  AfterRenderPhase2[AfterRenderPhase2[\"EarlyRead\"] = 0] = \"EarlyRead\";\n  AfterRenderPhase2[AfterRenderPhase2[\"Write\"] = 1] = \"Write\";\n  AfterRenderPhase2[AfterRenderPhase2[\"MixedReadWrite\"] = 2] = \"MixedReadWrite\";\n  AfterRenderPhase2[AfterRenderPhase2[\"Read\"] = 3] = \"Read\";\n})(AfterRenderPhase || (AfterRenderPhase = {}));\nvar AfterRenderManager = class _AfterRenderManager {\n  impl = null;\n  execute() {\n    this.impl?.execute();\n  }\n  /** @nocollapse */\n  static \\u0275prov = (\n    /** @pureOrBreakMyCode */\n    /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n      token: _AfterRenderManager,\n      providedIn: \"root\",\n      factory: () => new _AfterRenderManager()\n    })\n  );\n};\nvar AFTER_RENDER_PHASES = /* @__PURE__ */ (() => [AfterRenderPhase.EarlyRead, AfterRenderPhase.Write, AfterRenderPhase.MixedReadWrite, AfterRenderPhase.Read])();\nvar AfterRenderImpl = class _AfterRenderImpl {\n  ngZone = inject(NgZone);\n  scheduler = inject(ChangeDetectionScheduler);\n  errorHandler = inject(ErrorHandler, {\n    optional: true\n  });\n  /** Current set of active sequences. */\n  sequences = /* @__PURE__ */ new Set();\n  /** Tracks registrations made during the current set of executions. */\n  deferredRegistrations = /* @__PURE__ */ new Set();\n  /** Whether the `AfterRenderManager` is currently executing hooks. */\n  executing = false;\n  constructor() {\n    inject(TracingService, {\n      optional: true\n    });\n  }\n  /**\n   * Run the sequence of phases of hooks, once through. As a result of executing some hooks, more\n   * might be scheduled.\n   */\n  execute() {\n    const hasSequencesToExecute = this.sequences.size > 0;\n    if (hasSequencesToExecute) {\n      profiler(\n        16\n        /* ProfilerEvent.AfterRenderHooksStart */\n      );\n    }\n    this.executing = true;\n    for (const phase of AFTER_RENDER_PHASES) {\n      for (const sequence of this.sequences) {\n        if (sequence.erroredOrDestroyed || !sequence.hooks[phase]) {\n          continue;\n        }\n        try {\n          sequence.pipelinedValue = this.ngZone.runOutsideAngular(() => this.maybeTrace(() => {\n            const hookFn = sequence.hooks[phase];\n            const value = hookFn(sequence.pipelinedValue);\n            return value;\n          }, sequence.snapshot));\n        } catch (err) {\n          sequence.erroredOrDestroyed = true;\n          this.errorHandler?.handleError(err);\n        }\n      }\n    }\n    this.executing = false;\n    for (const sequence of this.sequences) {\n      sequence.afterRun();\n      if (sequence.once) {\n        this.sequences.delete(sequence);\n        sequence.destroy();\n      }\n    }\n    for (const sequence of this.deferredRegistrations) {\n      this.sequences.add(sequence);\n    }\n    if (this.deferredRegistrations.size > 0) {\n      this.scheduler.notify(\n        7\n        /* NotificationSource.RenderHook */\n      );\n    }\n    this.deferredRegistrations.clear();\n    if (hasSequencesToExecute) {\n      profiler(\n        17\n        /* ProfilerEvent.AfterRenderHooksEnd */\n      );\n    }\n  }\n  register(sequence) {\n    const {\n      view\n    } = sequence;\n    if (view !== void 0) {\n      (view[AFTER_RENDER_SEQUENCES_TO_ADD] ??= []).push(sequence);\n      markAncestorsForTraversal(view);\n      view[FLAGS] |= 8192;\n    } else if (!this.executing) {\n      this.addSequence(sequence);\n    } else {\n      this.deferredRegistrations.add(sequence);\n    }\n  }\n  addSequence(sequence) {\n    this.sequences.add(sequence);\n    this.scheduler.notify(\n      7\n      /* NotificationSource.RenderHook */\n    );\n  }\n  unregister(sequence) {\n    if (this.executing && this.sequences.has(sequence)) {\n      sequence.erroredOrDestroyed = true;\n      sequence.pipelinedValue = void 0;\n      sequence.once = true;\n    } else {\n      this.sequences.delete(sequence);\n      this.deferredRegistrations.delete(sequence);\n    }\n  }\n  maybeTrace(fn, snapshot) {\n    return snapshot ? snapshot.run(TracingAction.AFTER_NEXT_RENDER, fn) : fn();\n  }\n  /** @nocollapse */\n  static \\u0275prov = (\n    /** @pureOrBreakMyCode */\n    /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n      token: _AfterRenderImpl,\n      providedIn: \"root\",\n      factory: () => new _AfterRenderImpl()\n    })\n  );\n};\nvar AfterRenderSequence = class {\n  impl;\n  hooks;\n  view;\n  once;\n  snapshot;\n  /**\n   * Whether this sequence errored or was destroyed during this execution, and hooks should no\n   * longer run for it.\n   */\n  erroredOrDestroyed = false;\n  /**\n   * The value returned by the last hook execution (if any), ready to be pipelined into the next\n   * one.\n   */\n  pipelinedValue = void 0;\n  unregisterOnDestroy;\n  constructor(impl, hooks, view, once, destroyRef, snapshot = null) {\n    this.impl = impl;\n    this.hooks = hooks;\n    this.view = view;\n    this.once = once;\n    this.snapshot = snapshot;\n    this.unregisterOnDestroy = destroyRef?.onDestroy(() => this.destroy());\n  }\n  afterRun() {\n    this.erroredOrDestroyed = false;\n    this.pipelinedValue = void 0;\n    this.snapshot?.dispose();\n    this.snapshot = null;\n  }\n  destroy() {\n    this.impl.unregister(this);\n    this.unregisterOnDestroy?.();\n    const scheduled2 = this.view?.[AFTER_RENDER_SEQUENCES_TO_ADD];\n    if (scheduled2) {\n      this.view[AFTER_RENDER_SEQUENCES_TO_ADD] = scheduled2.filter((s) => s !== this);\n    }\n  }\n};\nfunction afterRender(callbackOrSpec, options) {\n  ngDevMode && assertNotInReactiveContext(afterRender, \"Call `afterRender` outside of a reactive context. For example, schedule the render callback inside the component constructor`.\");\n  !options?.injector && assertInInjectionContext(afterRender);\n  const injector = options?.injector ?? inject(Injector);\n  if (false) {\n    return NOOP_AFTER_RENDER_REF;\n  }\n  performanceMarkFeature(\"NgAfterRender\");\n  return afterRenderImpl(\n    callbackOrSpec,\n    injector,\n    options,\n    /* once */\n    false\n  );\n}\nfunction afterNextRender(callbackOrSpec, options) {\n  !options?.injector && assertInInjectionContext(afterNextRender);\n  const injector = options?.injector ?? inject(Injector);\n  if (false) {\n    return NOOP_AFTER_RENDER_REF;\n  }\n  performanceMarkFeature(\"NgAfterNextRender\");\n  return afterRenderImpl(\n    callbackOrSpec,\n    injector,\n    options,\n    /* once */\n    true\n  );\n}\nfunction getHooks(callbackOrSpec, phase) {\n  if (callbackOrSpec instanceof Function) {\n    const hooks = [void 0, void 0, void 0, void 0];\n    hooks[phase] = callbackOrSpec;\n    return hooks;\n  } else {\n    return [callbackOrSpec.earlyRead, callbackOrSpec.write, callbackOrSpec.mixedReadWrite, callbackOrSpec.read];\n  }\n}\nfunction afterRenderImpl(callbackOrSpec, injector, options, once) {\n  const manager = injector.get(AfterRenderManager);\n  manager.impl ??= injector.get(AfterRenderImpl);\n  const tracing = injector.get(TracingService, null, {\n    optional: true\n  });\n  const hooks = options?.phase ?? AfterRenderPhase.MixedReadWrite;\n  const destroyRef = options?.manualCleanup !== true ? injector.get(DestroyRef) : null;\n  const viewContext = injector.get(ViewContext, null, {\n    optional: true\n  });\n  const sequence = new AfterRenderSequence(manager.impl, getHooks(callbackOrSpec, hooks), viewContext?.view, once, destroyRef, tracing?.snapshot(null));\n  manager.impl.register(sequence);\n  return sequence;\n}\nvar DeferDependenciesLoadingState;\n(function(DeferDependenciesLoadingState2) {\n  DeferDependenciesLoadingState2[DeferDependenciesLoadingState2[\"NOT_STARTED\"] = 0] = \"NOT_STARTED\";\n  DeferDependenciesLoadingState2[DeferDependenciesLoadingState2[\"IN_PROGRESS\"] = 1] = \"IN_PROGRESS\";\n  DeferDependenciesLoadingState2[DeferDependenciesLoadingState2[\"COMPLETE\"] = 2] = \"COMPLETE\";\n  DeferDependenciesLoadingState2[DeferDependenciesLoadingState2[\"FAILED\"] = 3] = \"FAILED\";\n})(DeferDependenciesLoadingState || (DeferDependenciesLoadingState = {}));\nvar MINIMUM_SLOT = 0;\nvar LOADING_AFTER_SLOT = 1;\nvar DeferBlockState;\n(function(DeferBlockState2) {\n  DeferBlockState2[DeferBlockState2[\"Placeholder\"] = 0] = \"Placeholder\";\n  DeferBlockState2[DeferBlockState2[\"Loading\"] = 1] = \"Loading\";\n  DeferBlockState2[DeferBlockState2[\"Complete\"] = 2] = \"Complete\";\n  DeferBlockState2[DeferBlockState2[\"Error\"] = 3] = \"Error\";\n})(DeferBlockState || (DeferBlockState = {}));\nvar DeferBlockInternalState;\n(function(DeferBlockInternalState2) {\n  DeferBlockInternalState2[DeferBlockInternalState2[\"Initial\"] = -1] = \"Initial\";\n})(DeferBlockInternalState || (DeferBlockInternalState = {}));\nvar NEXT_DEFER_BLOCK_STATE = 0;\nvar DEFER_BLOCK_STATE = 1;\nvar STATE_IS_FROZEN_UNTIL = 2;\nvar LOADING_AFTER_CLEANUP_FN = 3;\nvar TRIGGER_CLEANUP_FNS = 4;\nvar PREFETCH_TRIGGER_CLEANUP_FNS = 5;\nvar SSR_UNIQUE_ID = 6;\nvar SSR_BLOCK_STATE = 7;\nvar ON_COMPLETE_FNS = 8;\nvar HYDRATE_TRIGGER_CLEANUP_FNS = 9;\nvar DeferBlockBehavior;\n(function(DeferBlockBehavior2) {\n  DeferBlockBehavior2[DeferBlockBehavior2[\"Manual\"] = 0] = \"Manual\";\n  DeferBlockBehavior2[DeferBlockBehavior2[\"Playthrough\"] = 1] = \"Playthrough\";\n})(DeferBlockBehavior || (DeferBlockBehavior = {}));\nfunction storeTriggerCleanupFn(type, lDetails, cleanupFn) {\n  const key = getCleanupFnKeyByType(type);\n  if (lDetails[key] === null) {\n    lDetails[key] = [];\n  }\n  lDetails[key].push(cleanupFn);\n}\nfunction invokeTriggerCleanupFns(type, lDetails) {\n  const key = getCleanupFnKeyByType(type);\n  const cleanupFns = lDetails[key];\n  if (cleanupFns !== null) {\n    for (const cleanupFn of cleanupFns) {\n      cleanupFn();\n    }\n    lDetails[key] = null;\n  }\n}\nfunction invokeAllTriggerCleanupFns(lDetails) {\n  invokeTriggerCleanupFns(1, lDetails);\n  invokeTriggerCleanupFns(0, lDetails);\n  invokeTriggerCleanupFns(2, lDetails);\n}\nfunction getCleanupFnKeyByType(type) {\n  let key = TRIGGER_CLEANUP_FNS;\n  if (type === 1) {\n    key = PREFETCH_TRIGGER_CLEANUP_FNS;\n  } else if (type === 2) {\n    key = HYDRATE_TRIGGER_CLEANUP_FNS;\n  }\n  return key;\n}\nfunction getDeferBlockDataIndex(deferBlockIndex) {\n  return deferBlockIndex + 1;\n}\nfunction getLDeferBlockDetails(lView, tNode) {\n  const tView = lView[TVIEW];\n  const slotIndex = getDeferBlockDataIndex(tNode.index);\n  ngDevMode && assertIndexInDeclRange(tView, slotIndex);\n  return lView[slotIndex];\n}\nfunction setLDeferBlockDetails(lView, deferBlockIndex, lDetails) {\n  const tView = lView[TVIEW];\n  const slotIndex = getDeferBlockDataIndex(deferBlockIndex);\n  ngDevMode && assertIndexInDeclRange(tView, slotIndex);\n  lView[slotIndex] = lDetails;\n}\nfunction getTDeferBlockDetails(tView, tNode) {\n  const slotIndex = getDeferBlockDataIndex(tNode.index);\n  ngDevMode && assertIndexInDeclRange(tView, slotIndex);\n  return tView.data[slotIndex];\n}\nfunction setTDeferBlockDetails(tView, deferBlockIndex, deferBlockConfig) {\n  const slotIndex = getDeferBlockDataIndex(deferBlockIndex);\n  ngDevMode && assertIndexInDeclRange(tView, slotIndex);\n  tView.data[slotIndex] = deferBlockConfig;\n}\nfunction getTemplateIndexForState(newState, hostLView, tNode) {\n  const tView = hostLView[TVIEW];\n  const tDetails = getTDeferBlockDetails(tView, tNode);\n  switch (newState) {\n    case DeferBlockState.Complete:\n      return tDetails.primaryTmplIndex;\n    case DeferBlockState.Loading:\n      return tDetails.loadingTmplIndex;\n    case DeferBlockState.Error:\n      return tDetails.errorTmplIndex;\n    case DeferBlockState.Placeholder:\n      return tDetails.placeholderTmplIndex;\n    default:\n      ngDevMode && throwError2(`Unexpected defer block state: ${newState}`);\n      return null;\n  }\n}\nfunction getMinimumDurationForState(tDetails, currentState) {\n  if (currentState === DeferBlockState.Placeholder) {\n    return tDetails.placeholderBlockConfig?.[MINIMUM_SLOT] ?? null;\n  } else if (currentState === DeferBlockState.Loading) {\n    return tDetails.loadingBlockConfig?.[MINIMUM_SLOT] ?? null;\n  }\n  return null;\n}\nfunction getLoadingBlockAfter(tDetails) {\n  return tDetails.loadingBlockConfig?.[LOADING_AFTER_SLOT] ?? null;\n}\nfunction addDepsToRegistry(currentDeps, newDeps) {\n  if (!currentDeps || currentDeps.length === 0) {\n    return newDeps;\n  }\n  const currentDepSet = new Set(currentDeps);\n  for (const dep of newDeps) {\n    currentDepSet.add(dep);\n  }\n  return currentDeps.length === currentDepSet.size ? currentDeps : Array.from(currentDepSet);\n}\nfunction getPrimaryBlockTNode(tView, tDetails) {\n  const adjustedIndex = tDetails.primaryTmplIndex + HEADER_OFFSET;\n  return getTNode(tView, adjustedIndex);\n}\nfunction assertDeferredDependenciesLoaded(tDetails) {\n  assertEqual(tDetails.loadingState, DeferDependenciesLoadingState.COMPLETE, \"Expecting all deferred dependencies to be loaded.\");\n}\nfunction isTDeferBlockDetails(value) {\n  return value !== null && typeof value === \"object\" && typeof value.primaryTmplIndex === \"number\";\n}\nfunction trackTriggerForDebugging(tView, tNode, textRepresentation) {\n  const tDetails = getTDeferBlockDetails(tView, tNode);\n  tDetails.debug ??= {};\n  tDetails.debug.triggers ??= /* @__PURE__ */ new Set();\n  tDetails.debug.triggers.add(textRepresentation);\n}\nvar eventListenerOptions = {\n  passive: true,\n  capture: true\n};\nvar hoverTriggers = /* @__PURE__ */ new WeakMap();\nvar interactionTriggers = /* @__PURE__ */ new WeakMap();\nvar viewportTriggers = /* @__PURE__ */ new WeakMap();\nvar interactionEventNames = [\"click\", \"keydown\"];\nvar hoverEventNames = [\"mouseenter\", \"mouseover\", \"focusin\"];\nvar intersectionObserver = null;\nvar observedViewportElements = 0;\nvar DeferEventEntry = class {\n  callbacks = /* @__PURE__ */ new Set();\n  listener = () => {\n    for (const callback of this.callbacks) {\n      callback();\n    }\n  };\n};\nfunction onInteraction(trigger, callback) {\n  let entry = interactionTriggers.get(trigger);\n  if (!entry) {\n    entry = new DeferEventEntry();\n    interactionTriggers.set(trigger, entry);\n    for (const name of interactionEventNames) {\n      trigger.addEventListener(name, entry.listener, eventListenerOptions);\n    }\n  }\n  entry.callbacks.add(callback);\n  return () => {\n    const {\n      callbacks,\n      listener\n    } = entry;\n    callbacks.delete(callback);\n    if (callbacks.size === 0) {\n      interactionTriggers.delete(trigger);\n      for (const name of interactionEventNames) {\n        trigger.removeEventListener(name, listener, eventListenerOptions);\n      }\n    }\n  };\n}\nfunction onHover(trigger, callback) {\n  let entry = hoverTriggers.get(trigger);\n  if (!entry) {\n    entry = new DeferEventEntry();\n    hoverTriggers.set(trigger, entry);\n    for (const name of hoverEventNames) {\n      trigger.addEventListener(name, entry.listener, eventListenerOptions);\n    }\n  }\n  entry.callbacks.add(callback);\n  return () => {\n    const {\n      callbacks,\n      listener\n    } = entry;\n    callbacks.delete(callback);\n    if (callbacks.size === 0) {\n      for (const name of hoverEventNames) {\n        trigger.removeEventListener(name, listener, eventListenerOptions);\n      }\n      hoverTriggers.delete(trigger);\n    }\n  };\n}\nfunction onViewport(trigger, callback, injector) {\n  const ngZone = injector.get(NgZone);\n  let entry = viewportTriggers.get(trigger);\n  intersectionObserver = intersectionObserver || ngZone.runOutsideAngular(() => {\n    return new IntersectionObserver((entries) => {\n      for (const current of entries) {\n        if (current.isIntersecting && viewportTriggers.has(current.target)) {\n          ngZone.run(viewportTriggers.get(current.target).listener);\n        }\n      }\n    });\n  });\n  if (!entry) {\n    entry = new DeferEventEntry();\n    ngZone.runOutsideAngular(() => intersectionObserver.observe(trigger));\n    viewportTriggers.set(trigger, entry);\n    observedViewportElements++;\n  }\n  entry.callbacks.add(callback);\n  return () => {\n    if (!viewportTriggers.has(trigger)) {\n      return;\n    }\n    entry.callbacks.delete(callback);\n    if (entry.callbacks.size === 0) {\n      intersectionObserver?.unobserve(trigger);\n      viewportTriggers.delete(trigger);\n      observedViewportElements--;\n    }\n    if (observedViewportElements === 0) {\n      intersectionObserver?.disconnect();\n      intersectionObserver = null;\n    }\n  };\n}\nfunction getTriggerLView(deferredHostLView, deferredTNode, walkUpTimes) {\n  if (walkUpTimes == null) {\n    return deferredHostLView;\n  }\n  if (walkUpTimes >= 0) {\n    return walkUpViews(walkUpTimes, deferredHostLView);\n  }\n  const deferredContainer = deferredHostLView[deferredTNode.index];\n  ngDevMode && assertLContainer(deferredContainer);\n  const triggerLView = deferredContainer[CONTAINER_HEADER_OFFSET] ?? null;\n  if (ngDevMode && triggerLView !== null) {\n    const lDetails = getLDeferBlockDetails(deferredHostLView, deferredTNode);\n    const renderedState = lDetails[DEFER_BLOCK_STATE];\n    assertEqual(renderedState, DeferBlockState.Placeholder, \"Expected a placeholder to be rendered in this defer block.\");\n    assertLView(triggerLView);\n  }\n  return triggerLView;\n}\nfunction getTriggerElement(triggerLView, triggerIndex) {\n  const element = getNativeByIndex(HEADER_OFFSET + triggerIndex, triggerLView);\n  ngDevMode && assertElement(element);\n  return element;\n}\nfunction registerDomTrigger(initialLView, tNode, triggerIndex, walkUpTimes, registerFn, callback, type) {\n  const injector = initialLView[INJECTOR];\n  const zone = injector.get(NgZone);\n  let poll;\n  function pollDomTrigger() {\n    if (isDestroyed(initialLView)) {\n      poll.destroy();\n      return;\n    }\n    const lDetails = getLDeferBlockDetails(initialLView, tNode);\n    const renderedState = lDetails[DEFER_BLOCK_STATE];\n    if (renderedState !== DeferBlockInternalState.Initial && renderedState !== DeferBlockState.Placeholder) {\n      poll.destroy();\n      return;\n    }\n    const triggerLView = getTriggerLView(initialLView, tNode, walkUpTimes);\n    if (!triggerLView) {\n      return;\n    }\n    poll.destroy();\n    if (isDestroyed(triggerLView)) {\n      return;\n    }\n    const element = getTriggerElement(triggerLView, triggerIndex);\n    const cleanup = registerFn(element, () => {\n      zone.run(() => {\n        if (initialLView !== triggerLView) {\n          removeLViewOnDestroy(triggerLView, cleanup);\n        }\n        callback();\n      });\n    }, injector);\n    if (initialLView !== triggerLView) {\n      storeLViewOnDestroy(triggerLView, cleanup);\n    }\n    storeTriggerCleanupFn(type, lDetails, cleanup);\n  }\n  poll = afterRender({\n    read: pollDomTrigger\n  }, {\n    injector\n  });\n}\nvar JSACTION_EVENT_CONTRACT = new InjectionToken(ngDevMode ? \"EVENT_CONTRACT_DETAILS\" : \"\", {\n  providedIn: \"root\",\n  factory: () => ({})\n});\nvar DEHYDRATED_BLOCK_REGISTRY = new InjectionToken(ngDevMode ? \"DEHYDRATED_BLOCK_REGISTRY\" : \"\");\nvar TRANSFER_STATE_TOKEN_ID = \"__nghData__\";\nvar NGH_DATA_KEY = makeStateKey(TRANSFER_STATE_TOKEN_ID);\nvar TRANSFER_STATE_DEFER_BLOCKS_INFO = \"__nghDeferData__\";\nvar NGH_DEFER_BLOCKS_KEY = makeStateKey(TRANSFER_STATE_DEFER_BLOCKS_INFO);\nvar _retrieveHydrationInfoImpl = () => null;\nfunction retrieveHydrationInfo(rNode, injector, isRootView2 = false) {\n  return _retrieveHydrationInfoImpl(rNode, injector, isRootView2);\n}\nfunction getLNodeForHydration(viewRef) {\n  let lView = viewRef._lView;\n  const tView = lView[TVIEW];\n  if (tView.type === 2) {\n    return null;\n  }\n  if (isRootView(lView)) {\n    lView = lView[HEADER_OFFSET];\n  }\n  return lView;\n}\nvar HydrationStatus;\n(function(HydrationStatus2) {\n  HydrationStatus2[\"Hydrated\"] = \"hydrated\";\n  HydrationStatus2[\"Skipped\"] = \"skipped\";\n  HydrationStatus2[\"Mismatched\"] = \"mismatched\";\n})(HydrationStatus || (HydrationStatus = {}));\nvar HYDRATION_INFO_KEY = \"__ngDebugHydrationInfo__\";\nfunction patchHydrationInfo(node, info) {\n  node[HYDRATION_INFO_KEY] = info;\n}\nfunction markRNodeAsHavingHydrationMismatch(node, expectedNodeDetails = null, actualNodeDetails = null) {\n  if (!ngDevMode) {\n    throw new Error(\"Calling `markRNodeAsMismatchedByHydration` in prod mode is not supported and likely a mistake.\");\n  }\n  while (node && !getComponent(node)) {\n    node = node?.parentNode;\n  }\n  if (node) {\n    patchHydrationInfo(node, {\n      status: HydrationStatus.Mismatched,\n      expectedNodeDetails,\n      actualNodeDetails\n    });\n  }\n}\nfunction isIncrementalHydrationEnabled(injector) {\n  return injector.get(IS_INCREMENTAL_HYDRATION_ENABLED, false, {\n    optional: true\n  });\n}\nfunction assertIncrementalHydrationIsConfigured(injector) {\n  if (!isIncrementalHydrationEnabled(injector)) {\n    throw new RuntimeError(508, \"Angular has detected that some `@defer` blocks use `hydrate` triggers, but incremental hydration was not enabled. Please ensure that the `withIncrementalHydration()` call is added as an argument for the `provideClientHydration()` function call in your application config.\");\n  }\n}\nfunction assertSsrIdDefined(ssrUniqueId) {\n  assertDefined(ssrUniqueId, \"Internal error: expecting an SSR id for a defer block that should be hydrated, but the id is not present\");\n}\nfunction getParentBlockHydrationQueue(deferBlockId, injector) {\n  const dehydratedBlockRegistry = injector.get(DEHYDRATED_BLOCK_REGISTRY);\n  const transferState = injector.get(TransferState);\n  const deferBlockParents = transferState.get(NGH_DEFER_BLOCKS_KEY, {});\n  let isTopMostDeferBlock = false;\n  let currentBlockId = deferBlockId;\n  let parentBlockPromise = null;\n  const hydrationQueue = [];\n  while (!isTopMostDeferBlock && currentBlockId) {\n    ngDevMode && assertEqual(hydrationQueue.indexOf(currentBlockId), -1, \"Internal error: defer block hierarchy has a cycle.\");\n    isTopMostDeferBlock = dehydratedBlockRegistry.has(currentBlockId);\n    const hydratingParentBlock = dehydratedBlockRegistry.hydrating.get(currentBlockId);\n    if (parentBlockPromise === null && hydratingParentBlock != null) {\n      parentBlockPromise = hydratingParentBlock.promise;\n      break;\n    }\n    hydrationQueue.unshift(currentBlockId);\n    currentBlockId = deferBlockParents[currentBlockId][DEFER_PARENT_BLOCK_ID];\n  }\n  return {\n    parentBlockPromise,\n    hydrationQueue\n  };\n}\nfunction refreshContentQueries(tView, lView) {\n  const contentQueries = tView.contentQueries;\n  if (contentQueries !== null) {\n    const prevConsumer = setActiveConsumer(null);\n    try {\n      for (let i = 0; i < contentQueries.length; i += 2) {\n        const queryStartIdx = contentQueries[i];\n        const directiveDefIdx = contentQueries[i + 1];\n        if (directiveDefIdx !== -1) {\n          const directiveDef = tView.data[directiveDefIdx];\n          ngDevMode && assertDefined(directiveDef, \"DirectiveDef not found.\");\n          ngDevMode && assertDefined(directiveDef.contentQueries, \"contentQueries function should be defined\");\n          setCurrentQueryIndex(queryStartIdx);\n          directiveDef.contentQueries(2, lView[directiveDefIdx], directiveDefIdx);\n        }\n      }\n    } finally {\n      setActiveConsumer(prevConsumer);\n    }\n  }\n}\nfunction executeViewQueryFn(flags, viewQueryFn, component) {\n  ngDevMode && assertDefined(viewQueryFn, \"View queries function to execute must be defined.\");\n  setCurrentQueryIndex(0);\n  const prevConsumer = setActiveConsumer(null);\n  try {\n    viewQueryFn(flags, component);\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\nfunction executeContentQueries(tView, tNode, lView) {\n  if (isContentQueryHost(tNode)) {\n    const prevConsumer = setActiveConsumer(null);\n    try {\n      const start = tNode.directiveStart;\n      const end = tNode.directiveEnd;\n      for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {\n        const def = tView.data[directiveIndex];\n        if (def.contentQueries) {\n          const directiveInstance = lView[directiveIndex];\n          ngDevMode && assertDefined(directiveIndex, \"Incorrect reference to a directive defining a content query\");\n          def.contentQueries(1, directiveInstance, directiveIndex);\n        }\n      }\n    } finally {\n      setActiveConsumer(prevConsumer);\n    }\n  }\n}\nvar ViewEncapsulation;\n(function(ViewEncapsulation2) {\n  ViewEncapsulation2[ViewEncapsulation2[\"Emulated\"] = 0] = \"Emulated\";\n  ViewEncapsulation2[ViewEncapsulation2[\"None\"] = 2] = \"None\";\n  ViewEncapsulation2[ViewEncapsulation2[\"ShadowDom\"] = 3] = \"ShadowDom\";\n})(ViewEncapsulation || (ViewEncapsulation = {}));\nvar policy$1;\nfunction getPolicy$1() {\n  if (policy$1 === void 0) {\n    policy$1 = null;\n    if (_global.trustedTypes) {\n      try {\n        policy$1 = _global.trustedTypes.createPolicy(\"angular\", {\n          createHTML: (s) => s,\n          createScript: (s) => s,\n          createScriptURL: (s) => s\n        });\n      } catch {\n      }\n    }\n  }\n  return policy$1;\n}\nfunction trustedHTMLFromString(html) {\n  return getPolicy$1()?.createHTML(html) || html;\n}\nfunction trustedScriptURLFromString(url) {\n  return getPolicy$1()?.createScriptURL(url) || url;\n}\nvar policy;\nfunction getPolicy() {\n  if (policy === void 0) {\n    policy = null;\n    if (_global.trustedTypes) {\n      try {\n        policy = _global.trustedTypes.createPolicy(\"angular#unsafe-bypass\", {\n          createHTML: (s) => s,\n          createScript: (s) => s,\n          createScriptURL: (s) => s\n        });\n      } catch {\n      }\n    }\n  }\n  return policy;\n}\nfunction trustedHTMLFromStringBypass(html) {\n  return getPolicy()?.createHTML(html) || html;\n}\nfunction trustedScriptFromStringBypass(script) {\n  return getPolicy()?.createScript(script) || script;\n}\nfunction trustedScriptURLFromStringBypass(url) {\n  return getPolicy()?.createScriptURL(url) || url;\n}\nvar SafeValueImpl = class {\n  changingThisBreaksApplicationSecurity;\n  constructor(changingThisBreaksApplicationSecurity) {\n    this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity;\n  }\n  toString() {\n    return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${XSS_SECURITY_URL})`;\n  }\n};\nvar SafeHtmlImpl = class extends SafeValueImpl {\n  getTypeName() {\n    return \"HTML\";\n  }\n};\nvar SafeStyleImpl = class extends SafeValueImpl {\n  getTypeName() {\n    return \"Style\";\n  }\n};\nvar SafeScriptImpl = class extends SafeValueImpl {\n  getTypeName() {\n    return \"Script\";\n  }\n};\nvar SafeUrlImpl = class extends SafeValueImpl {\n  getTypeName() {\n    return \"URL\";\n  }\n};\nvar SafeResourceUrlImpl = class extends SafeValueImpl {\n  getTypeName() {\n    return \"ResourceURL\";\n  }\n};\nfunction unwrapSafeValue(value) {\n  return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity : value;\n}\nfunction allowSanitizationBypassAndThrow(value, type) {\n  const actualType = getSanitizationBypassType(value);\n  if (actualType != null && actualType !== type) {\n    if (actualType === \"ResourceURL\" && type === \"URL\") return true;\n    throw new Error(`Required a safe ${type}, got a ${actualType} (see ${XSS_SECURITY_URL})`);\n  }\n  return actualType === type;\n}\nfunction getSanitizationBypassType(value) {\n  return value instanceof SafeValueImpl && value.getTypeName() || null;\n}\nfunction bypassSanitizationTrustHtml(trustedHtml) {\n  return new SafeHtmlImpl(trustedHtml);\n}\nfunction bypassSanitizationTrustStyle(trustedStyle) {\n  return new SafeStyleImpl(trustedStyle);\n}\nfunction bypassSanitizationTrustScript(trustedScript) {\n  return new SafeScriptImpl(trustedScript);\n}\nfunction bypassSanitizationTrustUrl(trustedUrl) {\n  return new SafeUrlImpl(trustedUrl);\n}\nfunction bypassSanitizationTrustResourceUrl(trustedResourceUrl) {\n  return new SafeResourceUrlImpl(trustedResourceUrl);\n}\nfunction getInertBodyHelper(defaultDoc) {\n  const inertDocumentHelper = new InertDocumentHelper(defaultDoc);\n  return isDOMParserAvailable() ? new DOMParserHelper(inertDocumentHelper) : inertDocumentHelper;\n}\nvar DOMParserHelper = class {\n  inertDocumentHelper;\n  constructor(inertDocumentHelper) {\n    this.inertDocumentHelper = inertDocumentHelper;\n  }\n  getInertBodyElement(html) {\n    html = \"<body><remove></remove>\" + html;\n    try {\n      const body = new window.DOMParser().parseFromString(trustedHTMLFromString(html), \"text/html\").body;\n      if (body === null) {\n        return this.inertDocumentHelper.getInertBodyElement(html);\n      }\n      body.firstChild?.remove();\n      return body;\n    } catch {\n      return null;\n    }\n  }\n};\nvar InertDocumentHelper = class {\n  defaultDoc;\n  inertDocument;\n  constructor(defaultDoc) {\n    this.defaultDoc = defaultDoc;\n    this.inertDocument = this.defaultDoc.implementation.createHTMLDocument(\"sanitization-inert\");\n  }\n  getInertBodyElement(html) {\n    const templateEl = this.inertDocument.createElement(\"template\");\n    templateEl.innerHTML = trustedHTMLFromString(html);\n    return templateEl;\n  }\n};\nfunction isDOMParserAvailable() {\n  try {\n    return !!new window.DOMParser().parseFromString(trustedHTMLFromString(\"\"), \"text/html\");\n  } catch {\n    return false;\n  }\n}\nvar SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\\/?#]*(?:[\\/?#]|$))/i;\nfunction _sanitizeUrl(url) {\n  url = String(url);\n  if (url.match(SAFE_URL_PATTERN)) return url;\n  if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n    console.warn(`WARNING: sanitizing unsafe URL value ${url} (see ${XSS_SECURITY_URL})`);\n  }\n  return \"unsafe:\" + url;\n}\nfunction tagSet(tags) {\n  const res = {};\n  for (const t of tags.split(\",\")) res[t] = true;\n  return res;\n}\nfunction merge2(...sets) {\n  const res = {};\n  for (const s of sets) {\n    for (const v in s) {\n      if (s.hasOwnProperty(v)) res[v] = true;\n    }\n  }\n  return res;\n}\nvar VOID_ELEMENTS = tagSet(\"area,br,col,hr,img,wbr\");\nvar OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet(\"colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr\");\nvar OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet(\"rp,rt\");\nvar OPTIONAL_END_TAG_ELEMENTS = merge2(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);\nvar BLOCK_ELEMENTS = merge2(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet(\"address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul\"));\nvar INLINE_ELEMENTS = merge2(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet(\"a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video\"));\nvar VALID_ELEMENTS = merge2(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);\nvar URI_ATTRS = tagSet(\"background,cite,href,itemtype,longdesc,poster,src,xlink:href\");\nvar HTML_ATTRS = tagSet(\"abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width\");\nvar ARIA_ATTRS = tagSet(\"aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext\");\nvar VALID_ATTRS = merge2(URI_ATTRS, HTML_ATTRS, ARIA_ATTRS);\nvar SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet(\"script,style,template\");\nvar SanitizingHtmlSerializer = class {\n  // Explicitly track if something was stripped, to avoid accidentally warning of sanitization just\n  // because characters were re-encoded.\n  sanitizedSomething = false;\n  buf = [];\n  sanitizeChildren(el) {\n    let current = el.firstChild;\n    let traverseContent = true;\n    let parentNodes = [];\n    while (current) {\n      if (current.nodeType === Node.ELEMENT_NODE) {\n        traverseContent = this.startElement(current);\n      } else if (current.nodeType === Node.TEXT_NODE) {\n        this.chars(current.nodeValue);\n      } else {\n        this.sanitizedSomething = true;\n      }\n      if (traverseContent && current.firstChild) {\n        parentNodes.push(current);\n        current = getFirstChild(current);\n        continue;\n      }\n      while (current) {\n        if (current.nodeType === Node.ELEMENT_NODE) {\n          this.endElement(current);\n        }\n        let next = getNextSibling(current);\n        if (next) {\n          current = next;\n          break;\n        }\n        current = parentNodes.pop();\n      }\n    }\n    return this.buf.join(\"\");\n  }\n  /**\n   * Sanitizes an opening element tag (if valid) and returns whether the element's contents should\n   * be traversed. Element content must always be traversed (even if the element itself is not\n   * valid/safe), unless the element is one of `SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS`.\n   *\n   * @param element The element to sanitize.\n   * @return True if the element's contents should be traversed.\n   */\n  startElement(element) {\n    const tagName = getNodeName(element).toLowerCase();\n    if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {\n      this.sanitizedSomething = true;\n      return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);\n    }\n    this.buf.push(\"<\");\n    this.buf.push(tagName);\n    const elAttrs = element.attributes;\n    for (let i = 0; i < elAttrs.length; i++) {\n      const elAttr = elAttrs.item(i);\n      const attrName = elAttr.name;\n      const lower = attrName.toLowerCase();\n      if (!VALID_ATTRS.hasOwnProperty(lower)) {\n        this.sanitizedSomething = true;\n        continue;\n      }\n      let value = elAttr.value;\n      if (URI_ATTRS[lower]) value = _sanitizeUrl(value);\n      this.buf.push(\" \", attrName, '=\"', encodeEntities(value), '\"');\n    }\n    this.buf.push(\">\");\n    return true;\n  }\n  endElement(current) {\n    const tagName = getNodeName(current).toLowerCase();\n    if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {\n      this.buf.push(\"</\");\n      this.buf.push(tagName);\n      this.buf.push(\">\");\n    }\n  }\n  chars(chars) {\n    this.buf.push(encodeEntities(chars));\n  }\n};\nfunction isClobberedElement(parentNode, childNode) {\n  return (parentNode.compareDocumentPosition(childNode) & Node.DOCUMENT_POSITION_CONTAINED_BY) !== Node.DOCUMENT_POSITION_CONTAINED_BY;\n}\nfunction getNextSibling(node) {\n  const nextSibling = node.nextSibling;\n  if (nextSibling && node !== nextSibling.previousSibling) {\n    throw clobberedElementError(nextSibling);\n  }\n  return nextSibling;\n}\nfunction getFirstChild(node) {\n  const firstChild = node.firstChild;\n  if (firstChild && isClobberedElement(node, firstChild)) {\n    throw clobberedElementError(firstChild);\n  }\n  return firstChild;\n}\nfunction getNodeName(node) {\n  const nodeName = node.nodeName;\n  return typeof nodeName === \"string\" ? nodeName : \"FORM\";\n}\nfunction clobberedElementError(node) {\n  return new Error(`Failed to sanitize html because the element is clobbered: ${node.outerHTML}`);\n}\nvar SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\nvar NON_ALPHANUMERIC_REGEXP = /([^\\#-~ |!])/g;\nfunction encodeEntities(value) {\n  return value.replace(/&/g, \"&amp;\").replace(SURROGATE_PAIR_REGEXP, function(match2) {\n    const hi = match2.charCodeAt(0);\n    const low = match2.charCodeAt(1);\n    return \"&#\" + ((hi - 55296) * 1024 + (low - 56320) + 65536) + \";\";\n  }).replace(NON_ALPHANUMERIC_REGEXP, function(match2) {\n    return \"&#\" + match2.charCodeAt(0) + \";\";\n  }).replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\");\n}\nvar inertBodyHelper;\nfunction _sanitizeHtml(defaultDoc, unsafeHtmlInput) {\n  let inertBodyElement = null;\n  try {\n    inertBodyHelper = inertBodyHelper || getInertBodyHelper(defaultDoc);\n    let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : \"\";\n    inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\n    let mXSSAttempts = 5;\n    let parsedHtml = unsafeHtml;\n    do {\n      if (mXSSAttempts === 0) {\n        throw new Error(\"Failed to sanitize html because the input is unstable\");\n      }\n      mXSSAttempts--;\n      unsafeHtml = parsedHtml;\n      parsedHtml = inertBodyElement.innerHTML;\n      inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\n    } while (unsafeHtml !== parsedHtml);\n    const sanitizer = new SanitizingHtmlSerializer();\n    const safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);\n    if ((typeof ngDevMode === \"undefined\" || ngDevMode) && sanitizer.sanitizedSomething) {\n      console.warn(`WARNING: sanitizing HTML stripped some content, see ${XSS_SECURITY_URL}`);\n    }\n    return trustedHTMLFromString(safeHtml);\n  } finally {\n    if (inertBodyElement) {\n      const parent = getTemplateContent(inertBodyElement) || inertBodyElement;\n      while (parent.firstChild) {\n        parent.firstChild.remove();\n      }\n    }\n  }\n}\nfunction getTemplateContent(el) {\n  return \"content\" in el && isTemplateElement(el) ? el.content : null;\n}\nfunction isTemplateElement(el) {\n  return el.nodeType === Node.ELEMENT_NODE && el.nodeName === \"TEMPLATE\";\n}\nvar SecurityContext;\n(function(SecurityContext2) {\n  SecurityContext2[SecurityContext2[\"NONE\"] = 0] = \"NONE\";\n  SecurityContext2[SecurityContext2[\"HTML\"] = 1] = \"HTML\";\n  SecurityContext2[SecurityContext2[\"STYLE\"] = 2] = \"STYLE\";\n  SecurityContext2[SecurityContext2[\"SCRIPT\"] = 3] = \"SCRIPT\";\n  SecurityContext2[SecurityContext2[\"URL\"] = 4] = \"URL\";\n  SecurityContext2[SecurityContext2[\"RESOURCE_URL\"] = 5] = \"RESOURCE_URL\";\n})(SecurityContext || (SecurityContext = {}));\nfunction \\u0275\\u0275sanitizeHtml(unsafeHtml) {\n  const sanitizer = getSanitizer();\n  if (sanitizer) {\n    return trustedHTMLFromStringBypass(sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || \"\");\n  }\n  if (allowSanitizationBypassAndThrow(\n    unsafeHtml,\n    \"HTML\"\n    /* BypassType.Html */\n  )) {\n    return trustedHTMLFromStringBypass(unwrapSafeValue(unsafeHtml));\n  }\n  return _sanitizeHtml(getDocument(), renderStringify(unsafeHtml));\n}\nfunction \\u0275\\u0275sanitizeStyle(unsafeStyle) {\n  const sanitizer = getSanitizer();\n  if (sanitizer) {\n    return sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || \"\";\n  }\n  if (allowSanitizationBypassAndThrow(\n    unsafeStyle,\n    \"Style\"\n    /* BypassType.Style */\n  )) {\n    return unwrapSafeValue(unsafeStyle);\n  }\n  return renderStringify(unsafeStyle);\n}\nfunction \\u0275\\u0275sanitizeUrl(unsafeUrl) {\n  const sanitizer = getSanitizer();\n  if (sanitizer) {\n    return sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || \"\";\n  }\n  if (allowSanitizationBypassAndThrow(\n    unsafeUrl,\n    \"URL\"\n    /* BypassType.Url */\n  )) {\n    return unwrapSafeValue(unsafeUrl);\n  }\n  return _sanitizeUrl(renderStringify(unsafeUrl));\n}\nfunction \\u0275\\u0275sanitizeResourceUrl(unsafeResourceUrl) {\n  const sanitizer = getSanitizer();\n  if (sanitizer) {\n    return trustedScriptURLFromStringBypass(sanitizer.sanitize(SecurityContext.RESOURCE_URL, unsafeResourceUrl) || \"\");\n  }\n  if (allowSanitizationBypassAndThrow(\n    unsafeResourceUrl,\n    \"ResourceURL\"\n    /* BypassType.ResourceUrl */\n  )) {\n    return trustedScriptURLFromStringBypass(unwrapSafeValue(unsafeResourceUrl));\n  }\n  throw new RuntimeError(904, ngDevMode && `unsafe value used in a resource URL context (see ${XSS_SECURITY_URL})`);\n}\nfunction \\u0275\\u0275sanitizeScript(unsafeScript) {\n  const sanitizer = getSanitizer();\n  if (sanitizer) {\n    return trustedScriptFromStringBypass(sanitizer.sanitize(SecurityContext.SCRIPT, unsafeScript) || \"\");\n  }\n  if (allowSanitizationBypassAndThrow(\n    unsafeScript,\n    \"Script\"\n    /* BypassType.Script */\n  )) {\n    return trustedScriptFromStringBypass(unwrapSafeValue(unsafeScript));\n  }\n  throw new RuntimeError(905, ngDevMode && \"unsafe value used in a script context\");\n}\nfunction \\u0275\\u0275trustConstantHtml(html) {\n  if (ngDevMode && (!Array.isArray(html) || !Array.isArray(html.raw) || html.length !== 1)) {\n    throw new Error(`Unexpected interpolation in trusted HTML constant: ${html.join(\"?\")}`);\n  }\n  return trustedHTMLFromString(html[0]);\n}\nfunction \\u0275\\u0275trustConstantResourceUrl(url) {\n  if (ngDevMode && (!Array.isArray(url) || !Array.isArray(url.raw) || url.length !== 1)) {\n    throw new Error(`Unexpected interpolation in trusted URL constant: ${url.join(\"?\")}`);\n  }\n  return trustedScriptURLFromString(url[0]);\n}\nfunction getUrlSanitizer(tag, prop) {\n  if (prop === \"src\" && (tag === \"embed\" || tag === \"frame\" || tag === \"iframe\" || tag === \"media\" || tag === \"script\") || prop === \"href\" && (tag === \"base\" || tag === \"link\")) {\n    return \\u0275\\u0275sanitizeResourceUrl;\n  }\n  return \\u0275\\u0275sanitizeUrl;\n}\nfunction \\u0275\\u0275sanitizeUrlOrResourceUrl(unsafeUrl, tag, prop) {\n  return getUrlSanitizer(tag, prop)(unsafeUrl);\n}\nfunction validateAgainstEventProperties(name) {\n  if (name.toLowerCase().startsWith(\"on\")) {\n    const errorMessage = `Binding to event property '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...\nIf '${name}' is a directive input, make sure the directive is imported by the current module.`;\n    throw new RuntimeError(306, errorMessage);\n  }\n}\nfunction validateAgainstEventAttributes(name) {\n  if (name.toLowerCase().startsWith(\"on\")) {\n    const errorMessage = `Binding to event attribute '${name}' is disallowed for security reasons, please use (${name.slice(2)})=...`;\n    throw new RuntimeError(306, errorMessage);\n  }\n}\nfunction getSanitizer() {\n  const lView = getLView();\n  return lView && lView[ENVIRONMENT].sanitizer;\n}\nvar COMMENT_DISALLOWED = /^>|^->|<!--|-->|--!>|<!-$/g;\nvar COMMENT_DELIMITER = /(<|>)/g;\nvar COMMENT_DELIMITER_ESCAPED = \"\\u200B$1\\u200B\";\nfunction escapeCommentText(value) {\n  return value.replace(COMMENT_DISALLOWED, (text) => text.replace(COMMENT_DELIMITER, COMMENT_DELIMITER_ESCAPED));\n}\nfunction normalizeDebugBindingName(name) {\n  name = camelCaseToDashCase(name.replace(/[$@]/g, \"_\"));\n  return `ng-reflect-${name}`;\n}\nvar CAMEL_CASE_REGEXP = /([A-Z])/g;\nfunction camelCaseToDashCase(input2) {\n  return input2.replace(CAMEL_CASE_REGEXP, (...m) => \"-\" + m[1].toLowerCase());\n}\nfunction normalizeDebugBindingValue(value) {\n  try {\n    return value != null ? value.toString().slice(0, 30) : value;\n  } catch (e) {\n    return \"[ERROR] Exception while trying to serialize the value\";\n  }\n}\nvar CUSTOM_ELEMENTS_SCHEMA = {\n  name: \"custom-elements\"\n};\nvar NO_ERRORS_SCHEMA = {\n  name: \"no-errors-schema\"\n};\nvar shouldThrowErrorOnUnknownElement = false;\nvar shouldThrowErrorOnUnknownProperty = false;\nfunction validateElementIsKnown(element, lView, tagName, schemas, hasDirectives) {\n  if (schemas === null) return;\n  if (!hasDirectives && tagName !== null) {\n    const isUnknown = (\n      // Note that we can't check for `typeof HTMLUnknownElement === 'function'` because\n      // Domino doesn't expose HTMLUnknownElement globally.\n      typeof HTMLUnknownElement !== \"undefined\" && HTMLUnknownElement && element instanceof HTMLUnknownElement || typeof customElements !== \"undefined\" && tagName.indexOf(\"-\") > -1 && !customElements.get(tagName)\n    );\n    if (isUnknown && !matchingSchemas(schemas, tagName)) {\n      const isHostStandalone = isHostComponentStandalone(lView);\n      const templateLocation = getTemplateLocationDetails(lView);\n      const schemas2 = `'${isHostStandalone ? \"@Component\" : \"@NgModule\"}.schemas'`;\n      let message = `'${tagName}' is not a known element${templateLocation}:\n`;\n      message += `1. If '${tagName}' is an Angular component, then verify that it is ${isHostStandalone ? \"included in the '@Component.imports' of this component\" : \"a part of an @NgModule where this component is declared\"}.\n`;\n      if (tagName && tagName.indexOf(\"-\") > -1) {\n        message += `2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas2} of this component to suppress this message.`;\n      } else {\n        message += `2. To allow any element add 'NO_ERRORS_SCHEMA' to the ${schemas2} of this component.`;\n      }\n      if (shouldThrowErrorOnUnknownElement) {\n        throw new RuntimeError(304, message);\n      } else {\n        console.error(formatRuntimeError(304, message));\n      }\n    }\n  }\n}\nfunction isPropertyValid(element, propName, tagName, schemas) {\n  if (schemas === null) return true;\n  if (matchingSchemas(schemas, tagName) || propName in element || isAnimationProp(propName)) {\n    return true;\n  }\n  return typeof Node === \"undefined\" || Node === null || !(element instanceof Node);\n}\nfunction handleUnknownPropertyError(propName, tagName, nodeType, lView) {\n  if (!tagName && nodeType === 4) {\n    tagName = \"ng-template\";\n  }\n  const isHostStandalone = isHostComponentStandalone(lView);\n  const templateLocation = getTemplateLocationDetails(lView);\n  let message = `Can't bind to '${propName}' since it isn't a known property of '${tagName}'${templateLocation}.`;\n  const schemas = `'${isHostStandalone ? \"@Component\" : \"@NgModule\"}.schemas'`;\n  const importLocation = isHostStandalone ? \"included in the '@Component.imports' of this component\" : \"a part of an @NgModule where this component is declared\";\n  if (KNOWN_CONTROL_FLOW_DIRECTIVES.has(propName)) {\n    const correspondingImport = KNOWN_CONTROL_FLOW_DIRECTIVES.get(propName);\n    message += `\nIf the '${propName}' is an Angular control flow directive, please make sure that either the '${correspondingImport}' directive or the 'CommonModule' is ${importLocation}.`;\n  } else {\n    message += `\n1. If '${tagName}' is an Angular component and it has the '${propName}' input, then verify that it is ${importLocation}.`;\n    if (tagName && tagName.indexOf(\"-\") > -1) {\n      message += `\n2. If '${tagName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the ${schemas} of this component to suppress this message.`;\n      message += `\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;\n    } else {\n      message += `\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the ${schemas} of this component.`;\n    }\n  }\n  reportUnknownPropertyError(message);\n}\nfunction reportUnknownPropertyError(message) {\n  if (shouldThrowErrorOnUnknownProperty) {\n    throw new RuntimeError(303, message);\n  } else {\n    console.error(formatRuntimeError(303, message));\n  }\n}\nfunction getDeclarationComponentDef(lView) {\n  !ngDevMode && throwError2(\"Must never be called in production mode\");\n  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];\n  const context2 = declarationLView[CONTEXT];\n  if (!context2) return null;\n  return context2.constructor ? getComponentDef(context2.constructor) : null;\n}\nfunction isHostComponentStandalone(lView) {\n  !ngDevMode && throwError2(\"Must never be called in production mode\");\n  const componentDef = getDeclarationComponentDef(lView);\n  return !!componentDef?.standalone;\n}\nfunction getTemplateLocationDetails(lView) {\n  !ngDevMode && throwError2(\"Must never be called in production mode\");\n  const hostComponentDef = getDeclarationComponentDef(lView);\n  const componentClassName = hostComponentDef?.type?.name;\n  return componentClassName ? ` (used in the '${componentClassName}' component template)` : \"\";\n}\nvar KNOWN_CONTROL_FLOW_DIRECTIVES = /* @__PURE__ */ new Map([[\"ngIf\", \"NgIf\"], [\"ngFor\", \"NgFor\"], [\"ngSwitchCase\", \"NgSwitchCase\"], [\"ngSwitchDefault\", \"NgSwitchDefault\"]]);\nfunction matchingSchemas(schemas, tagName) {\n  if (schemas !== null) {\n    for (let i = 0; i < schemas.length; i++) {\n      const schema = schemas[i];\n      if (schema === NO_ERRORS_SCHEMA || schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf(\"-\") > -1) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction \\u0275\\u0275resolveWindow(element) {\n  return element.ownerDocument.defaultView;\n}\nfunction \\u0275\\u0275resolveDocument(element) {\n  return element.ownerDocument;\n}\nfunction \\u0275\\u0275resolveBody(element) {\n  return element.ownerDocument.body;\n}\nvar INTERPOLATION_DELIMITER = `\\uFFFD`;\nfunction maybeUnwrapFn(value) {\n  if (value instanceof Function) {\n    return value();\n  } else {\n    return value;\n  }\n}\nvar VALUE_STRING_LENGTH_LIMIT = 200;\nfunction assertStandaloneComponentType(type) {\n  assertComponentDef(type);\n  const componentDef = getComponentDef(type);\n  if (!componentDef.standalone) {\n    throw new RuntimeError(907, `The ${stringifyForError(type)} component is not marked as standalone, but Angular expects to have a standalone component here. Please make sure the ${stringifyForError(type)} component has the \\`standalone: true\\` flag in the decorator.`);\n  }\n}\nfunction assertComponentDef(type) {\n  if (!getComponentDef(type)) {\n    throw new RuntimeError(906, `The ${stringifyForError(type)} is not an Angular component, make sure it has the \\`@Component\\` decorator.`);\n  }\n}\nfunction throwMultipleComponentError(tNode, first2, second) {\n  throw new RuntimeError(-300, `Multiple components match node with tagname ${tNode.value}: ${stringifyForError(first2)} and ${stringifyForError(second)}`);\n}\nfunction throwErrorIfNoChangesMode(creationMode, oldValue, currValue, propName, lView) {\n  const hostComponentDef = getDeclarationComponentDef(lView);\n  const componentClassName = hostComponentDef?.type?.name;\n  const field = propName ? ` for '${propName}'` : \"\";\n  let msg = `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value${field}: '${formatValue(oldValue)}'. Current value: '${formatValue(currValue)}'.${componentClassName ? ` Expression location: ${componentClassName} component` : \"\"}`;\n  if (creationMode) {\n    msg += ` It seems like the view has been created after its parent and its children have been dirty checked. Has it been created in a change detection hook?`;\n  }\n  throw new RuntimeError(-100, msg);\n}\nfunction formatValue(value) {\n  let strValue = String(value);\n  try {\n    if (Array.isArray(value) || strValue === \"[object Object]\") {\n      strValue = JSON.stringify(value);\n    }\n  } catch (error) {\n  }\n  return strValue.length > VALUE_STRING_LENGTH_LIMIT ? strValue.substring(0, VALUE_STRING_LENGTH_LIMIT) + \"\\u2026\" : strValue;\n}\nfunction constructDetailsForInterpolation(lView, rootIndex, expressionIndex, meta, changedValue) {\n  const [propName, prefix, ...chunks] = meta.split(INTERPOLATION_DELIMITER);\n  let oldValue = prefix, newValue = prefix;\n  for (let i = 0; i < chunks.length; i++) {\n    const slotIdx = rootIndex + i;\n    oldValue += `${lView[slotIdx]}${chunks[i]}`;\n    newValue += `${slotIdx === expressionIndex ? changedValue : lView[slotIdx]}${chunks[i]}`;\n  }\n  return {\n    propName,\n    oldValue,\n    newValue\n  };\n}\nfunction getExpressionChangedErrorDetails(lView, bindingIndex, oldValue, newValue) {\n  const tData = lView[TVIEW].data;\n  const metadata = tData[bindingIndex];\n  if (typeof metadata === \"string\") {\n    if (metadata.indexOf(INTERPOLATION_DELIMITER) > -1) {\n      return constructDetailsForInterpolation(lView, bindingIndex, bindingIndex, metadata, newValue);\n    }\n    return {\n      propName: metadata,\n      oldValue,\n      newValue\n    };\n  }\n  if (metadata === null) {\n    let idx = bindingIndex - 1;\n    while (typeof tData[idx] !== \"string\" && tData[idx + 1] === null) {\n      idx--;\n    }\n    const meta = tData[idx];\n    if (typeof meta === \"string\") {\n      const matches = meta.match(new RegExp(INTERPOLATION_DELIMITER, \"g\"));\n      if (matches && matches.length - 1 > bindingIndex - idx) {\n        return constructDetailsForInterpolation(lView, idx, bindingIndex, meta, newValue);\n      }\n    }\n  }\n  return {\n    propName: void 0,\n    oldValue,\n    newValue\n  };\n}\nfunction classIndexOf(className, classToSearch, startingIndex) {\n  ngDevMode && assertNotEqual(classToSearch, \"\", 'can not look for \"\" string.');\n  let end = className.length;\n  while (true) {\n    const foundIndex = className.indexOf(classToSearch, startingIndex);\n    if (foundIndex === -1) return foundIndex;\n    if (foundIndex === 0 || className.charCodeAt(foundIndex - 1) <= 32) {\n      const length = classToSearch.length;\n      if (foundIndex + length === end || className.charCodeAt(foundIndex + length) <= 32) {\n        return foundIndex;\n      }\n    }\n    startingIndex = foundIndex + 1;\n  }\n}\nvar NG_TEMPLATE_SELECTOR = \"ng-template\";\nfunction isCssClassMatching(tNode, attrs, cssClassToMatch, isProjectionMode) {\n  ngDevMode && assertEqual(cssClassToMatch, cssClassToMatch.toLowerCase(), \"Class name expected to be lowercase.\");\n  let i = 0;\n  if (isProjectionMode) {\n    for (; i < attrs.length && typeof attrs[i] === \"string\"; i += 2) {\n      if (attrs[i] === \"class\" && classIndexOf(attrs[i + 1].toLowerCase(), cssClassToMatch, 0) !== -1) {\n        return true;\n      }\n    }\n  } else if (isInlineTemplate(tNode)) {\n    return false;\n  }\n  i = attrs.indexOf(1, i);\n  if (i > -1) {\n    let item;\n    while (++i < attrs.length && typeof (item = attrs[i]) === \"string\") {\n      if (item.toLowerCase() === cssClassToMatch) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction isInlineTemplate(tNode) {\n  return tNode.type === 4 && tNode.value !== NG_TEMPLATE_SELECTOR;\n}\nfunction hasTagAndTypeMatch(tNode, currentSelector, isProjectionMode) {\n  const tagNameToCompare = tNode.type === 4 && !isProjectionMode ? NG_TEMPLATE_SELECTOR : tNode.value;\n  return currentSelector === tagNameToCompare;\n}\nfunction isNodeMatchingSelector(tNode, selector, isProjectionMode) {\n  ngDevMode && assertDefined(selector[0], \"Selector should have a tag name\");\n  let mode = 4;\n  const nodeAttrs = tNode.attrs;\n  const nameOnlyMarkerIdx = nodeAttrs !== null ? getNameOnlyMarkerIndex(nodeAttrs) : 0;\n  let skipToNextSelector = false;\n  for (let i = 0; i < selector.length; i++) {\n    const current = selector[i];\n    if (typeof current === \"number\") {\n      if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {\n        return false;\n      }\n      if (skipToNextSelector && isPositive(current)) continue;\n      skipToNextSelector = false;\n      mode = current | mode & 1;\n      continue;\n    }\n    if (skipToNextSelector) continue;\n    if (mode & 4) {\n      mode = 2 | mode & 1;\n      if (current !== \"\" && !hasTagAndTypeMatch(tNode, current, isProjectionMode) || current === \"\" && selector.length === 1) {\n        if (isPositive(mode)) return false;\n        skipToNextSelector = true;\n      }\n    } else if (mode & 8) {\n      if (nodeAttrs === null || !isCssClassMatching(tNode, nodeAttrs, current, isProjectionMode)) {\n        if (isPositive(mode)) return false;\n        skipToNextSelector = true;\n      }\n    } else {\n      const selectorAttrValue = selector[++i];\n      const attrIndexInNode = findAttrIndexInNode(current, nodeAttrs, isInlineTemplate(tNode), isProjectionMode);\n      if (attrIndexInNode === -1) {\n        if (isPositive(mode)) return false;\n        skipToNextSelector = true;\n        continue;\n      }\n      if (selectorAttrValue !== \"\") {\n        let nodeAttrValue;\n        if (attrIndexInNode > nameOnlyMarkerIdx) {\n          nodeAttrValue = \"\";\n        } else {\n          ngDevMode && assertNotEqual(nodeAttrs[attrIndexInNode], 0, \"We do not match directives on namespaced attributes\");\n          nodeAttrValue = nodeAttrs[attrIndexInNode + 1].toLowerCase();\n        }\n        if (mode & 2 && selectorAttrValue !== nodeAttrValue) {\n          if (isPositive(mode)) return false;\n          skipToNextSelector = true;\n        }\n      }\n    }\n  }\n  return isPositive(mode) || skipToNextSelector;\n}\nfunction isPositive(mode) {\n  return (mode & 1) === 0;\n}\nfunction findAttrIndexInNode(name, attrs, isInlineTemplate2, isProjectionMode) {\n  if (attrs === null) return -1;\n  let i = 0;\n  if (isProjectionMode || !isInlineTemplate2) {\n    let bindingsMode = false;\n    while (i < attrs.length) {\n      const maybeAttrName = attrs[i];\n      if (maybeAttrName === name) {\n        return i;\n      } else if (maybeAttrName === 3 || maybeAttrName === 6) {\n        bindingsMode = true;\n      } else if (maybeAttrName === 1 || maybeAttrName === 2) {\n        let value = attrs[++i];\n        while (typeof value === \"string\") {\n          value = attrs[++i];\n        }\n        continue;\n      } else if (maybeAttrName === 4) {\n        break;\n      } else if (maybeAttrName === 0) {\n        i += 4;\n        continue;\n      }\n      i += bindingsMode ? 1 : 2;\n    }\n    return -1;\n  } else {\n    return matchTemplateAttribute(attrs, name);\n  }\n}\nfunction isNodeMatchingSelectorList(tNode, selector, isProjectionMode = false) {\n  for (let i = 0; i < selector.length; i++) {\n    if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction getProjectAsAttrValue(tNode) {\n  const nodeAttrs = tNode.attrs;\n  if (nodeAttrs != null) {\n    const ngProjectAsAttrIdx = nodeAttrs.indexOf(\n      5\n      /* AttributeMarker.ProjectAs */\n    );\n    if ((ngProjectAsAttrIdx & 1) === 0) {\n      return nodeAttrs[ngProjectAsAttrIdx + 1];\n    }\n  }\n  return null;\n}\nfunction getNameOnlyMarkerIndex(nodeAttrs) {\n  for (let i = 0; i < nodeAttrs.length; i++) {\n    const nodeAttr = nodeAttrs[i];\n    if (isNameOnlyAttributeMarker(nodeAttr)) {\n      return i;\n    }\n  }\n  return nodeAttrs.length;\n}\nfunction matchTemplateAttribute(attrs, name) {\n  let i = attrs.indexOf(\n    4\n    /* AttributeMarker.Template */\n  );\n  if (i > -1) {\n    i++;\n    while (i < attrs.length) {\n      const attr = attrs[i];\n      if (typeof attr === \"number\") return -1;\n      if (attr === name) return i;\n      i++;\n    }\n  }\n  return -1;\n}\nfunction isSelectorInSelectorList(selector, list) {\n  selectorListLoop: for (let i = 0; i < list.length; i++) {\n    const currentSelectorInList = list[i];\n    if (selector.length !== currentSelectorInList.length) {\n      continue;\n    }\n    for (let j = 0; j < selector.length; j++) {\n      if (selector[j] !== currentSelectorInList[j]) {\n        continue selectorListLoop;\n      }\n    }\n    return true;\n  }\n  return false;\n}\nfunction maybeWrapInNotSelector(isNegativeMode, chunk) {\n  return isNegativeMode ? \":not(\" + chunk.trim() + \")\" : chunk;\n}\nfunction stringifyCSSSelector(selector) {\n  let result = selector[0];\n  let i = 1;\n  let mode = 2;\n  let currentChunk = \"\";\n  let isNegativeMode = false;\n  while (i < selector.length) {\n    let valueOrMarker = selector[i];\n    if (typeof valueOrMarker === \"string\") {\n      if (mode & 2) {\n        const attrValue = selector[++i];\n        currentChunk += \"[\" + valueOrMarker + (attrValue.length > 0 ? '=\"' + attrValue + '\"' : \"\") + \"]\";\n      } else if (mode & 8) {\n        currentChunk += \".\" + valueOrMarker;\n      } else if (mode & 4) {\n        currentChunk += \" \" + valueOrMarker;\n      }\n    } else {\n      if (currentChunk !== \"\" && !isPositive(valueOrMarker)) {\n        result += maybeWrapInNotSelector(isNegativeMode, currentChunk);\n        currentChunk = \"\";\n      }\n      mode = valueOrMarker;\n      isNegativeMode = isNegativeMode || !isPositive(mode);\n    }\n    i++;\n  }\n  if (currentChunk !== \"\") {\n    result += maybeWrapInNotSelector(isNegativeMode, currentChunk);\n  }\n  return result;\n}\nfunction stringifyCSSSelectorList(selectorList) {\n  return selectorList.map(stringifyCSSSelector).join(\",\");\n}\nfunction extractAttrsAndClassesFromSelector(selector) {\n  const attrs = [];\n  const classes = [];\n  let i = 1;\n  let mode = 2;\n  while (i < selector.length) {\n    let valueOrMarker = selector[i];\n    if (typeof valueOrMarker === \"string\") {\n      if (mode === 2) {\n        if (valueOrMarker !== \"\") {\n          attrs.push(valueOrMarker, selector[++i]);\n        }\n      } else if (mode === 8) {\n        classes.push(valueOrMarker);\n      }\n    } else {\n      if (!isPositive(mode)) break;\n      mode = valueOrMarker;\n    }\n    i++;\n  }\n  if (classes.length) {\n    attrs.push(1, ...classes);\n  }\n  return attrs;\n}\nvar NO_CHANGE = typeof ngDevMode === \"undefined\" || ngDevMode ? {\n  __brand__: \"NO_CHANGE\"\n} : {};\nfunction createTextNode(renderer, value) {\n  ngDevMode && ngDevMode.rendererCreateTextNode++;\n  ngDevMode && ngDevMode.rendererSetText++;\n  return renderer.createText(value);\n}\nfunction updateTextNode(renderer, rNode, value) {\n  ngDevMode && ngDevMode.rendererSetText++;\n  renderer.setValue(rNode, value);\n}\nfunction createCommentNode(renderer, value) {\n  ngDevMode && ngDevMode.rendererCreateComment++;\n  return renderer.createComment(escapeCommentText(value));\n}\nfunction createElementNode(renderer, name, namespace) {\n  ngDevMode && ngDevMode.rendererCreateElement++;\n  return renderer.createElement(name, namespace);\n}\nfunction nativeInsertBefore(renderer, parent, child, beforeNode, isMove) {\n  ngDevMode && ngDevMode.rendererInsertBefore++;\n  renderer.insertBefore(parent, child, beforeNode, isMove);\n}\nfunction nativeAppendChild(renderer, parent, child) {\n  ngDevMode && ngDevMode.rendererAppendChild++;\n  ngDevMode && assertDefined(parent, \"parent node must be defined\");\n  renderer.appendChild(parent, child);\n}\nfunction nativeAppendOrInsertBefore(renderer, parent, child, beforeNode, isMove) {\n  if (beforeNode !== null) {\n    nativeInsertBefore(renderer, parent, child, beforeNode, isMove);\n  } else {\n    nativeAppendChild(renderer, parent, child);\n  }\n}\nfunction nativeRemoveNode(renderer, rNode, isHostElement) {\n  ngDevMode && ngDevMode.rendererRemoveNode++;\n  renderer.removeChild(null, rNode, isHostElement);\n}\nfunction writeDirectStyle(renderer, element, newValue) {\n  ngDevMode && assertString(newValue, \"'newValue' should be a string\");\n  renderer.setAttribute(element, \"style\", newValue);\n  ngDevMode && ngDevMode.rendererSetStyle++;\n}\nfunction writeDirectClass(renderer, element, newValue) {\n  ngDevMode && assertString(newValue, \"'newValue' should be a string\");\n  if (newValue === \"\") {\n    renderer.removeAttribute(element, \"class\");\n  } else {\n    renderer.setAttribute(element, \"class\", newValue);\n  }\n  ngDevMode && ngDevMode.rendererSetClassName++;\n}\nfunction setupStaticAttributes(renderer, element, tNode) {\n  const {\n    mergedAttrs,\n    classes,\n    styles\n  } = tNode;\n  if (mergedAttrs !== null) {\n    setUpAttributes(renderer, element, mergedAttrs);\n  }\n  if (classes !== null) {\n    writeDirectClass(renderer, element, classes);\n  }\n  if (styles !== null) {\n    writeDirectStyle(renderer, element, styles);\n  }\n}\nfunction createTView(type, declTNode, templateFn, decls, vars, directives, pipes, viewQuery, schemas, constsOrFactory, ssrId) {\n  ngDevMode && ngDevMode.tView++;\n  const bindingStartIndex = HEADER_OFFSET + decls;\n  const initialViewLength = bindingStartIndex + vars;\n  const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);\n  const consts = typeof constsOrFactory === \"function\" ? constsOrFactory() : constsOrFactory;\n  const tView = blueprint[TVIEW] = {\n    type,\n    blueprint,\n    template: templateFn,\n    queries: null,\n    viewQuery,\n    declTNode,\n    data: blueprint.slice().fill(null, bindingStartIndex),\n    bindingStartIndex,\n    expandoStartIndex: initialViewLength,\n    hostBindingOpCodes: null,\n    firstCreatePass: true,\n    firstUpdatePass: true,\n    staticViewQueries: false,\n    staticContentQueries: false,\n    preOrderHooks: null,\n    preOrderCheckHooks: null,\n    contentHooks: null,\n    contentCheckHooks: null,\n    viewHooks: null,\n    viewCheckHooks: null,\n    destroyHooks: null,\n    cleanup: null,\n    contentQueries: null,\n    components: null,\n    directiveRegistry: typeof directives === \"function\" ? directives() : directives,\n    pipeRegistry: typeof pipes === \"function\" ? pipes() : pipes,\n    firstChild: null,\n    schemas,\n    consts,\n    incompleteFirstPass: false,\n    ssrId\n  };\n  if (ngDevMode) {\n    Object.seal(tView);\n  }\n  return tView;\n}\nfunction createViewBlueprint(bindingStartIndex, initialViewLength) {\n  const blueprint = [];\n  for (let i = 0; i < initialViewLength; i++) {\n    blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);\n  }\n  return blueprint;\n}\nfunction getOrCreateComponentTView(def) {\n  const tView = def.tView;\n  if (tView === null || tView.incompleteFirstPass) {\n    const declTNode = null;\n    return def.tView = createTView(1, declTNode, def.template, def.decls, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas, def.consts, def.id);\n  }\n  return tView;\n}\nfunction createLView(parentLView, tView, context2, flags, host, tHostNode, environment2, renderer, injector, embeddedViewInjector, hydrationInfo) {\n  const lView = tView.blueprint.slice();\n  lView[HOST] = host;\n  lView[FLAGS] = flags | 4 | 128 | 8 | 64 | 1024;\n  if (embeddedViewInjector !== null || parentLView && parentLView[FLAGS] & 2048) {\n    lView[FLAGS] |= 2048;\n  }\n  resetPreOrderHookFlags(lView);\n  ngDevMode && tView.declTNode && parentLView && assertTNodeForLView(tView.declTNode, parentLView);\n  lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;\n  lView[CONTEXT] = context2;\n  lView[ENVIRONMENT] = environment2 || parentLView && parentLView[ENVIRONMENT];\n  ngDevMode && assertDefined(lView[ENVIRONMENT], \"LViewEnvironment is required\");\n  lView[RENDERER] = renderer || parentLView && parentLView[RENDERER];\n  ngDevMode && assertDefined(lView[RENDERER], \"Renderer is required\");\n  lView[INJECTOR] = injector || parentLView && parentLView[INJECTOR] || null;\n  lView[T_HOST] = tHostNode;\n  lView[ID] = getUniqueLViewId();\n  lView[HYDRATION] = hydrationInfo;\n  lView[EMBEDDED_VIEW_INJECTOR] = embeddedViewInjector;\n  ngDevMode && assertEqual(tView.type == 2 ? parentLView !== null : true, true, \"Embedded views must have parentLView\");\n  lView[DECLARATION_COMPONENT_VIEW] = tView.type == 2 ? parentLView[DECLARATION_COMPONENT_VIEW] : lView;\n  return lView;\n}\nfunction createComponentLView(lView, hostTNode, def) {\n  const native = getNativeByTNode(hostTNode, lView);\n  const tView = getOrCreateComponentTView(def);\n  const rendererFactory = lView[ENVIRONMENT].rendererFactory;\n  const componentView = addToEndOfViewTree(lView, createLView(lView, tView, null, getInitialLViewFlagsFromDef(def), native, hostTNode, null, rendererFactory.createRenderer(native, def), null, null, null));\n  return lView[hostTNode.index] = componentView;\n}\nfunction getInitialLViewFlagsFromDef(def) {\n  let flags = 16;\n  if (def.signals) {\n    flags = 4096;\n  } else if (def.onPush) {\n    flags = 64;\n  }\n  return flags;\n}\nfunction allocExpando(tView, lView, numSlotsToAlloc, initialValue) {\n  if (numSlotsToAlloc === 0) return -1;\n  if (ngDevMode) {\n    assertFirstCreatePass(tView);\n    assertSame(tView, lView[TVIEW], \"`LView` must be associated with `TView`!\");\n    assertEqual(tView.data.length, lView.length, \"Expecting LView to be same size as TView\");\n    assertEqual(tView.data.length, tView.blueprint.length, \"Expecting Blueprint to be same size as TView\");\n    assertFirstUpdatePass(tView);\n  }\n  const allocIdx = lView.length;\n  for (let i = 0; i < numSlotsToAlloc; i++) {\n    lView.push(initialValue);\n    tView.blueprint.push(initialValue);\n    tView.data.push(null);\n  }\n  return allocIdx;\n}\nfunction addToEndOfViewTree(lView, lViewOrLContainer) {\n  if (lView[CHILD_HEAD]) {\n    lView[CHILD_TAIL][NEXT] = lViewOrLContainer;\n  } else {\n    lView[CHILD_HEAD] = lViewOrLContainer;\n  }\n  lView[CHILD_TAIL] = lViewOrLContainer;\n  return lViewOrLContainer;\n}\nfunction \\u0275\\u0275advance(delta = 1) {\n  ngDevMode && assertGreaterThan(delta, 0, \"Can only advance forward\");\n  selectIndexInternal(getTView(), getLView(), getSelectedIndex() + delta, !!ngDevMode && isInCheckNoChangesMode());\n}\nfunction selectIndexInternal(tView, lView, index, checkNoChangesMode) {\n  ngDevMode && assertIndexInDeclRange(lView[TVIEW], index);\n  if (!checkNoChangesMode) {\n    const hooksInitPhaseCompleted = (lView[FLAGS] & 3) === 3;\n    if (hooksInitPhaseCompleted) {\n      const preOrderCheckHooks = tView.preOrderCheckHooks;\n      if (preOrderCheckHooks !== null) {\n        executeCheckHooks(lView, preOrderCheckHooks, index);\n      }\n    } else {\n      const preOrderHooks = tView.preOrderHooks;\n      if (preOrderHooks !== null) {\n        executeInitAndCheckHooks(lView, preOrderHooks, 0, index);\n      }\n    }\n  }\n  setSelectedIndex(index);\n}\nvar InputFlags;\n(function(InputFlags2) {\n  InputFlags2[InputFlags2[\"None\"] = 0] = \"None\";\n  InputFlags2[InputFlags2[\"SignalBased\"] = 1] = \"SignalBased\";\n  InputFlags2[InputFlags2[\"HasDecoratorInputTransform\"] = 2] = \"HasDecoratorInputTransform\";\n})(InputFlags || (InputFlags = {}));\nfunction writeToDirectiveInput(def, instance, publicName, value) {\n  const prevConsumer = setActiveConsumer(null);\n  try {\n    if (ngDevMode) {\n      if (!def.inputs.hasOwnProperty(publicName)) {\n        throw new Error(`ASSERTION ERROR: Directive ${def.type.name} does not have an input with a public name of \"${publicName}\"`);\n      }\n      if (instance instanceof NodeInjectorFactory) {\n        throw new Error(`ASSERTION ERROR: Cannot write input to factory for type ${def.type.name}. Directive has not been created yet.`);\n      }\n    }\n    const [privateName, flags, transform] = def.inputs[publicName];\n    let inputSignalNode = null;\n    if ((flags & InputFlags.SignalBased) !== 0) {\n      const field = instance[privateName];\n      inputSignalNode = field[SIGNAL];\n    }\n    if (inputSignalNode !== null && inputSignalNode.transformFn !== void 0) {\n      value = inputSignalNode.transformFn(value);\n    } else if (transform !== null) {\n      value = transform.call(instance, value);\n    }\n    if (def.setInput !== null) {\n      def.setInput(instance, inputSignalNode, value, publicName, privateName);\n    } else {\n      applyValueToInputField(instance, inputSignalNode, privateName, value);\n    }\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\nfunction executeTemplate(tView, lView, templateFn, rf, context2) {\n  const prevSelectedIndex = getSelectedIndex();\n  const isUpdatePhase = rf & 2;\n  try {\n    setSelectedIndex(-1);\n    if (isUpdatePhase && lView.length > HEADER_OFFSET) {\n      selectIndexInternal(tView, lView, HEADER_OFFSET, !!ngDevMode && isInCheckNoChangesMode());\n    }\n    const preHookType = isUpdatePhase ? 2 : 0;\n    profiler(preHookType, context2);\n    templateFn(rf, context2);\n  } finally {\n    setSelectedIndex(prevSelectedIndex);\n    const postHookType = isUpdatePhase ? 3 : 1;\n    profiler(postHookType, context2);\n  }\n}\nfunction createDirectivesInstances(tView, lView, tNode) {\n  instantiateAllDirectives(tView, lView, tNode);\n  if ((tNode.flags & 64) === 64) {\n    invokeDirectivesHostBindings(tView, lView, tNode);\n  }\n}\nfunction saveResolvedLocalsInData(viewData, tNode, localRefExtractor = getNativeByTNode) {\n  const localNames = tNode.localNames;\n  if (localNames !== null) {\n    let localIndex = tNode.index + 1;\n    for (let i = 0; i < localNames.length; i += 2) {\n      const index = localNames[i + 1];\n      const value = index === -1 ? localRefExtractor(tNode, viewData) : viewData[index];\n      viewData[localIndex++] = value;\n    }\n  }\n}\nfunction locateHostElement(renderer, elementOrSelector, encapsulation, injector) {\n  const preserveHostContent = injector.get(PRESERVE_HOST_CONTENT, PRESERVE_HOST_CONTENT_DEFAULT);\n  const preserveContent = preserveHostContent || encapsulation === ViewEncapsulation.ShadowDom;\n  const rootElement = renderer.selectRootElement(elementOrSelector, preserveContent);\n  applyRootElementTransform(rootElement);\n  return rootElement;\n}\nfunction applyRootElementTransform(rootElement) {\n  _applyRootElementTransformImpl(rootElement);\n}\nvar _applyRootElementTransformImpl = () => null;\nfunction mapPropName(name) {\n  if (name === \"class\") return \"className\";\n  if (name === \"for\") return \"htmlFor\";\n  if (name === \"formaction\") return \"formAction\";\n  if (name === \"innerHtml\") return \"innerHTML\";\n  if (name === \"readonly\") return \"readOnly\";\n  if (name === \"tabindex\") return \"tabIndex\";\n  return name;\n}\nfunction elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, nativeOnly) {\n  ngDevMode && assertNotSame(value, NO_CHANGE, \"Incoming value should never be NO_CHANGE.\");\n  if (!nativeOnly) {\n    const hasSetInput = setAllInputsForProperty(tNode, tView, lView, propName, value);\n    if (hasSetInput) {\n      isComponentHost(tNode) && markDirtyIfOnPush(lView, tNode.index);\n      ngDevMode && setNgReflectProperties(lView, tView, tNode, propName, value);\n      return;\n    }\n  }\n  if (tNode.type & 3) {\n    const element = getNativeByTNode(tNode, lView);\n    propName = mapPropName(propName);\n    if (ngDevMode) {\n      validateAgainstEventProperties(propName);\n      if (!isPropertyValid(element, propName, tNode.value, tView.schemas)) {\n        handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);\n      }\n      ngDevMode.rendererSetProperty++;\n    }\n    value = sanitizer != null ? sanitizer(value, tNode.value || \"\", propName) : value;\n    renderer.setProperty(element, propName, value);\n  } else if (tNode.type & 12) {\n    if (ngDevMode && !matchingSchemas(tView.schemas, tNode.value)) {\n      handleUnknownPropertyError(propName, tNode.value, tNode.type, lView);\n    }\n  }\n}\nfunction markDirtyIfOnPush(lView, viewIndex) {\n  ngDevMode && assertLView(lView);\n  const childComponentLView = getComponentLViewByIndex(viewIndex, lView);\n  if (!(childComponentLView[FLAGS] & 16)) {\n    childComponentLView[FLAGS] |= 64;\n  }\n}\nfunction setNgReflectProperty(lView, tNode, attrName, value) {\n  const element = getNativeByTNode(tNode, lView);\n  const renderer = lView[RENDERER];\n  attrName = normalizeDebugBindingName(attrName);\n  const debugValue = normalizeDebugBindingValue(value);\n  if (tNode.type & 3) {\n    if (value == null) {\n      renderer.removeAttribute(element, attrName);\n    } else {\n      renderer.setAttribute(element, attrName, debugValue);\n    }\n  } else {\n    const textContent = escapeCommentText(`bindings=${JSON.stringify({\n      [attrName]: debugValue\n    }, null, 2)}`);\n    renderer.setValue(element, textContent);\n  }\n}\nfunction setNgReflectProperties(lView, tView, tNode, publicName, value) {\n  if (!(tNode.type & (3 | 4))) {\n    return;\n  }\n  const inputConfig = tNode.inputs?.[publicName];\n  const hostInputConfig = tNode.hostDirectiveInputs?.[publicName];\n  if (hostInputConfig) {\n    for (let i = 0; i < hostInputConfig.length; i += 2) {\n      const index = hostInputConfig[i];\n      const publicName2 = hostInputConfig[i + 1];\n      const def = tView.data[index];\n      setNgReflectProperty(lView, tNode, def.inputs[publicName2][0], value);\n    }\n  }\n  if (inputConfig) {\n    for (const index of inputConfig) {\n      const def = tView.data[index];\n      setNgReflectProperty(lView, tNode, def.inputs[publicName][0], value);\n    }\n  }\n}\nfunction instantiateAllDirectives(tView, lView, tNode) {\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n  if (isComponentHost(tNode)) {\n    ngDevMode && assertTNodeType(\n      tNode,\n      3\n      /* TNodeType.AnyRNode */\n    );\n    createComponentLView(lView, tNode, tView.data[start + tNode.componentOffset]);\n  }\n  if (!tView.firstCreatePass) {\n    getOrCreateNodeInjectorForNode(tNode, lView);\n  }\n  const initialInputs = tNode.initialInputs;\n  for (let i = start; i < end; i++) {\n    const def = tView.data[i];\n    const directive = getNodeInjectable(lView, tView, i, tNode);\n    attachPatchData(directive, lView);\n    if (initialInputs !== null) {\n      setInputsFromAttrs(lView, i - start, directive, def, tNode, initialInputs);\n    }\n    if (isComponentDef(def)) {\n      const componentView = getComponentLViewByIndex(tNode.index, lView);\n      componentView[CONTEXT] = getNodeInjectable(lView, tView, i, tNode);\n    }\n  }\n}\nfunction invokeDirectivesHostBindings(tView, lView, tNode) {\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n  const elementIndex = tNode.index;\n  const currentDirectiveIndex = getCurrentDirectiveIndex();\n  try {\n    setSelectedIndex(elementIndex);\n    for (let dirIndex = start; dirIndex < end; dirIndex++) {\n      const def = tView.data[dirIndex];\n      const directive = lView[dirIndex];\n      setCurrentDirectiveIndex(dirIndex);\n      if (def.hostBindings !== null || def.hostVars !== 0 || def.hostAttrs !== null) {\n        invokeHostBindingsInCreationMode(def, directive);\n      }\n    }\n  } finally {\n    setSelectedIndex(-1);\n    setCurrentDirectiveIndex(currentDirectiveIndex);\n  }\n}\nfunction invokeHostBindingsInCreationMode(def, directive) {\n  if (def.hostBindings !== null) {\n    def.hostBindings(1, directive);\n  }\n}\nfunction findDirectiveDefMatches(tView, tNode) {\n  ngDevMode && assertFirstCreatePass(tView);\n  ngDevMode && assertTNodeType(\n    tNode,\n    3 | 12\n    /* TNodeType.AnyContainer */\n  );\n  const registry = tView.directiveRegistry;\n  let matches = null;\n  if (registry) {\n    for (let i = 0; i < registry.length; i++) {\n      const def = registry[i];\n      if (isNodeMatchingSelectorList(\n        tNode,\n        def.selectors,\n        /* isProjectionMode */\n        false\n      )) {\n        matches ??= [];\n        if (isComponentDef(def)) {\n          if (ngDevMode) {\n            assertTNodeType(tNode, 2, `\"${tNode.value}\" tags cannot be used as component hosts. Please use a different tag to activate the ${stringify(def.type)} component.`);\n            if (matches.length && isComponentDef(matches[0])) {\n              throwMultipleComponentError(tNode, matches.find(isComponentDef).type, def.type);\n            }\n          }\n          matches.unshift(def);\n        } else {\n          matches.push(def);\n        }\n      }\n    }\n  }\n  return matches;\n}\nfunction elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace) {\n  if (ngDevMode) {\n    assertNotSame(value, NO_CHANGE, \"Incoming value should never be NO_CHANGE.\");\n    validateAgainstEventAttributes(name);\n    assertTNodeType(tNode, 2, `Attempted to set attribute \\`${name}\\` on a container node. Host bindings are not valid on ng-container or ng-template.`);\n  }\n  const element = getNativeByTNode(tNode, lView);\n  setElementAttribute(lView[RENDERER], element, namespace, tNode.value, name, value, sanitizer);\n}\nfunction setElementAttribute(renderer, element, namespace, tagName, name, value, sanitizer) {\n  if (value == null) {\n    ngDevMode && ngDevMode.rendererRemoveAttribute++;\n    renderer.removeAttribute(element, name, namespace);\n  } else {\n    ngDevMode && ngDevMode.rendererSetAttribute++;\n    const strValue = sanitizer == null ? renderStringify(value) : sanitizer(value, tagName || \"\", name);\n    renderer.setAttribute(element, name, strValue, namespace);\n  }\n}\nfunction setInputsFromAttrs(lView, directiveIndex, instance, def, tNode, initialInputData) {\n  const initialInputs = initialInputData[directiveIndex];\n  if (initialInputs !== null) {\n    for (let i = 0; i < initialInputs.length; i += 2) {\n      const lookupName = initialInputs[i];\n      const value = initialInputs[i + 1];\n      writeToDirectiveInput(def, instance, lookupName, value);\n      if (ngDevMode) {\n        setNgReflectProperty(lView, tNode, def.inputs[lookupName][0], value);\n      }\n    }\n  }\n}\nfunction storePropertyBindingMetadata(tData, tNode, propertyName, bindingIndex, ...interpolationParts) {\n  if (tData[bindingIndex] === null) {\n    if (!tNode.inputs?.[propertyName] && !tNode.hostDirectiveInputs?.[propertyName]) {\n      const propBindingIdxs = tNode.propertyBindings || (tNode.propertyBindings = []);\n      propBindingIdxs.push(bindingIndex);\n      let bindingMetadata = propertyName;\n      if (interpolationParts.length > 0) {\n        bindingMetadata += INTERPOLATION_DELIMITER + interpolationParts.join(INTERPOLATION_DELIMITER);\n      }\n      tData[bindingIndex] = bindingMetadata;\n    }\n  }\n}\nfunction loadComponentRenderer(currentDef, tNode, lView) {\n  if (currentDef === null || isComponentDef(currentDef)) {\n    lView = unwrapLView(lView[tNode.index]);\n  }\n  return lView[RENDERER];\n}\nfunction handleError(lView, error) {\n  const injector = lView[INJECTOR];\n  const errorHandler2 = injector ? injector.get(ErrorHandler, null) : null;\n  errorHandler2 && errorHandler2.handleError(error);\n}\nfunction setAllInputsForProperty(tNode, tView, lView, publicName, value) {\n  const inputs = tNode.inputs?.[publicName];\n  const hostDirectiveInputs = tNode.hostDirectiveInputs?.[publicName];\n  let hasMatch = false;\n  if (hostDirectiveInputs) {\n    for (let i = 0; i < hostDirectiveInputs.length; i += 2) {\n      const index = hostDirectiveInputs[i];\n      ngDevMode && assertIndexInRange(lView, index);\n      const publicName2 = hostDirectiveInputs[i + 1];\n      const def = tView.data[index];\n      writeToDirectiveInput(def, lView[index], publicName2, value);\n      hasMatch = true;\n    }\n  }\n  if (inputs) {\n    for (const index of inputs) {\n      ngDevMode && assertIndexInRange(lView, index);\n      const instance = lView[index];\n      const def = tView.data[index];\n      writeToDirectiveInput(def, instance, publicName, value);\n      hasMatch = true;\n    }\n  }\n  return hasMatch;\n}\nfunction renderComponent(hostLView, componentHostIdx) {\n  ngDevMode && assertEqual(isCreationMode(hostLView), true, \"Should be run in creation mode\");\n  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);\n  const componentTView = componentView[TVIEW];\n  syncViewWithBlueprint(componentTView, componentView);\n  const hostRNode = componentView[HOST];\n  if (hostRNode !== null && componentView[HYDRATION] === null) {\n    componentView[HYDRATION] = retrieveHydrationInfo(hostRNode, componentView[INJECTOR]);\n  }\n  profiler(\n    18\n    /* ProfilerEvent.ComponentStart */\n  );\n  renderView(componentTView, componentView, componentView[CONTEXT]);\n  profiler(19, componentView[CONTEXT]);\n}\nfunction syncViewWithBlueprint(tView, lView) {\n  for (let i = lView.length; i < tView.blueprint.length; i++) {\n    lView.push(tView.blueprint[i]);\n  }\n}\nfunction renderView(tView, lView, context2) {\n  ngDevMode && assertEqual(isCreationMode(lView), true, \"Should be run in creation mode\");\n  ngDevMode && assertNotReactive(renderView.name);\n  enterView(lView);\n  try {\n    const viewQuery = tView.viewQuery;\n    if (viewQuery !== null) {\n      executeViewQueryFn(1, viewQuery, context2);\n    }\n    const templateFn = tView.template;\n    if (templateFn !== null) {\n      executeTemplate(tView, lView, templateFn, 1, context2);\n    }\n    if (tView.firstCreatePass) {\n      tView.firstCreatePass = false;\n    }\n    lView[QUERIES]?.finishViewCreation(tView);\n    if (tView.staticContentQueries) {\n      refreshContentQueries(tView, lView);\n    }\n    if (tView.staticViewQueries) {\n      executeViewQueryFn(2, tView.viewQuery, context2);\n    }\n    const components = tView.components;\n    if (components !== null) {\n      renderChildComponents(lView, components);\n    }\n  } catch (error) {\n    if (tView.firstCreatePass) {\n      tView.incompleteFirstPass = true;\n      tView.firstCreatePass = false;\n    }\n    throw error;\n  } finally {\n    lView[FLAGS] &= -5;\n    leaveView();\n  }\n}\nfunction renderChildComponents(hostLView, components) {\n  for (let i = 0; i < components.length; i++) {\n    renderComponent(hostLView, components[i]);\n  }\n}\nfunction createAndRenderEmbeddedLView(declarationLView, templateTNode, context2, options) {\n  const prevConsumer = setActiveConsumer(null);\n  try {\n    const embeddedTView = templateTNode.tView;\n    ngDevMode && assertDefined(embeddedTView, \"TView must be defined for a template node.\");\n    ngDevMode && assertTNodeForLView(templateTNode, declarationLView);\n    const isSignalView = declarationLView[FLAGS] & 4096;\n    const viewFlags = isSignalView ? 4096 : 16;\n    const embeddedLView = createLView(declarationLView, embeddedTView, context2, viewFlags, null, templateTNode, null, null, options?.injector ?? null, options?.embeddedViewInjector ?? null, options?.dehydratedView ?? null);\n    const declarationLContainer = declarationLView[templateTNode.index];\n    ngDevMode && assertLContainer(declarationLContainer);\n    embeddedLView[DECLARATION_LCONTAINER] = declarationLContainer;\n    const declarationViewLQueries = declarationLView[QUERIES];\n    if (declarationViewLQueries !== null) {\n      embeddedLView[QUERIES] = declarationViewLQueries.createEmbeddedView(embeddedTView);\n    }\n    renderView(embeddedTView, embeddedLView, context2);\n    return embeddedLView;\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\nfunction shouldAddViewToDom(tNode, dehydratedView) {\n  return !dehydratedView || dehydratedView.firstChild === null || hasInSkipHydrationBlockFlag(tNode);\n}\nvar _icuContainerIterate;\nfunction icuContainerIterate(tIcuContainerNode, lView) {\n  return _icuContainerIterate(tIcuContainerNode, lView);\n}\nfunction ensureIcuContainerVisitorLoaded(loader) {\n  if (_icuContainerIterate === void 0) {\n    _icuContainerIterate = loader();\n  }\n}\nvar RendererStyleFlags2;\n(function(RendererStyleFlags22) {\n  RendererStyleFlags22[RendererStyleFlags22[\"Important\"] = 1] = \"Important\";\n  RendererStyleFlags22[RendererStyleFlags22[\"DashCase\"] = 2] = \"DashCase\";\n})(RendererStyleFlags2 || (RendererStyleFlags2 = {}));\nfunction isDetachedByI18n(tNode) {\n  return (tNode.flags & 32) === 32;\n}\nfunction applyToElementOrContainer(action, renderer, parent, lNodeToHandle, beforeNode) {\n  if (lNodeToHandle != null) {\n    let lContainer;\n    let isComponent3 = false;\n    if (isLContainer(lNodeToHandle)) {\n      lContainer = lNodeToHandle;\n    } else if (isLView(lNodeToHandle)) {\n      isComponent3 = true;\n      ngDevMode && assertDefined(lNodeToHandle[HOST], \"HOST must be defined for a component LView\");\n      lNodeToHandle = lNodeToHandle[HOST];\n    }\n    const rNode = unwrapRNode(lNodeToHandle);\n    if (action === 0 && parent !== null) {\n      if (beforeNode == null) {\n        nativeAppendChild(renderer, parent, rNode);\n      } else {\n        nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);\n      }\n    } else if (action === 1 && parent !== null) {\n      nativeInsertBefore(renderer, parent, rNode, beforeNode || null, true);\n    } else if (action === 2) {\n      nativeRemoveNode(renderer, rNode, isComponent3);\n    } else if (action === 3) {\n      ngDevMode && ngDevMode.rendererDestroyNode++;\n      renderer.destroyNode(rNode);\n    }\n    if (lContainer != null) {\n      applyContainer(renderer, action, lContainer, parent, beforeNode);\n    }\n  }\n}\nfunction removeViewFromDOM(tView, lView) {\n  detachViewFromDOM(tView, lView);\n  lView[HOST] = null;\n  lView[T_HOST] = null;\n}\nfunction addViewToDOM(tView, parentTNode, renderer, lView, parentNativeNode, beforeNode) {\n  lView[HOST] = parentNativeNode;\n  lView[T_HOST] = parentTNode;\n  applyView(tView, lView, renderer, 1, parentNativeNode, beforeNode);\n}\nfunction detachViewFromDOM(tView, lView) {\n  lView[ENVIRONMENT].changeDetectionScheduler?.notify(\n    9\n    /* NotificationSource.ViewDetachedFromDOM */\n  );\n  applyView(tView, lView, lView[RENDERER], 2, null, null);\n}\nfunction destroyViewTree(rootView) {\n  let lViewOrLContainer = rootView[CHILD_HEAD];\n  if (!lViewOrLContainer) {\n    return cleanUpView(rootView[TVIEW], rootView);\n  }\n  while (lViewOrLContainer) {\n    let next = null;\n    if (isLView(lViewOrLContainer)) {\n      next = lViewOrLContainer[CHILD_HEAD];\n    } else {\n      ngDevMode && assertLContainer(lViewOrLContainer);\n      const firstView = lViewOrLContainer[CONTAINER_HEADER_OFFSET];\n      if (firstView) next = firstView;\n    }\n    if (!next) {\n      while (lViewOrLContainer && !lViewOrLContainer[NEXT] && lViewOrLContainer !== rootView) {\n        if (isLView(lViewOrLContainer)) {\n          cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);\n        }\n        lViewOrLContainer = lViewOrLContainer[PARENT];\n      }\n      if (lViewOrLContainer === null) lViewOrLContainer = rootView;\n      if (isLView(lViewOrLContainer)) {\n        cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);\n      }\n      next = lViewOrLContainer && lViewOrLContainer[NEXT];\n    }\n    lViewOrLContainer = next;\n  }\n}\nfunction detachMovedView(declarationContainer, lView) {\n  ngDevMode && assertLContainer(declarationContainer);\n  ngDevMode && assertDefined(declarationContainer[MOVED_VIEWS], \"A projected view should belong to a non-empty projected views collection\");\n  const movedViews = declarationContainer[MOVED_VIEWS];\n  const declarationViewIndex = movedViews.indexOf(lView);\n  movedViews.splice(declarationViewIndex, 1);\n}\nfunction destroyLView(tView, lView) {\n  if (isDestroyed(lView)) {\n    return;\n  }\n  const renderer = lView[RENDERER];\n  if (renderer.destroyNode) {\n    applyView(tView, lView, renderer, 3, null, null);\n  }\n  destroyViewTree(lView);\n}\nfunction cleanUpView(tView, lView) {\n  if (isDestroyed(lView)) {\n    return;\n  }\n  const prevConsumer = setActiveConsumer(null);\n  try {\n    lView[FLAGS] &= ~128;\n    lView[FLAGS] |= 256;\n    lView[REACTIVE_TEMPLATE_CONSUMER] && consumerDestroy(lView[REACTIVE_TEMPLATE_CONSUMER]);\n    executeOnDestroys(tView, lView);\n    processCleanups(tView, lView);\n    if (lView[TVIEW].type === 1) {\n      ngDevMode && ngDevMode.rendererDestroy++;\n      lView[RENDERER].destroy();\n    }\n    const declarationContainer = lView[DECLARATION_LCONTAINER];\n    if (declarationContainer !== null && isLContainer(lView[PARENT])) {\n      if (declarationContainer !== lView[PARENT]) {\n        detachMovedView(declarationContainer, lView);\n      }\n      const lQueries = lView[QUERIES];\n      if (lQueries !== null) {\n        lQueries.detachView(tView);\n      }\n    }\n    unregisterLView(lView);\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\nfunction processCleanups(tView, lView) {\n  ngDevMode && assertNotReactive(processCleanups.name);\n  const tCleanup = tView.cleanup;\n  const lCleanup = lView[CLEANUP];\n  if (tCleanup !== null) {\n    for (let i = 0; i < tCleanup.length - 1; i += 2) {\n      if (typeof tCleanup[i] === \"string\") {\n        const targetIdx = tCleanup[i + 3];\n        ngDevMode && assertNumber(targetIdx, \"cleanup target must be a number\");\n        if (targetIdx >= 0) {\n          lCleanup[targetIdx]();\n        } else {\n          lCleanup[-targetIdx].unsubscribe();\n        }\n        i += 2;\n      } else {\n        const context2 = lCleanup[tCleanup[i + 1]];\n        tCleanup[i].call(context2);\n      }\n    }\n  }\n  if (lCleanup !== null) {\n    lView[CLEANUP] = null;\n  }\n  const destroyHooks = lView[ON_DESTROY_HOOKS];\n  if (destroyHooks !== null) {\n    lView[ON_DESTROY_HOOKS] = null;\n    for (let i = 0; i < destroyHooks.length; i++) {\n      const destroyHooksFn = destroyHooks[i];\n      ngDevMode && assertFunction(destroyHooksFn, \"Expecting destroy hook to be a function.\");\n      destroyHooksFn();\n    }\n  }\n  const effects = lView[EFFECTS];\n  if (effects !== null) {\n    lView[EFFECTS] = null;\n    for (const effect2 of effects) {\n      effect2.destroy();\n    }\n  }\n}\nfunction executeOnDestroys(tView, lView) {\n  ngDevMode && assertNotReactive(executeOnDestroys.name);\n  let destroyHooks;\n  if (tView != null && (destroyHooks = tView.destroyHooks) != null) {\n    for (let i = 0; i < destroyHooks.length; i += 2) {\n      const context2 = lView[destroyHooks[i]];\n      if (!(context2 instanceof NodeInjectorFactory)) {\n        const toCall = destroyHooks[i + 1];\n        if (Array.isArray(toCall)) {\n          for (let j = 0; j < toCall.length; j += 2) {\n            const callContext = context2[toCall[j]];\n            const hook = toCall[j + 1];\n            profiler(4, callContext, hook);\n            try {\n              hook.call(callContext);\n            } finally {\n              profiler(5, callContext, hook);\n            }\n          }\n        } else {\n          profiler(4, context2, toCall);\n          try {\n            toCall.call(context2);\n          } finally {\n            profiler(5, context2, toCall);\n          }\n        }\n      }\n    }\n  }\n}\nfunction getParentRElement(tView, tNode, lView) {\n  return getClosestRElement(tView, tNode.parent, lView);\n}\nfunction getClosestRElement(tView, tNode, lView) {\n  let parentTNode = tNode;\n  while (parentTNode !== null && parentTNode.type & (8 | 32 | 128)) {\n    tNode = parentTNode;\n    parentTNode = tNode.parent;\n  }\n  if (parentTNode === null) {\n    return lView[HOST];\n  } else {\n    ngDevMode && assertTNodeType(\n      parentTNode,\n      3 | 4\n      /* TNodeType.Container */\n    );\n    if (isComponentHost(parentTNode)) {\n      ngDevMode && assertTNodeForLView(parentTNode, lView);\n      const {\n        encapsulation\n      } = tView.data[parentTNode.directiveStart + parentTNode.componentOffset];\n      if (encapsulation === ViewEncapsulation.None || encapsulation === ViewEncapsulation.Emulated) {\n        return null;\n      }\n    }\n    return getNativeByTNode(parentTNode, lView);\n  }\n}\nfunction getInsertInFrontOfRNode(parentTNode, currentTNode, lView) {\n  return _getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView);\n}\nfunction getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView) {\n  if (parentTNode.type & (8 | 32)) {\n    return getNativeByTNode(parentTNode, lView);\n  }\n  return null;\n}\nvar _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithNoI18n;\nvar _processI18nInsertBefore;\nfunction setI18nHandling(getInsertInFrontOfRNodeWithI18n2, processI18nInsertBefore2) {\n  _getInsertInFrontOfRNodeWithI18n = getInsertInFrontOfRNodeWithI18n2;\n  _processI18nInsertBefore = processI18nInsertBefore2;\n}\nfunction appendChild(tView, lView, childRNode, childTNode) {\n  const parentRNode = getParentRElement(tView, childTNode, lView);\n  const renderer = lView[RENDERER];\n  const parentTNode = childTNode.parent || lView[T_HOST];\n  const anchorNode = getInsertInFrontOfRNode(parentTNode, childTNode, lView);\n  if (parentRNode != null) {\n    if (Array.isArray(childRNode)) {\n      for (let i = 0; i < childRNode.length; i++) {\n        nativeAppendOrInsertBefore(renderer, parentRNode, childRNode[i], anchorNode, false);\n      }\n    } else {\n      nativeAppendOrInsertBefore(renderer, parentRNode, childRNode, anchorNode, false);\n    }\n  }\n  _processI18nInsertBefore !== void 0 && _processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRNode);\n}\nfunction getFirstNativeNode(lView, tNode) {\n  if (tNode !== null) {\n    ngDevMode && assertTNodeType(\n      tNode,\n      3 | 12 | 32 | 16 | 128\n      /* TNodeType.LetDeclaration */\n    );\n    const tNodeType = tNode.type;\n    if (tNodeType & 3) {\n      return getNativeByTNode(tNode, lView);\n    } else if (tNodeType & 4) {\n      return getBeforeNodeForView(-1, lView[tNode.index]);\n    } else if (tNodeType & 8) {\n      const elIcuContainerChild = tNode.child;\n      if (elIcuContainerChild !== null) {\n        return getFirstNativeNode(lView, elIcuContainerChild);\n      } else {\n        const rNodeOrLContainer = lView[tNode.index];\n        if (isLContainer(rNodeOrLContainer)) {\n          return getBeforeNodeForView(-1, rNodeOrLContainer);\n        } else {\n          return unwrapRNode(rNodeOrLContainer);\n        }\n      }\n    } else if (tNodeType & 128) {\n      return getFirstNativeNode(lView, tNode.next);\n    } else if (tNodeType & 32) {\n      let nextRNode = icuContainerIterate(tNode, lView);\n      let rNode = nextRNode();\n      return rNode || unwrapRNode(lView[tNode.index]);\n    } else {\n      const projectionNodes = getProjectionNodes(lView, tNode);\n      if (projectionNodes !== null) {\n        if (Array.isArray(projectionNodes)) {\n          return projectionNodes[0];\n        }\n        const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);\n        ngDevMode && assertParentView(parentView);\n        return getFirstNativeNode(parentView, projectionNodes);\n      } else {\n        return getFirstNativeNode(lView, tNode.next);\n      }\n    }\n  }\n  return null;\n}\nfunction getProjectionNodes(lView, tNode) {\n  if (tNode !== null) {\n    const componentView = lView[DECLARATION_COMPONENT_VIEW];\n    const componentHost = componentView[T_HOST];\n    const slotIdx = tNode.projection;\n    ngDevMode && assertProjectionSlots(lView);\n    return componentHost.projection[slotIdx];\n  }\n  return null;\n}\nfunction getBeforeNodeForView(viewIndexInContainer, lContainer) {\n  const nextViewIndex = CONTAINER_HEADER_OFFSET + viewIndexInContainer + 1;\n  if (nextViewIndex < lContainer.length) {\n    const lView = lContainer[nextViewIndex];\n    const firstTNodeOfView = lView[TVIEW].firstChild;\n    if (firstTNodeOfView !== null) {\n      return getFirstNativeNode(lView, firstTNodeOfView);\n    }\n  }\n  return lContainer[NATIVE];\n}\nfunction applyNodes(renderer, action, tNode, lView, parentRElement, beforeNode, isProjection) {\n  while (tNode != null) {\n    ngDevMode && assertTNodeForLView(tNode, lView);\n    if (tNode.type === 128) {\n      tNode = tNode.next;\n      continue;\n    }\n    ngDevMode && assertTNodeType(\n      tNode,\n      3 | 12 | 16 | 32\n      /* TNodeType.Icu */\n    );\n    const rawSlotValue = lView[tNode.index];\n    const tNodeType = tNode.type;\n    if (isProjection) {\n      if (action === 0) {\n        rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView);\n        tNode.flags |= 2;\n      }\n    }\n    if (!isDetachedByI18n(tNode)) {\n      if (tNodeType & 8) {\n        applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, false);\n        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n      } else if (tNodeType & 32) {\n        const nextRNode = icuContainerIterate(tNode, lView);\n        let rNode;\n        while (rNode = nextRNode()) {\n          applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);\n        }\n        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n      } else if (tNodeType & 16) {\n        applyProjectionRecursive(renderer, action, lView, tNode, parentRElement, beforeNode);\n      } else {\n        ngDevMode && assertTNodeType(\n          tNode,\n          3 | 4\n          /* TNodeType.Container */\n        );\n        applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);\n      }\n    }\n    tNode = isProjection ? tNode.projectionNext : tNode.next;\n  }\n}\nfunction applyView(tView, lView, renderer, action, parentRElement, beforeNode) {\n  applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, false);\n}\nfunction applyProjection(tView, lView, tProjectionNode) {\n  const renderer = lView[RENDERER];\n  const parentRNode = getParentRElement(tView, tProjectionNode, lView);\n  const parentTNode = tProjectionNode.parent || lView[T_HOST];\n  let beforeNode = getInsertInFrontOfRNode(parentTNode, tProjectionNode, lView);\n  applyProjectionRecursive(renderer, 0, lView, tProjectionNode, parentRNode, beforeNode);\n}\nfunction applyProjectionRecursive(renderer, action, lView, tProjectionNode, parentRElement, beforeNode) {\n  const componentLView = lView[DECLARATION_COMPONENT_VIEW];\n  const componentNode = componentLView[T_HOST];\n  ngDevMode && assertEqual(typeof tProjectionNode.projection, \"number\", \"expecting projection index\");\n  const nodeToProjectOrRNodes = componentNode.projection[tProjectionNode.projection];\n  if (Array.isArray(nodeToProjectOrRNodes)) {\n    for (let i = 0; i < nodeToProjectOrRNodes.length; i++) {\n      const rNode = nodeToProjectOrRNodes[i];\n      applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);\n    }\n  } else {\n    let nodeToProject = nodeToProjectOrRNodes;\n    const projectedComponentLView = componentLView[PARENT];\n    if (hasInSkipHydrationBlockFlag(tProjectionNode)) {\n      nodeToProject.flags |= 128;\n    }\n    applyNodes(renderer, action, nodeToProject, projectedComponentLView, parentRElement, beforeNode, true);\n  }\n}\nfunction applyContainer(renderer, action, lContainer, parentRElement, beforeNode) {\n  ngDevMode && assertLContainer(lContainer);\n  const anchor = lContainer[NATIVE];\n  const native = unwrapRNode(lContainer);\n  if (anchor !== native) {\n    applyToElementOrContainer(action, renderer, parentRElement, anchor, beforeNode);\n  }\n  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n    const lView = lContainer[i];\n    applyView(lView[TVIEW], lView, renderer, action, parentRElement, anchor);\n  }\n}\nfunction applyStyling(renderer, isClassBased, rNode, prop, value) {\n  if (isClassBased) {\n    if (!value) {\n      ngDevMode && ngDevMode.rendererRemoveClass++;\n      renderer.removeClass(rNode, prop);\n    } else {\n      ngDevMode && ngDevMode.rendererAddClass++;\n      renderer.addClass(rNode, prop);\n    }\n  } else {\n    let flags = prop.indexOf(\"-\") === -1 ? void 0 : RendererStyleFlags2.DashCase;\n    if (value == null) {\n      ngDevMode && ngDevMode.rendererRemoveStyle++;\n      renderer.removeStyle(rNode, prop, flags);\n    } else {\n      const isImportant = typeof value === \"string\" ? value.endsWith(\"!important\") : false;\n      if (isImportant) {\n        value = value.slice(0, -10);\n        flags |= RendererStyleFlags2.Important;\n      }\n      ngDevMode && ngDevMode.rendererSetStyle++;\n      renderer.setStyle(rNode, prop, value, flags);\n    }\n  }\n}\nfunction collectNativeNodes(tView, lView, tNode, result, isProjection = false) {\n  while (tNode !== null) {\n    if (tNode.type === 128) {\n      tNode = isProjection ? tNode.projectionNext : tNode.next;\n      continue;\n    }\n    ngDevMode && assertTNodeType(\n      tNode,\n      3 | 12 | 16 | 32\n      /* TNodeType.Icu */\n    );\n    const lNode = lView[tNode.index];\n    if (lNode !== null) {\n      result.push(unwrapRNode(lNode));\n    }\n    if (isLContainer(lNode)) {\n      collectNativeNodesInLContainer(lNode, result);\n    }\n    const tNodeType = tNode.type;\n    if (tNodeType & 8) {\n      collectNativeNodes(tView, lView, tNode.child, result);\n    } else if (tNodeType & 32) {\n      const nextRNode = icuContainerIterate(tNode, lView);\n      let rNode;\n      while (rNode = nextRNode()) {\n        result.push(rNode);\n      }\n    } else if (tNodeType & 16) {\n      const nodesInSlot = getProjectionNodes(lView, tNode);\n      if (Array.isArray(nodesInSlot)) {\n        result.push(...nodesInSlot);\n      } else {\n        const parentView = getLViewParent(lView[DECLARATION_COMPONENT_VIEW]);\n        ngDevMode && assertParentView(parentView);\n        collectNativeNodes(parentView[TVIEW], parentView, nodesInSlot, result, true);\n      }\n    }\n    tNode = isProjection ? tNode.projectionNext : tNode.next;\n  }\n  return result;\n}\nfunction collectNativeNodesInLContainer(lContainer, result) {\n  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n    const lViewInAContainer = lContainer[i];\n    const lViewFirstChildTNode = lViewInAContainer[TVIEW].firstChild;\n    if (lViewFirstChildTNode !== null) {\n      collectNativeNodes(lViewInAContainer[TVIEW], lViewInAContainer, lViewFirstChildTNode, result);\n    }\n  }\n  if (lContainer[NATIVE] !== lContainer[HOST]) {\n    result.push(lContainer[NATIVE]);\n  }\n}\nfunction addAfterRenderSequencesForView(lView) {\n  if (lView[AFTER_RENDER_SEQUENCES_TO_ADD] !== null) {\n    for (const sequence of lView[AFTER_RENDER_SEQUENCES_TO_ADD]) {\n      sequence.impl.addSequence(sequence);\n    }\n    lView[AFTER_RENDER_SEQUENCES_TO_ADD].length = 0;\n  }\n}\nvar freeConsumers = [];\nfunction getOrBorrowReactiveLViewConsumer(lView) {\n  return lView[REACTIVE_TEMPLATE_CONSUMER] ?? borrowReactiveLViewConsumer(lView);\n}\nfunction borrowReactiveLViewConsumer(lView) {\n  const consumer = freeConsumers.pop() ?? Object.create(REACTIVE_LVIEW_CONSUMER_NODE);\n  consumer.lView = lView;\n  return consumer;\n}\nfunction maybeReturnReactiveLViewConsumer(consumer) {\n  if (consumer.lView[REACTIVE_TEMPLATE_CONSUMER] === consumer) {\n    return;\n  }\n  consumer.lView = null;\n  freeConsumers.push(consumer);\n}\nvar REACTIVE_LVIEW_CONSUMER_NODE = __spreadProps(__spreadValues({}, REACTIVE_NODE), {\n  consumerIsAlwaysLive: true,\n  kind: \"template\",\n  consumerMarkedDirty: (node) => {\n    markAncestorsForTraversal(node.lView);\n  },\n  consumerOnSignalRead() {\n    this.lView[REACTIVE_TEMPLATE_CONSUMER] = this;\n  }\n});\nfunction getOrCreateTemporaryConsumer(lView) {\n  const consumer = lView[REACTIVE_TEMPLATE_CONSUMER] ?? Object.create(TEMPORARY_CONSUMER_NODE);\n  consumer.lView = lView;\n  return consumer;\n}\nvar TEMPORARY_CONSUMER_NODE = __spreadProps(__spreadValues({}, REACTIVE_NODE), {\n  consumerIsAlwaysLive: true,\n  kind: \"template\",\n  consumerMarkedDirty: (node) => {\n    let parent = getLViewParent(node.lView);\n    while (parent && !viewShouldHaveReactiveConsumer(parent[TVIEW])) {\n      parent = getLViewParent(parent);\n    }\n    if (!parent) {\n      return;\n    }\n    markViewForRefresh(parent);\n  },\n  consumerOnSignalRead() {\n    this.lView[REACTIVE_TEMPLATE_CONSUMER] = this;\n  }\n});\nfunction viewShouldHaveReactiveConsumer(tView) {\n  return tView.type !== 2;\n}\nfunction runEffectsInView(view) {\n  if (view[EFFECTS] === null) {\n    return;\n  }\n  let tryFlushEffects = true;\n  while (tryFlushEffects) {\n    let foundDirtyEffect = false;\n    for (const effect2 of view[EFFECTS]) {\n      if (!effect2.dirty) {\n        continue;\n      }\n      foundDirtyEffect = true;\n      if (effect2.zone === null || Zone.current === effect2.zone) {\n        effect2.run();\n      } else {\n        effect2.zone.run(() => effect2.run());\n      }\n    }\n    tryFlushEffects = foundDirtyEffect && !!(view[FLAGS] & 8192);\n  }\n}\nvar MAXIMUM_REFRESH_RERUNS$1 = 100;\nfunction detectChangesInternal(lView, notifyErrorHandler = true, mode = 0) {\n  const environment2 = lView[ENVIRONMENT];\n  const rendererFactory = environment2.rendererFactory;\n  const checkNoChangesMode = !!ngDevMode && isInCheckNoChangesMode();\n  if (!checkNoChangesMode) {\n    rendererFactory.begin?.();\n  }\n  try {\n    detectChangesInViewWhileDirty(lView, mode);\n  } catch (error) {\n    if (notifyErrorHandler) {\n      handleError(lView, error);\n    }\n    throw error;\n  } finally {\n    if (!checkNoChangesMode) {\n      rendererFactory.end?.();\n    }\n  }\n}\nfunction detectChangesInViewWhileDirty(lView, mode) {\n  const lastIsRefreshingViewsValue = isRefreshingViews();\n  try {\n    setIsRefreshingViews(true);\n    detectChangesInView(lView, mode);\n    if (ngDevMode && isExhaustiveCheckNoChanges()) {\n      return;\n    }\n    let retries = 0;\n    while (requiresRefreshOrTraversal(lView)) {\n      if (retries === MAXIMUM_REFRESH_RERUNS$1) {\n        throw new RuntimeError(103, ngDevMode && \"Infinite change detection while trying to refresh views. There may be components which each cause the other to require a refresh, causing an infinite loop.\");\n      }\n      retries++;\n      detectChangesInView(\n        lView,\n        1\n        /* ChangeDetectionMode.Targeted */\n      );\n    }\n  } finally {\n    setIsRefreshingViews(lastIsRefreshingViewsValue);\n  }\n}\nfunction checkNoChangesInternal(lView, mode, notifyErrorHandler = true) {\n  setIsInCheckNoChangesMode(mode);\n  try {\n    detectChangesInternal(lView, notifyErrorHandler);\n  } finally {\n    setIsInCheckNoChangesMode(CheckNoChangesMode.Off);\n  }\n}\nfunction refreshView(tView, lView, templateFn, context2) {\n  ngDevMode && assertEqual(isCreationMode(lView), false, \"Should be run in update mode\");\n  if (isDestroyed(lView)) return;\n  const flags = lView[FLAGS];\n  const isInCheckNoChangesPass = ngDevMode && isInCheckNoChangesMode();\n  const isInExhaustiveCheckNoChangesPass = ngDevMode && isExhaustiveCheckNoChanges();\n  enterView(lView);\n  let returnConsumerToPool = true;\n  let prevConsumer = null;\n  let currentConsumer = null;\n  if (!isInCheckNoChangesPass) {\n    if (viewShouldHaveReactiveConsumer(tView)) {\n      currentConsumer = getOrBorrowReactiveLViewConsumer(lView);\n      prevConsumer = consumerBeforeComputation(currentConsumer);\n    } else if (getActiveConsumer() === null) {\n      returnConsumerToPool = false;\n      currentConsumer = getOrCreateTemporaryConsumer(lView);\n      prevConsumer = consumerBeforeComputation(currentConsumer);\n    } else if (lView[REACTIVE_TEMPLATE_CONSUMER]) {\n      consumerDestroy(lView[REACTIVE_TEMPLATE_CONSUMER]);\n      lView[REACTIVE_TEMPLATE_CONSUMER] = null;\n    }\n  }\n  try {\n    resetPreOrderHookFlags(lView);\n    setBindingIndex(tView.bindingStartIndex);\n    if (templateFn !== null) {\n      executeTemplate(tView, lView, templateFn, 2, context2);\n    }\n    const hooksInitPhaseCompleted = (flags & 3) === 3;\n    if (!isInCheckNoChangesPass) {\n      if (hooksInitPhaseCompleted) {\n        const preOrderCheckHooks = tView.preOrderCheckHooks;\n        if (preOrderCheckHooks !== null) {\n          executeCheckHooks(lView, preOrderCheckHooks, null);\n        }\n      } else {\n        const preOrderHooks = tView.preOrderHooks;\n        if (preOrderHooks !== null) {\n          executeInitAndCheckHooks(lView, preOrderHooks, 0, null);\n        }\n        incrementInitPhaseFlags(\n          lView,\n          0\n          /* InitPhaseState.OnInitHooksToBeRun */\n        );\n      }\n    }\n    if (!isInExhaustiveCheckNoChangesPass) {\n      markTransplantedViewsForRefresh(lView);\n    }\n    runEffectsInView(lView);\n    detectChangesInEmbeddedViews(\n      lView,\n      0\n      /* ChangeDetectionMode.Global */\n    );\n    if (tView.contentQueries !== null) {\n      refreshContentQueries(tView, lView);\n    }\n    if (!isInCheckNoChangesPass) {\n      if (hooksInitPhaseCompleted) {\n        const contentCheckHooks = tView.contentCheckHooks;\n        if (contentCheckHooks !== null) {\n          executeCheckHooks(lView, contentCheckHooks);\n        }\n      } else {\n        const contentHooks = tView.contentHooks;\n        if (contentHooks !== null) {\n          executeInitAndCheckHooks(\n            lView,\n            contentHooks,\n            1\n            /* InitPhaseState.AfterContentInitHooksToBeRun */\n          );\n        }\n        incrementInitPhaseFlags(\n          lView,\n          1\n          /* InitPhaseState.AfterContentInitHooksToBeRun */\n        );\n      }\n    }\n    processHostBindingOpCodes(tView, lView);\n    const components = tView.components;\n    if (components !== null) {\n      detectChangesInChildComponents(\n        lView,\n        components,\n        0\n        /* ChangeDetectionMode.Global */\n      );\n    }\n    const viewQuery = tView.viewQuery;\n    if (viewQuery !== null) {\n      executeViewQueryFn(2, viewQuery, context2);\n    }\n    if (!isInCheckNoChangesPass) {\n      if (hooksInitPhaseCompleted) {\n        const viewCheckHooks = tView.viewCheckHooks;\n        if (viewCheckHooks !== null) {\n          executeCheckHooks(lView, viewCheckHooks);\n        }\n      } else {\n        const viewHooks = tView.viewHooks;\n        if (viewHooks !== null) {\n          executeInitAndCheckHooks(\n            lView,\n            viewHooks,\n            2\n            /* InitPhaseState.AfterViewInitHooksToBeRun */\n          );\n        }\n        incrementInitPhaseFlags(\n          lView,\n          2\n          /* InitPhaseState.AfterViewInitHooksToBeRun */\n        );\n      }\n    }\n    if (tView.firstUpdatePass === true) {\n      tView.firstUpdatePass = false;\n    }\n    if (lView[EFFECTS_TO_SCHEDULE]) {\n      for (const notifyEffect of lView[EFFECTS_TO_SCHEDULE]) {\n        notifyEffect();\n      }\n      lView[EFFECTS_TO_SCHEDULE] = null;\n    }\n    if (!isInCheckNoChangesPass) {\n      addAfterRenderSequencesForView(lView);\n      lView[FLAGS] &= ~(64 | 8);\n    }\n  } catch (e) {\n    if (!isInCheckNoChangesPass) {\n      markAncestorsForTraversal(lView);\n    }\n    throw e;\n  } finally {\n    if (currentConsumer !== null) {\n      consumerAfterComputation(currentConsumer, prevConsumer);\n      if (returnConsumerToPool) {\n        maybeReturnReactiveLViewConsumer(currentConsumer);\n      }\n    }\n    leaveView();\n  }\n}\nfunction detectChangesInEmbeddedViews(lView, mode) {\n  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {\n    for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n      const embeddedLView = lContainer[i];\n      detectChangesInViewIfAttached(embeddedLView, mode);\n    }\n  }\n}\nfunction markTransplantedViewsForRefresh(lView) {\n  for (let lContainer = getFirstLContainer(lView); lContainer !== null; lContainer = getNextLContainer(lContainer)) {\n    if (!(lContainer[FLAGS] & 2)) continue;\n    const movedViews = lContainer[MOVED_VIEWS];\n    ngDevMode && assertDefined(movedViews, \"Transplanted View flags set but missing MOVED_VIEWS\");\n    for (let i = 0; i < movedViews.length; i++) {\n      const movedLView = movedViews[i];\n      markViewForRefresh(movedLView);\n    }\n  }\n}\nfunction detectChangesInComponent(hostLView, componentHostIdx, mode) {\n  ngDevMode && assertEqual(isCreationMode(hostLView), false, \"Should be run in update mode\");\n  profiler(\n    18\n    /* ProfilerEvent.ComponentStart */\n  );\n  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);\n  detectChangesInViewIfAttached(componentView, mode);\n  profiler(19, componentView[CONTEXT]);\n}\nfunction detectChangesInViewIfAttached(lView, mode) {\n  if (!viewAttachedToChangeDetector(lView)) {\n    return;\n  }\n  detectChangesInView(lView, mode);\n}\nfunction detectChangesInView(lView, mode) {\n  const isInCheckNoChangesPass = ngDevMode && isInCheckNoChangesMode();\n  const tView = lView[TVIEW];\n  const flags = lView[FLAGS];\n  const consumer = lView[REACTIVE_TEMPLATE_CONSUMER];\n  let shouldRefreshView = !!(mode === 0 && flags & 16);\n  shouldRefreshView ||= !!(flags & 64 && mode === 0 && !isInCheckNoChangesPass);\n  shouldRefreshView ||= !!(flags & 1024);\n  shouldRefreshView ||= !!(consumer?.dirty && consumerPollProducersForChange(consumer));\n  shouldRefreshView ||= !!(ngDevMode && isExhaustiveCheckNoChanges());\n  if (consumer) {\n    consumer.dirty = false;\n  }\n  lView[FLAGS] &= -9217;\n  if (shouldRefreshView) {\n    refreshView(tView, lView, tView.template, lView[CONTEXT]);\n  } else if (flags & 8192) {\n    if (!isInCheckNoChangesPass) {\n      runEffectsInView(lView);\n    }\n    detectChangesInEmbeddedViews(\n      lView,\n      1\n      /* ChangeDetectionMode.Targeted */\n    );\n    const components = tView.components;\n    if (components !== null) {\n      detectChangesInChildComponents(\n        lView,\n        components,\n        1\n        /* ChangeDetectionMode.Targeted */\n      );\n    }\n    if (!isInCheckNoChangesPass) {\n      addAfterRenderSequencesForView(lView);\n    }\n  }\n}\nfunction detectChangesInChildComponents(hostLView, components, mode) {\n  for (let i = 0; i < components.length; i++) {\n    detectChangesInComponent(hostLView, components[i], mode);\n  }\n}\nfunction processHostBindingOpCodes(tView, lView) {\n  const hostBindingOpCodes = tView.hostBindingOpCodes;\n  if (hostBindingOpCodes === null) return;\n  try {\n    for (let i = 0; i < hostBindingOpCodes.length; i++) {\n      const opCode = hostBindingOpCodes[i];\n      if (opCode < 0) {\n        setSelectedIndex(~opCode);\n      } else {\n        const directiveIdx = opCode;\n        const bindingRootIndx = hostBindingOpCodes[++i];\n        const hostBindingFn = hostBindingOpCodes[++i];\n        setBindingRootForHostBindings(bindingRootIndx, directiveIdx);\n        const context2 = lView[directiveIdx];\n        profiler(24, context2);\n        hostBindingFn(2, context2);\n        profiler(25, context2);\n      }\n    }\n  } finally {\n    setSelectedIndex(-1);\n  }\n}\nfunction markViewDirty(lView, source) {\n  const dirtyBitsToUse = isRefreshingViews() ? (\n    // When we are actively refreshing views, we only use the `Dirty` bit to mark a view\n    64\n  ) : (\n    // When we are not actively refreshing a view tree, it is absolutely\n    // valid to update state and mark views dirty. We use the `RefreshView` flag in this\n    // case to allow synchronously rerunning change detection. This applies today to\n    // afterRender hooks as well as animation listeners which execute after detecting\n    // changes in a view when the render factory flushes.\n    1024 | 64\n  );\n  lView[ENVIRONMENT].changeDetectionScheduler?.notify(source);\n  while (lView) {\n    lView[FLAGS] |= dirtyBitsToUse;\n    const parent = getLViewParent(lView);\n    if (isRootView(lView) && !parent) {\n      return lView;\n    }\n    lView = parent;\n  }\n  return null;\n}\nfunction createLContainer(hostNative, currentView, native, tNode) {\n  ngDevMode && assertLView(currentView);\n  const lContainer = [\n    hostNative,\n    // host native\n    true,\n    // Boolean `true` in this position signifies that this is an `LContainer`\n    0,\n    // flags\n    currentView,\n    // parent\n    null,\n    // next\n    tNode,\n    // t_host\n    null,\n    // dehydrated views\n    native,\n    // native,\n    null,\n    // view refs\n    null\n    // moved views\n  ];\n  ngDevMode && assertEqual(lContainer.length, CONTAINER_HEADER_OFFSET, \"Should allocate correct number of slots for LContainer header.\");\n  return lContainer;\n}\nfunction getLViewFromLContainer(lContainer, index) {\n  const adjustedIndex = CONTAINER_HEADER_OFFSET + index;\n  if (adjustedIndex < lContainer.length) {\n    const lView = lContainer[adjustedIndex];\n    ngDevMode && assertLView(lView);\n    return lView;\n  }\n  return void 0;\n}\nfunction addLViewToLContainer(lContainer, lView, index, addToDOM = true) {\n  const tView = lView[TVIEW];\n  insertView(tView, lView, lContainer, index);\n  if (addToDOM) {\n    const beforeNode = getBeforeNodeForView(index, lContainer);\n    const renderer = lView[RENDERER];\n    const parentRNode = renderer.parentNode(lContainer[NATIVE]);\n    if (parentRNode !== null) {\n      addViewToDOM(tView, lContainer[T_HOST], renderer, lView, parentRNode, beforeNode);\n    }\n  }\n  const hydrationInfo = lView[HYDRATION];\n  if (hydrationInfo !== null && hydrationInfo.firstChild !== null) {\n    hydrationInfo.firstChild = null;\n  }\n}\nfunction removeLViewFromLContainer(lContainer, index) {\n  const lView = detachView(lContainer, index);\n  if (lView !== void 0) {\n    destroyLView(lView[TVIEW], lView);\n  }\n  return lView;\n}\nfunction detachView(lContainer, removeIndex) {\n  if (lContainer.length <= CONTAINER_HEADER_OFFSET) return;\n  const indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex;\n  const viewToDetach = lContainer[indexInContainer];\n  if (viewToDetach) {\n    const declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];\n    if (declarationLContainer !== null && declarationLContainer !== lContainer) {\n      detachMovedView(declarationLContainer, viewToDetach);\n    }\n    if (removeIndex > 0) {\n      lContainer[indexInContainer - 1][NEXT] = viewToDetach[NEXT];\n    }\n    const removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);\n    removeViewFromDOM(viewToDetach[TVIEW], viewToDetach);\n    const lQueries = removedLView[QUERIES];\n    if (lQueries !== null) {\n      lQueries.detachView(removedLView[TVIEW]);\n    }\n    viewToDetach[PARENT] = null;\n    viewToDetach[NEXT] = null;\n    viewToDetach[FLAGS] &= -129;\n  }\n  return viewToDetach;\n}\nfunction insertView(tView, lView, lContainer, index) {\n  ngDevMode && assertLView(lView);\n  ngDevMode && assertLContainer(lContainer);\n  const indexInContainer = CONTAINER_HEADER_OFFSET + index;\n  const containerLength = lContainer.length;\n  if (index > 0) {\n    lContainer[indexInContainer - 1][NEXT] = lView;\n  }\n  if (index < containerLength - CONTAINER_HEADER_OFFSET) {\n    lView[NEXT] = lContainer[indexInContainer];\n    addToArray(lContainer, CONTAINER_HEADER_OFFSET + index, lView);\n  } else {\n    lContainer.push(lView);\n    lView[NEXT] = null;\n  }\n  lView[PARENT] = lContainer;\n  const declarationLContainer = lView[DECLARATION_LCONTAINER];\n  if (declarationLContainer !== null && lContainer !== declarationLContainer) {\n    trackMovedView(declarationLContainer, lView);\n  }\n  const lQueries = lView[QUERIES];\n  if (lQueries !== null) {\n    lQueries.insertView(tView);\n  }\n  updateAncestorTraversalFlagsOnAttach(lView);\n  lView[FLAGS] |= 128;\n}\nfunction trackMovedView(declarationContainer, lView) {\n  ngDevMode && assertDefined(lView, \"LView required\");\n  ngDevMode && assertLContainer(declarationContainer);\n  const movedViews = declarationContainer[MOVED_VIEWS];\n  const parent = lView[PARENT];\n  ngDevMode && assertDefined(parent, \"missing parent\");\n  if (isLView(parent)) {\n    declarationContainer[FLAGS] |= 2;\n  } else {\n    const insertedComponentLView = parent[PARENT][DECLARATION_COMPONENT_VIEW];\n    ngDevMode && assertDefined(insertedComponentLView, \"Missing insertedComponentLView\");\n    const declaredComponentLView = lView[DECLARATION_COMPONENT_VIEW];\n    ngDevMode && assertDefined(declaredComponentLView, \"Missing declaredComponentLView\");\n    if (declaredComponentLView !== insertedComponentLView) {\n      declarationContainer[FLAGS] |= 2;\n    }\n  }\n  if (movedViews === null) {\n    declarationContainer[MOVED_VIEWS] = [lView];\n  } else {\n    movedViews.push(lView);\n  }\n}\nvar ViewRef$1 = class ViewRef {\n  _lView;\n  _cdRefInjectingView;\n  notifyErrorHandler;\n  _appRef = null;\n  _attachedToViewContainer = false;\n  get rootNodes() {\n    const lView = this._lView;\n    const tView = lView[TVIEW];\n    return collectNativeNodes(tView, lView, tView.firstChild, []);\n  }\n  constructor(_lView, _cdRefInjectingView, notifyErrorHandler = true) {\n    this._lView = _lView;\n    this._cdRefInjectingView = _cdRefInjectingView;\n    this.notifyErrorHandler = notifyErrorHandler;\n  }\n  get context() {\n    return this._lView[CONTEXT];\n  }\n  /**\n   * @deprecated Replacing the full context object is not supported. Modify the context\n   *   directly, or consider using a `Proxy` if you need to replace the full object.\n   * // TODO(devversion): Remove this.\n   */\n  set context(value) {\n    if (ngDevMode) {\n      console.warn(\"Angular: Replacing the `context` object of an `EmbeddedViewRef` is deprecated.\");\n    }\n    this._lView[CONTEXT] = value;\n  }\n  get destroyed() {\n    return isDestroyed(this._lView);\n  }\n  destroy() {\n    if (this._appRef) {\n      this._appRef.detachView(this);\n    } else if (this._attachedToViewContainer) {\n      const parent = this._lView[PARENT];\n      if (isLContainer(parent)) {\n        const viewRefs = parent[VIEW_REFS];\n        const index = viewRefs ? viewRefs.indexOf(this) : -1;\n        if (index > -1) {\n          ngDevMode && assertEqual(index, parent.indexOf(this._lView) - CONTAINER_HEADER_OFFSET, \"An attached view should be in the same position within its container as its ViewRef in the VIEW_REFS array.\");\n          detachView(parent, index);\n          removeFromArray(viewRefs, index);\n        }\n      }\n      this._attachedToViewContainer = false;\n    }\n    destroyLView(this._lView[TVIEW], this._lView);\n  }\n  onDestroy(callback) {\n    storeLViewOnDestroy(this._lView, callback);\n  }\n  /**\n   * Marks a view and all of its ancestors dirty.\n   *\n   * This can be used to ensure an {@link ChangeDetectionStrategy#OnPush} component is\n   * checked when it needs to be re-rendered but the two normal triggers haven't marked it\n   * dirty (i.e. inputs haven't changed and events haven't fired in the view).\n   *\n   * <!-- TODO: Add a link to a chapter on OnPush components -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * ```ts\n   * @Component({\n   *   selector: 'app-root',\n   *   template: `Number of ticks: {{numberOfTicks}}`\n   *   changeDetection: ChangeDetectionStrategy.OnPush,\n   * })\n   * class AppComponent {\n   *   numberOfTicks = 0;\n   *\n   *   constructor(private ref: ChangeDetectorRef) {\n   *     setInterval(() => {\n   *       this.numberOfTicks++;\n   *       // the following is required, otherwise the view will not be updated\n   *       this.ref.markForCheck();\n   *     }, 1000);\n   *   }\n   * }\n   * ```\n   */\n  markForCheck() {\n    markViewDirty(\n      this._cdRefInjectingView || this._lView,\n      4\n      /* NotificationSource.MarkForCheck */\n    );\n  }\n  /**\n   * Detaches the view from the change detection tree.\n   *\n   * Detached views will not be checked during change detection runs until they are\n   * re-attached, even if they are dirty. `detach` can be used in combination with\n   * {@link ChangeDetectorRef#detectChanges} to implement local change\n   * detection checks.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example defines a component with a large list of readonly data.\n   * Imagine the data changes constantly, many times per second. For performance reasons,\n   * we want to check and update the list every five seconds. We can do that by detaching\n   * the component's change detector and doing a local check every five seconds.\n   *\n   * ```ts\n   * class DataProvider {\n   *   // in a real application the returned data will be different every time\n   *   get data() {\n   *     return [1,2,3,4,5];\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'giant-list',\n   *   template: `\n   *     <li *ngFor=\"let d of dataProvider.data\">Data {{d}}</li>\n   *   `,\n   * })\n   * class GiantList {\n   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {\n   *     ref.detach();\n   *     setInterval(() => {\n   *       this.ref.detectChanges();\n   *     }, 5000);\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'app',\n   *   providers: [DataProvider],\n   *   template: `\n   *     <giant-list><giant-list>\n   *   `,\n   * })\n   * class App {\n   * }\n   * ```\n   */\n  detach() {\n    this._lView[FLAGS] &= -129;\n  }\n  /**\n   * Re-attaches a view to the change detection tree.\n   *\n   * This can be used to re-attach views that were previously detached from the tree\n   * using {@link ChangeDetectorRef#detach}. Views are attached to the tree by default.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example creates a component displaying `live` data. The component will detach\n   * its change detector from the main change detector tree when the component's live property\n   * is set to false.\n   *\n   * ```ts\n   * class DataProvider {\n   *   data = 1;\n   *\n   *   constructor() {\n   *     setInterval(() => {\n   *       this.data = this.data * 2;\n   *     }, 500);\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'live-data',\n   *   inputs: ['live'],\n   *   template: 'Data: {{dataProvider.data}}'\n   * })\n   * class LiveData {\n   *   constructor(private ref: ChangeDetectorRef, private dataProvider: DataProvider) {}\n   *\n   *   set live(value) {\n   *     if (value) {\n   *       this.ref.reattach();\n   *     } else {\n   *       this.ref.detach();\n   *     }\n   *   }\n   * }\n   *\n   * @Component({\n   *   selector: 'app-root',\n   *   providers: [DataProvider],\n   *   template: `\n   *     Live Update: <input type=\"checkbox\" [(ngModel)]=\"live\">\n   *     <live-data [live]=\"live\"><live-data>\n   *   `,\n   * })\n   * class AppComponent {\n   *   live = true;\n   * }\n   * ```\n   */\n  reattach() {\n    updateAncestorTraversalFlagsOnAttach(this._lView);\n    this._lView[FLAGS] |= 128;\n  }\n  /**\n   * Checks the view and its children.\n   *\n   * This can also be used in combination with {@link ChangeDetectorRef#detach} to implement\n   * local change detection checks.\n   *\n   * <!-- TODO: Add a link to a chapter on detach/reattach/local digest -->\n   * <!-- TODO: Add a live demo once ref.detectChanges is merged into master -->\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example defines a component with a large list of readonly data.\n   * Imagine, the data changes constantly, many times per second. For performance reasons,\n   * we want to check and update the list every five seconds.\n   *\n   * We can do that by detaching the component's change detector and doing a local change detection\n   * check every five seconds.\n   *\n   * See {@link ChangeDetectorRef#detach} for more information.\n   */\n  detectChanges() {\n    this._lView[FLAGS] |= 1024;\n    detectChangesInternal(this._lView, this.notifyErrorHandler);\n  }\n  /**\n   * Checks the change detector and its children, and throws if any changes are detected.\n   *\n   * This is used in development mode to verify that running change detection doesn't\n   * introduce other changes.\n   */\n  checkNoChanges() {\n    if (ngDevMode) {\n      checkNoChangesInternal(this._lView, CheckNoChangesMode.OnlyDirtyViews, this.notifyErrorHandler);\n    }\n  }\n  attachToViewContainerRef() {\n    if (this._appRef) {\n      throw new RuntimeError(902, ngDevMode && \"This view is already attached directly to the ApplicationRef!\");\n    }\n    this._attachedToViewContainer = true;\n  }\n  detachFromAppRef() {\n    this._appRef = null;\n    const isRoot = isRootView(this._lView);\n    const declarationContainer = this._lView[DECLARATION_LCONTAINER];\n    if (declarationContainer !== null && !isRoot) {\n      detachMovedView(declarationContainer, this._lView);\n    }\n    detachViewFromDOM(this._lView[TVIEW], this._lView);\n  }\n  attachToAppRef(appRef) {\n    if (this._attachedToViewContainer) {\n      throw new RuntimeError(902, ngDevMode && \"This view is already attached to a ViewContainer!\");\n    }\n    this._appRef = appRef;\n    const isRoot = isRootView(this._lView);\n    const declarationContainer = this._lView[DECLARATION_LCONTAINER];\n    if (declarationContainer !== null && !isRoot) {\n      trackMovedView(declarationContainer, this._lView);\n    }\n    updateAncestorTraversalFlagsOnAttach(this._lView);\n  }\n};\nvar TemplateRef = class {\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ELEMENT_ID__ = injectTemplateRef;\n};\nvar ViewEngineTemplateRef = TemplateRef;\nvar R3TemplateRef = class TemplateRef2 extends ViewEngineTemplateRef {\n  _declarationLView;\n  _declarationTContainer;\n  elementRef;\n  constructor(_declarationLView, _declarationTContainer, elementRef) {\n    super();\n    this._declarationLView = _declarationLView;\n    this._declarationTContainer = _declarationTContainer;\n    this.elementRef = elementRef;\n  }\n  /**\n   * Returns an `ssrId` associated with a TView, which was used to\n   * create this instance of the `TemplateRef`.\n   *\n   * @internal\n   */\n  get ssrId() {\n    return this._declarationTContainer.tView?.ssrId || null;\n  }\n  createEmbeddedView(context2, injector) {\n    return this.createEmbeddedViewImpl(context2, injector);\n  }\n  /**\n   * @internal\n   */\n  createEmbeddedViewImpl(context2, injector, dehydratedView) {\n    const embeddedLView = createAndRenderEmbeddedLView(this._declarationLView, this._declarationTContainer, context2, {\n      embeddedViewInjector: injector,\n      dehydratedView\n    });\n    return new ViewRef$1(embeddedLView);\n  }\n};\nfunction injectTemplateRef() {\n  return createTemplateRef(getCurrentTNode(), getLView());\n}\nfunction createTemplateRef(hostTNode, hostLView) {\n  if (hostTNode.type & 4) {\n    ngDevMode && assertDefined(hostTNode.tView, \"TView must be allocated\");\n    return new R3TemplateRef(hostLView, hostTNode, createElementRef(hostTNode, hostLView));\n  }\n  return null;\n}\nvar AT_THIS_LOCATION = \"<-- AT THIS LOCATION\";\nfunction getFriendlyStringFromTNodeType(tNodeType) {\n  switch (tNodeType) {\n    case 4:\n      return \"view container\";\n    case 2:\n      return \"element\";\n    case 8:\n      return \"ng-container\";\n    case 32:\n      return \"icu\";\n    case 64:\n      return \"i18n\";\n    case 16:\n      return \"projection\";\n    case 1:\n      return \"text\";\n    case 128:\n      return \"@let\";\n    default:\n      return \"<unknown>\";\n  }\n}\nfunction validateSiblingNodeExists(node) {\n  validateNodeExists(node);\n  if (!node.nextSibling) {\n    const header = \"During hydration Angular expected more sibling nodes to be present.\\n\\n\";\n    const actual = `Actual DOM is:\n\n${describeDomFromNode(node)}\n\n`;\n    const footer = getHydrationErrorFooter();\n    const message = header + actual + footer;\n    markRNodeAsHavingHydrationMismatch(node, \"\", actual);\n    throw new RuntimeError(-501, message);\n  }\n}\nfunction validateNodeExists(node, lView = null, tNode = null) {\n  if (!node) {\n    const header = \"During hydration, Angular expected an element to be present at this location.\\n\\n\";\n    let expected = \"\";\n    let footer = \"\";\n    if (lView !== null && tNode !== null) {\n      expected = describeExpectedDom(lView, tNode, false);\n      footer = getHydrationErrorFooter();\n      markRNodeAsHavingHydrationMismatch(unwrapRNode(lView[HOST]), expected, \"\");\n    }\n    throw new RuntimeError(-502, `${header}${expected}\n\n${footer}`);\n  }\n}\nfunction stringifyTNodeAttrs(tNode) {\n  const results = [];\n  if (tNode.attrs) {\n    for (let i = 0; i < tNode.attrs.length; ) {\n      const attrName = tNode.attrs[i++];\n      if (typeof attrName == \"number\") {\n        break;\n      }\n      const attrValue = tNode.attrs[i++];\n      results.push(`${attrName}=\"${shorten(attrValue)}\"`);\n    }\n  }\n  return results.join(\" \");\n}\nvar internalAttrs = /* @__PURE__ */ new Set([\"ngh\", \"ng-version\", \"ng-server-context\"]);\nfunction stringifyRNodeAttrs(rNode) {\n  const results = [];\n  for (let i = 0; i < rNode.attributes.length; i++) {\n    const attr = rNode.attributes[i];\n    if (internalAttrs.has(attr.name)) continue;\n    results.push(`${attr.name}=\"${shorten(attr.value)}\"`);\n  }\n  return results.join(\" \");\n}\nfunction describeTNode(tNode, innerContent = \"\\u2026\") {\n  switch (tNode.type) {\n    case 1:\n      const content = tNode.value ? `(${tNode.value})` : \"\";\n      return `#text${content}`;\n    case 2:\n      const attrs = stringifyTNodeAttrs(tNode);\n      const tag = tNode.value.toLowerCase();\n      return `<${tag}${attrs ? \" \" + attrs : \"\"}>${innerContent}</${tag}>`;\n    case 8:\n      return \"<!-- ng-container -->\";\n    case 4:\n      return \"<!-- container -->\";\n    default:\n      const typeAsString = getFriendlyStringFromTNodeType(tNode.type);\n      return `#node(${typeAsString})`;\n  }\n}\nfunction describeRNode(rNode, innerContent = \"\\u2026\") {\n  const node = rNode;\n  switch (node.nodeType) {\n    case Node.ELEMENT_NODE:\n      const tag = node.tagName.toLowerCase();\n      const attrs = stringifyRNodeAttrs(node);\n      return `<${tag}${attrs ? \" \" + attrs : \"\"}>${innerContent}</${tag}>`;\n    case Node.TEXT_NODE:\n      const content = node.textContent ? shorten(node.textContent) : \"\";\n      return `#text${content ? `(${content})` : \"\"}`;\n    case Node.COMMENT_NODE:\n      return `<!-- ${shorten(node.textContent ?? \"\")} -->`;\n    default:\n      return `#node(${node.nodeType})`;\n  }\n}\nfunction describeExpectedDom(lView, tNode, isViewContainerAnchor) {\n  const spacer = \"  \";\n  let content = \"\";\n  if (tNode.prev) {\n    content += spacer + \"\\u2026\\n\";\n    content += spacer + describeTNode(tNode.prev) + \"\\n\";\n  } else if (tNode.type && tNode.type & 12) {\n    content += spacer + \"\\u2026\\n\";\n  }\n  if (isViewContainerAnchor) {\n    content += spacer + describeTNode(tNode) + \"\\n\";\n    content += spacer + `<!-- container -->  ${AT_THIS_LOCATION}\n`;\n  } else {\n    content += spacer + describeTNode(tNode) + `  ${AT_THIS_LOCATION}\n`;\n  }\n  content += spacer + \"\\u2026\\n\";\n  const parentRNode = tNode.type ? getParentRElement(lView[TVIEW], tNode, lView) : null;\n  if (parentRNode) {\n    content = describeRNode(parentRNode, \"\\n\" + content);\n  }\n  return content;\n}\nfunction describeDomFromNode(node) {\n  const spacer = \"  \";\n  let content = \"\";\n  const currentNode = node;\n  if (currentNode.previousSibling) {\n    content += spacer + \"\\u2026\\n\";\n    content += spacer + describeRNode(currentNode.previousSibling) + \"\\n\";\n  }\n  content += spacer + describeRNode(currentNode) + `  ${AT_THIS_LOCATION}\n`;\n  if (node.nextSibling) {\n    content += spacer + \"\\u2026\\n\";\n  }\n  if (node.parentNode) {\n    content = describeRNode(currentNode.parentNode, \"\\n\" + content);\n  }\n  return content;\n}\nfunction getHydrationErrorFooter(componentClassName) {\n  const componentInfo = componentClassName ? `the \"${componentClassName}\"` : \"corresponding\";\n  return `To fix this problem:\n  * check ${componentInfo} component for hydration-related issues\n  * check to see if your template has valid HTML structure\n  * or skip hydration by adding the \\`ngSkipHydration\\` attribute to its host node in a template\n\n`;\n}\nfunction stripNewlines(input2) {\n  return input2.replace(/\\s+/gm, \"\");\n}\nfunction shorten(input2, maxLength = 50) {\n  if (!input2) {\n    return \"\";\n  }\n  input2 = stripNewlines(input2);\n  return input2.length > maxLength ? `${input2.substring(0, maxLength - 1)}\\u2026` : input2;\n}\nfunction getInsertInFrontOfRNodeWithI18n(parentTNode, currentTNode, lView) {\n  const tNodeInsertBeforeIndex = currentTNode.insertBeforeIndex;\n  const insertBeforeIndex = Array.isArray(tNodeInsertBeforeIndex) ? tNodeInsertBeforeIndex[0] : tNodeInsertBeforeIndex;\n  if (insertBeforeIndex === null) {\n    return getInsertInFrontOfRNodeWithNoI18n(parentTNode, currentTNode, lView);\n  } else {\n    ngDevMode && assertIndexInRange(lView, insertBeforeIndex);\n    return unwrapRNode(lView[insertBeforeIndex]);\n  }\n}\nfunction processI18nInsertBefore(renderer, childTNode, lView, childRNode, parentRElement) {\n  const tNodeInsertBeforeIndex = childTNode.insertBeforeIndex;\n  if (Array.isArray(tNodeInsertBeforeIndex)) {\n    ngDevMode && assertDomNode(childRNode);\n    let i18nParent = childRNode;\n    let anchorRNode = null;\n    if (!(childTNode.type & 3)) {\n      anchorRNode = i18nParent;\n      i18nParent = parentRElement;\n    }\n    if (i18nParent !== null && childTNode.componentOffset === -1) {\n      for (let i = 1; i < tNodeInsertBeforeIndex.length; i++) {\n        const i18nChild = lView[tNodeInsertBeforeIndex[i]];\n        nativeInsertBefore(renderer, i18nParent, i18nChild, anchorRNode, false);\n      }\n    }\n  }\n}\nfunction getOrCreateTNode(tView, index, type, name, attrs) {\n  ngDevMode && index !== 0 && // 0 are bogus nodes and they are OK. See `createContainerRef` in\n  // `view_engine_compatibility` for additional context.\n  assertGreaterThanOrEqual(index, HEADER_OFFSET, \"TNodes can't be in the LView header.\");\n  ngDevMode && assertPureTNodeType(type);\n  let tNode = tView.data[index];\n  if (tNode === null) {\n    tNode = createTNodeAtIndex(tView, index, type, name, attrs);\n    if (isInI18nBlock()) {\n      tNode.flags |= 32;\n    }\n  } else if (tNode.type & 64) {\n    tNode.type = type;\n    tNode.value = name;\n    tNode.attrs = attrs;\n    const parent = getCurrentParentTNode();\n    tNode.injectorIndex = parent === null ? -1 : parent.injectorIndex;\n    ngDevMode && assertTNodeForTView(tNode, tView);\n    ngDevMode && assertEqual(index, tNode.index, \"Expecting same index\");\n  }\n  setCurrentTNode(tNode, true);\n  return tNode;\n}\nfunction createTNodeAtIndex(tView, index, type, name, attrs) {\n  const currentTNode = getCurrentTNodePlaceholderOk();\n  const isParent = isCurrentTNodeParent();\n  const parent = isParent ? currentTNode : currentTNode && currentTNode.parent;\n  const tNode = tView.data[index] = createTNode(tView, parent, type, index, name, attrs);\n  linkTNodeInTView(tView, tNode, currentTNode, isParent);\n  return tNode;\n}\nfunction linkTNodeInTView(tView, tNode, currentTNode, isParent) {\n  if (tView.firstChild === null) {\n    tView.firstChild = tNode;\n  }\n  if (currentTNode !== null) {\n    if (isParent) {\n      if (currentTNode.child == null && tNode.parent !== null) {\n        currentTNode.child = tNode;\n      }\n    } else {\n      if (currentTNode.next === null) {\n        currentTNode.next = tNode;\n        tNode.prev = currentTNode;\n      }\n    }\n  }\n}\nfunction createTNode(tView, tParent, type, index, value, attrs) {\n  ngDevMode && index !== 0 && // 0 are bogus nodes and they are OK. See `createContainerRef` in\n  // `view_engine_compatibility` for additional context.\n  assertGreaterThanOrEqual(index, HEADER_OFFSET, \"TNodes can't be in the LView header.\");\n  ngDevMode && assertNotSame(attrs, void 0, \"'undefined' is not valid value for 'attrs'\");\n  ngDevMode && ngDevMode.tNode++;\n  ngDevMode && tParent && assertTNodeForTView(tParent, tView);\n  let injectorIndex = tParent ? tParent.injectorIndex : -1;\n  let flags = 0;\n  if (isInSkipHydrationBlock$1()) {\n    flags |= 128;\n  }\n  const tNode = {\n    type,\n    index,\n    insertBeforeIndex: null,\n    injectorIndex,\n    directiveStart: -1,\n    directiveEnd: -1,\n    directiveStylingLast: -1,\n    componentOffset: -1,\n    propertyBindings: null,\n    flags,\n    providerIndexes: 0,\n    value,\n    attrs,\n    mergedAttrs: null,\n    localNames: null,\n    initialInputs: null,\n    inputs: null,\n    hostDirectiveInputs: null,\n    outputs: null,\n    hostDirectiveOutputs: null,\n    directiveToIndex: null,\n    tView: null,\n    next: null,\n    prev: null,\n    projectionNext: null,\n    child: null,\n    parent: tParent,\n    projection: null,\n    styles: null,\n    stylesWithoutHost: null,\n    residualStyles: void 0,\n    classes: null,\n    classesWithoutHost: null,\n    residualClasses: void 0,\n    classBindings: 0,\n    styleBindings: 0\n  };\n  if (ngDevMode) {\n    Object.seal(tNode);\n  }\n  return tNode;\n}\nfunction addTNodeAndUpdateInsertBeforeIndex(previousTNodes, newTNode) {\n  ngDevMode && assertEqual(newTNode.insertBeforeIndex, null, \"We expect that insertBeforeIndex is not set\");\n  previousTNodes.push(newTNode);\n  if (previousTNodes.length > 1) {\n    for (let i = previousTNodes.length - 2; i >= 0; i--) {\n      const existingTNode = previousTNodes[i];\n      if (!isI18nText(existingTNode)) {\n        if (isNewTNodeCreatedBefore(existingTNode, newTNode) && getInsertBeforeIndex(existingTNode) === null) {\n          setInsertBeforeIndex(existingTNode, newTNode.index);\n        }\n      }\n    }\n  }\n}\nfunction isI18nText(tNode) {\n  return !(tNode.type & 64);\n}\nfunction isNewTNodeCreatedBefore(existingTNode, newTNode) {\n  return isI18nText(newTNode) || existingTNode.index > newTNode.index;\n}\nfunction getInsertBeforeIndex(tNode) {\n  const index = tNode.insertBeforeIndex;\n  return Array.isArray(index) ? index[0] : index;\n}\nfunction setInsertBeforeIndex(tNode, value) {\n  const index = tNode.insertBeforeIndex;\n  if (Array.isArray(index)) {\n    index[0] = value;\n  } else {\n    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);\n    tNode.insertBeforeIndex = value;\n  }\n}\nfunction getTIcu(tView, index) {\n  const value = tView.data[index];\n  if (value === null || typeof value === \"string\") return null;\n  if (ngDevMode && !(value.hasOwnProperty(\"tView\") || value.hasOwnProperty(\"currentCaseLViewIndex\"))) {\n    throwError2(\"We expect to get 'null'|'TIcu'|'TIcuContainer', but got: \" + value);\n  }\n  const tIcu = value.hasOwnProperty(\"currentCaseLViewIndex\") ? value : value.value;\n  ngDevMode && assertTIcu(tIcu);\n  return tIcu;\n}\nfunction setTIcu(tView, index, tIcu) {\n  const tNode = tView.data[index];\n  ngDevMode && assertEqual(tNode === null || tNode.hasOwnProperty(\"tView\"), true, \"We expect to get 'null'|'TIcuContainer'\");\n  if (tNode === null) {\n    tView.data[index] = tIcu;\n  } else {\n    ngDevMode && assertTNodeType(\n      tNode,\n      32\n      /* TNodeType.Icu */\n    );\n    tNode.value = tIcu;\n  }\n}\nfunction setTNodeInsertBeforeIndex(tNode, index) {\n  ngDevMode && assertTNode(tNode);\n  let insertBeforeIndex = tNode.insertBeforeIndex;\n  if (insertBeforeIndex === null) {\n    setI18nHandling(getInsertInFrontOfRNodeWithI18n, processI18nInsertBefore);\n    insertBeforeIndex = tNode.insertBeforeIndex = [null, index];\n  } else {\n    assertEqual(Array.isArray(insertBeforeIndex), true, \"Expecting array here\");\n    insertBeforeIndex.push(index);\n  }\n}\nfunction createTNodePlaceholder(tView, previousTNodes, index) {\n  const tNode = createTNodeAtIndex(tView, index, 64, null, null);\n  addTNodeAndUpdateInsertBeforeIndex(previousTNodes, tNode);\n  return tNode;\n}\nfunction getCurrentICUCaseIndex(tIcu, lView) {\n  const currentCase = lView[tIcu.currentCaseLViewIndex];\n  return currentCase === null ? currentCase : currentCase < 0 ? ~currentCase : currentCase;\n}\nfunction getParentFromIcuCreateOpCode(mergedCode) {\n  return mergedCode >>> 17;\n}\nfunction getRefFromIcuCreateOpCode(mergedCode) {\n  return (mergedCode & 131070) >>> 1;\n}\nfunction getInstructionFromIcuCreateOpCode(mergedCode) {\n  return mergedCode & 1;\n}\nfunction icuCreateOpCode(opCode, parentIdx, refIdx) {\n  ngDevMode && assertGreaterThanOrEqual(parentIdx, 0, \"Missing parent index\");\n  ngDevMode && assertGreaterThan(refIdx, 0, \"Missing ref index\");\n  return opCode | parentIdx << 17 | refIdx << 1;\n}\nfunction isRootTemplateMessage(subTemplateIndex) {\n  return subTemplateIndex === -1;\n}\nfunction enterIcu(state, tIcu, lView) {\n  state.index = 0;\n  const currentCase = getCurrentICUCaseIndex(tIcu, lView);\n  if (currentCase !== null) {\n    ngDevMode && assertNumberInRange(currentCase, 0, tIcu.cases.length - 1);\n    state.removes = tIcu.remove[currentCase];\n  } else {\n    state.removes = EMPTY_ARRAY;\n  }\n}\nfunction icuContainerIteratorNext(state) {\n  if (state.index < state.removes.length) {\n    const removeOpCode = state.removes[state.index++];\n    ngDevMode && assertNumber(removeOpCode, \"Expecting OpCode number\");\n    if (removeOpCode > 0) {\n      const rNode = state.lView[removeOpCode];\n      ngDevMode && assertDomNode(rNode);\n      return rNode;\n    } else {\n      state.stack.push(state.index, state.removes);\n      const tIcuIndex = ~removeOpCode;\n      const tIcu = state.lView[TVIEW].data[tIcuIndex];\n      ngDevMode && assertTIcu(tIcu);\n      enterIcu(state, tIcu, state.lView);\n      return icuContainerIteratorNext(state);\n    }\n  } else {\n    if (state.stack.length === 0) {\n      return null;\n    } else {\n      state.removes = state.stack.pop();\n      state.index = state.stack.pop();\n      return icuContainerIteratorNext(state);\n    }\n  }\n}\nfunction loadIcuContainerVisitor() {\n  const _state = {\n    stack: [],\n    index: -1\n  };\n  function icuContainerIteratorStart(tIcuContainerNode, lView) {\n    _state.lView = lView;\n    while (_state.stack.length) _state.stack.pop();\n    ngDevMode && assertTNodeForLView(tIcuContainerNode, lView);\n    enterIcu(_state, tIcuContainerNode.value, lView);\n    return icuContainerIteratorNext.bind(null, _state);\n  }\n  return icuContainerIteratorStart;\n}\nvar REF_EXTRACTOR_REGEXP = /* @__PURE__ */ new RegExp(`^(\\\\d+)*(${REFERENCE_NODE_BODY}|${REFERENCE_NODE_HOST})*(.*)`);\nvar _prepareI18nBlockForHydrationImpl = () => {\n};\nfunction prepareI18nBlockForHydration(lView, index, parentTNode, subTemplateIndex) {\n  _prepareI18nBlockForHydrationImpl(lView, index, parentTNode, subTemplateIndex);\n}\nvar _claimDehydratedIcuCaseImpl = () => {\n};\nfunction claimDehydratedIcuCase(lView, icuIndex, caseIndex) {\n  _claimDehydratedIcuCaseImpl(lView, icuIndex, caseIndex);\n}\nfunction cleanupI18nHydrationData(lView) {\n  const hydrationInfo = lView[HYDRATION];\n  if (hydrationInfo) {\n    const {\n      i18nNodes,\n      dehydratedIcuData: dehydratedIcuDataMap\n    } = hydrationInfo;\n    if (i18nNodes && dehydratedIcuDataMap) {\n      const renderer = lView[RENDERER];\n      for (const dehydratedIcuData of dehydratedIcuDataMap.values()) {\n        cleanupDehydratedIcuData(renderer, i18nNodes, dehydratedIcuData);\n      }\n    }\n    hydrationInfo.i18nNodes = void 0;\n    hydrationInfo.dehydratedIcuData = void 0;\n  }\n}\nfunction cleanupDehydratedIcuData(renderer, i18nNodes, dehydratedIcuData) {\n  for (const node of dehydratedIcuData.node.cases[dehydratedIcuData.case]) {\n    const rNode = i18nNodes.get(node.index - HEADER_OFFSET);\n    if (rNode) {\n      nativeRemoveNode(renderer, rNode, false);\n    }\n  }\n}\nfunction removeDehydratedViews(lContainer) {\n  const views = lContainer[DEHYDRATED_VIEWS] ?? [];\n  const parentLView = lContainer[PARENT];\n  const renderer = parentLView[RENDERER];\n  const retainedViews = [];\n  for (const view of views) {\n    if (view.data[DEFER_BLOCK_ID] !== void 0) {\n      retainedViews.push(view);\n    } else {\n      removeDehydratedView(view, renderer);\n      ngDevMode && ngDevMode.dehydratedViewsRemoved++;\n    }\n  }\n  lContainer[DEHYDRATED_VIEWS] = retainedViews;\n}\nfunction removeDehydratedViewList(deferBlock) {\n  const {\n    lContainer\n  } = deferBlock;\n  const dehydratedViews = lContainer[DEHYDRATED_VIEWS];\n  if (dehydratedViews === null) return;\n  const parentLView = lContainer[PARENT];\n  const renderer = parentLView[RENDERER];\n  for (const view of dehydratedViews) {\n    removeDehydratedView(view, renderer);\n    ngDevMode && ngDevMode.dehydratedViewsRemoved++;\n  }\n}\nfunction removeDehydratedView(dehydratedView, renderer) {\n  let nodesRemoved = 0;\n  let currentRNode = dehydratedView.firstChild;\n  if (currentRNode) {\n    const numNodes = dehydratedView.data[NUM_ROOT_NODES];\n    while (nodesRemoved < numNodes) {\n      ngDevMode && validateSiblingNodeExists(currentRNode);\n      const nextSibling = currentRNode.nextSibling;\n      nativeRemoveNode(renderer, currentRNode, false);\n      currentRNode = nextSibling;\n      nodesRemoved++;\n    }\n  }\n}\nfunction cleanupLContainer(lContainer) {\n  removeDehydratedViews(lContainer);\n  const hostLView = lContainer[HOST];\n  if (isLView(hostLView)) {\n    cleanupLView(hostLView);\n  }\n  for (let i = CONTAINER_HEADER_OFFSET; i < lContainer.length; i++) {\n    cleanupLView(lContainer[i]);\n  }\n}\nfunction cleanupLView(lView) {\n  cleanupI18nHydrationData(lView);\n  const tView = lView[TVIEW];\n  for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {\n    if (isLContainer(lView[i])) {\n      const lContainer = lView[i];\n      cleanupLContainer(lContainer);\n    } else if (isLView(lView[i])) {\n      cleanupLView(lView[i]);\n    }\n  }\n}\nfunction cleanupDehydratedViews(appRef) {\n  const viewRefs = appRef._views;\n  for (const viewRef of viewRefs) {\n    const lNode = getLNodeForHydration(viewRef);\n    if (lNode !== null && lNode[HOST] !== null) {\n      if (isLView(lNode)) {\n        cleanupLView(lNode);\n      } else {\n        cleanupLContainer(lNode);\n      }\n      ngDevMode && ngDevMode.dehydratedViewsCleanupRuns++;\n    }\n  }\n}\nfunction cleanupHydratedDeferBlocks(deferBlock, hydratedBlocks, registry, appRef) {\n  if (deferBlock !== null) {\n    registry.cleanup(hydratedBlocks);\n    cleanupLContainer(deferBlock.lContainer);\n    cleanupDehydratedViews(appRef);\n  }\n}\nvar _findMatchingDehydratedViewImpl = () => null;\nfunction findMatchingDehydratedView(lContainer, template) {\n  return _findMatchingDehydratedViewImpl(lContainer, template);\n}\nvar ComponentRef$1 = class ComponentRef {\n};\nvar ComponentFactory$1 = class ComponentFactory {\n};\nvar _NullComponentFactoryResolver = class {\n  resolveComponentFactory(component) {\n    throw Error(`No component factory found for ${stringify(component)}.`);\n  }\n};\nvar ComponentFactoryResolver$1 = class ComponentFactoryResolver {\n  static NULL = new _NullComponentFactoryResolver();\n};\nvar RendererFactory2 = class {\n};\nvar Renderer2 = class {\n  /**\n   * If null or undefined, the view engine won't call it.\n   * This is used as a performance optimization for production mode.\n   */\n  destroyNode = null;\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ELEMENT_ID__ = () => injectRenderer2();\n};\nfunction injectRenderer2() {\n  const lView = getLView();\n  const tNode = getCurrentTNode();\n  const nodeAtIndex = getComponentLViewByIndex(tNode.index, lView);\n  return (isLView(nodeAtIndex) ? nodeAtIndex : lView)[RENDERER];\n}\nvar Sanitizer = class _Sanitizer {\n  /** @nocollapse */\n  static \\u0275prov = (\n    /** @pureOrBreakMyCode */\n    /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n      token: _Sanitizer,\n      providedIn: \"root\",\n      factory: () => null\n    })\n  );\n};\nfunction isModuleWithProviders(value) {\n  return value.ngModule !== void 0;\n}\nfunction isNgModule(value) {\n  return !!getNgModuleDef(value);\n}\nfunction isPipe(value) {\n  return !!getPipeDef$1(value);\n}\nfunction isDirective(value) {\n  return !!getDirectiveDef(value);\n}\nfunction isComponent(value) {\n  return !!getComponentDef(value);\n}\nfunction getDependencyTypeForError(type) {\n  if (getComponentDef(type)) return \"component\";\n  if (getDirectiveDef(type)) return \"directive\";\n  if (getPipeDef$1(type)) return \"pipe\";\n  return \"type\";\n}\nfunction verifyStandaloneImport(depType, importingType) {\n  if (isForwardRef(depType)) {\n    depType = resolveForwardRef(depType);\n    if (!depType) {\n      throw new Error(`Expected forwardRef function, imported from \"${stringifyForError(importingType)}\", to return a standalone entity or NgModule but got \"${stringifyForError(depType) || depType}\".`);\n    }\n  }\n  if (getNgModuleDef(depType) == null) {\n    const def = getComponentDef(depType) || getDirectiveDef(depType) || getPipeDef$1(depType);\n    if (def != null) {\n      if (!def.standalone) {\n        throw new Error(`The \"${stringifyForError(depType)}\" ${getDependencyTypeForError(depType)}, imported from \"${stringifyForError(importingType)}\", is not standalone. Did you forget to add the standalone: true flag?`);\n      }\n    } else {\n      if (isModuleWithProviders(depType)) {\n        throw new Error(`A module with providers was imported from \"${stringifyForError(importingType)}\". Modules with providers are not supported in standalone components imports.`);\n      } else {\n        throw new Error(`The \"${stringifyForError(depType)}\" type, imported from \"${stringifyForError(importingType)}\", must be a standalone component / directive / pipe or an NgModule. Did you forget to add the required @Component / @Directive / @Pipe or @NgModule annotation?`);\n      }\n    }\n  }\n}\nvar DepsTracker = class {\n  ownerNgModule = /* @__PURE__ */ new Map();\n  ngModulesWithSomeUnresolvedDecls = /* @__PURE__ */ new Set();\n  ngModulesScopeCache = /* @__PURE__ */ new Map();\n  standaloneComponentsScopeCache = /* @__PURE__ */ new Map();\n  /**\n   * Attempts to resolve ng module's forward ref declarations as much as possible and add them to\n   * the `ownerNgModule` map. This method normally should be called after the initial parsing when\n   * all the forward refs are resolved (e.g., when trying to render a component)\n   */\n  resolveNgModulesDecls() {\n    if (this.ngModulesWithSomeUnresolvedDecls.size === 0) {\n      return;\n    }\n    for (const moduleType of this.ngModulesWithSomeUnresolvedDecls) {\n      const def = getNgModuleDef(moduleType);\n      if (def?.declarations) {\n        for (const decl of maybeUnwrapFn(def.declarations)) {\n          if (isComponent(decl)) {\n            this.ownerNgModule.set(decl, moduleType);\n          }\n        }\n      }\n    }\n    this.ngModulesWithSomeUnresolvedDecls.clear();\n  }\n  /** @override */\n  getComponentDependencies(type, rawImports) {\n    this.resolveNgModulesDecls();\n    const def = getComponentDef(type);\n    if (def === null) {\n      throw new Error(`Attempting to get component dependencies for a type that is not a component: ${type}`);\n    }\n    if (def.standalone) {\n      const scope = this.getStandaloneComponentScope(type, rawImports);\n      if (scope.compilation.isPoisoned) {\n        return {\n          dependencies: []\n        };\n      }\n      return {\n        dependencies: [...scope.compilation.directives, ...scope.compilation.pipes, ...scope.compilation.ngModules]\n      };\n    } else {\n      if (!this.ownerNgModule.has(type)) {\n        return {\n          dependencies: []\n        };\n      }\n      const scope = this.getNgModuleScope(this.ownerNgModule.get(type));\n      if (scope.compilation.isPoisoned) {\n        return {\n          dependencies: []\n        };\n      }\n      return {\n        dependencies: [...scope.compilation.directives, ...scope.compilation.pipes]\n      };\n    }\n  }\n  /**\n   * @override\n   * This implementation does not make use of param scopeInfo since it assumes the scope info is\n   * already added to the type itself through methods like {@link ɵɵsetNgModuleScope}\n   */\n  registerNgModule(type, scopeInfo) {\n    if (!isNgModule(type)) {\n      throw new Error(`Attempting to register a Type which is not NgModule as NgModule: ${type}`);\n    }\n    this.ngModulesWithSomeUnresolvedDecls.add(type);\n  }\n  /** @override */\n  clearScopeCacheFor(type) {\n    this.ngModulesScopeCache.delete(type);\n    this.standaloneComponentsScopeCache.delete(type);\n  }\n  /** @override */\n  getNgModuleScope(type) {\n    if (this.ngModulesScopeCache.has(type)) {\n      return this.ngModulesScopeCache.get(type);\n    }\n    const scope = this.computeNgModuleScope(type);\n    this.ngModulesScopeCache.set(type, scope);\n    return scope;\n  }\n  /** Compute NgModule scope afresh. */\n  computeNgModuleScope(type) {\n    const def = getNgModuleDef(type, true);\n    const scope = {\n      exported: {\n        directives: /* @__PURE__ */ new Set(),\n        pipes: /* @__PURE__ */ new Set()\n      },\n      compilation: {\n        directives: /* @__PURE__ */ new Set(),\n        pipes: /* @__PURE__ */ new Set()\n      }\n    };\n    for (const imported of maybeUnwrapFn(def.imports)) {\n      if (isNgModule(imported)) {\n        const importedScope = this.getNgModuleScope(imported);\n        addSet(importedScope.exported.directives, scope.compilation.directives);\n        addSet(importedScope.exported.pipes, scope.compilation.pipes);\n      } else if (isStandalone(imported)) {\n        if (isDirective(imported) || isComponent(imported)) {\n          scope.compilation.directives.add(imported);\n        } else if (isPipe(imported)) {\n          scope.compilation.pipes.add(imported);\n        } else {\n          throw new RuntimeError(980, \"The standalone imported type is neither a component nor a directive nor a pipe\");\n        }\n      } else {\n        scope.compilation.isPoisoned = true;\n        break;\n      }\n    }\n    if (!scope.compilation.isPoisoned) {\n      for (const decl of maybeUnwrapFn(def.declarations)) {\n        if (isNgModule(decl) || isStandalone(decl)) {\n          scope.compilation.isPoisoned = true;\n          break;\n        }\n        if (isPipe(decl)) {\n          scope.compilation.pipes.add(decl);\n        } else {\n          scope.compilation.directives.add(decl);\n        }\n      }\n    }\n    for (const exported of maybeUnwrapFn(def.exports)) {\n      if (isNgModule(exported)) {\n        const exportedScope = this.getNgModuleScope(exported);\n        addSet(exportedScope.exported.directives, scope.exported.directives);\n        addSet(exportedScope.exported.pipes, scope.exported.pipes);\n        addSet(exportedScope.exported.directives, scope.compilation.directives);\n        addSet(exportedScope.exported.pipes, scope.compilation.pipes);\n      } else if (isPipe(exported)) {\n        scope.exported.pipes.add(exported);\n      } else {\n        scope.exported.directives.add(exported);\n      }\n    }\n    return scope;\n  }\n  /** @override */\n  getStandaloneComponentScope(type, rawImports) {\n    if (this.standaloneComponentsScopeCache.has(type)) {\n      return this.standaloneComponentsScopeCache.get(type);\n    }\n    const ans = this.computeStandaloneComponentScope(type, rawImports);\n    this.standaloneComponentsScopeCache.set(type, ans);\n    return ans;\n  }\n  computeStandaloneComponentScope(type, rawImports) {\n    const ans = {\n      compilation: {\n        // Standalone components are always able to self-reference.\n        directives: /* @__PURE__ */ new Set([type]),\n        pipes: /* @__PURE__ */ new Set(),\n        ngModules: /* @__PURE__ */ new Set()\n      }\n    };\n    for (const rawImport of flatten(rawImports ?? [])) {\n      const imported = resolveForwardRef(rawImport);\n      try {\n        verifyStandaloneImport(imported, type);\n      } catch (e) {\n        ans.compilation.isPoisoned = true;\n        return ans;\n      }\n      if (isNgModule(imported)) {\n        ans.compilation.ngModules.add(imported);\n        const importedScope = this.getNgModuleScope(imported);\n        if (importedScope.exported.isPoisoned) {\n          ans.compilation.isPoisoned = true;\n          return ans;\n        }\n        addSet(importedScope.exported.directives, ans.compilation.directives);\n        addSet(importedScope.exported.pipes, ans.compilation.pipes);\n      } else if (isPipe(imported)) {\n        ans.compilation.pipes.add(imported);\n      } else if (isDirective(imported) || isComponent(imported)) {\n        ans.compilation.directives.add(imported);\n      } else {\n        ans.compilation.isPoisoned = true;\n        return ans;\n      }\n    }\n    return ans;\n  }\n  /** @override */\n  isOrphanComponent(cmp) {\n    const def = getComponentDef(cmp);\n    if (!def || def.standalone) {\n      return false;\n    }\n    this.resolveNgModulesDecls();\n    return !this.ownerNgModule.has(cmp);\n  }\n};\nfunction addSet(sourceSet, targetSet) {\n  for (const m of sourceSet) {\n    targetSet.add(m);\n  }\n}\nvar depsTracker = new DepsTracker();\nfunction computeStaticStyling(tNode, attrs, writeToHost) {\n  ngDevMode && assertFirstCreatePass(getTView(), \"Expecting to be called in first template pass only\");\n  let styles = writeToHost ? tNode.styles : null;\n  let classes = writeToHost ? tNode.classes : null;\n  let mode = 0;\n  if (attrs !== null) {\n    for (let i = 0; i < attrs.length; i++) {\n      const value = attrs[i];\n      if (typeof value === \"number\") {\n        mode = value;\n      } else if (mode == 1) {\n        classes = concatStringsWithSpace(classes, value);\n      } else if (mode == 2) {\n        const style = value;\n        const styleValue = attrs[++i];\n        styles = concatStringsWithSpace(styles, style + \": \" + styleValue + \";\");\n      }\n    }\n  }\n  writeToHost ? tNode.styles = styles : tNode.stylesWithoutHost = styles;\n  writeToHost ? tNode.classes = classes : tNode.classesWithoutHost = classes;\n}\nfunction \\u0275\\u0275directiveInject(token, flags = InjectFlags.Default) {\n  const lView = getLView();\n  if (lView === null) {\n    ngDevMode && assertInjectImplementationNotEqual(\\u0275\\u0275directiveInject);\n    return \\u0275\\u0275inject(token, flags);\n  }\n  const tNode = getCurrentTNode();\n  const value = getOrCreateInjectable(tNode, lView, resolveForwardRef(token), flags);\n  ngDevMode && emitInjectEvent(token, value, flags);\n  return value;\n}\nfunction \\u0275\\u0275invalidFactory() {\n  const msg = ngDevMode ? `This constructor was not compatible with Dependency Injection.` : \"invalid\";\n  throw new Error(msg);\n}\nfunction resolveDirectives(tView, lView, tNode, localRefs, directiveMatcher) {\n  ngDevMode && assertFirstCreatePass(tView);\n  const exportsMap = localRefs === null ? null : {\n    \"\": -1\n  };\n  const matchedDirectiveDefs = directiveMatcher(tView, tNode);\n  if (matchedDirectiveDefs !== null) {\n    let directiveDefs;\n    let hostDirectiveDefs = null;\n    let hostDirectiveRanges = null;\n    const hostDirectiveResolution = resolveHostDirectives(matchedDirectiveDefs);\n    if (hostDirectiveResolution === null) {\n      directiveDefs = matchedDirectiveDefs;\n    } else {\n      [directiveDefs, hostDirectiveDefs, hostDirectiveRanges] = hostDirectiveResolution;\n    }\n    initializeDirectives(tView, lView, tNode, directiveDefs, exportsMap, hostDirectiveDefs, hostDirectiveRanges);\n  }\n  if (exportsMap !== null && localRefs !== null) {\n    cacheMatchingLocalNames(tNode, localRefs, exportsMap);\n  }\n}\nfunction cacheMatchingLocalNames(tNode, localRefs, exportsMap) {\n  const localNames = tNode.localNames = [];\n  for (let i = 0; i < localRefs.length; i += 2) {\n    const index = exportsMap[localRefs[i + 1]];\n    if (index == null) throw new RuntimeError(-301, ngDevMode && `Export of name '${localRefs[i + 1]}' not found!`);\n    localNames.push(localRefs[i], index);\n  }\n}\nfunction resolveHostDirectives(matches) {\n  let componentDef = null;\n  let hasHostDirectives = false;\n  for (let i = 0; i < matches.length; i++) {\n    const def = matches[i];\n    if (i === 0 && isComponentDef(def)) {\n      componentDef = def;\n    }\n    if (def.findHostDirectiveDefs !== null) {\n      hasHostDirectives = true;\n      break;\n    }\n  }\n  if (!hasHostDirectives) {\n    return null;\n  }\n  let allDirectiveDefs = null;\n  let hostDirectiveDefs = null;\n  let hostDirectiveRanges = null;\n  for (const def of matches) {\n    if (def.findHostDirectiveDefs !== null) {\n      allDirectiveDefs ??= [];\n      hostDirectiveDefs ??= /* @__PURE__ */ new Map();\n      hostDirectiveRanges ??= /* @__PURE__ */ new Map();\n      resolveHostDirectivesForDef(def, allDirectiveDefs, hostDirectiveRanges, hostDirectiveDefs);\n    }\n    if (def === componentDef) {\n      allDirectiveDefs ??= [];\n      allDirectiveDefs.push(def);\n    }\n  }\n  if (allDirectiveDefs !== null) {\n    allDirectiveDefs.push(...componentDef === null ? matches : matches.slice(1));\n    ngDevMode && assertNoDuplicateDirectives(allDirectiveDefs);\n    return [allDirectiveDefs, hostDirectiveDefs, hostDirectiveRanges];\n  }\n  return null;\n}\nfunction resolveHostDirectivesForDef(def, allDirectiveDefs, hostDirectiveRanges, hostDirectiveDefs) {\n  ngDevMode && assertDefined(def.findHostDirectiveDefs, \"Expected host directive resolve function\");\n  const start = allDirectiveDefs.length;\n  def.findHostDirectiveDefs(def, allDirectiveDefs, hostDirectiveDefs);\n  hostDirectiveRanges.set(def, [start, allDirectiveDefs.length - 1]);\n}\nfunction markAsComponentHost(tView, hostTNode, componentOffset) {\n  ngDevMode && assertFirstCreatePass(tView);\n  ngDevMode && assertGreaterThan(componentOffset, -1, \"componentOffset must be great than -1\");\n  hostTNode.componentOffset = componentOffset;\n  (tView.components ??= []).push(hostTNode.index);\n}\nfunction initializeDirectives(tView, lView, tNode, directives, exportsMap, hostDirectiveDefs, hostDirectiveRanges) {\n  ngDevMode && assertFirstCreatePass(tView);\n  const directivesLength = directives.length;\n  let hasSeenComponent = false;\n  for (let i = 0; i < directivesLength; i++) {\n    const def = directives[i];\n    if (!hasSeenComponent && isComponentDef(def)) {\n      hasSeenComponent = true;\n      markAsComponentHost(tView, tNode, i);\n    }\n    diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, def.type);\n  }\n  initTNodeFlags(tNode, tView.data.length, directivesLength);\n  for (let i = 0; i < directivesLength; i++) {\n    const def = directives[i];\n    if (def.providersResolver) def.providersResolver(def);\n  }\n  let preOrderHooksFound = false;\n  let preOrderCheckHooksFound = false;\n  let directiveIdx = allocExpando(tView, lView, directivesLength, null);\n  ngDevMode && assertSame(directiveIdx, tNode.directiveStart, \"TNode.directiveStart should point to just allocated space\");\n  if (directivesLength > 0) {\n    tNode.directiveToIndex = /* @__PURE__ */ new Map();\n  }\n  for (let i = 0; i < directivesLength; i++) {\n    const def = directives[i];\n    tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);\n    configureViewWithDirective(tView, tNode, lView, directiveIdx, def);\n    saveNameToExportMap(directiveIdx, def, exportsMap);\n    if (hostDirectiveRanges !== null && hostDirectiveRanges.has(def)) {\n      const [start, end] = hostDirectiveRanges.get(def);\n      tNode.directiveToIndex.set(def.type, [directiveIdx, start + tNode.directiveStart, end + tNode.directiveStart]);\n    } else if (hostDirectiveDefs === null || !hostDirectiveDefs.has(def)) {\n      tNode.directiveToIndex.set(def.type, directiveIdx);\n    }\n    if (def.contentQueries !== null) tNode.flags |= 4;\n    if (def.hostBindings !== null || def.hostAttrs !== null || def.hostVars !== 0) tNode.flags |= 64;\n    const lifeCycleHooks = def.type.prototype;\n    if (!preOrderHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngOnInit || lifeCycleHooks.ngDoCheck)) {\n      (tView.preOrderHooks ??= []).push(tNode.index);\n      preOrderHooksFound = true;\n    }\n    if (!preOrderCheckHooksFound && (lifeCycleHooks.ngOnChanges || lifeCycleHooks.ngDoCheck)) {\n      (tView.preOrderCheckHooks ??= []).push(tNode.index);\n      preOrderCheckHooksFound = true;\n    }\n    directiveIdx++;\n  }\n  initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefs);\n}\nfunction initializeInputAndOutputAliases(tView, tNode, hostDirectiveDefs) {\n  ngDevMode && assertFirstCreatePass(tView);\n  for (let index = tNode.directiveStart; index < tNode.directiveEnd; index++) {\n    const directiveDef = tView.data[index];\n    if (hostDirectiveDefs === null || !hostDirectiveDefs.has(directiveDef)) {\n      setupSelectorMatchedInputsOrOutputs(0, tNode, directiveDef, index);\n      setupSelectorMatchedInputsOrOutputs(1, tNode, directiveDef, index);\n      setupInitialInputs(tNode, index, false);\n    } else {\n      const hostDirectiveDef = hostDirectiveDefs.get(directiveDef);\n      setupHostDirectiveInputsOrOutputs(0, tNode, hostDirectiveDef, index);\n      setupHostDirectiveInputsOrOutputs(1, tNode, hostDirectiveDef, index);\n      setupInitialInputs(tNode, index, true);\n    }\n  }\n}\nfunction setupSelectorMatchedInputsOrOutputs(mode, tNode, def, directiveIndex) {\n  const aliasMap = mode === 0 ? def.inputs : def.outputs;\n  for (const publicName in aliasMap) {\n    if (aliasMap.hasOwnProperty(publicName)) {\n      let bindings;\n      if (mode === 0) {\n        bindings = tNode.inputs ??= {};\n      } else {\n        bindings = tNode.outputs ??= {};\n      }\n      bindings[publicName] ??= [];\n      bindings[publicName].push(directiveIndex);\n      setShadowStylingInputFlags(tNode, publicName);\n    }\n  }\n}\nfunction setupHostDirectiveInputsOrOutputs(mode, tNode, config2, directiveIndex) {\n  const aliasMap = mode === 0 ? config2.inputs : config2.outputs;\n  for (const initialName in aliasMap) {\n    if (aliasMap.hasOwnProperty(initialName)) {\n      const publicName = aliasMap[initialName];\n      let bindings;\n      if (mode === 0) {\n        bindings = tNode.hostDirectiveInputs ??= {};\n      } else {\n        bindings = tNode.hostDirectiveOutputs ??= {};\n      }\n      bindings[publicName] ??= [];\n      bindings[publicName].push(directiveIndex, initialName);\n      setShadowStylingInputFlags(tNode, publicName);\n    }\n  }\n}\nfunction setShadowStylingInputFlags(tNode, publicName) {\n  if (publicName === \"class\") {\n    tNode.flags |= 8;\n  } else if (publicName === \"style\") {\n    tNode.flags |= 16;\n  }\n}\nfunction setupInitialInputs(tNode, directiveIndex, isHostDirective) {\n  const {\n    attrs,\n    inputs,\n    hostDirectiveInputs\n  } = tNode;\n  if (attrs === null || !isHostDirective && inputs === null || isHostDirective && hostDirectiveInputs === null || // Do not use unbound attributes as inputs to structural directives, since structural\n  // directive inputs can only be set using microsyntax (e.g. `<div *dir=\"exp\">`).\n  isInlineTemplate(tNode)) {\n    tNode.initialInputs ??= [];\n    tNode.initialInputs.push(null);\n    return;\n  }\n  let inputsToStore = null;\n  let i = 0;\n  while (i < attrs.length) {\n    const attrName = attrs[i];\n    if (attrName === 0) {\n      i += 4;\n      continue;\n    } else if (attrName === 5) {\n      i += 2;\n      continue;\n    } else if (typeof attrName === \"number\") {\n      break;\n    }\n    if (!isHostDirective && inputs.hasOwnProperty(attrName)) {\n      const inputConfig = inputs[attrName];\n      for (const index of inputConfig) {\n        if (index === directiveIndex) {\n          inputsToStore ??= [];\n          inputsToStore.push(attrName, attrs[i + 1]);\n          break;\n        }\n      }\n    } else if (isHostDirective && hostDirectiveInputs.hasOwnProperty(attrName)) {\n      const config2 = hostDirectiveInputs[attrName];\n      for (let j = 0; j < config2.length; j += 2) {\n        if (config2[j] === directiveIndex) {\n          inputsToStore ??= [];\n          inputsToStore.push(config2[j + 1], attrs[i + 1]);\n          break;\n        }\n      }\n    }\n    i += 2;\n  }\n  tNode.initialInputs ??= [];\n  tNode.initialInputs.push(inputsToStore);\n}\nfunction configureViewWithDirective(tView, tNode, lView, directiveIndex, def) {\n  ngDevMode && assertGreaterThanOrEqual(directiveIndex, HEADER_OFFSET, \"Must be in Expando section\");\n  tView.data[directiveIndex] = def;\n  const directiveFactory = def.factory || (def.factory = getFactoryDef(def.type, true));\n  const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), \\u0275\\u0275directiveInject);\n  tView.blueprint[directiveIndex] = nodeInjectorFactory;\n  lView[directiveIndex] = nodeInjectorFactory;\n  registerHostBindingOpCodes(tView, tNode, directiveIndex, allocExpando(tView, lView, def.hostVars, NO_CHANGE), def);\n}\nfunction registerHostBindingOpCodes(tView, tNode, directiveIdx, directiveVarsIdx, def) {\n  ngDevMode && assertFirstCreatePass(tView);\n  const hostBindings = def.hostBindings;\n  if (hostBindings) {\n    let hostBindingOpCodes = tView.hostBindingOpCodes;\n    if (hostBindingOpCodes === null) {\n      hostBindingOpCodes = tView.hostBindingOpCodes = [];\n    }\n    const elementIndx = ~tNode.index;\n    if (lastSelectedElementIdx(hostBindingOpCodes) != elementIndx) {\n      hostBindingOpCodes.push(elementIndx);\n    }\n    hostBindingOpCodes.push(directiveIdx, directiveVarsIdx, hostBindings);\n  }\n}\nfunction lastSelectedElementIdx(hostBindingOpCodes) {\n  let i = hostBindingOpCodes.length;\n  while (i > 0) {\n    const value = hostBindingOpCodes[--i];\n    if (typeof value === \"number\" && value < 0) {\n      return value;\n    }\n  }\n  return 0;\n}\nfunction saveNameToExportMap(directiveIdx, def, exportsMap) {\n  if (exportsMap) {\n    if (def.exportAs) {\n      for (let i = 0; i < def.exportAs.length; i++) {\n        exportsMap[def.exportAs[i]] = directiveIdx;\n      }\n    }\n    if (isComponentDef(def)) exportsMap[\"\"] = directiveIdx;\n  }\n}\nfunction initTNodeFlags(tNode, index, numberOfDirectives) {\n  ngDevMode && assertNotEqual(numberOfDirectives, tNode.directiveEnd - tNode.directiveStart, \"Reached the max number of directives\");\n  tNode.flags |= 1;\n  tNode.directiveStart = index;\n  tNode.directiveEnd = index + numberOfDirectives;\n  tNode.providerIndexes = index;\n}\nfunction assertNoDuplicateDirectives(directives) {\n  if (directives.length < 2) {\n    return;\n  }\n  const seenDirectives = /* @__PURE__ */ new Set();\n  for (const current of directives) {\n    if (seenDirectives.has(current)) {\n      throw new RuntimeError(309, `Directive ${current.type.name} matches multiple times on the same element. Directives can only match an element once.`);\n    }\n    seenDirectives.add(current);\n  }\n}\nfunction elementStartFirstCreatePass(index, tView, lView, name, directiveMatcher, bindingsEnabled, attrsIndex, localRefsIndex) {\n  ngDevMode && assertFirstCreatePass(tView);\n  ngDevMode && ngDevMode.firstCreatePass++;\n  const tViewConsts = tView.consts;\n  const attrs = getConstant(tViewConsts, attrsIndex);\n  const tNode = getOrCreateTNode(tView, index, 2, name, attrs);\n  if (bindingsEnabled) {\n    resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex), directiveMatcher);\n  }\n  tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);\n  if (tNode.attrs !== null) {\n    computeStaticStyling(tNode, tNode.attrs, false);\n  }\n  if (tNode.mergedAttrs !== null) {\n    computeStaticStyling(tNode, tNode.mergedAttrs, true);\n  }\n  if (tView.queries !== null) {\n    tView.queries.elementStart(tView, tNode);\n  }\n  return tNode;\n}\nfunction elementEndFirstCreatePass(tView, tNode) {\n  ngDevMode && assertFirstCreatePass(tView);\n  registerPostOrderHooks(tView, tNode);\n  if (isContentQueryHost(tNode)) {\n    tView.queries.elementEnd(tNode);\n  }\n}\nvar ComponentFactoryResolver2 = class extends ComponentFactoryResolver$1 {\n  ngModule;\n  /**\n   * @param ngModule The NgModuleRef to which all resolved factories are bound.\n   */\n  constructor(ngModule) {\n    super();\n    this.ngModule = ngModule;\n  }\n  resolveComponentFactory(component) {\n    ngDevMode && assertComponentType(component);\n    const componentDef = getComponentDef(component);\n    return new ComponentFactory2(componentDef, this.ngModule);\n  }\n};\nfunction toInputRefArray(map2) {\n  return Object.keys(map2).map((name) => {\n    const [propName, flags, transform] = map2[name];\n    const inputData = {\n      propName,\n      templateName: name,\n      isSignal: (flags & InputFlags.SignalBased) !== 0\n    };\n    if (transform) {\n      inputData.transform = transform;\n    }\n    return inputData;\n  });\n}\nfunction toOutputRefArray(map2) {\n  return Object.keys(map2).map((name) => ({\n    propName: map2[name],\n    templateName: name\n  }));\n}\nfunction verifyNotAnOrphanComponent(componentDef) {\n  if (false) {\n    if (depsTracker.isOrphanComponent(componentDef.type)) {\n      throw new RuntimeError(981, `Orphan component found! Trying to render the component ${debugStringifyTypeForError(componentDef.type)} without first loading the NgModule that declares it. It is recommended to make this component standalone in order to avoid this error. If this is not possible now, import the component's NgModule in the appropriate NgModule, or the standalone component in which you are trying to render this component. If this is a lazy import, load the NgModule lazily as well and use its module injector.`);\n    }\n  }\n}\nfunction createRootViewInjector(componentDef, environmentInjector, injector) {\n  let realEnvironmentInjector = environmentInjector instanceof EnvironmentInjector ? environmentInjector : environmentInjector?.injector;\n  if (realEnvironmentInjector && componentDef.getStandaloneInjector !== null) {\n    realEnvironmentInjector = componentDef.getStandaloneInjector(realEnvironmentInjector) || realEnvironmentInjector;\n  }\n  const rootViewInjector = realEnvironmentInjector ? new ChainedInjector(injector, realEnvironmentInjector) : injector;\n  return rootViewInjector;\n}\nfunction createRootLViewEnvironment(rootLViewInjector) {\n  const rendererFactory = rootLViewInjector.get(RendererFactory2, null);\n  if (rendererFactory === null) {\n    throw new RuntimeError(407, ngDevMode && \"Angular was not able to inject a renderer (RendererFactory2). Likely this is due to a broken DI hierarchy. Make sure that any injector used to create this component has a correct parent.\");\n  }\n  const sanitizer = rootLViewInjector.get(Sanitizer, null);\n  const changeDetectionScheduler = rootLViewInjector.get(ChangeDetectionScheduler, null);\n  return {\n    rendererFactory,\n    sanitizer,\n    changeDetectionScheduler\n  };\n}\nfunction createHostElement(componentDef, render) {\n  const tagName = (componentDef.selectors[0][0] || \"div\").toLowerCase();\n  const namespace = tagName === \"svg\" ? SVG_NAMESPACE : tagName === \"math\" ? MATH_ML_NAMESPACE : null;\n  return createElementNode(render, tagName, namespace);\n}\nvar ComponentFactory2 = class extends ComponentFactory$1 {\n  componentDef;\n  ngModule;\n  selector;\n  componentType;\n  ngContentSelectors;\n  isBoundToModule;\n  cachedInputs = null;\n  cachedOutputs = null;\n  get inputs() {\n    this.cachedInputs ??= toInputRefArray(this.componentDef.inputs);\n    return this.cachedInputs;\n  }\n  get outputs() {\n    this.cachedOutputs ??= toOutputRefArray(this.componentDef.outputs);\n    return this.cachedOutputs;\n  }\n  /**\n   * @param componentDef The component definition.\n   * @param ngModule The NgModuleRef to which the factory is bound.\n   */\n  constructor(componentDef, ngModule) {\n    super();\n    this.componentDef = componentDef;\n    this.ngModule = ngModule;\n    this.componentType = componentDef.type;\n    this.selector = stringifyCSSSelectorList(componentDef.selectors);\n    this.ngContentSelectors = componentDef.ngContentSelectors ?? [];\n    this.isBoundToModule = !!ngModule;\n  }\n  create(injector, projectableNodes, rootSelectorOrNode, environmentInjector) {\n    profiler(\n      22\n      /* ProfilerEvent.DynamicComponentStart */\n    );\n    const prevConsumer = setActiveConsumer(null);\n    try {\n      const cmpDef = this.componentDef;\n      ngDevMode && verifyNotAnOrphanComponent(cmpDef);\n      const tAttributes = rootSelectorOrNode ? [\"ng-version\", \"19.2.3\"] : (\n        // Extract attributes and classes from the first selector only to match VE behavior.\n        extractAttrsAndClassesFromSelector(this.componentDef.selectors[0])\n      );\n      const rootTView = createTView(0, null, null, 1, 0, null, null, null, null, [tAttributes], null);\n      const rootViewInjector = createRootViewInjector(cmpDef, environmentInjector || this.ngModule, injector);\n      const environment2 = createRootLViewEnvironment(rootViewInjector);\n      const hostRenderer = environment2.rendererFactory.createRenderer(null, cmpDef);\n      const hostElement = rootSelectorOrNode ? locateHostElement(hostRenderer, rootSelectorOrNode, cmpDef.encapsulation, rootViewInjector) : createHostElement(cmpDef, hostRenderer);\n      const rootLView = createLView(null, rootTView, null, 512 | getInitialLViewFlagsFromDef(cmpDef), null, null, environment2, hostRenderer, rootViewInjector, null, retrieveHydrationInfo(\n        hostElement,\n        rootViewInjector,\n        true\n        /* isRootView */\n      ));\n      rootLView[HEADER_OFFSET] = hostElement;\n      enterView(rootLView);\n      let componentView = null;\n      try {\n        const hostTNode = elementStartFirstCreatePass(HEADER_OFFSET, rootTView, rootLView, \"#host\", () => [this.componentDef], true, 0);\n        if (hostElement) {\n          setupStaticAttributes(hostRenderer, hostElement, hostTNode);\n          attachPatchData(hostElement, rootLView);\n        }\n        createDirectivesInstances(rootTView, rootLView, hostTNode);\n        executeContentQueries(rootTView, hostTNode, rootLView);\n        elementEndFirstCreatePass(rootTView, hostTNode);\n        if (projectableNodes !== void 0) {\n          projectNodes(hostTNode, this.ngContentSelectors, projectableNodes);\n        }\n        componentView = getComponentLViewByIndex(hostTNode.index, rootLView);\n        rootLView[CONTEXT] = componentView[CONTEXT];\n        renderView(rootTView, rootLView, null);\n      } catch (e) {\n        if (componentView !== null) {\n          unregisterLView(componentView);\n        }\n        unregisterLView(rootLView);\n        throw e;\n      } finally {\n        profiler(\n          23\n          /* ProfilerEvent.DynamicComponentEnd */\n        );\n        leaveView();\n      }\n      return new ComponentRef2(this.componentType, rootLView);\n    } finally {\n      setActiveConsumer(prevConsumer);\n    }\n  }\n};\nvar ComponentRef2 = class extends ComponentRef$1 {\n  _rootLView;\n  instance;\n  hostView;\n  changeDetectorRef;\n  componentType;\n  location;\n  previousInputValues = null;\n  _tNode;\n  constructor(componentType, _rootLView) {\n    super();\n    this._rootLView = _rootLView;\n    this._tNode = getTNode(_rootLView[TVIEW], HEADER_OFFSET);\n    this.location = createElementRef(this._tNode, _rootLView);\n    this.instance = getComponentLViewByIndex(this._tNode.index, _rootLView)[CONTEXT];\n    this.hostView = this.changeDetectorRef = new ViewRef$1(\n      _rootLView,\n      void 0,\n      false\n      /* notifyErrorHandler */\n    );\n    this.componentType = componentType;\n  }\n  setInput(name, value) {\n    const tNode = this._tNode;\n    this.previousInputValues ??= /* @__PURE__ */ new Map();\n    if (this.previousInputValues.has(name) && Object.is(this.previousInputValues.get(name), value)) {\n      return;\n    }\n    const lView = this._rootLView;\n    const hasSetInput = setAllInputsForProperty(tNode, lView[TVIEW], lView, name, value);\n    this.previousInputValues.set(name, value);\n    const childComponentLView = getComponentLViewByIndex(tNode.index, lView);\n    markViewDirty(\n      childComponentLView,\n      1\n      /* NotificationSource.SetInput */\n    );\n    if (ngDevMode && !hasSetInput) {\n      const cmpNameForError = stringifyForError(this.componentType);\n      let message = `Can't set value of the '${name}' input on the '${cmpNameForError}' component. `;\n      message += `Make sure that the '${name}' property is annotated with @Input() or a mapped @Input('${name}') exists.`;\n      reportUnknownPropertyError(message);\n    }\n  }\n  get injector() {\n    return new NodeInjector(this._tNode, this._rootLView);\n  }\n  destroy() {\n    this.hostView.destroy();\n  }\n  onDestroy(callback) {\n    this.hostView.onDestroy(callback);\n  }\n};\nfunction projectNodes(tNode, ngContentSelectors, projectableNodes) {\n  const projection = tNode.projection = [];\n  for (let i = 0; i < ngContentSelectors.length; i++) {\n    const nodesforSlot = projectableNodes[i];\n    projection.push(nodesforSlot != null && nodesforSlot.length ? Array.from(nodesforSlot) : null);\n  }\n}\nvar ViewContainerRef = class {\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ELEMENT_ID__ = injectViewContainerRef;\n};\nfunction injectViewContainerRef() {\n  const previousTNode = getCurrentTNode();\n  return createContainerRef(previousTNode, getLView());\n}\nvar VE_ViewContainerRef = ViewContainerRef;\nvar R3ViewContainerRef = class ViewContainerRef2 extends VE_ViewContainerRef {\n  _lContainer;\n  _hostTNode;\n  _hostLView;\n  constructor(_lContainer, _hostTNode, _hostLView) {\n    super();\n    this._lContainer = _lContainer;\n    this._hostTNode = _hostTNode;\n    this._hostLView = _hostLView;\n  }\n  get element() {\n    return createElementRef(this._hostTNode, this._hostLView);\n  }\n  get injector() {\n    return new NodeInjector(this._hostTNode, this._hostLView);\n  }\n  /** @deprecated No replacement */\n  get parentInjector() {\n    const parentLocation = getParentInjectorLocation(this._hostTNode, this._hostLView);\n    if (hasParentInjector(parentLocation)) {\n      const parentView = getParentInjectorView(parentLocation, this._hostLView);\n      const injectorIndex = getParentInjectorIndex(parentLocation);\n      ngDevMode && assertNodeInjector(parentView, injectorIndex);\n      const parentTNode = parentView[TVIEW].data[\n        injectorIndex + 8\n        /* NodeInjectorOffset.TNODE */\n      ];\n      return new NodeInjector(parentTNode, parentView);\n    } else {\n      return new NodeInjector(null, this._hostLView);\n    }\n  }\n  clear() {\n    while (this.length > 0) {\n      this.remove(this.length - 1);\n    }\n  }\n  get(index) {\n    const viewRefs = getViewRefs(this._lContainer);\n    return viewRefs !== null && viewRefs[index] || null;\n  }\n  get length() {\n    return this._lContainer.length - CONTAINER_HEADER_OFFSET;\n  }\n  createEmbeddedView(templateRef, context2, indexOrOptions) {\n    let index;\n    let injector;\n    if (typeof indexOrOptions === \"number\") {\n      index = indexOrOptions;\n    } else if (indexOrOptions != null) {\n      index = indexOrOptions.index;\n      injector = indexOrOptions.injector;\n    }\n    const dehydratedView = findMatchingDehydratedView(this._lContainer, templateRef.ssrId);\n    const viewRef = templateRef.createEmbeddedViewImpl(context2 || {}, injector, dehydratedView);\n    this.insertImpl(viewRef, index, shouldAddViewToDom(this._hostTNode, dehydratedView));\n    return viewRef;\n  }\n  createComponent(componentFactoryOrType, indexOrOptions, injector, projectableNodes, environmentInjector) {\n    const isComponentFactory = componentFactoryOrType && !isType(componentFactoryOrType);\n    let index;\n    if (isComponentFactory) {\n      if (ngDevMode) {\n        assertEqual(typeof indexOrOptions !== \"object\", true, \"It looks like Component factory was provided as the first argument and an options object as the second argument. This combination of arguments is incompatible. You can either change the first argument to provide Component type or change the second argument to be a number (representing an index at which to insert the new component's host view into this container)\");\n      }\n      index = indexOrOptions;\n    } else {\n      if (ngDevMode) {\n        assertDefined(getComponentDef(componentFactoryOrType), `Provided Component class doesn't contain Component definition. Please check whether provided class has @Component decorator.`);\n        assertEqual(typeof indexOrOptions !== \"number\", true, \"It looks like Component type was provided as the first argument and a number (representing an index at which to insert the new component's host view into this container as the second argument. This combination of arguments is incompatible. Please use an object as the second argument instead.\");\n      }\n      const options = indexOrOptions || {};\n      if (ngDevMode && options.environmentInjector && options.ngModuleRef) {\n        throwError2(`Cannot pass both environmentInjector and ngModuleRef options to createComponent().`);\n      }\n      index = options.index;\n      injector = options.injector;\n      projectableNodes = options.projectableNodes;\n      environmentInjector = options.environmentInjector || options.ngModuleRef;\n    }\n    const componentFactory = isComponentFactory ? componentFactoryOrType : new ComponentFactory2(getComponentDef(componentFactoryOrType));\n    const contextInjector = injector || this.parentInjector;\n    if (!environmentInjector && componentFactory.ngModule == null) {\n      const _injector = isComponentFactory ? contextInjector : this.parentInjector;\n      const result = _injector.get(EnvironmentInjector, null);\n      if (result) {\n        environmentInjector = result;\n      }\n    }\n    const componentDef = getComponentDef(componentFactory.componentType ?? {});\n    const dehydratedView = findMatchingDehydratedView(this._lContainer, componentDef?.id ?? null);\n    const rNode = dehydratedView?.firstChild ?? null;\n    const componentRef = componentFactory.create(contextInjector, projectableNodes, rNode, environmentInjector);\n    this.insertImpl(componentRef.hostView, index, shouldAddViewToDom(this._hostTNode, dehydratedView));\n    return componentRef;\n  }\n  insert(viewRef, index) {\n    return this.insertImpl(viewRef, index, true);\n  }\n  insertImpl(viewRef, index, addToDOM) {\n    const lView = viewRef._lView;\n    if (ngDevMode && viewRef.destroyed) {\n      throw new Error(\"Cannot insert a destroyed View in a ViewContainer!\");\n    }\n    if (viewAttachedToContainer(lView)) {\n      const prevIdx = this.indexOf(viewRef);\n      if (prevIdx !== -1) {\n        this.detach(prevIdx);\n      } else {\n        const prevLContainer = lView[PARENT];\n        ngDevMode && assertEqual(isLContainer(prevLContainer), true, \"An attached view should have its PARENT point to a container.\");\n        const prevVCRef = new R3ViewContainerRef(prevLContainer, prevLContainer[T_HOST], prevLContainer[PARENT]);\n        prevVCRef.detach(prevVCRef.indexOf(viewRef));\n      }\n    }\n    const adjustedIdx = this._adjustIndex(index);\n    const lContainer = this._lContainer;\n    addLViewToLContainer(lContainer, lView, adjustedIdx, addToDOM);\n    viewRef.attachToViewContainerRef();\n    addToArray(getOrCreateViewRefs(lContainer), adjustedIdx, viewRef);\n    return viewRef;\n  }\n  move(viewRef, newIndex) {\n    if (ngDevMode && viewRef.destroyed) {\n      throw new Error(\"Cannot move a destroyed View in a ViewContainer!\");\n    }\n    return this.insert(viewRef, newIndex);\n  }\n  indexOf(viewRef) {\n    const viewRefsArr = getViewRefs(this._lContainer);\n    return viewRefsArr !== null ? viewRefsArr.indexOf(viewRef) : -1;\n  }\n  remove(index) {\n    const adjustedIdx = this._adjustIndex(index, -1);\n    const detachedView = detachView(this._lContainer, adjustedIdx);\n    if (detachedView) {\n      removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx);\n      destroyLView(detachedView[TVIEW], detachedView);\n    }\n  }\n  detach(index) {\n    const adjustedIdx = this._adjustIndex(index, -1);\n    const view = detachView(this._lContainer, adjustedIdx);\n    const wasDetached = view && removeFromArray(getOrCreateViewRefs(this._lContainer), adjustedIdx) != null;\n    return wasDetached ? new ViewRef$1(view) : null;\n  }\n  _adjustIndex(index, shift = 0) {\n    if (index == null) {\n      return this.length + shift;\n    }\n    if (ngDevMode) {\n      assertGreaterThan(index, -1, `ViewRef index must be positive, got ${index}`);\n      assertLessThan(index, this.length + 1 + shift, \"index\");\n    }\n    return index;\n  }\n};\nfunction getViewRefs(lContainer) {\n  return lContainer[VIEW_REFS];\n}\nfunction getOrCreateViewRefs(lContainer) {\n  return lContainer[VIEW_REFS] || (lContainer[VIEW_REFS] = []);\n}\nfunction createContainerRef(hostTNode, hostLView) {\n  ngDevMode && assertTNodeType(\n    hostTNode,\n    12 | 3\n    /* TNodeType.AnyRNode */\n  );\n  let lContainer;\n  const slotValue = hostLView[hostTNode.index];\n  if (isLContainer(slotValue)) {\n    lContainer = slotValue;\n  } else {\n    lContainer = createLContainer(slotValue, hostLView, null, hostTNode);\n    hostLView[hostTNode.index] = lContainer;\n    addToEndOfViewTree(hostLView, lContainer);\n  }\n  _locateOrCreateAnchorNode(lContainer, hostLView, hostTNode, slotValue);\n  return new R3ViewContainerRef(lContainer, hostTNode, hostLView);\n}\nfunction insertAnchorNode(hostLView, hostTNode) {\n  const renderer = hostLView[RENDERER];\n  ngDevMode && ngDevMode.rendererCreateComment++;\n  const commentNode = renderer.createComment(ngDevMode ? \"container\" : \"\");\n  const hostNative = getNativeByTNode(hostTNode, hostLView);\n  const parentOfHostNative = renderer.parentNode(hostNative);\n  nativeInsertBefore(renderer, parentOfHostNative, commentNode, renderer.nextSibling(hostNative), false);\n  return commentNode;\n}\nvar _locateOrCreateAnchorNode = createAnchorNode;\nvar _populateDehydratedViewsInLContainer = () => false;\nfunction populateDehydratedViewsInLContainer(lContainer, tNode, hostLView) {\n  return _populateDehydratedViewsInLContainer(lContainer, tNode, hostLView);\n}\nfunction createAnchorNode(lContainer, hostLView, hostTNode, slotValue) {\n  if (lContainer[NATIVE]) return;\n  let commentNode;\n  if (hostTNode.type & 8) {\n    commentNode = unwrapRNode(slotValue);\n  } else {\n    commentNode = insertAnchorNode(hostLView, hostTNode);\n  }\n  lContainer[NATIVE] = commentNode;\n}\nvar LQuery_ = class _LQuery_ {\n  queryList;\n  matches = null;\n  constructor(queryList) {\n    this.queryList = queryList;\n  }\n  clone() {\n    return new _LQuery_(this.queryList);\n  }\n  setDirty() {\n    this.queryList.setDirty();\n  }\n};\nvar LQueries_ = class _LQueries_ {\n  queries;\n  constructor(queries = []) {\n    this.queries = queries;\n  }\n  createEmbeddedView(tView) {\n    const tQueries = tView.queries;\n    if (tQueries !== null) {\n      const noOfInheritedQueries = tView.contentQueries !== null ? tView.contentQueries[0] : tQueries.length;\n      const viewLQueries = [];\n      for (let i = 0; i < noOfInheritedQueries; i++) {\n        const tQuery = tQueries.getByIndex(i);\n        const parentLQuery = this.queries[tQuery.indexInDeclarationView];\n        viewLQueries.push(parentLQuery.clone());\n      }\n      return new _LQueries_(viewLQueries);\n    }\n    return null;\n  }\n  insertView(tView) {\n    this.dirtyQueriesWithMatches(tView);\n  }\n  detachView(tView) {\n    this.dirtyQueriesWithMatches(tView);\n  }\n  finishViewCreation(tView) {\n    this.dirtyQueriesWithMatches(tView);\n  }\n  dirtyQueriesWithMatches(tView) {\n    for (let i = 0; i < this.queries.length; i++) {\n      if (getTQuery(tView, i).matches !== null) {\n        this.queries[i].setDirty();\n      }\n    }\n  }\n};\nvar TQueryMetadata_ = class {\n  flags;\n  read;\n  predicate;\n  constructor(predicate, flags, read = null) {\n    this.flags = flags;\n    this.read = read;\n    if (typeof predicate === \"string\") {\n      this.predicate = splitQueryMultiSelectors(predicate);\n    } else {\n      this.predicate = predicate;\n    }\n  }\n};\nvar TQueries_ = class _TQueries_ {\n  queries;\n  constructor(queries = []) {\n    this.queries = queries;\n  }\n  elementStart(tView, tNode) {\n    ngDevMode && assertFirstCreatePass(tView, \"Queries should collect results on the first template pass only\");\n    for (let i = 0; i < this.queries.length; i++) {\n      this.queries[i].elementStart(tView, tNode);\n    }\n  }\n  elementEnd(tNode) {\n    for (let i = 0; i < this.queries.length; i++) {\n      this.queries[i].elementEnd(tNode);\n    }\n  }\n  embeddedTView(tNode) {\n    let queriesForTemplateRef = null;\n    for (let i = 0; i < this.length; i++) {\n      const childQueryIndex = queriesForTemplateRef !== null ? queriesForTemplateRef.length : 0;\n      const tqueryClone = this.getByIndex(i).embeddedTView(tNode, childQueryIndex);\n      if (tqueryClone) {\n        tqueryClone.indexInDeclarationView = i;\n        if (queriesForTemplateRef !== null) {\n          queriesForTemplateRef.push(tqueryClone);\n        } else {\n          queriesForTemplateRef = [tqueryClone];\n        }\n      }\n    }\n    return queriesForTemplateRef !== null ? new _TQueries_(queriesForTemplateRef) : null;\n  }\n  template(tView, tNode) {\n    ngDevMode && assertFirstCreatePass(tView, \"Queries should collect results on the first template pass only\");\n    for (let i = 0; i < this.queries.length; i++) {\n      this.queries[i].template(tView, tNode);\n    }\n  }\n  getByIndex(index) {\n    ngDevMode && assertIndexInRange(this.queries, index);\n    return this.queries[index];\n  }\n  get length() {\n    return this.queries.length;\n  }\n  track(tquery) {\n    this.queries.push(tquery);\n  }\n};\nvar TQuery_ = class _TQuery_ {\n  metadata;\n  matches = null;\n  indexInDeclarationView = -1;\n  crossesNgTemplate = false;\n  /**\n   * A node index on which a query was declared (-1 for view queries and ones inherited from the\n   * declaration template). We use this index (alongside with _appliesToNextNode flag) to know\n   * when to apply content queries to elements in a template.\n   */\n  _declarationNodeIndex;\n  /**\n   * A flag indicating if a given query still applies to nodes it is crossing. We use this flag\n   * (alongside with _declarationNodeIndex) to know when to stop applying content queries to\n   * elements in a template.\n   */\n  _appliesToNextNode = true;\n  constructor(metadata, nodeIndex = -1) {\n    this.metadata = metadata;\n    this._declarationNodeIndex = nodeIndex;\n  }\n  elementStart(tView, tNode) {\n    if (this.isApplyingToNode(tNode)) {\n      this.matchTNode(tView, tNode);\n    }\n  }\n  elementEnd(tNode) {\n    if (this._declarationNodeIndex === tNode.index) {\n      this._appliesToNextNode = false;\n    }\n  }\n  template(tView, tNode) {\n    this.elementStart(tView, tNode);\n  }\n  embeddedTView(tNode, childQueryIndex) {\n    if (this.isApplyingToNode(tNode)) {\n      this.crossesNgTemplate = true;\n      this.addMatch(-tNode.index, childQueryIndex);\n      return new _TQuery_(this.metadata);\n    }\n    return null;\n  }\n  isApplyingToNode(tNode) {\n    if (this._appliesToNextNode && (this.metadata.flags & 1) !== 1) {\n      const declarationNodeIdx = this._declarationNodeIndex;\n      let parent = tNode.parent;\n      while (parent !== null && parent.type & 8 && parent.index !== declarationNodeIdx) {\n        parent = parent.parent;\n      }\n      return declarationNodeIdx === (parent !== null ? parent.index : -1);\n    }\n    return this._appliesToNextNode;\n  }\n  matchTNode(tView, tNode) {\n    const predicate = this.metadata.predicate;\n    if (Array.isArray(predicate)) {\n      for (let i = 0; i < predicate.length; i++) {\n        const name = predicate[i];\n        this.matchTNodeWithReadOption(tView, tNode, getIdxOfMatchingSelector(tNode, name));\n        this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, name, false, false));\n      }\n    } else {\n      if (predicate === TemplateRef) {\n        if (tNode.type & 4) {\n          this.matchTNodeWithReadOption(tView, tNode, -1);\n        }\n      } else {\n        this.matchTNodeWithReadOption(tView, tNode, locateDirectiveOrProvider(tNode, tView, predicate, false, false));\n      }\n    }\n  }\n  matchTNodeWithReadOption(tView, tNode, nodeMatchIdx) {\n    if (nodeMatchIdx !== null) {\n      const read = this.metadata.read;\n      if (read !== null) {\n        if (read === ElementRef || read === ViewContainerRef || read === TemplateRef && tNode.type & 4) {\n          this.addMatch(tNode.index, -2);\n        } else {\n          const directiveOrProviderIdx = locateDirectiveOrProvider(tNode, tView, read, false, false);\n          if (directiveOrProviderIdx !== null) {\n            this.addMatch(tNode.index, directiveOrProviderIdx);\n          }\n        }\n      } else {\n        this.addMatch(tNode.index, nodeMatchIdx);\n      }\n    }\n  }\n  addMatch(tNodeIdx, matchIdx) {\n    if (this.matches === null) {\n      this.matches = [tNodeIdx, matchIdx];\n    } else {\n      this.matches.push(tNodeIdx, matchIdx);\n    }\n  }\n};\nfunction getIdxOfMatchingSelector(tNode, selector) {\n  const localNames = tNode.localNames;\n  if (localNames !== null) {\n    for (let i = 0; i < localNames.length; i += 2) {\n      if (localNames[i] === selector) {\n        return localNames[i + 1];\n      }\n    }\n  }\n  return null;\n}\nfunction createResultByTNodeType(tNode, currentView) {\n  if (tNode.type & (3 | 8)) {\n    return createElementRef(tNode, currentView);\n  } else if (tNode.type & 4) {\n    return createTemplateRef(tNode, currentView);\n  }\n  return null;\n}\nfunction createResultForNode(lView, tNode, matchingIdx, read) {\n  if (matchingIdx === -1) {\n    return createResultByTNodeType(tNode, lView);\n  } else if (matchingIdx === -2) {\n    return createSpecialToken(lView, tNode, read);\n  } else {\n    return getNodeInjectable(lView, lView[TVIEW], matchingIdx, tNode);\n  }\n}\nfunction createSpecialToken(lView, tNode, read) {\n  if (read === ElementRef) {\n    return createElementRef(tNode, lView);\n  } else if (read === TemplateRef) {\n    return createTemplateRef(tNode, lView);\n  } else if (read === ViewContainerRef) {\n    ngDevMode && assertTNodeType(\n      tNode,\n      3 | 12\n      /* TNodeType.AnyContainer */\n    );\n    return createContainerRef(tNode, lView);\n  } else {\n    ngDevMode && throwError2(`Special token to read should be one of ElementRef, TemplateRef or ViewContainerRef but got ${stringify(read)}.`);\n  }\n}\nfunction materializeViewResults(tView, lView, tQuery, queryIndex) {\n  const lQuery = lView[QUERIES].queries[queryIndex];\n  if (lQuery.matches === null) {\n    const tViewData = tView.data;\n    const tQueryMatches = tQuery.matches;\n    const result = [];\n    for (let i = 0; tQueryMatches !== null && i < tQueryMatches.length; i += 2) {\n      const matchedNodeIdx = tQueryMatches[i];\n      if (matchedNodeIdx < 0) {\n        result.push(null);\n      } else {\n        ngDevMode && assertIndexInRange(tViewData, matchedNodeIdx);\n        const tNode = tViewData[matchedNodeIdx];\n        result.push(createResultForNode(lView, tNode, tQueryMatches[i + 1], tQuery.metadata.read));\n      }\n    }\n    lQuery.matches = result;\n  }\n  return lQuery.matches;\n}\nfunction collectQueryResults(tView, lView, queryIndex, result) {\n  const tQuery = tView.queries.getByIndex(queryIndex);\n  const tQueryMatches = tQuery.matches;\n  if (tQueryMatches !== null) {\n    const lViewResults = materializeViewResults(tView, lView, tQuery, queryIndex);\n    for (let i = 0; i < tQueryMatches.length; i += 2) {\n      const tNodeIdx = tQueryMatches[i];\n      if (tNodeIdx > 0) {\n        result.push(lViewResults[i / 2]);\n      } else {\n        const childQueryIndex = tQueryMatches[i + 1];\n        const declarationLContainer = lView[-tNodeIdx];\n        ngDevMode && assertLContainer(declarationLContainer);\n        for (let i2 = CONTAINER_HEADER_OFFSET; i2 < declarationLContainer.length; i2++) {\n          const embeddedLView = declarationLContainer[i2];\n          if (embeddedLView[DECLARATION_LCONTAINER] === embeddedLView[PARENT]) {\n            collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);\n          }\n        }\n        if (declarationLContainer[MOVED_VIEWS] !== null) {\n          const embeddedLViews = declarationLContainer[MOVED_VIEWS];\n          for (let i2 = 0; i2 < embeddedLViews.length; i2++) {\n            const embeddedLView = embeddedLViews[i2];\n            collectQueryResults(embeddedLView[TVIEW], embeddedLView, childQueryIndex, result);\n          }\n        }\n      }\n    }\n  }\n  return result;\n}\nfunction loadQueryInternal(lView, queryIndex) {\n  ngDevMode && assertDefined(lView[QUERIES], \"LQueries should be defined when trying to load a query\");\n  ngDevMode && assertIndexInRange(lView[QUERIES].queries, queryIndex);\n  return lView[QUERIES].queries[queryIndex].queryList;\n}\nfunction createLQuery(tView, lView, flags) {\n  const queryList = new QueryList(\n    (flags & 4) === 4\n    /* QueryFlags.emitDistinctChangesOnly */\n  );\n  storeCleanupWithContext(tView, lView, queryList, queryList.destroy);\n  const lQueries = (lView[QUERIES] ??= new LQueries_()).queries;\n  return lQueries.push(new LQuery_(queryList)) - 1;\n}\nfunction createViewQuery(predicate, flags, read) {\n  ngDevMode && assertNumber(flags, \"Expecting flags\");\n  const tView = getTView();\n  if (tView.firstCreatePass) {\n    createTQuery(tView, new TQueryMetadata_(predicate, flags, read), -1);\n    if ((flags & 2) === 2) {\n      tView.staticViewQueries = true;\n    }\n  }\n  return createLQuery(tView, getLView(), flags);\n}\nfunction createContentQuery(directiveIndex, predicate, flags, read) {\n  ngDevMode && assertNumber(flags, \"Expecting flags\");\n  const tView = getTView();\n  if (tView.firstCreatePass) {\n    const tNode = getCurrentTNode();\n    createTQuery(tView, new TQueryMetadata_(predicate, flags, read), tNode.index);\n    saveContentQueryAndDirectiveIndex(tView, directiveIndex);\n    if ((flags & 2) === 2) {\n      tView.staticContentQueries = true;\n    }\n  }\n  return createLQuery(tView, getLView(), flags);\n}\nfunction splitQueryMultiSelectors(locator) {\n  return locator.split(\",\").map((s) => s.trim());\n}\nfunction createTQuery(tView, metadata, nodeIndex) {\n  if (tView.queries === null) tView.queries = new TQueries_();\n  tView.queries.track(new TQuery_(metadata, nodeIndex));\n}\nfunction saveContentQueryAndDirectiveIndex(tView, directiveIndex) {\n  const tViewContentQueries = tView.contentQueries || (tView.contentQueries = []);\n  const lastSavedDirectiveIndex = tViewContentQueries.length ? tViewContentQueries[tViewContentQueries.length - 1] : -1;\n  if (directiveIndex !== lastSavedDirectiveIndex) {\n    tViewContentQueries.push(tView.queries.length - 1, directiveIndex);\n  }\n}\nfunction getTQuery(tView, index) {\n  ngDevMode && assertDefined(tView.queries, \"TQueries must be defined to retrieve a TQuery\");\n  return tView.queries.getByIndex(index);\n}\nfunction getQueryResults(lView, queryIndex) {\n  const tView = lView[TVIEW];\n  const tQuery = getTQuery(tView, queryIndex);\n  return tQuery.crossesNgTemplate ? collectQueryResults(tView, lView, queryIndex, []) : materializeViewResults(tView, lView, tQuery, queryIndex);\n}\nfunction createQuerySignalFn(firstOnly, required, opts) {\n  let node;\n  const signalFn = createComputed(() => {\n    node._dirtyCounter();\n    const value = refreshSignalQuery(node, firstOnly);\n    if (required && value === void 0) {\n      throw new RuntimeError(-951, ngDevMode && \"Child query result is required but no value is available.\");\n    }\n    return value;\n  });\n  node = signalFn[SIGNAL];\n  node._dirtyCounter = signal(0);\n  node._flatValue = void 0;\n  if (ngDevMode) {\n    signalFn.toString = () => `[Query Signal]`;\n    node.debugName = opts?.debugName;\n  }\n  return signalFn;\n}\nfunction createSingleResultOptionalQuerySignalFn(opts) {\n  return createQuerySignalFn(\n    /* firstOnly */\n    true,\n    /* required */\n    false,\n    opts\n  );\n}\nfunction createSingleResultRequiredQuerySignalFn(opts) {\n  return createQuerySignalFn(\n    /* firstOnly */\n    true,\n    /* required */\n    true,\n    opts\n  );\n}\nfunction createMultiResultQuerySignalFn(opts) {\n  return createQuerySignalFn(\n    /* firstOnly */\n    false,\n    /* required */\n    false,\n    opts\n  );\n}\nfunction bindQueryToSignal(target, queryIndex) {\n  const node = target[SIGNAL];\n  node._lView = getLView();\n  node._queryIndex = queryIndex;\n  node._queryList = loadQueryInternal(node._lView, queryIndex);\n  node._queryList.onDirty(() => node._dirtyCounter.update((v) => v + 1));\n}\nfunction refreshSignalQuery(node, firstOnly) {\n  const lView = node._lView;\n  const queryIndex = node._queryIndex;\n  if (lView === void 0 || queryIndex === void 0 || lView[FLAGS] & 4) {\n    return firstOnly ? void 0 : EMPTY_ARRAY;\n  }\n  const queryList = loadQueryInternal(lView, queryIndex);\n  const results = getQueryResults(lView, queryIndex);\n  queryList.reset(results, unwrapElementRef);\n  if (firstOnly) {\n    return queryList.first;\n  } else {\n    const resultChanged = queryList._changesDetected;\n    if (resultChanged || node._flatValue === void 0) {\n      return node._flatValue = queryList.toArray();\n    }\n    return node._flatValue;\n  }\n}\nfunction viewChildFn(locator, opts) {\n  ngDevMode && assertInInjectionContext(viewChild);\n  return createSingleResultOptionalQuerySignalFn(opts);\n}\nfunction viewChildRequiredFn(locator, opts) {\n  ngDevMode && assertInInjectionContext(viewChild);\n  return createSingleResultRequiredQuerySignalFn(opts);\n}\nvar viewChild = (() => {\n  viewChildFn.required = viewChildRequiredFn;\n  return viewChildFn;\n})();\nfunction contentChildFn(locator, opts) {\n  ngDevMode && assertInInjectionContext(contentChild);\n  return createSingleResultOptionalQuerySignalFn(opts);\n}\nfunction contentChildRequiredFn(locator, opts) {\n  ngDevMode && assertInInjectionContext(contentChildren);\n  return createSingleResultRequiredQuerySignalFn(opts);\n}\nvar contentChild = (() => {\n  contentChildFn.required = contentChildRequiredFn;\n  return contentChildFn;\n})();\nfunction contentChildren(locator, opts) {\n  return createMultiResultQuerySignalFn(opts);\n}\nfunction createModelSignal(initialValue, opts) {\n  const node = Object.create(INPUT_SIGNAL_NODE);\n  const emitterRef = new OutputEmitterRef();\n  node.value = initialValue;\n  function getter() {\n    producerAccessed(node);\n    assertModelSet(node.value);\n    return node.value;\n  }\n  getter[SIGNAL] = node;\n  getter.asReadonly = signalAsReadonlyFn.bind(getter);\n  getter.set = (newValue) => {\n    if (!node.equal(node.value, newValue)) {\n      signalSetFn(node, newValue);\n      emitterRef.emit(newValue);\n    }\n  };\n  getter.update = (updateFn) => {\n    assertModelSet(node.value);\n    getter.set(updateFn(node.value));\n  };\n  getter.subscribe = emitterRef.subscribe.bind(emitterRef);\n  getter.destroyRef = emitterRef.destroyRef;\n  if (ngDevMode) {\n    getter.toString = () => `[Model Signal: ${getter()}]`;\n    node.debugName = opts?.debugName;\n  }\n  return getter;\n}\nfunction assertModelSet(value) {\n  if (value === REQUIRED_UNSET_VALUE) {\n    throw new RuntimeError(952, ngDevMode && \"Model is required but no value is available yet.\");\n  }\n}\nfunction modelFunction(initialValue, opts) {\n  ngDevMode && assertInInjectionContext(model);\n  return createModelSignal(initialValue, opts);\n}\nfunction modelRequiredFunction(opts) {\n  ngDevMode && assertInInjectionContext(model);\n  return createModelSignal(REQUIRED_UNSET_VALUE, opts);\n}\nvar model = (() => {\n  modelFunction.required = modelRequiredFunction;\n  return modelFunction;\n})();\nvar emitDistinctChangesOnlyDefaultValue = true;\nvar Query = class {\n};\nvar ContentChildren = makePropDecorator(\"ContentChildren\", (selector, opts = {}) => __spreadValues({\n  selector,\n  first: false,\n  isViewQuery: false,\n  descendants: false,\n  emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue\n}, opts), Query);\nvar ContentChild = makePropDecorator(\"ContentChild\", (selector, opts = {}) => __spreadValues({\n  selector,\n  first: true,\n  isViewQuery: false,\n  descendants: true\n}, opts), Query);\nvar ViewChildren = makePropDecorator(\"ViewChildren\", (selector, opts = {}) => __spreadValues({\n  selector,\n  first: false,\n  isViewQuery: true,\n  descendants: true,\n  emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue\n}, opts), Query);\nvar ViewChild = makePropDecorator(\"ViewChild\", (selector, opts) => __spreadValues({\n  selector,\n  first: true,\n  isViewQuery: true,\n  descendants: true\n}, opts), Query);\nfunction resolveComponentResources(resourceResolver) {\n  const componentResolved = [];\n  const urlMap = /* @__PURE__ */ new Map();\n  function cachedResourceResolve(url) {\n    let promise = urlMap.get(url);\n    if (!promise) {\n      const resp = resourceResolver(url);\n      urlMap.set(url, promise = resp.then(unwrapResponse));\n    }\n    return promise;\n  }\n  componentResourceResolutionQueue.forEach((component, type) => {\n    const promises = [];\n    if (component.templateUrl) {\n      promises.push(cachedResourceResolve(component.templateUrl).then((template) => {\n        component.template = template;\n      }));\n    }\n    const styles = typeof component.styles === \"string\" ? [component.styles] : component.styles || [];\n    component.styles = styles;\n    if (component.styleUrl && component.styleUrls?.length) {\n      throw new Error(\"@Component cannot define both `styleUrl` and `styleUrls`. Use `styleUrl` if the component has one stylesheet, or `styleUrls` if it has multiple\");\n    } else if (component.styleUrls?.length) {\n      const styleOffset = component.styles.length;\n      const styleUrls = component.styleUrls;\n      component.styleUrls.forEach((styleUrl, index) => {\n        styles.push(\"\");\n        promises.push(cachedResourceResolve(styleUrl).then((style) => {\n          styles[styleOffset + index] = style;\n          styleUrls.splice(styleUrls.indexOf(styleUrl), 1);\n          if (styleUrls.length == 0) {\n            component.styleUrls = void 0;\n          }\n        }));\n      });\n    } else if (component.styleUrl) {\n      promises.push(cachedResourceResolve(component.styleUrl).then((style) => {\n        styles.push(style);\n        component.styleUrl = void 0;\n      }));\n    }\n    const fullyResolved = Promise.all(promises).then(() => componentDefResolved(type));\n    componentResolved.push(fullyResolved);\n  });\n  clearResolutionOfComponentResourcesQueue();\n  return Promise.all(componentResolved).then(() => void 0);\n}\nvar componentResourceResolutionQueue = /* @__PURE__ */ new Map();\nvar componentDefPendingResolution = /* @__PURE__ */ new Set();\nfunction maybeQueueResolutionOfComponentResources(type, metadata) {\n  if (componentNeedsResolution(metadata)) {\n    componentResourceResolutionQueue.set(type, metadata);\n    componentDefPendingResolution.add(type);\n  }\n}\nfunction componentNeedsResolution(component) {\n  return !!(component.templateUrl && !component.hasOwnProperty(\"template\") || component.styleUrls && component.styleUrls.length || component.styleUrl);\n}\nfunction clearResolutionOfComponentResourcesQueue() {\n  const old = componentResourceResolutionQueue;\n  componentResourceResolutionQueue = /* @__PURE__ */ new Map();\n  return old;\n}\nfunction isComponentResourceResolutionQueueEmpty() {\n  return componentResourceResolutionQueue.size === 0;\n}\nfunction unwrapResponse(response) {\n  return typeof response == \"string\" ? response : response.text();\n}\nfunction componentDefResolved(type) {\n  componentDefPendingResolution.delete(type);\n}\nvar modules = /* @__PURE__ */ new Map();\nvar checkForDuplicateNgModules = true;\nfunction assertSameOrNotExisting(id, type, incoming) {\n  if (type && type !== incoming && checkForDuplicateNgModules) {\n    throw new Error(`Duplicate module registered for ${id} - ${stringify(type)} vs ${stringify(type.name)}`);\n  }\n}\nfunction registerNgModuleType(ngModuleType, id) {\n  const existing = modules.get(id) || null;\n  assertSameOrNotExisting(id, existing, ngModuleType);\n  modules.set(id, ngModuleType);\n}\nfunction \\u0275\\u0275validateIframeAttribute(attrValue, tagName, attrName) {\n  const lView = getLView();\n  const tNode = getSelectedTNode();\n  const element = getNativeByTNode(tNode, lView);\n  if (tNode.type === 2 && tagName.toLowerCase() === \"iframe\") {\n    const iframe = element;\n    iframe.src = \"\";\n    iframe.srcdoc = trustedHTMLFromString(\"\");\n    nativeRemoveNode(lView[RENDERER], iframe);\n    const errorMessage = ngDevMode && `Angular has detected that the \\`${attrName}\\` was applied as a binding to an <iframe>${getTemplateLocationDetails(lView)}. For security reasons, the \\`${attrName}\\` can be set on an <iframe> as a static attribute only. \nTo fix this, switch the \\`${attrName}\\` binding to a static attribute in a template or in host bindings section.`;\n    throw new RuntimeError(-910, errorMessage);\n  }\n  return attrValue;\n}\nvar NgModuleRef$1 = class NgModuleRef {\n};\nvar NgModuleFactory$1 = class NgModuleFactory {\n};\nfunction createNgModule(ngModule, parentInjector) {\n  return new NgModuleRef2(ngModule, parentInjector ?? null, []);\n}\nvar NgModuleRef2 = class extends NgModuleRef$1 {\n  ngModuleType;\n  _parent;\n  // tslint:disable-next-line:require-internal-with-underscore\n  _bootstrapComponents = [];\n  _r3Injector;\n  instance;\n  destroyCbs = [];\n  // When bootstrapping a module we have a dependency graph that looks like this:\n  // ApplicationRef -> ComponentFactoryResolver -> NgModuleRef. The problem is that if the\n  // module being resolved tries to inject the ComponentFactoryResolver, it'll create a\n  // circular dependency which will result in a runtime error, because the injector doesn't\n  // exist yet. We work around the issue by creating the ComponentFactoryResolver ourselves\n  // and providing it, rather than letting the injector resolve it.\n  componentFactoryResolver = new ComponentFactoryResolver2(this);\n  constructor(ngModuleType, _parent, additionalProviders, runInjectorInitializers = true) {\n    super();\n    this.ngModuleType = ngModuleType;\n    this._parent = _parent;\n    const ngModuleDef = getNgModuleDef(ngModuleType);\n    ngDevMode && assertDefined(ngModuleDef, `NgModule '${stringify(ngModuleType)}' is not a subtype of 'NgModuleType'.`);\n    this._bootstrapComponents = maybeUnwrapFn(ngModuleDef.bootstrap);\n    this._r3Injector = createInjectorWithoutInjectorInstances(ngModuleType, _parent, [{\n      provide: NgModuleRef$1,\n      useValue: this\n    }, {\n      provide: ComponentFactoryResolver$1,\n      useValue: this.componentFactoryResolver\n    }, ...additionalProviders], stringify(ngModuleType), /* @__PURE__ */ new Set([\"environment\"]));\n    if (runInjectorInitializers) {\n      this.resolveInjectorInitializers();\n    }\n  }\n  resolveInjectorInitializers() {\n    this._r3Injector.resolveInjectorInitializers();\n    this.instance = this._r3Injector.get(this.ngModuleType);\n  }\n  get injector() {\n    return this._r3Injector;\n  }\n  destroy() {\n    ngDevMode && assertDefined(this.destroyCbs, \"NgModule already destroyed\");\n    const injector = this._r3Injector;\n    !injector.destroyed && injector.destroy();\n    this.destroyCbs.forEach((fn) => fn());\n    this.destroyCbs = null;\n  }\n  onDestroy(callback) {\n    ngDevMode && assertDefined(this.destroyCbs, \"NgModule already destroyed\");\n    this.destroyCbs.push(callback);\n  }\n};\nvar NgModuleFactory2 = class extends NgModuleFactory$1 {\n  moduleType;\n  constructor(moduleType) {\n    super();\n    this.moduleType = moduleType;\n  }\n  create(parentInjector) {\n    return new NgModuleRef2(this.moduleType, parentInjector, []);\n  }\n};\nfunction createNgModuleRefWithProviders(moduleType, parentInjector, additionalProviders) {\n  return new NgModuleRef2(moduleType, parentInjector, additionalProviders, false);\n}\nvar EnvironmentNgModuleRefAdapter = class extends NgModuleRef$1 {\n  injector;\n  componentFactoryResolver = new ComponentFactoryResolver2(this);\n  instance = null;\n  constructor(config2) {\n    super();\n    const injector = new R3Injector([...config2.providers, {\n      provide: NgModuleRef$1,\n      useValue: this\n    }, {\n      provide: ComponentFactoryResolver$1,\n      useValue: this.componentFactoryResolver\n    }], config2.parent || getNullInjector(), config2.debugName, /* @__PURE__ */ new Set([\"environment\"]));\n    this.injector = injector;\n    if (config2.runEnvironmentInitializers) {\n      injector.resolveInjectorInitializers();\n    }\n  }\n  destroy() {\n    this.injector.destroy();\n  }\n  onDestroy(callback) {\n    this.injector.onDestroy(callback);\n  }\n};\nfunction createEnvironmentInjector(providers, parent, debugName = null) {\n  const adapter = new EnvironmentNgModuleRefAdapter({\n    providers,\n    parent,\n    debugName,\n    runEnvironmentInitializers: true\n  });\n  return adapter.injector;\n}\nvar StandaloneService = class _StandaloneService {\n  _injector;\n  cachedInjectors = /* @__PURE__ */ new Map();\n  constructor(_injector) {\n    this._injector = _injector;\n  }\n  getOrCreateStandaloneInjector(componentDef) {\n    if (!componentDef.standalone) {\n      return null;\n    }\n    if (!this.cachedInjectors.has(componentDef)) {\n      const providers = internalImportProvidersFrom(false, componentDef.type);\n      const standaloneInjector = providers.length > 0 ? createEnvironmentInjector([providers], this._injector, `Standalone[${componentDef.type.name}]`) : null;\n      this.cachedInjectors.set(componentDef, standaloneInjector);\n    }\n    return this.cachedInjectors.get(componentDef);\n  }\n  ngOnDestroy() {\n    try {\n      for (const injector of this.cachedInjectors.values()) {\n        if (injector !== null) {\n          injector.destroy();\n        }\n      }\n    } finally {\n      this.cachedInjectors.clear();\n    }\n  }\n  /** @nocollapse */\n  static \\u0275prov = (\n    /** @pureOrBreakMyCode */\n    /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n      token: _StandaloneService,\n      providedIn: \"environment\",\n      factory: () => new _StandaloneService(\\u0275\\u0275inject(EnvironmentInjector))\n    })\n  );\n};\nfunction \\u0275\\u0275defineComponent(componentDefinition) {\n  return noSideEffects(() => {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && initNgDevMode();\n    const baseDef = getNgDirectiveDef(componentDefinition);\n    const def = __spreadProps(__spreadValues({}, baseDef), {\n      decls: componentDefinition.decls,\n      vars: componentDefinition.vars,\n      template: componentDefinition.template,\n      consts: componentDefinition.consts || null,\n      ngContentSelectors: componentDefinition.ngContentSelectors,\n      onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,\n      directiveDefs: null,\n      // assigned in noSideEffects\n      pipeDefs: null,\n      // assigned in noSideEffects\n      dependencies: baseDef.standalone && componentDefinition.dependencies || null,\n      getStandaloneInjector: baseDef.standalone ? (parentInjector) => {\n        return parentInjector.get(StandaloneService).getOrCreateStandaloneInjector(def);\n      } : null,\n      getExternalStyles: null,\n      signals: componentDefinition.signals ?? false,\n      data: componentDefinition.data || {},\n      encapsulation: componentDefinition.encapsulation || ViewEncapsulation.Emulated,\n      styles: componentDefinition.styles || EMPTY_ARRAY,\n      _: null,\n      schemas: componentDefinition.schemas || null,\n      tView: null,\n      id: \"\"\n    });\n    if (baseDef.standalone) {\n      performanceMarkFeature(\"NgStandalone\");\n    }\n    initFeatures(def);\n    const dependencies = componentDefinition.dependencies;\n    def.directiveDefs = extractDefListOrFactory(\n      dependencies,\n      /* pipeDef */\n      false\n    );\n    def.pipeDefs = extractDefListOrFactory(\n      dependencies,\n      /* pipeDef */\n      true\n    );\n    def.id = getComponentId(def);\n    return def;\n  });\n}\nfunction extractDirectiveDef(type) {\n  return getComponentDef(type) || getDirectiveDef(type);\n}\nfunction nonNull(value) {\n  return value !== null;\n}\nfunction \\u0275\\u0275defineNgModule(def) {\n  return noSideEffects(() => {\n    const res = {\n      type: def.type,\n      bootstrap: def.bootstrap || EMPTY_ARRAY,\n      declarations: def.declarations || EMPTY_ARRAY,\n      imports: def.imports || EMPTY_ARRAY,\n      exports: def.exports || EMPTY_ARRAY,\n      transitiveCompileScopes: null,\n      schemas: def.schemas || null,\n      id: def.id || null\n    };\n    return res;\n  });\n}\nfunction parseAndConvertInputsForDefinition(obj, declaredInputs) {\n  if (obj == null) return EMPTY_OBJ;\n  const newLookup = {};\n  for (const minifiedKey in obj) {\n    if (obj.hasOwnProperty(minifiedKey)) {\n      const value = obj[minifiedKey];\n      let publicName;\n      let declaredName;\n      let inputFlags;\n      let transform;\n      if (Array.isArray(value)) {\n        inputFlags = value[0];\n        publicName = value[1];\n        declaredName = value[2] ?? publicName;\n        transform = value[3] || null;\n      } else {\n        publicName = value;\n        declaredName = value;\n        inputFlags = InputFlags.None;\n        transform = null;\n      }\n      newLookup[publicName] = [minifiedKey, inputFlags, transform];\n      declaredInputs[publicName] = declaredName;\n    }\n  }\n  return newLookup;\n}\nfunction parseAndConvertOutputsForDefinition(obj) {\n  if (obj == null) return EMPTY_OBJ;\n  const newLookup = {};\n  for (const minifiedKey in obj) {\n    if (obj.hasOwnProperty(minifiedKey)) {\n      newLookup[obj[minifiedKey]] = minifiedKey;\n    }\n  }\n  return newLookup;\n}\nfunction \\u0275\\u0275defineDirective(directiveDefinition) {\n  return noSideEffects(() => {\n    const def = getNgDirectiveDef(directiveDefinition);\n    initFeatures(def);\n    return def;\n  });\n}\nfunction \\u0275\\u0275definePipe(pipeDef) {\n  return {\n    type: pipeDef.type,\n    name: pipeDef.name,\n    factory: null,\n    pure: pipeDef.pure !== false,\n    standalone: pipeDef.standalone ?? true,\n    onDestroy: pipeDef.type.prototype.ngOnDestroy || null\n  };\n}\nfunction getNgDirectiveDef(directiveDefinition) {\n  const declaredInputs = {};\n  return {\n    type: directiveDefinition.type,\n    providersResolver: null,\n    factory: null,\n    hostBindings: directiveDefinition.hostBindings || null,\n    hostVars: directiveDefinition.hostVars || 0,\n    hostAttrs: directiveDefinition.hostAttrs || null,\n    contentQueries: directiveDefinition.contentQueries || null,\n    declaredInputs,\n    inputConfig: directiveDefinition.inputs || EMPTY_OBJ,\n    exportAs: directiveDefinition.exportAs || null,\n    standalone: directiveDefinition.standalone ?? true,\n    signals: directiveDefinition.signals === true,\n    selectors: directiveDefinition.selectors || EMPTY_ARRAY,\n    viewQuery: directiveDefinition.viewQuery || null,\n    features: directiveDefinition.features || null,\n    setInput: null,\n    findHostDirectiveDefs: null,\n    hostDirectives: null,\n    inputs: parseAndConvertInputsForDefinition(directiveDefinition.inputs, declaredInputs),\n    outputs: parseAndConvertOutputsForDefinition(directiveDefinition.outputs),\n    debugInfo: null\n  };\n}\nfunction initFeatures(definition) {\n  definition.features?.forEach((fn) => fn(definition));\n}\nfunction extractDefListOrFactory(dependencies, pipeDef) {\n  if (!dependencies) {\n    return null;\n  }\n  const defExtractor = pipeDef ? getPipeDef$1 : extractDirectiveDef;\n  return () => (typeof dependencies === \"function\" ? dependencies() : dependencies).map((dep) => defExtractor(dep)).filter(nonNull);\n}\nvar GENERATED_COMP_IDS = /* @__PURE__ */ new Map();\nfunction getComponentId(componentDef) {\n  let hash = 0;\n  const componentDefConsts = typeof componentDef.consts === \"function\" ? \"\" : componentDef.consts;\n  const hashSelectors = [\n    componentDef.selectors,\n    componentDef.ngContentSelectors,\n    componentDef.hostVars,\n    componentDef.hostAttrs,\n    componentDefConsts,\n    componentDef.vars,\n    componentDef.decls,\n    componentDef.encapsulation,\n    componentDef.standalone,\n    componentDef.signals,\n    componentDef.exportAs,\n    JSON.stringify(componentDef.inputs),\n    JSON.stringify(componentDef.outputs),\n    // We cannot use 'componentDef.type.name' as the name of the symbol will change and will not\n    // match in the server and browser bundles.\n    Object.getOwnPropertyNames(componentDef.type.prototype),\n    !!componentDef.contentQueries,\n    !!componentDef.viewQuery\n  ];\n  if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n    for (const item of hashSelectors) {\n      assertNotEqual(typeof item, \"function\", \"Internal error: attempting to use a function in component id computation logic.\");\n    }\n  }\n  for (const char of hashSelectors.join(\"|\")) {\n    hash = Math.imul(31, hash) + char.charCodeAt(0) << 0;\n  }\n  hash += 2147483647 + 1;\n  const compId = \"c\" + hash;\n  if ((typeof ngDevMode === \"undefined\" || ngDevMode) && true) {\n    if (GENERATED_COMP_IDS.has(compId)) {\n      const previousCompDefType = GENERATED_COMP_IDS.get(compId);\n      if (previousCompDefType !== componentDef.type) {\n        console.warn(formatRuntimeError(-912, `Component ID generation collision detected. Components '${previousCompDefType.name}' and '${componentDef.type.name}' with selector '${stringifyCSSSelectorList(componentDef.selectors)}' generated the same component ID. To fix this, you can change the selector of one of those components or add an extra host attribute to force a different ID.`));\n      }\n    } else {\n      GENERATED_COMP_IDS.set(compId, componentDef.type);\n    }\n  }\n  return compId;\n}\nfunction getSuperType(type) {\n  return Object.getPrototypeOf(type.prototype).constructor;\n}\nfunction \\u0275\\u0275InheritDefinitionFeature(definition) {\n  let superType = getSuperType(definition.type);\n  let shouldInheritFields = true;\n  const inheritanceChain = [definition];\n  while (superType) {\n    let superDef = void 0;\n    if (isComponentDef(definition)) {\n      superDef = superType.\\u0275cmp || superType.\\u0275dir;\n    } else {\n      if (superType.\\u0275cmp) {\n        throw new RuntimeError(903, ngDevMode && `Directives cannot inherit Components. Directive ${stringifyForError(definition.type)} is attempting to extend component ${stringifyForError(superType)}`);\n      }\n      superDef = superType.\\u0275dir;\n    }\n    if (superDef) {\n      if (shouldInheritFields) {\n        inheritanceChain.push(superDef);\n        const writeableDef = definition;\n        writeableDef.inputs = maybeUnwrapEmpty(definition.inputs);\n        writeableDef.declaredInputs = maybeUnwrapEmpty(definition.declaredInputs);\n        writeableDef.outputs = maybeUnwrapEmpty(definition.outputs);\n        const superHostBindings = superDef.hostBindings;\n        superHostBindings && inheritHostBindings(definition, superHostBindings);\n        const superViewQuery = superDef.viewQuery;\n        const superContentQueries = superDef.contentQueries;\n        superViewQuery && inheritViewQuery(definition, superViewQuery);\n        superContentQueries && inheritContentQueries(definition, superContentQueries);\n        mergeInputsWithTransforms(definition, superDef);\n        fillProperties(definition.outputs, superDef.outputs);\n        if (isComponentDef(superDef) && superDef.data.animation) {\n          const defData = definition.data;\n          defData.animation = (defData.animation || []).concat(superDef.data.animation);\n        }\n      }\n      const features = superDef.features;\n      if (features) {\n        for (let i = 0; i < features.length; i++) {\n          const feature = features[i];\n          if (feature && feature.ngInherit) {\n            feature(definition);\n          }\n          if (feature === \\u0275\\u0275InheritDefinitionFeature) {\n            shouldInheritFields = false;\n          }\n        }\n      }\n    }\n    superType = Object.getPrototypeOf(superType);\n  }\n  mergeHostAttrsAcrossInheritance(inheritanceChain);\n}\nfunction mergeInputsWithTransforms(target, source) {\n  for (const key in source.inputs) {\n    if (!source.inputs.hasOwnProperty(key)) {\n      continue;\n    }\n    if (target.inputs.hasOwnProperty(key)) {\n      continue;\n    }\n    const value = source.inputs[key];\n    if (value !== void 0) {\n      target.inputs[key] = value;\n      target.declaredInputs[key] = source.declaredInputs[key];\n    }\n  }\n}\nfunction mergeHostAttrsAcrossInheritance(inheritanceChain) {\n  let hostVars = 0;\n  let hostAttrs = null;\n  for (let i = inheritanceChain.length - 1; i >= 0; i--) {\n    const def = inheritanceChain[i];\n    def.hostVars = hostVars += def.hostVars;\n    def.hostAttrs = mergeHostAttrs(def.hostAttrs, hostAttrs = mergeHostAttrs(hostAttrs, def.hostAttrs));\n  }\n}\nfunction maybeUnwrapEmpty(value) {\n  if (value === EMPTY_OBJ) {\n    return {};\n  } else if (value === EMPTY_ARRAY) {\n    return [];\n  } else {\n    return value;\n  }\n}\nfunction inheritViewQuery(definition, superViewQuery) {\n  const prevViewQuery = definition.viewQuery;\n  if (prevViewQuery) {\n    definition.viewQuery = (rf, ctx) => {\n      superViewQuery(rf, ctx);\n      prevViewQuery(rf, ctx);\n    };\n  } else {\n    definition.viewQuery = superViewQuery;\n  }\n}\nfunction inheritContentQueries(definition, superContentQueries) {\n  const prevContentQueries = definition.contentQueries;\n  if (prevContentQueries) {\n    definition.contentQueries = (rf, ctx, directiveIndex) => {\n      superContentQueries(rf, ctx, directiveIndex);\n      prevContentQueries(rf, ctx, directiveIndex);\n    };\n  } else {\n    definition.contentQueries = superContentQueries;\n  }\n}\nfunction inheritHostBindings(definition, superHostBindings) {\n  const prevHostBindings = definition.hostBindings;\n  if (prevHostBindings) {\n    definition.hostBindings = (rf, ctx) => {\n      superHostBindings(rf, ctx);\n      prevHostBindings(rf, ctx);\n    };\n  } else {\n    definition.hostBindings = superHostBindings;\n  }\n}\nvar COPY_DIRECTIVE_FIELDS = [\n  // The child class should use the providers of its parent.\n  \"providersResolver\"\n  // Not listed here are any fields which are handled by the `ɵɵInheritDefinitionFeature`, such\n  // as inputs, outputs, and host binding functions.\n];\nvar COPY_COMPONENT_FIELDS = [\n  // The child class should use the template function of its parent, including all template\n  // semantics.\n  \"template\",\n  \"decls\",\n  \"consts\",\n  \"vars\",\n  \"onPush\",\n  \"ngContentSelectors\",\n  // The child class should use the CSS styles of its parent, including all styling semantics.\n  \"styles\",\n  \"encapsulation\",\n  // The child class should be checked by the runtime in the same way as its parent.\n  \"schemas\"\n];\nfunction \\u0275\\u0275CopyDefinitionFeature(definition) {\n  let superType = getSuperType(definition.type);\n  let superDef = void 0;\n  if (isComponentDef(definition)) {\n    superDef = superType.\\u0275cmp;\n  } else {\n    superDef = superType.\\u0275dir;\n  }\n  const defAny = definition;\n  for (const field of COPY_DIRECTIVE_FIELDS) {\n    defAny[field] = superDef[field];\n  }\n  if (isComponentDef(superDef)) {\n    for (const field of COPY_COMPONENT_FIELDS) {\n      defAny[field] = superDef[field];\n    }\n  }\n}\nfunction \\u0275\\u0275HostDirectivesFeature(rawHostDirectives) {\n  const feature = (definition) => {\n    const isEager = Array.isArray(rawHostDirectives);\n    if (definition.hostDirectives === null) {\n      definition.findHostDirectiveDefs = findHostDirectiveDefs;\n      definition.hostDirectives = isEager ? rawHostDirectives.map(createHostDirectiveDef) : [rawHostDirectives];\n    } else if (isEager) {\n      definition.hostDirectives.unshift(...rawHostDirectives.map(createHostDirectiveDef));\n    } else {\n      definition.hostDirectives.unshift(rawHostDirectives);\n    }\n  };\n  feature.ngInherit = true;\n  return feature;\n}\nfunction findHostDirectiveDefs(currentDef, matchedDefs, hostDirectiveDefs) {\n  if (currentDef.hostDirectives !== null) {\n    for (const configOrFn of currentDef.hostDirectives) {\n      if (typeof configOrFn === \"function\") {\n        const resolved = configOrFn();\n        for (const config2 of resolved) {\n          trackHostDirectiveDef(createHostDirectiveDef(config2), matchedDefs, hostDirectiveDefs);\n        }\n      } else {\n        trackHostDirectiveDef(configOrFn, matchedDefs, hostDirectiveDefs);\n      }\n    }\n  }\n}\nfunction trackHostDirectiveDef(def, matchedDefs, hostDirectiveDefs) {\n  const hostDirectiveDef = getDirectiveDef(def.directive);\n  if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n    validateHostDirective(def, hostDirectiveDef);\n  }\n  patchDeclaredInputs(hostDirectiveDef.declaredInputs, def.inputs);\n  findHostDirectiveDefs(hostDirectiveDef, matchedDefs, hostDirectiveDefs);\n  hostDirectiveDefs.set(hostDirectiveDef, def);\n  matchedDefs.push(hostDirectiveDef);\n}\nfunction createHostDirectiveDef(config2) {\n  return typeof config2 === \"function\" ? {\n    directive: resolveForwardRef(config2),\n    inputs: EMPTY_OBJ,\n    outputs: EMPTY_OBJ\n  } : {\n    directive: resolveForwardRef(config2.directive),\n    inputs: bindingArrayToMap(config2.inputs),\n    outputs: bindingArrayToMap(config2.outputs)\n  };\n}\nfunction bindingArrayToMap(bindings) {\n  if (bindings === void 0 || bindings.length === 0) {\n    return EMPTY_OBJ;\n  }\n  const result = {};\n  for (let i = 0; i < bindings.length; i += 2) {\n    result[bindings[i]] = bindings[i + 1];\n  }\n  return result;\n}\nfunction patchDeclaredInputs(declaredInputs, exposedInputs) {\n  for (const publicName in exposedInputs) {\n    if (exposedInputs.hasOwnProperty(publicName)) {\n      const remappedPublicName = exposedInputs[publicName];\n      const privateName = declaredInputs[publicName];\n      if ((typeof ngDevMode === \"undefined\" || ngDevMode) && declaredInputs.hasOwnProperty(remappedPublicName)) {\n        assertEqual(declaredInputs[remappedPublicName], declaredInputs[publicName], `Conflicting host directive input alias ${publicName}.`);\n      }\n      declaredInputs[remappedPublicName] = privateName;\n    }\n  }\n}\nfunction validateHostDirective(hostDirectiveConfig, directiveDef) {\n  const type = hostDirectiveConfig.directive;\n  if (directiveDef === null) {\n    if (getComponentDef(type) !== null) {\n      throw new RuntimeError(310, `Host directive ${type.name} cannot be a component.`);\n    }\n    throw new RuntimeError(307, `Could not resolve metadata for host directive ${type.name}. Make sure that the ${type.name} class is annotated with an @Directive decorator.`);\n  }\n  if (!directiveDef.standalone) {\n    throw new RuntimeError(308, `Host directive ${directiveDef.type.name} must be standalone.`);\n  }\n  validateMappings(\"input\", directiveDef, hostDirectiveConfig.inputs);\n  validateMappings(\"output\", directiveDef, hostDirectiveConfig.outputs);\n}\nfunction validateMappings(bindingType, def, hostDirectiveBindings) {\n  const className = def.type.name;\n  const bindings = bindingType === \"input\" ? def.inputs : def.outputs;\n  for (const publicName in hostDirectiveBindings) {\n    if (hostDirectiveBindings.hasOwnProperty(publicName)) {\n      if (!bindings.hasOwnProperty(publicName)) {\n        throw new RuntimeError(311, `Directive ${className} does not have an ${bindingType} with a public name of ${publicName}.`);\n      }\n      const remappedPublicName = hostDirectiveBindings[publicName];\n      if (bindings.hasOwnProperty(remappedPublicName) && remappedPublicName !== publicName) {\n        throw new RuntimeError(312, `Cannot alias ${bindingType} ${publicName} of host directive ${className} to ${remappedPublicName}, because it already has a different ${bindingType} with the same public name.`);\n      }\n    }\n  }\n}\nfunction isListLikeIterable(obj) {\n  if (!isJsObject(obj)) return false;\n  return Array.isArray(obj) || !(obj instanceof Map) && // JS Map are iterables but return entries as [k, v]\n  Symbol.iterator in obj;\n}\nfunction areIterablesEqual(a, b, comparator) {\n  const iterator1 = a[Symbol.iterator]();\n  const iterator2 = b[Symbol.iterator]();\n  while (true) {\n    const item1 = iterator1.next();\n    const item2 = iterator2.next();\n    if (item1.done && item2.done) return true;\n    if (item1.done || item2.done) return false;\n    if (!comparator(item1.value, item2.value)) return false;\n  }\n}\nfunction iterateListLike(obj, fn) {\n  if (Array.isArray(obj)) {\n    for (let i = 0; i < obj.length; i++) {\n      fn(obj[i]);\n    }\n  } else {\n    const iterator2 = obj[Symbol.iterator]();\n    let item;\n    while (!(item = iterator2.next()).done) {\n      fn(item.value);\n    }\n  }\n}\nfunction isJsObject(o) {\n  return o !== null && (typeof o === \"function\" || typeof o === \"object\");\n}\nfunction devModeEqual(a, b) {\n  const isListLikeIterableA = isListLikeIterable(a);\n  const isListLikeIterableB = isListLikeIterable(b);\n  if (isListLikeIterableA && isListLikeIterableB) {\n    return areIterablesEqual(a, b, devModeEqual);\n  } else {\n    const isAObject = a && (typeof a === \"object\" || typeof a === \"function\");\n    const isBObject = b && (typeof b === \"object\" || typeof b === \"function\");\n    if (!isListLikeIterableA && isAObject && !isListLikeIterableB && isBObject) {\n      return true;\n    } else {\n      return Object.is(a, b);\n    }\n  }\n}\nfunction updateBinding(lView, bindingIndex, value) {\n  return lView[bindingIndex] = value;\n}\nfunction getBinding(lView, bindingIndex) {\n  ngDevMode && assertIndexInRange(lView, bindingIndex);\n  ngDevMode && assertNotSame(lView[bindingIndex], NO_CHANGE, \"Stored value should never be NO_CHANGE.\");\n  return lView[bindingIndex];\n}\nfunction bindingUpdated(lView, bindingIndex, value) {\n  ngDevMode && assertNotSame(value, NO_CHANGE, \"Incoming value should never be NO_CHANGE.\");\n  ngDevMode && assertLessThan(bindingIndex, lView.length, `Slot should have been initialized to NO_CHANGE`);\n  const oldValue = lView[bindingIndex];\n  if (Object.is(oldValue, value)) {\n    return false;\n  } else {\n    if (ngDevMode && isInCheckNoChangesMode()) {\n      const oldValueToCompare = oldValue !== NO_CHANGE ? oldValue : void 0;\n      if (!devModeEqual(oldValueToCompare, value)) {\n        const details = getExpressionChangedErrorDetails(lView, bindingIndex, oldValueToCompare, value);\n        throwErrorIfNoChangesMode(oldValue === NO_CHANGE, details.oldValue, details.newValue, details.propName, lView);\n      }\n      return false;\n    }\n    lView[bindingIndex] = value;\n    return true;\n  }\n}\nfunction bindingUpdated2(lView, bindingIndex, exp1, exp2) {\n  const different = bindingUpdated(lView, bindingIndex, exp1);\n  return bindingUpdated(lView, bindingIndex + 1, exp2) || different;\n}\nfunction bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) {\n  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);\n  return bindingUpdated(lView, bindingIndex + 2, exp3) || different;\n}\nfunction bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) {\n  const different = bindingUpdated2(lView, bindingIndex, exp1, exp2);\n  return bindingUpdated2(lView, bindingIndex + 2, exp3, exp4) || different;\n}\nfunction templateFirstCreatePass(index, tView, lView, templateFn, decls, vars, tagName, attrs, localRefsIndex) {\n  ngDevMode && assertFirstCreatePass(tView);\n  ngDevMode && ngDevMode.firstCreatePass++;\n  const tViewConsts = tView.consts;\n  const tNode = getOrCreateTNode(tView, index, 4, tagName || null, attrs || null);\n  if (getBindingsEnabled()) {\n    resolveDirectives(tView, lView, tNode, getConstant(tViewConsts, localRefsIndex), findDirectiveDefMatches);\n  }\n  tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);\n  registerPostOrderHooks(tView, tNode);\n  const embeddedTView = tNode.tView = createTView(\n    2,\n    tNode,\n    templateFn,\n    decls,\n    vars,\n    tView.directiveRegistry,\n    tView.pipeRegistry,\n    null,\n    tView.schemas,\n    tViewConsts,\n    null\n    /* ssrId */\n  );\n  if (tView.queries !== null) {\n    tView.queries.template(tView, tNode);\n    embeddedTView.queries = tView.queries.embeddedTView(tNode);\n  }\n  return tNode;\n}\nfunction declareTemplate(declarationLView, declarationTView, index, templateFn, decls, vars, tagName, attrs, localRefsIndex, localRefExtractor) {\n  const adjustedIndex = index + HEADER_OFFSET;\n  const tNode = declarationTView.firstCreatePass ? templateFirstCreatePass(adjustedIndex, declarationTView, declarationLView, templateFn, decls, vars, tagName, attrs, localRefsIndex) : declarationTView.data[adjustedIndex];\n  setCurrentTNode(tNode, false);\n  const comment = _locateOrCreateContainerAnchor(declarationTView, declarationLView, tNode, index);\n  if (wasLastNodeCreated()) {\n    appendChild(declarationTView, declarationLView, comment, tNode);\n  }\n  attachPatchData(comment, declarationLView);\n  const lContainer = createLContainer(comment, declarationLView, comment, tNode);\n  declarationLView[adjustedIndex] = lContainer;\n  addToEndOfViewTree(declarationLView, lContainer);\n  populateDehydratedViewsInLContainer(lContainer, tNode, declarationLView);\n  if (isDirectiveHost(tNode)) {\n    createDirectivesInstances(declarationTView, declarationLView, tNode);\n  }\n  if (localRefsIndex != null) {\n    saveResolvedLocalsInData(declarationLView, tNode, localRefExtractor);\n  }\n  return tNode;\n}\nfunction \\u0275\\u0275template(index, templateFn, decls, vars, tagName, attrsIndex, localRefsIndex, localRefExtractor) {\n  const lView = getLView();\n  const tView = getTView();\n  const attrs = getConstant(tView.consts, attrsIndex);\n  declareTemplate(lView, tView, index, templateFn, decls, vars, tagName, attrs, localRefsIndex, localRefExtractor);\n  return \\u0275\\u0275template;\n}\nvar _locateOrCreateContainerAnchor = createContainerAnchorImpl;\nfunction createContainerAnchorImpl(tView, lView, tNode, index) {\n  lastNodeWasCreated(true);\n  return lView[RENDERER].createComment(ngDevMode ? \"container\" : \"\");\n}\nfunction onIdle(callback, injector) {\n  const scheduler = injector.get(IdleScheduler);\n  const cleanupFn = () => scheduler.remove(callback);\n  scheduler.add(callback);\n  return cleanupFn;\n}\nvar _requestIdleCallback = () => typeof requestIdleCallback !== \"undefined\" ? requestIdleCallback : setTimeout;\nvar _cancelIdleCallback = () => typeof requestIdleCallback !== \"undefined\" ? cancelIdleCallback : clearTimeout;\nvar IdleScheduler = class _IdleScheduler {\n  // Indicates whether current callbacks are being invoked.\n  executingCallbacks = false;\n  // Currently scheduled idle callback id.\n  idleId = null;\n  // Set of callbacks to be invoked next.\n  current = /* @__PURE__ */ new Set();\n  // Set of callbacks collected while invoking current set of callbacks.\n  // Those callbacks are scheduled for the next idle period.\n  deferred = /* @__PURE__ */ new Set();\n  ngZone = inject(NgZone);\n  requestIdleCallbackFn = _requestIdleCallback().bind(globalThis);\n  cancelIdleCallbackFn = _cancelIdleCallback().bind(globalThis);\n  add(callback) {\n    const target = this.executingCallbacks ? this.deferred : this.current;\n    target.add(callback);\n    if (this.idleId === null) {\n      this.scheduleIdleCallback();\n    }\n  }\n  remove(callback) {\n    const {\n      current,\n      deferred\n    } = this;\n    current.delete(callback);\n    deferred.delete(callback);\n    if (current.size === 0 && deferred.size === 0) {\n      this.cancelIdleCallback();\n    }\n  }\n  scheduleIdleCallback() {\n    const callback = () => {\n      this.cancelIdleCallback();\n      this.executingCallbacks = true;\n      for (const callback2 of this.current) {\n        callback2();\n      }\n      this.current.clear();\n      this.executingCallbacks = false;\n      if (this.deferred.size > 0) {\n        for (const callback2 of this.deferred) {\n          this.current.add(callback2);\n        }\n        this.deferred.clear();\n        this.scheduleIdleCallback();\n      }\n    };\n    this.idleId = this.requestIdleCallbackFn(() => this.ngZone.run(callback));\n  }\n  cancelIdleCallback() {\n    if (this.idleId !== null) {\n      this.cancelIdleCallbackFn(this.idleId);\n      this.idleId = null;\n    }\n  }\n  ngOnDestroy() {\n    this.cancelIdleCallback();\n    this.current.clear();\n    this.deferred.clear();\n  }\n  /** @nocollapse */\n  static \\u0275prov = (\n    /** @pureOrBreakMyCode */\n    /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n      token: _IdleScheduler,\n      providedIn: \"root\",\n      factory: () => new _IdleScheduler()\n    })\n  );\n};\nfunction onTimer(delay) {\n  return (callback, injector) => scheduleTimerTrigger(delay, callback, injector);\n}\nfunction scheduleTimerTrigger(delay, callback, injector) {\n  const scheduler = injector.get(TimerScheduler);\n  const ngZone = injector.get(NgZone);\n  const cleanupFn = () => scheduler.remove(callback);\n  scheduler.add(delay, callback, ngZone);\n  return cleanupFn;\n}\nvar TimerScheduler = class _TimerScheduler {\n  // Indicates whether current callbacks are being invoked.\n  executingCallbacks = false;\n  // Currently scheduled `setTimeout` id.\n  timeoutId = null;\n  // When currently scheduled timer would fire.\n  invokeTimerAt = null;\n  // List of callbacks to be invoked.\n  // For each callback we also store a timestamp on when the callback\n  // should be invoked. We store timestamps and callback functions\n  // in a flat array to avoid creating new objects for each entry.\n  // [timestamp1, callback1, timestamp2, callback2, ...]\n  current = [];\n  // List of callbacks collected while invoking current set of callbacks.\n  // Those callbacks are added to the \"current\" queue at the end of\n  // the current callback invocation. The shape of this list is the same\n  // as the shape of the `current` list.\n  deferred = [];\n  add(delay, callback, ngZone) {\n    const target = this.executingCallbacks ? this.deferred : this.current;\n    this.addToQueue(target, Date.now() + delay, callback);\n    this.scheduleTimer(ngZone);\n  }\n  remove(callback) {\n    const {\n      current,\n      deferred\n    } = this;\n    const callbackIndex = this.removeFromQueue(current, callback);\n    if (callbackIndex === -1) {\n      this.removeFromQueue(deferred, callback);\n    }\n    if (current.length === 0 && deferred.length === 0) {\n      this.clearTimeout();\n    }\n  }\n  addToQueue(target, invokeAt, callback) {\n    let insertAtIndex = target.length;\n    for (let i = 0; i < target.length; i += 2) {\n      const invokeQueuedCallbackAt = target[i];\n      if (invokeQueuedCallbackAt > invokeAt) {\n        insertAtIndex = i;\n        break;\n      }\n    }\n    arrayInsert2(target, insertAtIndex, invokeAt, callback);\n  }\n  removeFromQueue(target, callback) {\n    let index = -1;\n    for (let i = 0; i < target.length; i += 2) {\n      const queuedCallback = target[i + 1];\n      if (queuedCallback === callback) {\n        index = i;\n        break;\n      }\n    }\n    if (index > -1) {\n      arraySplice(target, index, 2);\n    }\n    return index;\n  }\n  scheduleTimer(ngZone) {\n    const callback = () => {\n      this.clearTimeout();\n      this.executingCallbacks = true;\n      const current = [...this.current];\n      const now = Date.now();\n      for (let i = 0; i < current.length; i += 2) {\n        const invokeAt = current[i];\n        const callback2 = current[i + 1];\n        if (invokeAt <= now) {\n          callback2();\n        } else {\n          break;\n        }\n      }\n      let lastCallbackIndex = -1;\n      for (let i = 0; i < this.current.length; i += 2) {\n        const invokeAt = this.current[i];\n        if (invokeAt <= now) {\n          lastCallbackIndex = i + 1;\n        } else {\n          break;\n        }\n      }\n      if (lastCallbackIndex >= 0) {\n        arraySplice(this.current, 0, lastCallbackIndex + 1);\n      }\n      this.executingCallbacks = false;\n      if (this.deferred.length > 0) {\n        for (let i = 0; i < this.deferred.length; i += 2) {\n          const invokeAt = this.deferred[i];\n          const callback2 = this.deferred[i + 1];\n          this.addToQueue(this.current, invokeAt, callback2);\n        }\n        this.deferred.length = 0;\n      }\n      this.scheduleTimer(ngZone);\n    };\n    const FRAME_DURATION_MS = 16;\n    if (this.current.length > 0) {\n      const now = Date.now();\n      const invokeAt = this.current[0];\n      if (this.timeoutId === null || // Reschedule a timer in case a queue contains an item with\n      // an earlier timestamp and the delta is more than an average\n      // frame duration.\n      this.invokeTimerAt && this.invokeTimerAt - invokeAt > FRAME_DURATION_MS) {\n        this.clearTimeout();\n        const timeout2 = Math.max(invokeAt - now, FRAME_DURATION_MS);\n        this.invokeTimerAt = invokeAt;\n        this.timeoutId = ngZone.runOutsideAngular(() => {\n          return setTimeout(() => ngZone.run(callback), timeout2);\n        });\n      }\n    }\n  }\n  clearTimeout() {\n    if (this.timeoutId !== null) {\n      clearTimeout(this.timeoutId);\n      this.timeoutId = null;\n    }\n  }\n  ngOnDestroy() {\n    this.clearTimeout();\n    this.current.length = 0;\n    this.deferred.length = 0;\n  }\n  /** @nocollapse */\n  static \\u0275prov = (\n    /** @pureOrBreakMyCode */\n    /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n      token: _TimerScheduler,\n      providedIn: \"root\",\n      factory: () => new _TimerScheduler()\n    })\n  );\n};\nvar CachedInjectorService = class _CachedInjectorService {\n  cachedInjectors = /* @__PURE__ */ new Map();\n  getOrCreateInjector(key, parentInjector, providers, debugName) {\n    if (!this.cachedInjectors.has(key)) {\n      const injector = providers.length > 0 ? createEnvironmentInjector(providers, parentInjector, debugName) : null;\n      this.cachedInjectors.set(key, injector);\n    }\n    return this.cachedInjectors.get(key);\n  }\n  ngOnDestroy() {\n    try {\n      for (const injector of this.cachedInjectors.values()) {\n        if (injector !== null) {\n          injector.destroy();\n        }\n      }\n    } finally {\n      this.cachedInjectors.clear();\n    }\n  }\n  /** @nocollapse */\n  static \\u0275prov = (\n    /** @pureOrBreakMyCode */\n    /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n      token: _CachedInjectorService,\n      providedIn: \"environment\",\n      factory: () => new _CachedInjectorService()\n    })\n  );\n};\nvar DEFER_BLOCK_DEPENDENCY_INTERCEPTOR = /* @__PURE__ */ new InjectionToken(\"DEFER_BLOCK_DEPENDENCY_INTERCEPTOR\");\nvar DEFER_BLOCK_CONFIG = new InjectionToken(ngDevMode ? \"DEFER_BLOCK_CONFIG\" : \"\");\nfunction getOrCreateEnvironmentInjector(parentInjector, tDetails, providers) {\n  return parentInjector.get(CachedInjectorService).getOrCreateInjector(tDetails, parentInjector, providers, ngDevMode ? \"DeferBlock Injector\" : \"\");\n}\nfunction createDeferBlockInjector(parentInjector, tDetails, providers) {\n  if (parentInjector instanceof ChainedInjector) {\n    const origInjector = parentInjector.injector;\n    const parentEnvInjector2 = parentInjector.parentInjector;\n    const envInjector = getOrCreateEnvironmentInjector(parentEnvInjector2, tDetails, providers);\n    return new ChainedInjector(origInjector, envInjector);\n  }\n  const parentEnvInjector = parentInjector.get(EnvironmentInjector);\n  if (parentEnvInjector !== parentInjector) {\n    const envInjector = getOrCreateEnvironmentInjector(parentEnvInjector, tDetails, providers);\n    return new ChainedInjector(parentInjector, envInjector);\n  }\n  return getOrCreateEnvironmentInjector(parentInjector, tDetails, providers);\n}\nfunction renderDeferBlockState(newState, tNode, lContainer, skipTimerScheduling = false) {\n  const hostLView = lContainer[PARENT];\n  const hostTView = hostLView[TVIEW];\n  if (isDestroyed(hostLView)) return;\n  ngDevMode && assertTNodeForLView(tNode, hostLView);\n  const lDetails = getLDeferBlockDetails(hostLView, tNode);\n  ngDevMode && assertDefined(lDetails, \"Expected a defer block state defined\");\n  const currentState = lDetails[DEFER_BLOCK_STATE];\n  const ssrState = lDetails[SSR_BLOCK_STATE];\n  if (ssrState !== null && newState < ssrState) {\n    return;\n  }\n  if (isValidStateChange(currentState, newState) && isValidStateChange(lDetails[NEXT_DEFER_BLOCK_STATE] ?? -1, newState)) {\n    const tDetails = getTDeferBlockDetails(hostTView, tNode);\n    const needsScheduling = !skipTimerScheduling && true && (getLoadingBlockAfter(tDetails) !== null || getMinimumDurationForState(tDetails, DeferBlockState.Loading) !== null || getMinimumDurationForState(tDetails, DeferBlockState.Placeholder));\n    if (ngDevMode && needsScheduling) {\n      assertDefined(applyDeferBlockStateWithSchedulingImpl, \"Expected scheduling function to be defined\");\n    }\n    const applyStateFn = needsScheduling ? applyDeferBlockStateWithSchedulingImpl : applyDeferBlockState;\n    try {\n      applyStateFn(newState, lDetails, lContainer, tNode, hostLView);\n    } catch (error) {\n      handleError(hostLView, error);\n    }\n  }\n}\nfunction findMatchingDehydratedViewForDeferBlock(lContainer, lDetails) {\n  const dehydratedViewIx = lContainer[DEHYDRATED_VIEWS]?.findIndex((view) => view.data[DEFER_BLOCK_STATE$1] === lDetails[DEFER_BLOCK_STATE]) ?? -1;\n  const dehydratedView = dehydratedViewIx > -1 ? lContainer[DEHYDRATED_VIEWS][dehydratedViewIx] : null;\n  return {\n    dehydratedView,\n    dehydratedViewIx\n  };\n}\nfunction applyDeferBlockState(newState, lDetails, lContainer, tNode, hostLView) {\n  profiler(\n    20\n    /* ProfilerEvent.DeferBlockStateStart */\n  );\n  const stateTmplIndex = getTemplateIndexForState(newState, hostLView, tNode);\n  if (stateTmplIndex !== null) {\n    lDetails[DEFER_BLOCK_STATE] = newState;\n    const hostTView = hostLView[TVIEW];\n    const adjustedIndex = stateTmplIndex + HEADER_OFFSET;\n    const activeBlockTNode = getTNode(hostTView, adjustedIndex);\n    const viewIndex = 0;\n    removeLViewFromLContainer(lContainer, viewIndex);\n    let injector;\n    if (newState === DeferBlockState.Complete) {\n      const tDetails = getTDeferBlockDetails(hostTView, tNode);\n      const providers = tDetails.providers;\n      if (providers && providers.length > 0) {\n        injector = createDeferBlockInjector(hostLView[INJECTOR], tDetails, providers);\n      }\n    }\n    const {\n      dehydratedView,\n      dehydratedViewIx\n    } = findMatchingDehydratedViewForDeferBlock(lContainer, lDetails);\n    const embeddedLView = createAndRenderEmbeddedLView(hostLView, activeBlockTNode, null, {\n      injector,\n      dehydratedView\n    });\n    addLViewToLContainer(lContainer, embeddedLView, viewIndex, shouldAddViewToDom(activeBlockTNode, dehydratedView));\n    markViewDirty(\n      embeddedLView,\n      2\n      /* NotificationSource.DeferBlockStateUpdate */\n    );\n    if (dehydratedViewIx > -1) {\n      lContainer[DEHYDRATED_VIEWS]?.splice(dehydratedViewIx, 1);\n    }\n    if ((newState === DeferBlockState.Complete || newState === DeferBlockState.Error) && Array.isArray(lDetails[ON_COMPLETE_FNS])) {\n      for (const callback of lDetails[ON_COMPLETE_FNS]) {\n        callback();\n      }\n      lDetails[ON_COMPLETE_FNS] = null;\n    }\n  }\n  profiler(\n    21\n    /* ProfilerEvent.DeferBlockStateEnd */\n  );\n}\nfunction applyDeferBlockStateWithScheduling(newState, lDetails, lContainer, tNode, hostLView) {\n  const now = Date.now();\n  const hostTView = hostLView[TVIEW];\n  const tDetails = getTDeferBlockDetails(hostTView, tNode);\n  if (lDetails[STATE_IS_FROZEN_UNTIL] === null || lDetails[STATE_IS_FROZEN_UNTIL] <= now) {\n    lDetails[STATE_IS_FROZEN_UNTIL] = null;\n    const loadingAfter = getLoadingBlockAfter(tDetails);\n    const inLoadingAfterPhase = lDetails[LOADING_AFTER_CLEANUP_FN] !== null;\n    if (newState === DeferBlockState.Loading && loadingAfter !== null && !inLoadingAfterPhase) {\n      lDetails[NEXT_DEFER_BLOCK_STATE] = newState;\n      const cleanupFn = scheduleDeferBlockUpdate(loadingAfter, lDetails, tNode, lContainer, hostLView);\n      lDetails[LOADING_AFTER_CLEANUP_FN] = cleanupFn;\n    } else {\n      if (newState > DeferBlockState.Loading && inLoadingAfterPhase) {\n        lDetails[LOADING_AFTER_CLEANUP_FN]();\n        lDetails[LOADING_AFTER_CLEANUP_FN] = null;\n        lDetails[NEXT_DEFER_BLOCK_STATE] = null;\n      }\n      applyDeferBlockState(newState, lDetails, lContainer, tNode, hostLView);\n      const duration = getMinimumDurationForState(tDetails, newState);\n      if (duration !== null) {\n        lDetails[STATE_IS_FROZEN_UNTIL] = now + duration;\n        scheduleDeferBlockUpdate(duration, lDetails, tNode, lContainer, hostLView);\n      }\n    }\n  } else {\n    lDetails[NEXT_DEFER_BLOCK_STATE] = newState;\n  }\n}\nfunction scheduleDeferBlockUpdate(timeout2, lDetails, tNode, lContainer, hostLView) {\n  const callback = () => {\n    const nextState = lDetails[NEXT_DEFER_BLOCK_STATE];\n    lDetails[STATE_IS_FROZEN_UNTIL] = null;\n    lDetails[NEXT_DEFER_BLOCK_STATE] = null;\n    if (nextState !== null) {\n      renderDeferBlockState(nextState, tNode, lContainer);\n    }\n  };\n  return scheduleTimerTrigger(timeout2, callback, hostLView[INJECTOR]);\n}\nfunction isValidStateChange(currentState, newState) {\n  return currentState < newState;\n}\nfunction renderPlaceholder(lView, tNode) {\n  const lContainer = lView[tNode.index];\n  ngDevMode && assertLContainer(lContainer);\n  renderDeferBlockState(DeferBlockState.Placeholder, tNode, lContainer);\n}\nfunction renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer) {\n  ngDevMode && assertDefined(tDetails.loadingPromise, \"Expected loading Promise to exist on this defer block\");\n  tDetails.loadingPromise.then(() => {\n    if (tDetails.loadingState === DeferDependenciesLoadingState.COMPLETE) {\n      ngDevMode && assertDeferredDependenciesLoaded(tDetails);\n      renderDeferBlockState(DeferBlockState.Complete, tNode, lContainer);\n    } else if (tDetails.loadingState === DeferDependenciesLoadingState.FAILED) {\n      renderDeferBlockState(DeferBlockState.Error, tNode, lContainer);\n    }\n  });\n}\nvar applyDeferBlockStateWithSchedulingImpl = null;\nfunction \\u0275\\u0275deferEnableTimerScheduling(tView, tDetails, placeholderConfigIndex, loadingConfigIndex) {\n  const tViewConsts = tView.consts;\n  if (placeholderConfigIndex != null) {\n    tDetails.placeholderBlockConfig = getConstant(tViewConsts, placeholderConfigIndex);\n  }\n  if (loadingConfigIndex != null) {\n    tDetails.loadingBlockConfig = getConstant(tViewConsts, loadingConfigIndex);\n  }\n  if (applyDeferBlockStateWithSchedulingImpl === null) {\n    applyDeferBlockStateWithSchedulingImpl = applyDeferBlockStateWithScheduling;\n  }\n}\nfunction setClassMetadata(type, decorators, ctorParameters, propDecorators) {\n  return noSideEffects(() => {\n    const clazz = type;\n    if (decorators !== null) {\n      if (clazz.hasOwnProperty(\"decorators\") && clazz.decorators !== void 0) {\n        clazz.decorators.push(...decorators);\n      } else {\n        clazz.decorators = decorators;\n      }\n    }\n    if (ctorParameters !== null) {\n      clazz.ctorParameters = ctorParameters;\n    }\n    if (propDecorators !== null) {\n      if (clazz.hasOwnProperty(\"propDecorators\") && clazz.propDecorators !== void 0) {\n        clazz.propDecorators = __spreadValues(__spreadValues({}, clazz.propDecorators), propDecorators);\n      } else {\n        clazz.propDecorators = propDecorators;\n      }\n    }\n  });\n}\nvar Console = class _Console {\n  log(message) {\n    console.log(message);\n  }\n  // Note: for reporting errors use `DOM.logError()` as it is platform specific\n  warn(message) {\n    console.warn(message);\n  }\n  static \\u0275fac = function Console_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _Console)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _Console,\n    factory: _Console.\\u0275fac,\n    providedIn: \"platform\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(Console, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"platform\"\n    }]\n  }], null, null);\n})();\nvar DIDebugData = class {\n  resolverToTokenToDependencies = /* @__PURE__ */ new WeakMap();\n  resolverToProviders = /* @__PURE__ */ new WeakMap();\n  resolverToEffects = /* @__PURE__ */ new WeakMap();\n  standaloneInjectorToComponent = /* @__PURE__ */ new WeakMap();\n  reset() {\n    this.resolverToTokenToDependencies = /* @__PURE__ */ new WeakMap();\n    this.resolverToProviders = /* @__PURE__ */ new WeakMap();\n    this.standaloneInjectorToComponent = /* @__PURE__ */ new WeakMap();\n  }\n};\nvar frameworkDIDebugData = new DIDebugData();\nfunction getFrameworkDIDebugData() {\n  return frameworkDIDebugData;\n}\nfunction setupFrameworkInjectorProfiler() {\n  frameworkDIDebugData.reset();\n  setInjectorProfiler((injectorProfilerEvent) => handleInjectorProfilerEvent(injectorProfilerEvent));\n}\nfunction handleInjectorProfilerEvent(injectorProfilerEvent) {\n  const {\n    context: context2,\n    type\n  } = injectorProfilerEvent;\n  if (type === 0) {\n    handleInjectEvent(context2, injectorProfilerEvent.service);\n  } else if (type === 1) {\n    handleInstanceCreatedByInjectorEvent(context2, injectorProfilerEvent.instance);\n  } else if (type === 2) {\n    handleProviderConfiguredEvent(context2, injectorProfilerEvent.providerRecord);\n  } else if (type === 3) {\n    handleEffectCreatedEvent(context2, injectorProfilerEvent.effect);\n  }\n}\nfunction handleEffectCreatedEvent(context2, effect2) {\n  const diResolver = getDIResolver(context2.injector);\n  if (diResolver === null) {\n    throwError2(\"An EffectCreated event must be run within an injection context.\");\n  }\n  const {\n    resolverToEffects\n  } = frameworkDIDebugData;\n  if (!resolverToEffects.has(diResolver)) {\n    resolverToEffects.set(diResolver, []);\n  }\n  resolverToEffects.get(diResolver).push(effect2);\n}\nfunction handleInjectEvent(context2, data) {\n  const diResolver = getDIResolver(context2.injector);\n  if (diResolver === null) {\n    throwError2(\"An Inject event must be run within an injection context.\");\n  }\n  const diResolverToInstantiatedToken = frameworkDIDebugData.resolverToTokenToDependencies;\n  if (!diResolverToInstantiatedToken.has(diResolver)) {\n    diResolverToInstantiatedToken.set(diResolver, /* @__PURE__ */ new WeakMap());\n  }\n  if (!canBeHeldWeakly(context2.token)) {\n    return;\n  }\n  const instantiatedTokenToDependencies = diResolverToInstantiatedToken.get(diResolver);\n  if (!instantiatedTokenToDependencies.has(context2.token)) {\n    instantiatedTokenToDependencies.set(context2.token, []);\n  }\n  const {\n    token,\n    value,\n    flags\n  } = data;\n  assertDefined(context2.token, \"Injector profiler context token is undefined.\");\n  const dependencies = instantiatedTokenToDependencies.get(context2.token);\n  assertDefined(dependencies, \"Could not resolve dependencies for token.\");\n  if (context2.injector instanceof NodeInjector) {\n    dependencies.push({\n      token,\n      value,\n      flags,\n      injectedIn: getNodeInjectorContext(context2.injector)\n    });\n  } else {\n    dependencies.push({\n      token,\n      value,\n      flags\n    });\n  }\n}\nfunction getNodeInjectorContext(injector) {\n  if (!(injector instanceof NodeInjector)) {\n    throwError2(\"getNodeInjectorContext must be called with a NodeInjector\");\n  }\n  const lView = getNodeInjectorLView(injector);\n  const tNode = getNodeInjectorTNode(injector);\n  if (tNode === null) {\n    return;\n  }\n  assertTNodeForLView(tNode, lView);\n  return {\n    lView,\n    tNode\n  };\n}\nfunction handleInstanceCreatedByInjectorEvent(context2, data) {\n  const {\n    value\n  } = data;\n  if (getDIResolver(context2.injector) === null) {\n    throwError2(\"An InjectorCreatedInstance event must be run within an injection context.\");\n  }\n  let standaloneComponent = void 0;\n  if (typeof value === \"object\") {\n    standaloneComponent = value?.constructor;\n  }\n  if (standaloneComponent == void 0 || !isStandaloneComponent(standaloneComponent)) {\n    return;\n  }\n  const environmentInjector = context2.injector.get(EnvironmentInjector, null, {\n    optional: true\n  });\n  if (environmentInjector === null) {\n    return;\n  }\n  const {\n    standaloneInjectorToComponent\n  } = frameworkDIDebugData;\n  if (standaloneInjectorToComponent.has(environmentInjector)) {\n    return;\n  }\n  standaloneInjectorToComponent.set(environmentInjector, standaloneComponent);\n}\nfunction isStandaloneComponent(value) {\n  const def = getComponentDef(value);\n  return !!def?.standalone;\n}\nfunction handleProviderConfiguredEvent(context2, data) {\n  const {\n    resolverToProviders\n  } = frameworkDIDebugData;\n  let diResolver;\n  if (context2?.injector instanceof NodeInjector) {\n    diResolver = getNodeInjectorTNode(context2.injector);\n  } else {\n    diResolver = context2.injector;\n  }\n  if (diResolver === null) {\n    throwError2(\"A ProviderConfigured event must be run within an injection context.\");\n  }\n  if (!resolverToProviders.has(diResolver)) {\n    resolverToProviders.set(diResolver, []);\n  }\n  resolverToProviders.get(diResolver).push(data);\n}\nfunction getDIResolver(injector) {\n  let diResolver = null;\n  if (injector === void 0) {\n    return diResolver;\n  }\n  if (injector instanceof NodeInjector) {\n    diResolver = getNodeInjectorLView(injector);\n  } else {\n    diResolver = injector;\n  }\n  return diResolver;\n}\nfunction canBeHeldWeakly(value) {\n  return value !== null && (typeof value === \"object\" || typeof value === \"function\" || typeof value === \"symbol\");\n}\nfunction applyChanges(component) {\n  ngDevMode && assertDefined(component, \"component\");\n  markViewDirty(\n    getComponentViewByInstance(component),\n    3\n    /* NotificationSource.DebugApplyChanges */\n  );\n  getRootComponents(component).forEach((rootComponent) => detectChanges(rootComponent));\n}\nfunction detectChanges(component) {\n  const view = getComponentViewByInstance(component);\n  view[FLAGS] |= 1024;\n  detectChangesInternal(view);\n}\nfunction getDeferBlocks$1(lView, deferBlocks) {\n  const tView = lView[TVIEW];\n  for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {\n    if (isLContainer(lView[i])) {\n      const lContainer = lView[i];\n      const isLast = i === tView.bindingStartIndex - 1;\n      if (!isLast) {\n        const tNode = tView.data[i];\n        const tDetails = getTDeferBlockDetails(tView, tNode);\n        if (isTDeferBlockDetails(tDetails)) {\n          deferBlocks.push({\n            lContainer,\n            lView,\n            tNode,\n            tDetails\n          });\n          continue;\n        }\n      }\n      for (let i2 = CONTAINER_HEADER_OFFSET; i2 < lContainer.length; i2++) {\n        getDeferBlocks$1(lContainer[i2], deferBlocks);\n      }\n    } else if (isLView(lView[i])) {\n      getDeferBlocks$1(lView[i], deferBlocks);\n    }\n  }\n}\nfunction getDeferBlocks(node) {\n  const results = [];\n  const lView = getLContext(node)?.lView;\n  if (lView) {\n    findDeferBlocks(node, lView, results);\n  }\n  return results;\n}\nfunction findDeferBlocks(node, lView, results) {\n  const registry = lView[INJECTOR].get(DEHYDRATED_BLOCK_REGISTRY, null, {\n    optional: true\n  });\n  const blocks = [];\n  getDeferBlocks$1(lView, blocks);\n  for (const details of blocks) {\n    const native = getNativeByTNode(details.tNode, details.lView);\n    const lDetails = getLDeferBlockDetails(details.lView, details.tNode);\n    if (!node.contains(native)) {\n      continue;\n    }\n    const tDetails = details.tDetails;\n    const renderedLView = getRendererLView(details);\n    const rootNodes = [];\n    if (renderedLView !== null) {\n      collectNativeNodes(renderedLView[TVIEW], renderedLView, renderedLView[TVIEW].firstChild, rootNodes);\n    }\n    const data = {\n      state: stringifyState(lDetails[DEFER_BLOCK_STATE]),\n      incrementalHydrationState: inferHydrationState(tDetails, lDetails, registry),\n      hasErrorBlock: tDetails.errorTmplIndex !== null,\n      loadingBlock: {\n        exists: tDetails.loadingTmplIndex !== null,\n        minimumTime: tDetails.loadingBlockConfig?.[MINIMUM_SLOT] ?? null,\n        afterTime: tDetails.loadingBlockConfig?.[LOADING_AFTER_SLOT] ?? null\n      },\n      placeholderBlock: {\n        exists: tDetails.placeholderTmplIndex !== null,\n        minimumTime: tDetails.placeholderBlockConfig?.[MINIMUM_SLOT] ?? null\n      },\n      triggers: tDetails.debug?.triggers ? Array.from(tDetails.debug.triggers).sort() : [],\n      rootNodes\n    };\n    results.push(data);\n    if (renderedLView !== null) {\n      findDeferBlocks(node, renderedLView, results);\n    }\n  }\n}\nfunction stringifyState(state) {\n  switch (state) {\n    case DeferBlockState.Complete:\n      return \"complete\";\n    case DeferBlockState.Loading:\n      return \"loading\";\n    case DeferBlockState.Placeholder:\n      return \"placeholder\";\n    case DeferBlockState.Error:\n      return \"error\";\n    case DeferBlockInternalState.Initial:\n      return \"initial\";\n    default:\n      throw new Error(`Unrecognized state ${state}`);\n  }\n}\nfunction inferHydrationState(tDetails, lDetails, registry) {\n  if (registry === null || lDetails[SSR_UNIQUE_ID] === null || tDetails.hydrateTriggers === null || tDetails.hydrateTriggers.has(\n    7\n    /* DeferBlockTrigger.Never */\n  )) {\n    return \"not-configured\";\n  }\n  return registry.has(lDetails[SSR_UNIQUE_ID]) ? \"dehydrated\" : \"hydrated\";\n}\nfunction getRendererLView(details) {\n  if (details.lContainer.length <= CONTAINER_HEADER_OFFSET) {\n    return null;\n  }\n  const lView = details.lContainer[CONTAINER_HEADER_OFFSET];\n  ngDevMode && assertLView(lView);\n  return lView;\n}\nfunction getDependenciesFromInjectable(injector, token) {\n  const instance = injector.get(token, null, {\n    self: true,\n    optional: true\n  });\n  if (instance === null) {\n    throw new Error(`Unable to determine instance of ${token} in given injector`);\n  }\n  const unformattedDependencies = getDependenciesForTokenInInjector(token, injector);\n  const resolutionPath = getInjectorResolutionPath(injector);\n  const dependencies = unformattedDependencies.map((dep) => {\n    const formattedDependency = {\n      value: dep.value\n    };\n    const flags = dep.flags;\n    formattedDependency.flags = {\n      optional: (8 & flags) === 8,\n      host: (1 & flags) === 1,\n      self: (2 & flags) === 2,\n      skipSelf: (4 & flags) === 4\n      /* InternalInjectFlags.SkipSelf */\n    };\n    for (let i = 0; i < resolutionPath.length; i++) {\n      const injectorToCheck = resolutionPath[i];\n      if (i === 0 && formattedDependency.flags.skipSelf) {\n        continue;\n      }\n      if (formattedDependency.flags.host && injectorToCheck instanceof EnvironmentInjector) {\n        break;\n      }\n      const instance2 = injectorToCheck.get(dep.token, null, {\n        self: true,\n        optional: true\n      });\n      if (instance2 !== null) {\n        if (formattedDependency.flags.host) {\n          const firstInjector = resolutionPath[0];\n          const lookupFromFirstInjector = firstInjector.get(dep.token, null, __spreadProps(__spreadValues({}, formattedDependency.flags), {\n            optional: true\n          }));\n          if (lookupFromFirstInjector !== null) {\n            formattedDependency.providedIn = injectorToCheck;\n          }\n          break;\n        }\n        formattedDependency.providedIn = injectorToCheck;\n        break;\n      }\n      if (i === 0 && formattedDependency.flags.self) {\n        break;\n      }\n    }\n    if (dep.token) formattedDependency.token = dep.token;\n    return formattedDependency;\n  });\n  return {\n    instance,\n    dependencies\n  };\n}\nfunction getDependenciesForTokenInInjector(token, injector) {\n  const {\n    resolverToTokenToDependencies\n  } = getFrameworkDIDebugData();\n  if (!(injector instanceof NodeInjector)) {\n    return resolverToTokenToDependencies.get(injector)?.get?.(token) ?? [];\n  }\n  const lView = getNodeInjectorLView(injector);\n  const tokenDependencyMap = resolverToTokenToDependencies.get(lView);\n  const dependencies = tokenDependencyMap?.get(token) ?? [];\n  return dependencies.filter((dependency) => {\n    const dependencyNode = dependency.injectedIn?.tNode;\n    if (dependencyNode === void 0) {\n      return false;\n    }\n    const instanceNode = getNodeInjectorTNode(injector);\n    assertTNode(dependencyNode);\n    assertTNode(instanceNode);\n    return dependencyNode === instanceNode;\n  });\n}\nfunction getProviderImportsContainer(injector) {\n  const {\n    standaloneInjectorToComponent\n  } = getFrameworkDIDebugData();\n  if (standaloneInjectorToComponent.has(injector)) {\n    return standaloneInjectorToComponent.get(injector);\n  }\n  const defTypeRef = injector.get(NgModuleRef$1, null, {\n    self: true,\n    optional: true\n  });\n  if (defTypeRef === null) {\n    return null;\n  }\n  if (defTypeRef.instance === null) {\n    return null;\n  }\n  return defTypeRef.instance.constructor;\n}\nfunction getNodeInjectorProviders(injector) {\n  const diResolver = getNodeInjectorTNode(injector);\n  const {\n    resolverToProviders\n  } = getFrameworkDIDebugData();\n  return resolverToProviders.get(diResolver) ?? [];\n}\nfunction getProviderImportPaths(providerImportsContainer) {\n  const providerToPath = /* @__PURE__ */ new Map();\n  const visitedContainers = /* @__PURE__ */ new Set();\n  const visitor = walkProviderTreeToDiscoverImportPaths(providerToPath, visitedContainers);\n  walkProviderTree(providerImportsContainer, visitor, [], /* @__PURE__ */ new Set());\n  return providerToPath;\n}\nfunction walkProviderTreeToDiscoverImportPaths(providerToPath, visitedContainers) {\n  return (provider, container) => {\n    if (!providerToPath.has(provider)) {\n      providerToPath.set(provider, [container]);\n    }\n    if (!visitedContainers.has(container)) {\n      for (const prov of providerToPath.keys()) {\n        const existingImportPath = providerToPath.get(prov);\n        let containerDef = getInjectorDef(container);\n        if (!containerDef) {\n          const ngModule = container.ngModule;\n          containerDef = getInjectorDef(ngModule);\n        }\n        if (!containerDef) {\n          return;\n        }\n        const lastContainerAddedToPath = existingImportPath[0];\n        let isNextStepInPath = false;\n        deepForEach(containerDef.imports, (moduleImport) => {\n          if (isNextStepInPath) {\n            return;\n          }\n          isNextStepInPath = moduleImport.ngModule === lastContainerAddedToPath || moduleImport === lastContainerAddedToPath;\n          if (isNextStepInPath) {\n            providerToPath.get(prov)?.unshift(container);\n          }\n        });\n      }\n    }\n    visitedContainers.add(container);\n  };\n}\nfunction getEnvironmentInjectorProviders(injector) {\n  const providerRecordsWithoutImportPaths = getFrameworkDIDebugData().resolverToProviders.get(injector) ?? [];\n  if (isPlatformInjector(injector)) {\n    return providerRecordsWithoutImportPaths;\n  }\n  const providerImportsContainer = getProviderImportsContainer(injector);\n  if (providerImportsContainer === null) {\n    return providerRecordsWithoutImportPaths;\n  }\n  const providerToPath = getProviderImportPaths(providerImportsContainer);\n  const providerRecords = [];\n  for (const providerRecord of providerRecordsWithoutImportPaths) {\n    const provider = providerRecord.provider;\n    const token = provider.provide;\n    if (token === ENVIRONMENT_INITIALIZER || token === INJECTOR_DEF_TYPES) {\n      continue;\n    }\n    let importPath = providerToPath.get(provider) ?? [];\n    const def = getComponentDef(providerImportsContainer);\n    const isStandaloneComponent2 = !!def?.standalone;\n    if (isStandaloneComponent2) {\n      importPath = [providerImportsContainer, ...importPath];\n    }\n    providerRecords.push(__spreadProps(__spreadValues({}, providerRecord), {\n      importPath\n    }));\n  }\n  return providerRecords;\n}\nfunction isPlatformInjector(injector) {\n  return injector instanceof R3Injector && injector.scopes.has(\"platform\");\n}\nfunction getInjectorProviders(injector) {\n  if (injector instanceof NodeInjector) {\n    return getNodeInjectorProviders(injector);\n  } else if (injector instanceof EnvironmentInjector) {\n    return getEnvironmentInjectorProviders(injector);\n  }\n  throwError2(\"getInjectorProviders only supports NodeInjector and EnvironmentInjector\");\n}\nfunction getInjectorMetadata(injector) {\n  if (injector instanceof NodeInjector) {\n    const lView = getNodeInjectorLView(injector);\n    const tNode = getNodeInjectorTNode(injector);\n    assertTNodeForLView(tNode, lView);\n    return {\n      type: \"element\",\n      source: getNativeByTNode(tNode, lView)\n    };\n  }\n  if (injector instanceof R3Injector) {\n    return {\n      type: \"environment\",\n      source: injector.source ?? null\n    };\n  }\n  if (injector instanceof NullInjector) {\n    return {\n      type: \"null\",\n      source: null\n    };\n  }\n  return null;\n}\nfunction getInjectorResolutionPath(injector) {\n  const resolutionPath = [injector];\n  getInjectorResolutionPathHelper(injector, resolutionPath);\n  return resolutionPath;\n}\nfunction getInjectorResolutionPathHelper(injector, resolutionPath) {\n  const parent = getInjectorParent(injector);\n  if (parent === null) {\n    if (injector instanceof NodeInjector) {\n      const firstInjector = resolutionPath[0];\n      if (firstInjector instanceof NodeInjector) {\n        const moduleInjector = getModuleInjectorOfNodeInjector(firstInjector);\n        if (moduleInjector === null) {\n          throwError2(\"NodeInjector must have some connection to the module injector tree\");\n        }\n        resolutionPath.push(moduleInjector);\n        getInjectorResolutionPathHelper(moduleInjector, resolutionPath);\n      }\n      return resolutionPath;\n    }\n  } else {\n    resolutionPath.push(parent);\n    getInjectorResolutionPathHelper(parent, resolutionPath);\n  }\n  return resolutionPath;\n}\nfunction getInjectorParent(injector) {\n  if (injector instanceof R3Injector) {\n    const parent = injector.parent;\n    if (isRouterOutletInjector(parent)) {\n      return parent.parentInjector;\n    }\n    return parent;\n  }\n  let tNode;\n  let lView;\n  if (injector instanceof NodeInjector) {\n    tNode = getNodeInjectorTNode(injector);\n    lView = getNodeInjectorLView(injector);\n  } else if (injector instanceof NullInjector) {\n    return null;\n  } else if (injector instanceof ChainedInjector) {\n    return injector.parentInjector;\n  } else {\n    throwError2(\"getInjectorParent only support injectors of type R3Injector, NodeInjector, NullInjector\");\n  }\n  const parentLocation = getParentInjectorLocation(tNode, lView);\n  if (hasParentInjector(parentLocation)) {\n    const parentInjectorIndex = getParentInjectorIndex(parentLocation);\n    const parentLView = getParentInjectorView(parentLocation, lView);\n    const parentTView = parentLView[TVIEW];\n    const parentTNode = parentTView.data[\n      parentInjectorIndex + 8\n      /* NodeInjectorOffset.TNODE */\n    ];\n    return new NodeInjector(parentTNode, parentLView);\n  } else {\n    const chainedInjector = lView[INJECTOR];\n    const injectorParent = chainedInjector.injector?.parent;\n    if (injectorParent instanceof NodeInjector) {\n      return injectorParent;\n    }\n  }\n  return null;\n}\nfunction getModuleInjectorOfNodeInjector(injector) {\n  let lView;\n  if (injector instanceof NodeInjector) {\n    lView = getNodeInjectorLView(injector);\n  } else {\n    throwError2(\"getModuleInjectorOfNodeInjector must be called with a NodeInjector\");\n  }\n  const inj = lView[INJECTOR];\n  const moduleInjector = inj instanceof ChainedInjector ? inj.parentInjector : inj.parent;\n  if (!moduleInjector) {\n    throwError2(\"NodeInjector must have some connection to the module injector tree\");\n  }\n  return moduleInjector;\n}\nfunction isComputedNode(node) {\n  return node.kind === \"computed\";\n}\nfunction isTemplateEffectNode(node) {\n  return node.kind === \"template\";\n}\nfunction isEffectNode(node) {\n  return node.kind === \"effect\";\n}\nfunction isSignalNode(node) {\n  return node.kind === \"signal\";\n}\nfunction getTemplateConsumer(injector) {\n  const tNode = getNodeInjectorTNode(injector);\n  assertTNode(tNode);\n  const lView = getNodeInjectorLView(injector);\n  assertLView(lView);\n  const templateLView = lView[tNode.index];\n  assertLView(templateLView);\n  return templateLView[REACTIVE_TEMPLATE_CONSUMER];\n}\nfunction getNodesAndEdgesFromSignalMap(signalMap) {\n  const nodes = Array.from(signalMap.keys());\n  const debugSignalGraphNodes = [];\n  const edges = [];\n  for (const [consumer, producers] of signalMap.entries()) {\n    const consumerIndex = nodes.indexOf(consumer);\n    if (isComputedNode(consumer) || isSignalNode(consumer)) {\n      debugSignalGraphNodes.push({\n        label: consumer.debugName,\n        value: consumer.value,\n        kind: consumer.kind\n      });\n    } else if (isTemplateEffectNode(consumer)) {\n      debugSignalGraphNodes.push({\n        label: consumer.debugName ?? consumer.lView?.[HOST]?.tagName?.toLowerCase?.(),\n        kind: consumer.kind\n      });\n    } else if (isEffectNode(consumer)) {\n      debugSignalGraphNodes.push({\n        label: consumer.debugName,\n        kind: consumer.kind\n      });\n    } else {\n      debugSignalGraphNodes.push({\n        label: consumer.debugName,\n        kind: consumer.kind\n      });\n    }\n    for (const producer of producers) {\n      edges.push({\n        consumer: consumerIndex,\n        producer: nodes.indexOf(producer)\n      });\n    }\n  }\n  return {\n    nodes: debugSignalGraphNodes,\n    edges\n  };\n}\nfunction extractEffectsFromInjector(injector) {\n  let diResolver = injector;\n  if (injector instanceof NodeInjector) {\n    const lView = getNodeInjectorLView(injector);\n    diResolver = lView;\n  }\n  const resolverToEffects = getFrameworkDIDebugData().resolverToEffects;\n  const effects = resolverToEffects.get(diResolver) ?? [];\n  return effects.map((effect2) => effect2[SIGNAL]);\n}\nfunction extractSignalNodesAndEdgesFromRoots(nodes, signalDependenciesMap = /* @__PURE__ */ new Map()) {\n  for (const node of nodes) {\n    if (signalDependenciesMap.has(node)) {\n      continue;\n    }\n    const producerNodes = node.producerNode ?? [];\n    signalDependenciesMap.set(node, producerNodes);\n    extractSignalNodesAndEdgesFromRoots(producerNodes, signalDependenciesMap);\n  }\n  return signalDependenciesMap;\n}\nfunction getSignalGraph(injector) {\n  let templateConsumer = null;\n  if (!(injector instanceof NodeInjector) && !(injector instanceof R3Injector)) {\n    return throwError2(\"getSignalGraph must be called with a NodeInjector or R3Injector\");\n  }\n  if (injector instanceof NodeInjector) {\n    templateConsumer = getTemplateConsumer(injector);\n  }\n  const nonTemplateEffectNodes = extractEffectsFromInjector(injector);\n  const signalNodes = templateConsumer ? [templateConsumer, ...nonTemplateEffectNodes] : nonTemplateEffectNodes;\n  const signalDependenciesMap = extractSignalNodesAndEdgesFromRoots(signalNodes);\n  return getNodesAndEdgesFromSignalMap(signalDependenciesMap);\n}\nvar GLOBAL_PUBLISH_EXPANDO_KEY = \"ng\";\nvar globalUtilsFunctions = {\n  /**\n   * Warning: functions that start with `ɵ` are considered *INTERNAL* and should not be relied upon\n   * in application's code. The contract of those functions might be changed in any release and/or a\n   * function can be removed completely.\n   */\n  \"\\u0275getDependenciesFromInjectable\": getDependenciesFromInjectable,\n  \"\\u0275getInjectorProviders\": getInjectorProviders,\n  \"\\u0275getInjectorResolutionPath\": getInjectorResolutionPath,\n  \"\\u0275getInjectorMetadata\": getInjectorMetadata,\n  \"\\u0275setProfiler\": setProfiler,\n  \"\\u0275getSignalGraph\": getSignalGraph,\n  \"\\u0275getDeferBlocks\": getDeferBlocks,\n  \"getDirectiveMetadata\": getDirectiveMetadata$1,\n  \"getComponent\": getComponent,\n  \"getContext\": getContext,\n  \"getListeners\": getListeners,\n  \"getOwningComponent\": getOwningComponent,\n  \"getHostElement\": getHostElement,\n  \"getInjector\": getInjector,\n  \"getRootComponents\": getRootComponents,\n  \"getDirectives\": getDirectives,\n  \"applyChanges\": applyChanges,\n  \"isSignal\": isSignal\n};\nvar _published = false;\nfunction publishDefaultGlobalUtils$1() {\n  if (!_published) {\n    _published = true;\n    if (typeof window !== \"undefined\") {\n      setupFrameworkInjectorProfiler();\n    }\n    for (const [methodName, method] of Object.entries(globalUtilsFunctions)) {\n      publishGlobalUtil(methodName, method);\n    }\n  }\n}\nfunction publishGlobalUtil(name, fn) {\n  publishUtil(name, fn);\n}\nfunction publishUtil(name, fn) {\n  if (typeof COMPILED === \"undefined\" || !COMPILED) {\n    const w = _global;\n    ngDevMode && assertDefined(fn, \"function not defined\");\n    w[GLOBAL_PUBLISH_EXPANDO_KEY] ??= {};\n    w[GLOBAL_PUBLISH_EXPANDO_KEY][name] = fn;\n  }\n}\nvar TESTABILITY = new InjectionToken(\"\");\nvar TESTABILITY_GETTER = new InjectionToken(\"\");\nvar Testability = class _Testability {\n  _ngZone;\n  registry;\n  _isZoneStable = true;\n  _callbacks = [];\n  taskTrackingZone = null;\n  constructor(_ngZone, registry, testabilityGetter) {\n    this._ngZone = _ngZone;\n    this.registry = registry;\n    if (!_testabilityGetter) {\n      setTestabilityGetter(testabilityGetter);\n      testabilityGetter.addToWindow(registry);\n    }\n    this._watchAngularEvents();\n    _ngZone.run(() => {\n      this.taskTrackingZone = typeof Zone == \"undefined\" ? null : Zone.current.get(\"TaskTrackingZone\");\n    });\n  }\n  _watchAngularEvents() {\n    this._ngZone.onUnstable.subscribe({\n      next: () => {\n        this._isZoneStable = false;\n      }\n    });\n    this._ngZone.runOutsideAngular(() => {\n      this._ngZone.onStable.subscribe({\n        next: () => {\n          NgZone.assertNotInAngularZone();\n          queueMicrotask(() => {\n            this._isZoneStable = true;\n            this._runCallbacksIfReady();\n          });\n        }\n      });\n    });\n  }\n  /**\n   * Whether an associated application is stable\n   */\n  isStable() {\n    return this._isZoneStable && !this._ngZone.hasPendingMacrotasks;\n  }\n  _runCallbacksIfReady() {\n    if (this.isStable()) {\n      queueMicrotask(() => {\n        while (this._callbacks.length !== 0) {\n          let cb = this._callbacks.pop();\n          clearTimeout(cb.timeoutId);\n          cb.doneCb();\n        }\n      });\n    } else {\n      let pending = this.getPendingTasks();\n      this._callbacks = this._callbacks.filter((cb) => {\n        if (cb.updateCb && cb.updateCb(pending)) {\n          clearTimeout(cb.timeoutId);\n          return false;\n        }\n        return true;\n      });\n    }\n  }\n  getPendingTasks() {\n    if (!this.taskTrackingZone) {\n      return [];\n    }\n    return this.taskTrackingZone.macroTasks.map((t) => {\n      return {\n        source: t.source,\n        // From TaskTrackingZone:\n        // https://github.com/angular/zone.js/blob/master/lib/zone-spec/task-tracking.ts#L40\n        creationLocation: t.creationLocation,\n        data: t.data\n      };\n    });\n  }\n  addCallback(cb, timeout2, updateCb) {\n    let timeoutId = -1;\n    if (timeout2 && timeout2 > 0) {\n      timeoutId = setTimeout(() => {\n        this._callbacks = this._callbacks.filter((cb2) => cb2.timeoutId !== timeoutId);\n        cb();\n      }, timeout2);\n    }\n    this._callbacks.push({\n      doneCb: cb,\n      timeoutId,\n      updateCb\n    });\n  }\n  /**\n   * Wait for the application to be stable with a timeout. If the timeout is reached before that\n   * happens, the callback receives a list of the macro tasks that were pending, otherwise null.\n   *\n   * @param doneCb The callback to invoke when Angular is stable or the timeout expires\n   *    whichever comes first.\n   * @param timeout Optional. The maximum time to wait for Angular to become stable. If not\n   *    specified, whenStable() will wait forever.\n   * @param updateCb Optional. If specified, this callback will be invoked whenever the set of\n   *    pending macrotasks changes. If this callback returns true doneCb will not be invoked\n   *    and no further updates will be issued.\n   */\n  whenStable(doneCb, timeout2, updateCb) {\n    if (updateCb && !this.taskTrackingZone) {\n      throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is \"zone.js/plugins/task-tracking\" loaded?');\n    }\n    this.addCallback(doneCb, timeout2, updateCb);\n    this._runCallbacksIfReady();\n  }\n  /**\n   * Registers an application with a testability hook so that it can be tracked.\n   * @param token token of application, root element\n   *\n   * @internal\n   */\n  registerApplication(token) {\n    this.registry.registerApplication(token, this);\n  }\n  /**\n   * Unregisters an application.\n   * @param token token of application, root element\n   *\n   * @internal\n   */\n  unregisterApplication(token) {\n    this.registry.unregisterApplication(token);\n  }\n  /**\n   * Find providers by name\n   * @param using The root element to search from\n   * @param provider The name of binding variable\n   * @param exactMatch Whether using exactMatch\n   */\n  findProviders(using, provider, exactMatch) {\n    return [];\n  }\n  static \\u0275fac = function Testability_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _Testability)(\\u0275\\u0275inject(NgZone), \\u0275\\u0275inject(TestabilityRegistry), \\u0275\\u0275inject(TESTABILITY_GETTER));\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _Testability,\n    factory: _Testability.\\u0275fac\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(Testability, [{\n    type: Injectable\n  }], () => [{\n    type: NgZone\n  }, {\n    type: TestabilityRegistry\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [TESTABILITY_GETTER]\n    }]\n  }], null);\n})();\nvar TestabilityRegistry = class _TestabilityRegistry {\n  /** @internal */\n  _applications = /* @__PURE__ */ new Map();\n  /**\n   * Registers an application with a testability hook so that it can be tracked\n   * @param token token of application, root element\n   * @param testability Testability hook\n   */\n  registerApplication(token, testability) {\n    this._applications.set(token, testability);\n  }\n  /**\n   * Unregisters an application.\n   * @param token token of application, root element\n   */\n  unregisterApplication(token) {\n    this._applications.delete(token);\n  }\n  /**\n   * Unregisters all applications\n   */\n  unregisterAllApplications() {\n    this._applications.clear();\n  }\n  /**\n   * Get a testability hook associated with the application\n   * @param elem root element\n   */\n  getTestability(elem) {\n    return this._applications.get(elem) || null;\n  }\n  /**\n   * Get all registered testabilities\n   */\n  getAllTestabilities() {\n    return Array.from(this._applications.values());\n  }\n  /**\n   * Get all registered applications(root elements)\n   */\n  getAllRootElements() {\n    return Array.from(this._applications.keys());\n  }\n  /**\n   * Find testability of a node in the Tree\n   * @param elem node\n   * @param findInAncestors whether finding testability in ancestors if testability was not found in\n   * current node\n   */\n  findTestabilityInTree(elem, findInAncestors = true) {\n    return _testabilityGetter?.findTestabilityInTree(this, elem, findInAncestors) ?? null;\n  }\n  static \\u0275fac = function TestabilityRegistry_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _TestabilityRegistry)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _TestabilityRegistry,\n    factory: _TestabilityRegistry.\\u0275fac,\n    providedIn: \"platform\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(TestabilityRegistry, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"platform\"\n    }]\n  }], null, null);\n})();\nfunction setTestabilityGetter(getter) {\n  _testabilityGetter = getter;\n}\nvar _testabilityGetter;\nvar EffectScheduler = class _EffectScheduler {\n  /** @nocollapse */\n  static \\u0275prov = (\n    /** @pureOrBreakMyCode */\n    /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n      token: _EffectScheduler,\n      providedIn: \"root\",\n      factory: () => new ZoneAwareEffectScheduler()\n    })\n  );\n};\nvar ZoneAwareEffectScheduler = class {\n  queuedEffectCount = 0;\n  queues = /* @__PURE__ */ new Map();\n  schedule(handle) {\n    this.enqueue(handle);\n  }\n  remove(handle) {\n    const zone = handle.zone;\n    const queue2 = this.queues.get(zone);\n    if (!queue2.has(handle)) {\n      return;\n    }\n    queue2.delete(handle);\n    this.queuedEffectCount--;\n  }\n  enqueue(handle) {\n    const zone = handle.zone;\n    if (!this.queues.has(zone)) {\n      this.queues.set(zone, /* @__PURE__ */ new Set());\n    }\n    const queue2 = this.queues.get(zone);\n    if (queue2.has(handle)) {\n      return;\n    }\n    this.queuedEffectCount++;\n    queue2.add(handle);\n  }\n  /**\n   * Run all scheduled effects.\n   *\n   * Execution order of effects within the same zone is guaranteed to be FIFO, but there is no\n   * ordering guarantee between effects scheduled in different zones.\n   */\n  flush() {\n    while (this.queuedEffectCount > 0) {\n      for (const [zone, queue2] of this.queues) {\n        if (zone === null) {\n          this.flushQueue(queue2);\n        } else {\n          zone.run(() => this.flushQueue(queue2));\n        }\n      }\n    }\n  }\n  flushQueue(queue2) {\n    for (const handle of queue2) {\n      queue2.delete(handle);\n      this.queuedEffectCount--;\n      handle.run();\n    }\n  }\n};\nfunction isPromise2(obj) {\n  return !!obj && typeof obj.then === \"function\";\n}\nfunction isSubscribable(obj) {\n  return !!obj && typeof obj.subscribe === \"function\";\n}\nvar APP_INITIALIZER = new InjectionToken(ngDevMode ? \"Application Initializer\" : \"\");\nvar ApplicationInitStatus = class _ApplicationInitStatus {\n  // Using non null assertion, these fields are defined below\n  // within the `new Promise` callback (synchronously).\n  resolve;\n  reject;\n  initialized = false;\n  done = false;\n  donePromise = new Promise((res, rej) => {\n    this.resolve = res;\n    this.reject = rej;\n  });\n  appInits = inject(APP_INITIALIZER, {\n    optional: true\n  }) ?? [];\n  injector = inject(Injector);\n  constructor() {\n    if ((typeof ngDevMode === \"undefined\" || ngDevMode) && !Array.isArray(this.appInits)) {\n      throw new RuntimeError(-209, `Unexpected type of the \\`APP_INITIALIZER\\` token value (expected an array, but got ${typeof this.appInits}). Please check that the \\`APP_INITIALIZER\\` token is configured as a \\`multi: true\\` provider.`);\n    }\n  }\n  /** @internal */\n  runInitializers() {\n    if (this.initialized) {\n      return;\n    }\n    const asyncInitPromises = [];\n    for (const appInits of this.appInits) {\n      const initResult = runInInjectionContext(this.injector, appInits);\n      if (isPromise2(initResult)) {\n        asyncInitPromises.push(initResult);\n      } else if (isSubscribable(initResult)) {\n        const observableAsPromise = new Promise((resolve, reject) => {\n          initResult.subscribe({\n            complete: resolve,\n            error: reject\n          });\n        });\n        asyncInitPromises.push(observableAsPromise);\n      }\n    }\n    const complete = () => {\n      this.done = true;\n      this.resolve();\n    };\n    Promise.all(asyncInitPromises).then(() => {\n      complete();\n    }).catch((e) => {\n      this.reject(e);\n    });\n    if (asyncInitPromises.length === 0) {\n      complete();\n    }\n    this.initialized = true;\n  }\n  static \\u0275fac = function ApplicationInitStatus_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _ApplicationInitStatus)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _ApplicationInitStatus,\n    factory: _ApplicationInitStatus.\\u0275fac,\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(ApplicationInitStatus, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], () => [], null);\n})();\nvar APP_BOOTSTRAP_LISTENER = new InjectionToken(ngDevMode ? \"appBootstrapListener\" : \"\");\nfunction publishDefaultGlobalUtils() {\n  ngDevMode && publishDefaultGlobalUtils$1();\n}\nfunction publishSignalConfiguration() {\n  setThrowInvalidWriteToSignalError(() => {\n    throw new RuntimeError(600, ngDevMode && \"Writing to signals is not allowed in a `computed`.\");\n  });\n}\nfunction isBoundToModule(cf) {\n  return cf.isBoundToModule;\n}\nvar MAXIMUM_REFRESH_RERUNS = 10;\nfunction optionsReducer(dst, objs) {\n  if (Array.isArray(objs)) {\n    return objs.reduce(optionsReducer, dst);\n  }\n  return __spreadValues(__spreadValues({}, dst), objs);\n}\nvar ApplicationRef = class _ApplicationRef {\n  /** @internal */\n  _runningTick = false;\n  _destroyed = false;\n  _destroyListeners = [];\n  /** @internal */\n  _views = [];\n  internalErrorHandler = inject(INTERNAL_APPLICATION_ERROR_HANDLER);\n  afterRenderManager = inject(AfterRenderManager);\n  zonelessEnabled = inject(ZONELESS_ENABLED);\n  rootEffectScheduler = inject(EffectScheduler);\n  /**\n   * Current dirty state of the application across a number of dimensions (views, afterRender hooks,\n   * etc).\n   *\n   * A flag set here means that `tick()` will attempt to resolve the dirtiness when executed.\n   *\n   * @internal\n   */\n  dirtyFlags = 0;\n  /**\n   * Most recent snapshot from the `TracingService`, if any.\n   *\n   * This snapshot attempts to capture the context when `tick()` was first\n   * scheduled. It then runs wrapped in this context.\n   *\n   * @internal\n   */\n  tracingSnapshot = null;\n  // Needed for ComponentFixture temporarily during migration of autoDetect behavior\n  // Eventually the hostView of the fixture should just attach to ApplicationRef.\n  externalTestViews = /* @__PURE__ */ new Set();\n  /** @internal */\n  afterTick = new Subject();\n  /** @internal */\n  get allViews() {\n    return [...this.externalTestViews.keys(), ...this._views];\n  }\n  /**\n   * Indicates whether this instance was destroyed.\n   */\n  get destroyed() {\n    return this._destroyed;\n  }\n  /**\n   * Get a list of component types registered to this application.\n   * This list is populated even before the component is created.\n   */\n  componentTypes = [];\n  /**\n   * Get a list of components registered to this application.\n   */\n  components = [];\n  /**\n   * Returns an Observable that indicates when the application is stable or unstable.\n   */\n  isStable = inject(PendingTasksInternal).hasPendingTasks.pipe(map((pending) => !pending));\n  constructor() {\n    inject(TracingService, {\n      optional: true\n    });\n  }\n  /**\n   * @returns A promise that resolves when the application becomes stable\n   */\n  whenStable() {\n    let subscription;\n    return new Promise((resolve) => {\n      subscription = this.isStable.subscribe({\n        next: (stable) => {\n          if (stable) {\n            resolve();\n          }\n        }\n      });\n    }).finally(() => {\n      subscription.unsubscribe();\n    });\n  }\n  _injector = inject(EnvironmentInjector);\n  _rendererFactory = null;\n  /**\n   * The `EnvironmentInjector` used to create this application.\n   */\n  get injector() {\n    return this._injector;\n  }\n  /**\n   * Bootstrap a component onto the element identified by its selector or, optionally, to a\n   * specified element.\n   *\n   * @usageNotes\n   * ### Bootstrap process\n   *\n   * When bootstrapping a component, Angular mounts it onto a target DOM element\n   * and kicks off automatic change detection. The target DOM element can be\n   * provided using the `rootSelectorOrNode` argument.\n   *\n   * If the target DOM element is not provided, Angular tries to find one on a page\n   * using the `selector` of the component that is being bootstrapped\n   * (first matched element is used).\n   *\n   * ### Example\n   *\n   * Generally, we define the component to bootstrap in the `bootstrap` array of `NgModule`,\n   * but it requires us to know the component while writing the application code.\n   *\n   * Imagine a situation where we have to wait for an API call to decide about the component to\n   * bootstrap. We can use the `ngDoBootstrap` hook of the `NgModule` and call this method to\n   * dynamically bootstrap a component.\n   *\n   * {@example core/ts/platform/platform.ts region='componentSelector'}\n   *\n   * Optionally, a component can be mounted onto a DOM element that does not match the\n   * selector of the bootstrapped component.\n   *\n   * In the following example, we are providing a CSS selector to match the target element.\n   *\n   * {@example core/ts/platform/platform.ts region='cssSelector'}\n   *\n   * While in this example, we are providing reference to a DOM node.\n   *\n   * {@example core/ts/platform/platform.ts region='domNode'}\n   */\n  bootstrap(componentOrFactory, rootSelectorOrNode) {\n    profiler(\n      10\n      /* ProfilerEvent.BootstrapComponentStart */\n    );\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && warnIfDestroyed(this._destroyed);\n    const isComponentFactory = componentOrFactory instanceof ComponentFactory$1;\n    const initStatus = this._injector.get(ApplicationInitStatus);\n    if (!initStatus.done) {\n      let errorMessage = \"\";\n      if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n        const standalone = !isComponentFactory && isStandalone(componentOrFactory);\n        errorMessage = \"Cannot bootstrap as there are still asynchronous initializers running.\" + (standalone ? \"\" : \" Bootstrap components in the `ngDoBootstrap` method of the root module.\");\n      }\n      throw new RuntimeError(405, errorMessage);\n    }\n    let componentFactory;\n    if (isComponentFactory) {\n      componentFactory = componentOrFactory;\n    } else {\n      const resolver = this._injector.get(ComponentFactoryResolver$1);\n      componentFactory = resolver.resolveComponentFactory(componentOrFactory);\n    }\n    this.componentTypes.push(componentFactory.componentType);\n    const ngModule = isBoundToModule(componentFactory) ? void 0 : this._injector.get(NgModuleRef$1);\n    const selectorOrNode = rootSelectorOrNode || componentFactory.selector;\n    const compRef = componentFactory.create(Injector.NULL, [], selectorOrNode, ngModule);\n    const nativeElement = compRef.location.nativeElement;\n    const testability = compRef.injector.get(TESTABILITY, null);\n    testability?.registerApplication(nativeElement);\n    compRef.onDestroy(() => {\n      this.detachView(compRef.hostView);\n      remove(this.components, compRef);\n      testability?.unregisterApplication(nativeElement);\n    });\n    this._loadComponent(compRef);\n    if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n      const _console = this._injector.get(Console);\n      _console.log(`Angular is running in development mode.`);\n    }\n    profiler(11, compRef);\n    return compRef;\n  }\n  /**\n   * Invoke this method to explicitly process change detection and its side-effects.\n   *\n   * In development mode, `tick()` also performs a second change detection cycle to ensure that no\n   * further changes are detected. If additional changes are picked up during this second cycle,\n   * bindings in the app have side-effects that cannot be resolved in a single change detection\n   * pass.\n   * In this case, Angular throws an error, since an Angular application can only have one change\n   * detection pass during which all change detection must complete.\n   */\n  tick() {\n    if (!this.zonelessEnabled) {\n      this.dirtyFlags |= 1;\n    }\n    this._tick();\n  }\n  /** @internal */\n  _tick() {\n    profiler(\n      12\n      /* ProfilerEvent.ChangeDetectionStart */\n    );\n    if (this.tracingSnapshot !== null) {\n      this.tracingSnapshot.run(TracingAction.CHANGE_DETECTION, this.tickImpl);\n    } else {\n      this.tickImpl();\n    }\n  }\n  tickImpl = () => {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && warnIfDestroyed(this._destroyed);\n    if (this._runningTick) {\n      throw new RuntimeError(101, ngDevMode && \"ApplicationRef.tick is called recursively\");\n    }\n    const prevConsumer = setActiveConsumer(null);\n    try {\n      this._runningTick = true;\n      this.synchronize();\n      if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n        for (let view of this.allViews) {\n          view.checkNoChanges();\n        }\n      }\n    } catch (e) {\n      this.internalErrorHandler(e);\n    } finally {\n      this._runningTick = false;\n      this.tracingSnapshot?.dispose();\n      this.tracingSnapshot = null;\n      setActiveConsumer(prevConsumer);\n      this.afterTick.next();\n      profiler(\n        13\n        /* ProfilerEvent.ChangeDetectionEnd */\n      );\n    }\n  };\n  /**\n   * Performs the core work of synchronizing the application state with the UI, resolving any\n   * pending dirtiness (potentially in a loop).\n   */\n  synchronize() {\n    if (this._rendererFactory === null && !this._injector.destroyed) {\n      this._rendererFactory = this._injector.get(RendererFactory2, null, {\n        optional: true\n      });\n    }\n    let runs = 0;\n    while (this.dirtyFlags !== 0 && runs++ < MAXIMUM_REFRESH_RERUNS) {\n      profiler(\n        14\n        /* ProfilerEvent.ChangeDetectionSyncStart */\n      );\n      this.synchronizeOnce();\n      profiler(\n        15\n        /* ProfilerEvent.ChangeDetectionSyncEnd */\n      );\n    }\n    if ((typeof ngDevMode === \"undefined\" || ngDevMode) && runs >= MAXIMUM_REFRESH_RERUNS) {\n      throw new RuntimeError(103, ngDevMode && \"Infinite change detection while refreshing application views. Ensure views are not calling `markForCheck` on every template execution or that afterRender hooks always mark views for check.\");\n    }\n  }\n  /**\n   * Perform a single synchronization pass.\n   */\n  synchronizeOnce() {\n    if (this.dirtyFlags & 16) {\n      this.dirtyFlags &= -17;\n      this.rootEffectScheduler.flush();\n    }\n    if (this.dirtyFlags & 7) {\n      const useGlobalCheck = Boolean(\n        this.dirtyFlags & 1\n        /* ApplicationRefDirtyFlags.ViewTreeGlobal */\n      );\n      this.dirtyFlags &= -8;\n      this.dirtyFlags |= 8;\n      for (let {\n        _lView,\n        notifyErrorHandler\n      } of this.allViews) {\n        detectChangesInViewIfRequired(_lView, notifyErrorHandler, useGlobalCheck, this.zonelessEnabled);\n      }\n      this.dirtyFlags &= -5;\n      this.syncDirtyFlagsWithViews();\n      if (this.dirtyFlags & (7 | 16)) {\n        return;\n      }\n    } else {\n      this._rendererFactory?.begin?.();\n      this._rendererFactory?.end?.();\n    }\n    if (this.dirtyFlags & 8) {\n      this.dirtyFlags &= -9;\n      this.afterRenderManager.execute();\n    }\n    this.syncDirtyFlagsWithViews();\n  }\n  /**\n   * Checks `allViews` for views which require refresh/traversal, and updates `dirtyFlags`\n   * accordingly, with two potential behaviors:\n   *\n   * 1. If any of our views require updating, then this adds the `ViewTreeTraversal` dirty flag.\n   *    This _should_ be a no-op, since the scheduler should've added the flag at the same time the\n   *    view was marked as needing updating.\n   *\n   *    TODO(alxhub): figure out if this behavior is still needed for edge cases.\n   *\n   * 2. If none of our views require updating, then clear the view-related `dirtyFlag`s. This\n   *    happens when the scheduler is notified of a view becoming dirty, but the view itself isn't\n   *    reachable through traversal from our roots (e.g. it's detached from the CD tree).\n   */\n  syncDirtyFlagsWithViews() {\n    if (this.allViews.some(({\n      _lView\n    }) => requiresRefreshOrTraversal(_lView))) {\n      this.dirtyFlags |= 2;\n      return;\n    } else {\n      this.dirtyFlags &= -8;\n    }\n  }\n  /**\n   * Attaches a view so that it will be dirty checked.\n   * The view will be automatically detached when it is destroyed.\n   * This will throw if the view is already attached to a ViewContainer.\n   */\n  attachView(viewRef) {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && warnIfDestroyed(this._destroyed);\n    const view = viewRef;\n    this._views.push(view);\n    view.attachToAppRef(this);\n  }\n  /**\n   * Detaches a view from dirty checking again.\n   */\n  detachView(viewRef) {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && warnIfDestroyed(this._destroyed);\n    const view = viewRef;\n    remove(this._views, view);\n    view.detachFromAppRef();\n  }\n  _loadComponent(componentRef) {\n    this.attachView(componentRef.hostView);\n    this.tick();\n    this.components.push(componentRef);\n    const listeners = this._injector.get(APP_BOOTSTRAP_LISTENER, []);\n    if (ngDevMode && !Array.isArray(listeners)) {\n      throw new RuntimeError(-209, `Unexpected type of the \\`APP_BOOTSTRAP_LISTENER\\` token value (expected an array, but got ${typeof listeners}). Please check that the \\`APP_BOOTSTRAP_LISTENER\\` token is configured as a \\`multi: true\\` provider.`);\n    }\n    listeners.forEach((listener) => listener(componentRef));\n  }\n  /** @internal */\n  ngOnDestroy() {\n    if (this._destroyed) return;\n    try {\n      this._destroyListeners.forEach((listener) => listener());\n      this._views.slice().forEach((view) => view.destroy());\n    } finally {\n      this._destroyed = true;\n      this._views = [];\n      this._destroyListeners = [];\n    }\n  }\n  /**\n   * Registers a listener to be called when an instance is destroyed.\n   *\n   * @param callback A callback function to add as a listener.\n   * @returns A function which unregisters a listener.\n   */\n  onDestroy(callback) {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && warnIfDestroyed(this._destroyed);\n    this._destroyListeners.push(callback);\n    return () => remove(this._destroyListeners, callback);\n  }\n  /**\n   * Destroys an Angular application represented by this `ApplicationRef`. Calling this function\n   * will destroy the associated environment injectors as well as all the bootstrapped components\n   * with their views.\n   */\n  destroy() {\n    if (this._destroyed) {\n      throw new RuntimeError(406, ngDevMode && \"This instance of the `ApplicationRef` has already been destroyed.\");\n    }\n    const injector = this._injector;\n    if (injector.destroy && !injector.destroyed) {\n      injector.destroy();\n    }\n  }\n  /**\n   * Returns the number of attached views.\n   */\n  get viewCount() {\n    return this._views.length;\n  }\n  static \\u0275fac = function ApplicationRef_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _ApplicationRef)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _ApplicationRef,\n    factory: _ApplicationRef.\\u0275fac,\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(ApplicationRef, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], () => [], null);\n})();\nfunction warnIfDestroyed(destroyed) {\n  if (destroyed) {\n    console.warn(formatRuntimeError(406, \"This instance of the `ApplicationRef` has already been destroyed.\"));\n  }\n}\nfunction remove(list, el) {\n  const index = list.indexOf(el);\n  if (index > -1) {\n    list.splice(index, 1);\n  }\n}\nfunction detectChangesInViewIfRequired(lView, notifyErrorHandler, isFirstPass, zonelessEnabled) {\n  if (!isFirstPass && !requiresRefreshOrTraversal(lView)) {\n    return;\n  }\n  const mode = isFirstPass && !zonelessEnabled ? (\n    // The first pass is always in Global mode, which includes `CheckAlways` views.\n    0\n  ) : (\n    // Only refresh views with the `RefreshView` flag or views is a changed signal\n    1\n  );\n  detectChangesInternal(lView, notifyErrorHandler, mode);\n}\nfunction scheduleDelayedTrigger(scheduleFn) {\n  const lView = getLView();\n  const tNode = getCurrentTNode();\n  renderPlaceholder(lView, tNode);\n  if (!shouldTriggerDeferBlock(0, lView)) return;\n  const injector = lView[INJECTOR];\n  const lDetails = getLDeferBlockDetails(lView, tNode);\n  const cleanupFn = scheduleFn(() => triggerDeferBlock(0, lView, tNode), injector);\n  storeTriggerCleanupFn(0, lDetails, cleanupFn);\n}\nfunction scheduleDelayedPrefetching(scheduleFn, trigger) {\n  if (false) return;\n  const lView = getLView();\n  const injector = lView[INJECTOR];\n  const tNode = getCurrentTNode();\n  const tView = lView[TVIEW];\n  const tDetails = getTDeferBlockDetails(tView, tNode);\n  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {\n    const lDetails = getLDeferBlockDetails(lView, tNode);\n    const prefetch = () => triggerPrefetching(tDetails, lView, tNode);\n    const cleanupFn = scheduleFn(prefetch, injector);\n    storeTriggerCleanupFn(1, lDetails, cleanupFn);\n  }\n}\nfunction scheduleDelayedHydrating(scheduleFn, lView, tNode) {\n  if (false) return;\n  const injector = lView[INJECTOR];\n  const lDetails = getLDeferBlockDetails(lView, tNode);\n  const ssrUniqueId = lDetails[SSR_UNIQUE_ID];\n  ngDevMode && assertSsrIdDefined(ssrUniqueId);\n  const cleanupFn = scheduleFn(() => triggerHydrationFromBlockName(injector, ssrUniqueId), injector);\n  storeTriggerCleanupFn(2, lDetails, cleanupFn);\n}\nfunction triggerPrefetching(tDetails, lView, tNode) {\n  triggerResourceLoading(tDetails, lView, tNode);\n}\nfunction triggerResourceLoading(tDetails, lView, tNode) {\n  const injector = lView[INJECTOR];\n  const tView = lView[TVIEW];\n  if (tDetails.loadingState !== DeferDependenciesLoadingState.NOT_STARTED) {\n    return tDetails.loadingPromise ?? Promise.resolve();\n  }\n  const lDetails = getLDeferBlockDetails(lView, tNode);\n  const primaryBlockTNode = getPrimaryBlockTNode(tView, tDetails);\n  tDetails.loadingState = DeferDependenciesLoadingState.IN_PROGRESS;\n  invokeTriggerCleanupFns(1, lDetails);\n  let dependenciesFn = tDetails.dependencyResolverFn;\n  if (ngDevMode) {\n    const deferDependencyInterceptor = injector.get(DEFER_BLOCK_DEPENDENCY_INTERCEPTOR, null, {\n      optional: true\n    });\n    if (deferDependencyInterceptor) {\n      dependenciesFn = deferDependencyInterceptor.intercept(dependenciesFn);\n    }\n  }\n  const pendingTasks = injector.get(PendingTasksInternal);\n  const taskId = pendingTasks.add();\n  if (!dependenciesFn) {\n    tDetails.loadingPromise = Promise.resolve().then(() => {\n      tDetails.loadingPromise = null;\n      tDetails.loadingState = DeferDependenciesLoadingState.COMPLETE;\n      pendingTasks.remove(taskId);\n    });\n    return tDetails.loadingPromise;\n  }\n  tDetails.loadingPromise = Promise.allSettled(dependenciesFn()).then((results) => {\n    let failed = false;\n    const directiveDefs = [];\n    const pipeDefs = [];\n    for (const result of results) {\n      if (result.status === \"fulfilled\") {\n        const dependency = result.value;\n        const directiveDef = getComponentDef(dependency) || getDirectiveDef(dependency);\n        if (directiveDef) {\n          directiveDefs.push(directiveDef);\n        } else {\n          const pipeDef = getPipeDef$1(dependency);\n          if (pipeDef) {\n            pipeDefs.push(pipeDef);\n          }\n        }\n      } else {\n        failed = true;\n        break;\n      }\n    }\n    tDetails.loadingPromise = null;\n    pendingTasks.remove(taskId);\n    if (failed) {\n      tDetails.loadingState = DeferDependenciesLoadingState.FAILED;\n      if (tDetails.errorTmplIndex === null) {\n        const templateLocation = ngDevMode ? getTemplateLocationDetails(lView) : \"\";\n        const error = new RuntimeError(-750, ngDevMode && `Loading dependencies for \\`@defer\\` block failed, but no \\`@error\\` block was configured${templateLocation}. Consider using the \\`@error\\` block to render an error state.`);\n        handleError(lView, error);\n      }\n    } else {\n      tDetails.loadingState = DeferDependenciesLoadingState.COMPLETE;\n      const primaryBlockTView = primaryBlockTNode.tView;\n      if (directiveDefs.length > 0) {\n        primaryBlockTView.directiveRegistry = addDepsToRegistry(primaryBlockTView.directiveRegistry, directiveDefs);\n        const directiveTypes = directiveDefs.map((def) => def.type);\n        const providers = internalImportProvidersFrom(false, ...directiveTypes);\n        tDetails.providers = providers;\n      }\n      if (pipeDefs.length > 0) {\n        primaryBlockTView.pipeRegistry = addDepsToRegistry(primaryBlockTView.pipeRegistry, pipeDefs);\n      }\n    }\n  });\n  return tDetails.loadingPromise;\n}\nfunction shouldTriggerDeferBlock(triggerType, lView) {\n  if (triggerType === 0 && true && false) {\n    return false;\n  }\n  const injector = lView[INJECTOR];\n  const config2 = injector.get(DEFER_BLOCK_CONFIG, null, {\n    optional: true\n  });\n  if (config2?.behavior === DeferBlockBehavior.Manual) {\n    return false;\n  }\n  return true;\n}\nfunction triggerDeferBlock(triggerType, lView, tNode) {\n  const tView = lView[TVIEW];\n  const lContainer = lView[tNode.index];\n  ngDevMode && assertLContainer(lContainer);\n  if (!shouldTriggerDeferBlock(triggerType, lView)) return;\n  const lDetails = getLDeferBlockDetails(lView, tNode);\n  const tDetails = getTDeferBlockDetails(tView, tNode);\n  invokeAllTriggerCleanupFns(lDetails);\n  switch (tDetails.loadingState) {\n    case DeferDependenciesLoadingState.NOT_STARTED:\n      renderDeferBlockState(DeferBlockState.Loading, tNode, lContainer);\n      triggerResourceLoading(tDetails, lView, tNode);\n      if (tDetails.loadingState === DeferDependenciesLoadingState.IN_PROGRESS) {\n        renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer);\n      }\n      break;\n    case DeferDependenciesLoadingState.IN_PROGRESS:\n      renderDeferBlockState(DeferBlockState.Loading, tNode, lContainer);\n      renderDeferStateAfterResourceLoading(tDetails, tNode, lContainer);\n      break;\n    case DeferDependenciesLoadingState.COMPLETE:\n      ngDevMode && assertDeferredDependenciesLoaded(tDetails);\n      renderDeferBlockState(DeferBlockState.Complete, tNode, lContainer);\n      break;\n    case DeferDependenciesLoadingState.FAILED:\n      renderDeferBlockState(DeferBlockState.Error, tNode, lContainer);\n      break;\n    default:\n      if (ngDevMode) {\n        throwError2(\"Unknown defer block state\");\n      }\n  }\n}\nfunction triggerHydrationFromBlockName(injector, blockName, replayQueuedEventsFn) {\n  return __async(this, null, function* () {\n    const dehydratedBlockRegistry = injector.get(DEHYDRATED_BLOCK_REGISTRY);\n    const blocksBeingHydrated = dehydratedBlockRegistry.hydrating;\n    if (blocksBeingHydrated.has(blockName)) {\n      return;\n    }\n    const {\n      parentBlockPromise,\n      hydrationQueue\n    } = getParentBlockHydrationQueue(blockName, injector);\n    if (hydrationQueue.length === 0) return;\n    if (parentBlockPromise !== null) {\n      hydrationQueue.shift();\n    }\n    populateHydratingStateForQueue(dehydratedBlockRegistry, hydrationQueue);\n    if (parentBlockPromise !== null) {\n      yield parentBlockPromise;\n    }\n    const topmostParentBlock = hydrationQueue[0];\n    if (dehydratedBlockRegistry.has(topmostParentBlock)) {\n      yield triggerHydrationForBlockQueue(injector, hydrationQueue, replayQueuedEventsFn);\n    } else {\n      dehydratedBlockRegistry.awaitParentBlock(topmostParentBlock, () => __async(this, null, function* () {\n        return yield triggerHydrationForBlockQueue(injector, hydrationQueue, replayQueuedEventsFn);\n      }));\n    }\n  });\n}\nfunction triggerHydrationForBlockQueue(injector, hydrationQueue, replayQueuedEventsFn) {\n  return __async(this, null, function* () {\n    const dehydratedBlockRegistry = injector.get(DEHYDRATED_BLOCK_REGISTRY);\n    const blocksBeingHydrated = dehydratedBlockRegistry.hydrating;\n    const pendingTasks = injector.get(PendingTasksInternal);\n    const taskId = pendingTasks.add();\n    for (let blockQueueIdx = 0; blockQueueIdx < hydrationQueue.length; blockQueueIdx++) {\n      const dehydratedBlockId = hydrationQueue[blockQueueIdx];\n      const dehydratedDeferBlock = dehydratedBlockRegistry.get(dehydratedBlockId);\n      if (dehydratedDeferBlock != null) {\n        yield triggerResourceLoadingForHydration(dehydratedDeferBlock);\n        yield nextRender(injector);\n        if (deferBlockHasErrored(dehydratedDeferBlock)) {\n          removeDehydratedViewList(dehydratedDeferBlock);\n          cleanupRemainingHydrationQueue(hydrationQueue.slice(blockQueueIdx), dehydratedBlockRegistry);\n          break;\n        }\n        blocksBeingHydrated.get(dehydratedBlockId).resolve();\n      } else {\n        cleanupParentContainer(blockQueueIdx, hydrationQueue, dehydratedBlockRegistry);\n        cleanupRemainingHydrationQueue(hydrationQueue.slice(blockQueueIdx), dehydratedBlockRegistry);\n        break;\n      }\n    }\n    const lastBlockName = hydrationQueue[hydrationQueue.length - 1];\n    yield blocksBeingHydrated.get(lastBlockName)?.promise;\n    pendingTasks.remove(taskId);\n    if (replayQueuedEventsFn) {\n      replayQueuedEventsFn(hydrationQueue);\n    }\n    cleanupHydratedDeferBlocks(dehydratedBlockRegistry.get(lastBlockName), hydrationQueue, dehydratedBlockRegistry, injector.get(ApplicationRef));\n  });\n}\nfunction deferBlockHasErrored(deferBlock) {\n  return getLDeferBlockDetails(deferBlock.lView, deferBlock.tNode)[DEFER_BLOCK_STATE] === DeferBlockState.Error;\n}\nfunction cleanupParentContainer(currentBlockIdx, hydrationQueue, dehydratedBlockRegistry) {\n  const parentDeferBlockIdx = currentBlockIdx - 1;\n  const parentDeferBlock = parentDeferBlockIdx > -1 ? dehydratedBlockRegistry.get(hydrationQueue[parentDeferBlockIdx]) : null;\n  if (parentDeferBlock) {\n    cleanupLContainer(parentDeferBlock.lContainer);\n  }\n}\nfunction cleanupRemainingHydrationQueue(hydrationQueue, dehydratedBlockRegistry) {\n  const blocksBeingHydrated = dehydratedBlockRegistry.hydrating;\n  for (const dehydratedBlockId in hydrationQueue) {\n    blocksBeingHydrated.get(dehydratedBlockId)?.reject();\n  }\n  dehydratedBlockRegistry.cleanup(hydrationQueue);\n}\nfunction populateHydratingStateForQueue(registry, queue2) {\n  for (let blockId of queue2) {\n    registry.hydrating.set(blockId, Promise.withResolvers());\n  }\n}\nfunction nextRender(injector) {\n  return new Promise((resolveFn) => afterNextRender(resolveFn, {\n    injector\n  }));\n}\nfunction triggerResourceLoadingForHydration(dehydratedBlock) {\n  return __async(this, null, function* () {\n    const {\n      tNode,\n      lView\n    } = dehydratedBlock;\n    const lDetails = getLDeferBlockDetails(lView, tNode);\n    return new Promise((resolve) => {\n      onDeferBlockCompletion(lDetails, resolve);\n      triggerDeferBlock(2, lView, tNode);\n    });\n  });\n}\nfunction onDeferBlockCompletion(lDetails, callback) {\n  if (!Array.isArray(lDetails[ON_COMPLETE_FNS])) {\n    lDetails[ON_COMPLETE_FNS] = [];\n  }\n  lDetails[ON_COMPLETE_FNS].push(callback);\n}\nfunction shouldAttachTrigger(triggerType, lView, tNode) {\n  if (triggerType === 0) {\n    return shouldAttachRegularTrigger(lView, tNode);\n  } else if (triggerType === 2) {\n    return !shouldAttachRegularTrigger(lView, tNode);\n  }\n  return true;\n}\nfunction shouldAttachRegularTrigger(lView, tNode) {\n  const injector = lView[INJECTOR];\n  const tDetails = getTDeferBlockDetails(lView[TVIEW], tNode);\n  const incrementalHydrationEnabled = isIncrementalHydrationEnabled(injector);\n  const hasHydrateTriggers = tDetails.flags !== null && (tDetails.flags & 1) === 1;\n  if (false) {\n    return !incrementalHydrationEnabled || !hasHydrateTriggers;\n  }\n  const lDetails = getLDeferBlockDetails(lView, tNode);\n  const wasServerSideRendered = lDetails[SSR_UNIQUE_ID] !== null;\n  if (hasHydrateTriggers && wasServerSideRendered && incrementalHydrationEnabled) {\n    return false;\n  }\n  return true;\n}\nfunction getHydrateTriggers(tView, tNode) {\n  const tDetails = getTDeferBlockDetails(tView, tNode);\n  return tDetails.hydrateTriggers ??= /* @__PURE__ */ new Map();\n}\nfunction \\u0275\\u0275defer(index, primaryTmplIndex, dependencyResolverFn, loadingTmplIndex, placeholderTmplIndex, errorTmplIndex, loadingConfigIndex, placeholderConfigIndex, enableTimerScheduling, flags) {\n  const lView = getLView();\n  const tView = getTView();\n  const adjustedIndex = index + HEADER_OFFSET;\n  const tNode = declareTemplate(lView, tView, index, null, 0, 0);\n  const injector = lView[INJECTOR];\n  if (tView.firstCreatePass) {\n    performanceMarkFeature(\"NgDefer\");\n    const tDetails = {\n      primaryTmplIndex,\n      loadingTmplIndex: loadingTmplIndex ?? null,\n      placeholderTmplIndex: placeholderTmplIndex ?? null,\n      errorTmplIndex: errorTmplIndex ?? null,\n      placeholderBlockConfig: null,\n      loadingBlockConfig: null,\n      dependencyResolverFn: dependencyResolverFn ?? null,\n      loadingState: DeferDependenciesLoadingState.NOT_STARTED,\n      loadingPromise: null,\n      providers: null,\n      hydrateTriggers: null,\n      debug: null,\n      flags: flags ?? 0\n      /* TDeferDetailsFlags.Default */\n    };\n    enableTimerScheduling?.(tView, tDetails, placeholderConfigIndex, loadingConfigIndex);\n    setTDeferBlockDetails(tView, adjustedIndex, tDetails);\n  }\n  const lContainer = lView[adjustedIndex];\n  populateDehydratedViewsInLContainer(lContainer, tNode, lView);\n  let ssrBlockState = null;\n  let ssrUniqueId = null;\n  if (lContainer[DEHYDRATED_VIEWS]?.length > 0) {\n    const info = lContainer[DEHYDRATED_VIEWS][0].data;\n    ssrUniqueId = info[DEFER_BLOCK_ID] ?? null;\n    ssrBlockState = info[DEFER_BLOCK_STATE$1];\n  }\n  const lDetails = [\n    null,\n    // NEXT_DEFER_BLOCK_STATE\n    DeferBlockInternalState.Initial,\n    // DEFER_BLOCK_STATE\n    null,\n    // STATE_IS_FROZEN_UNTIL\n    null,\n    // LOADING_AFTER_CLEANUP_FN\n    null,\n    // TRIGGER_CLEANUP_FNS\n    null,\n    // PREFETCH_TRIGGER_CLEANUP_FNS\n    ssrUniqueId,\n    // SSR_UNIQUE_ID\n    ssrBlockState,\n    // SSR_BLOCK_STATE\n    null,\n    // ON_COMPLETE_FNS\n    null\n    // HYDRATE_TRIGGER_CLEANUP_FNS\n  ];\n  setLDeferBlockDetails(lView, adjustedIndex, lDetails);\n  let registry = null;\n  if (ssrUniqueId !== null) {\n    ngDevMode && assertIncrementalHydrationIsConfigured(injector);\n    registry = injector.get(DEHYDRATED_BLOCK_REGISTRY);\n    registry.add(ssrUniqueId, {\n      lView,\n      tNode,\n      lContainer\n    });\n  }\n  const onLViewDestroy = () => {\n    invokeAllTriggerCleanupFns(lDetails);\n    if (ssrUniqueId !== null) {\n      registry?.cleanup([ssrUniqueId]);\n    }\n  };\n  storeTriggerCleanupFn(0, lDetails, () => removeLViewOnDestroy(lView, onLViewDestroy));\n  storeLViewOnDestroy(lView, onLViewDestroy);\n}\nfunction \\u0275\\u0275deferWhen(rawValue) {\n  const lView = getLView();\n  const tNode = getSelectedTNode();\n  if (ngDevMode) {\n    trackTriggerForDebugging(lView[TVIEW], tNode, \"when <expression>\");\n  }\n  if (!shouldAttachTrigger(0, lView, tNode)) return;\n  const bindingIndex = nextBindingIndex();\n  if (bindingUpdated(lView, bindingIndex, rawValue)) {\n    const prevConsumer = setActiveConsumer(null);\n    try {\n      const value = Boolean(rawValue);\n      const lDetails = getLDeferBlockDetails(lView, tNode);\n      const renderedState = lDetails[DEFER_BLOCK_STATE];\n      if (value === false && renderedState === DeferBlockInternalState.Initial) {\n        renderPlaceholder(lView, tNode);\n      } else if (value === true && (renderedState === DeferBlockInternalState.Initial || renderedState === DeferBlockState.Placeholder)) {\n        triggerDeferBlock(0, lView, tNode);\n      }\n    } finally {\n      setActiveConsumer(prevConsumer);\n    }\n  }\n}\nfunction \\u0275\\u0275deferPrefetchWhen(rawValue) {\n  const lView = getLView();\n  const tNode = getSelectedTNode();\n  if (ngDevMode) {\n    trackTriggerForDebugging(lView[TVIEW], tNode, \"prefetch when <expression>\");\n  }\n  if (!shouldAttachTrigger(1, lView, tNode)) return;\n  const bindingIndex = nextBindingIndex();\n  if (bindingUpdated(lView, bindingIndex, rawValue)) {\n    const prevConsumer = setActiveConsumer(null);\n    try {\n      const value = Boolean(rawValue);\n      const tView = lView[TVIEW];\n      const tNode2 = getSelectedTNode();\n      const tDetails = getTDeferBlockDetails(tView, tNode2);\n      if (value === true && tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {\n        triggerPrefetching(tDetails, lView, tNode2);\n      }\n    } finally {\n      setActiveConsumer(prevConsumer);\n    }\n  }\n}\nfunction \\u0275\\u0275deferHydrateWhen(rawValue) {\n  const lView = getLView();\n  const tNode = getSelectedTNode();\n  if (ngDevMode) {\n    trackTriggerForDebugging(lView[TVIEW], tNode, \"hydrate when <expression>\");\n  }\n  if (!shouldAttachTrigger(2, lView, tNode)) return;\n  const bindingIndex = nextBindingIndex();\n  const tView = getTView();\n  const hydrateTriggers = getHydrateTriggers(tView, tNode);\n  hydrateTriggers.set(6, null);\n  if (bindingUpdated(lView, bindingIndex, rawValue)) {\n    if (false) {\n      triggerDeferBlock(2, lView, tNode);\n    } else {\n      const injector = lView[INJECTOR];\n      const prevConsumer = setActiveConsumer(null);\n      try {\n        const value = Boolean(rawValue);\n        if (value === true) {\n          const lDetails = getLDeferBlockDetails(lView, tNode);\n          const ssrUniqueId = lDetails[SSR_UNIQUE_ID];\n          ngDevMode && assertSsrIdDefined(ssrUniqueId);\n          triggerHydrationFromBlockName(injector, ssrUniqueId);\n        }\n      } finally {\n        setActiveConsumer(prevConsumer);\n      }\n    }\n  }\n}\nfunction \\u0275\\u0275deferHydrateNever() {\n  const lView = getLView();\n  const tNode = getCurrentTNode();\n  if (ngDevMode) {\n    trackTriggerForDebugging(lView[TVIEW], tNode, \"hydrate never\");\n  }\n  if (!shouldAttachTrigger(2, lView, tNode)) return;\n  const hydrateTriggers = getHydrateTriggers(getTView(), tNode);\n  hydrateTriggers.set(7, null);\n  if (false) {\n    triggerDeferBlock(2, lView, tNode);\n  }\n}\nfunction \\u0275\\u0275deferOnIdle() {\n  const lView = getLView();\n  const tNode = getCurrentTNode();\n  if (ngDevMode) {\n    trackTriggerForDebugging(lView[TVIEW], tNode, \"on idle\");\n  }\n  if (!shouldAttachTrigger(0, lView, tNode)) return;\n  scheduleDelayedTrigger(onIdle);\n}\nfunction \\u0275\\u0275deferPrefetchOnIdle() {\n  const lView = getLView();\n  const tNode = getCurrentTNode();\n  if (ngDevMode) {\n    trackTriggerForDebugging(lView[TVIEW], tNode, \"prefetch on idle\");\n  }\n  if (!shouldAttachTrigger(1, lView, tNode)) return;\n  scheduleDelayedPrefetching(onIdle);\n}\nfunction \\u0275\\u0275deferHydrateOnIdle() {\n  const lView = getLView();\n  const tNode = getCurrentTNode();\n  if (ngDevMode) {\n    trackTriggerForDebugging(lView[TVIEW], tNode, \"hydrate on idle\");\n  }\n  if (!shouldAttachTrigger(2, lView, tNode)) return;\n  const hydrateTriggers = getHydrateTriggers(getTView(), tNode);\n  hydrateTriggers.set(0, null);\n  if (false) {\n    triggerDeferBlock(2, lView, tNode);\n  } else {\n    scheduleDelayedHydrating(onIdle, lView, tNode);\n  }\n}\nfunction \\u0275\\u0275deferOnImmediate() {\n  const lView = getLView();\n  const tNode = getCurrentTNode();\n  if (ngDevMode) {\n    trackTriggerForDebugging(lView[TVIEW], tNode, \"on immediate\");\n  }\n  if (!shouldAttachTrigger(0, lView, tNode)) return;\n  const tDetails = getTDeferBlockDetails(lView[TVIEW], tNode);\n  if (tDetails.loadingTmplIndex === null) {\n    renderPlaceholder(lView, tNode);\n  }\n  triggerDeferBlock(0, lView, tNode);\n}\nfunction \\u0275\\u0275deferPrefetchOnImmediate() {\n  const lView = getLView();\n  const tNode = getCurrentTNode();\n  if (ngDevMode) {\n    trackTriggerForDebugging(lView[TVIEW], tNode, \"prefetch on immediate\");\n  }\n  if (!shouldAttachTrigger(1, lView, tNode)) return;\n  const tView = lView[TVIEW];\n  const tDetails = getTDeferBlockDetails(tView, tNode);\n  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {\n    triggerResourceLoading(tDetails, lView, tNode);\n  }\n}\nfunction \\u0275\\u0275deferHydrateOnImmediate() {\n  const lView = getLView();\n  const tNode = getCurrentTNode();\n  if (ngDevMode) {\n    trackTriggerForDebugging(lView[TVIEW], tNode, \"hydrate on immediate\");\n  }\n  if (!shouldAttachTrigger(2, lView, tNode)) return;\n  const hydrateTriggers = getHydrateTriggers(getTView(), tNode);\n  hydrateTriggers.set(1, null);\n  if (false) {\n    triggerDeferBlock(2, lView, tNode);\n  } else {\n    const injector = lView[INJECTOR];\n    const lDetails = getLDeferBlockDetails(lView, tNode);\n    const ssrUniqueId = lDetails[SSR_UNIQUE_ID];\n    ngDevMode && assertSsrIdDefined(ssrUniqueId);\n    triggerHydrationFromBlockName(injector, ssrUniqueId);\n  }\n}\nfunction \\u0275\\u0275deferOnTimer(delay) {\n  const lView = getLView();\n  const tNode = getCurrentTNode();\n  if (ngDevMode) {\n    trackTriggerForDebugging(lView[TVIEW], tNode, `on timer(${delay}ms)`);\n  }\n  if (!shouldAttachTrigger(0, lView, tNode)) return;\n  scheduleDelayedTrigger(onTimer(delay));\n}\nfunction \\u0275\\u0275deferPrefetchOnTimer(delay) {\n  const lView = getLView();\n  const tNode = getCurrentTNode();\n  if (ngDevMode) {\n    trackTriggerForDebugging(lView[TVIEW], tNode, `prefetch on timer(${delay}ms)`);\n  }\n  if (!shouldAttachTrigger(1, lView, tNode)) return;\n  scheduleDelayedPrefetching(onTimer(delay));\n}\nfunction \\u0275\\u0275deferHydrateOnTimer(delay) {\n  const lView = getLView();\n  const tNode = getCurrentTNode();\n  if (ngDevMode) {\n    trackTriggerForDebugging(lView[TVIEW], tNode, `hydrate on timer(${delay}ms)`);\n  }\n  if (!shouldAttachTrigger(2, lView, tNode)) return;\n  const hydrateTriggers = getHydrateTriggers(getTView(), tNode);\n  hydrateTriggers.set(5, {\n    delay\n  });\n  if (false) {\n    triggerDeferBlock(2, lView, tNode);\n  } else {\n    scheduleDelayedHydrating(onTimer(delay), lView, tNode);\n  }\n}\nfunction \\u0275\\u0275deferOnHover(triggerIndex, walkUpTimes) {\n  const lView = getLView();\n  const tNode = getCurrentTNode();\n  if (ngDevMode) {\n    trackTriggerForDebugging(lView[TVIEW], tNode, `on hover${walkUpTimes === -1 ? \"\" : \"(<target>)\"}`);\n  }\n  if (!shouldAttachTrigger(0, lView, tNode)) return;\n  renderPlaceholder(lView, tNode);\n  if (true) {\n    registerDomTrigger(\n      lView,\n      tNode,\n      triggerIndex,\n      walkUpTimes,\n      onHover,\n      () => triggerDeferBlock(0, lView, tNode),\n      0\n      /* TriggerType.Regular */\n    );\n  }\n}\nfunction \\u0275\\u0275deferPrefetchOnHover(triggerIndex, walkUpTimes) {\n  const lView = getLView();\n  const tNode = getCurrentTNode();\n  if (ngDevMode) {\n    trackTriggerForDebugging(lView[TVIEW], tNode, `prefetch on hover${walkUpTimes === -1 ? \"\" : \"(<target>)\"}`);\n  }\n  if (!shouldAttachTrigger(1, lView, tNode)) return;\n  const tView = lView[TVIEW];\n  const tDetails = getTDeferBlockDetails(tView, tNode);\n  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {\n    registerDomTrigger(\n      lView,\n      tNode,\n      triggerIndex,\n      walkUpTimes,\n      onHover,\n      () => triggerPrefetching(tDetails, lView, tNode),\n      1\n      /* TriggerType.Prefetch */\n    );\n  }\n}\nfunction \\u0275\\u0275deferHydrateOnHover() {\n  const lView = getLView();\n  const tNode = getCurrentTNode();\n  if (ngDevMode) {\n    trackTriggerForDebugging(lView[TVIEW], tNode, \"hydrate on hover\");\n  }\n  if (!shouldAttachTrigger(2, lView, tNode)) return;\n  const hydrateTriggers = getHydrateTriggers(getTView(), tNode);\n  hydrateTriggers.set(4, null);\n  if (false) {\n    triggerDeferBlock(2, lView, tNode);\n  }\n}\nfunction \\u0275\\u0275deferOnInteraction(triggerIndex, walkUpTimes) {\n  const lView = getLView();\n  const tNode = getCurrentTNode();\n  if (ngDevMode) {\n    trackTriggerForDebugging(lView[TVIEW], tNode, `on interaction${walkUpTimes === -1 ? \"\" : \"(<target>)\"}`);\n  }\n  if (!shouldAttachTrigger(0, lView, tNode)) return;\n  renderPlaceholder(lView, tNode);\n  if (true) {\n    registerDomTrigger(\n      lView,\n      tNode,\n      triggerIndex,\n      walkUpTimes,\n      onInteraction,\n      () => triggerDeferBlock(0, lView, tNode),\n      0\n      /* TriggerType.Regular */\n    );\n  }\n}\nfunction \\u0275\\u0275deferPrefetchOnInteraction(triggerIndex, walkUpTimes) {\n  const lView = getLView();\n  const tNode = getCurrentTNode();\n  if (ngDevMode) {\n    trackTriggerForDebugging(lView[TVIEW], tNode, `prefetch on interaction${walkUpTimes === -1 ? \"\" : \"(<target>)\"}`);\n  }\n  if (!shouldAttachTrigger(1, lView, tNode)) return;\n  const tView = lView[TVIEW];\n  const tDetails = getTDeferBlockDetails(tView, tNode);\n  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {\n    registerDomTrigger(\n      lView,\n      tNode,\n      triggerIndex,\n      walkUpTimes,\n      onInteraction,\n      () => triggerPrefetching(tDetails, lView, tNode),\n      1\n      /* TriggerType.Prefetch */\n    );\n  }\n}\nfunction \\u0275\\u0275deferHydrateOnInteraction() {\n  const lView = getLView();\n  const tNode = getCurrentTNode();\n  if (ngDevMode) {\n    trackTriggerForDebugging(lView[TVIEW], tNode, \"hydrate on interaction\");\n  }\n  if (!shouldAttachTrigger(2, lView, tNode)) return;\n  const hydrateTriggers = getHydrateTriggers(getTView(), tNode);\n  hydrateTriggers.set(3, null);\n  if (false) {\n    triggerDeferBlock(2, lView, tNode);\n  }\n}\nfunction \\u0275\\u0275deferOnViewport(triggerIndex, walkUpTimes) {\n  const lView = getLView();\n  const tNode = getCurrentTNode();\n  if (ngDevMode) {\n    trackTriggerForDebugging(lView[TVIEW], tNode, `on viewport${walkUpTimes === -1 ? \"\" : \"(<target>)\"}`);\n  }\n  if (!shouldAttachTrigger(0, lView, tNode)) return;\n  renderPlaceholder(lView, tNode);\n  if (true) {\n    registerDomTrigger(\n      lView,\n      tNode,\n      triggerIndex,\n      walkUpTimes,\n      onViewport,\n      () => triggerDeferBlock(0, lView, tNode),\n      0\n      /* TriggerType.Regular */\n    );\n  }\n}\nfunction \\u0275\\u0275deferPrefetchOnViewport(triggerIndex, walkUpTimes) {\n  const lView = getLView();\n  const tNode = getCurrentTNode();\n  if (ngDevMode) {\n    trackTriggerForDebugging(lView[TVIEW], tNode, `prefetch on viewport${walkUpTimes === -1 ? \"\" : \"(<target>)\"}`);\n  }\n  if (!shouldAttachTrigger(1, lView, tNode)) return;\n  const tView = lView[TVIEW];\n  const tDetails = getTDeferBlockDetails(tView, tNode);\n  if (tDetails.loadingState === DeferDependenciesLoadingState.NOT_STARTED) {\n    registerDomTrigger(\n      lView,\n      tNode,\n      triggerIndex,\n      walkUpTimes,\n      onViewport,\n      () => triggerPrefetching(tDetails, lView, tNode),\n      1\n      /* TriggerType.Prefetch */\n    );\n  }\n}\nfunction \\u0275\\u0275deferHydrateOnViewport() {\n  const lView = getLView();\n  const tNode = getCurrentTNode();\n  if (ngDevMode) {\n    trackTriggerForDebugging(lView[TVIEW], tNode, \"hydrate on viewport\");\n  }\n  if (!shouldAttachTrigger(2, lView, tNode)) return;\n  const hydrateTriggers = getHydrateTriggers(getTView(), tNode);\n  hydrateTriggers.set(2, null);\n  if (false) {\n    triggerDeferBlock(2, lView, tNode);\n  }\n}\nfunction \\u0275\\u0275attribute(name, value, sanitizer, namespace) {\n  const lView = getLView();\n  const bindingIndex = nextBindingIndex();\n  if (bindingUpdated(lView, bindingIndex, value)) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, name, value, sanitizer, namespace);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, \"attr.\" + name, bindingIndex);\n  }\n  return \\u0275\\u0275attribute;\n}\nfunction interpolationV(lView, values) {\n  ngDevMode && assertLessThan(2, values.length, \"should have at least 3 values\");\n  ngDevMode && assertEqual(values.length % 2, 1, \"should have an odd number of values\");\n  let isBindingUpdated = false;\n  let bindingIndex = getBindingIndex();\n  for (let i = 1; i < values.length; i += 2) {\n    isBindingUpdated = bindingUpdated(lView, bindingIndex++, values[i]) || isBindingUpdated;\n  }\n  setBindingIndex(bindingIndex);\n  if (!isBindingUpdated) {\n    return NO_CHANGE;\n  }\n  let content = values[0];\n  for (let i = 1; i < values.length; i += 2) {\n    content += renderStringify(values[i]) + values[i + 1];\n  }\n  return content;\n}\nfunction interpolation1(lView, prefix, v0, suffix) {\n  const different = bindingUpdated(lView, nextBindingIndex(), v0);\n  return different ? prefix + renderStringify(v0) + suffix : NO_CHANGE;\n}\nfunction interpolation2(lView, prefix, v0, i0, v1, suffix) {\n  const bindingIndex = getBindingIndex();\n  const different = bindingUpdated2(lView, bindingIndex, v0, v1);\n  incrementBindingIndex(2);\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + suffix : NO_CHANGE;\n}\nfunction interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix) {\n  const bindingIndex = getBindingIndex();\n  const different = bindingUpdated3(lView, bindingIndex, v0, v1, v2);\n  incrementBindingIndex(3);\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + suffix : NO_CHANGE;\n}\nfunction interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\n  const bindingIndex = getBindingIndex();\n  const different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  incrementBindingIndex(4);\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + suffix : NO_CHANGE;\n}\nfunction interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {\n  const bindingIndex = getBindingIndex();\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated(lView, bindingIndex + 4, v4) || different;\n  incrementBindingIndex(5);\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + suffix : NO_CHANGE;\n}\nfunction interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {\n  const bindingIndex = getBindingIndex();\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated2(lView, bindingIndex + 4, v4, v5) || different;\n  incrementBindingIndex(6);\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + suffix : NO_CHANGE;\n}\nfunction interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\n  const bindingIndex = getBindingIndex();\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated3(lView, bindingIndex + 4, v4, v5, v6) || different;\n  incrementBindingIndex(7);\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + suffix : NO_CHANGE;\n}\nfunction interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {\n  const bindingIndex = getBindingIndex();\n  let different = bindingUpdated4(lView, bindingIndex, v0, v1, v2, v3);\n  different = bindingUpdated4(lView, bindingIndex + 4, v4, v5, v6, v7) || different;\n  incrementBindingIndex(8);\n  return different ? prefix + renderStringify(v0) + i0 + renderStringify(v1) + i1 + renderStringify(v2) + i2 + renderStringify(v3) + i3 + renderStringify(v4) + i4 + renderStringify(v5) + i5 + renderStringify(v6) + i6 + renderStringify(v7) + suffix : NO_CHANGE;\n}\nfunction \\u0275\\u0275attributeInterpolate1(attrName, prefix, v0, suffix, sanitizer, namespace) {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, \"attr.\" + attrName, getBindingIndex() - 1, prefix, suffix);\n  }\n  return \\u0275\\u0275attributeInterpolate1;\n}\nfunction \\u0275\\u0275attributeInterpolate2(attrName, prefix, v0, i0, v1, suffix, sanitizer, namespace) {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, \"attr.\" + attrName, getBindingIndex() - 2, prefix, i0, suffix);\n  }\n  return \\u0275\\u0275attributeInterpolate2;\n}\nfunction \\u0275\\u0275attributeInterpolate3(attrName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer, namespace) {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, \"attr.\" + attrName, getBindingIndex() - 3, prefix, i0, i1, suffix);\n  }\n  return \\u0275\\u0275attributeInterpolate3;\n}\nfunction \\u0275\\u0275attributeInterpolate4(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer, namespace) {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, \"attr.\" + attrName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);\n  }\n  return \\u0275\\u0275attributeInterpolate4;\n}\nfunction \\u0275\\u0275attributeInterpolate5(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer, namespace) {\n  const lView = getLView();\n  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, \"attr.\" + attrName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);\n  }\n  return \\u0275\\u0275attributeInterpolate5;\n}\nfunction \\u0275\\u0275attributeInterpolate6(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer, namespace) {\n  const lView = getLView();\n  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, \"attr.\" + attrName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);\n  }\n  return \\u0275\\u0275attributeInterpolate6;\n}\nfunction \\u0275\\u0275attributeInterpolate7(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer, namespace) {\n  const lView = getLView();\n  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, \"attr.\" + attrName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5, suffix);\n  }\n  return \\u0275\\u0275attributeInterpolate7;\n}\nfunction \\u0275\\u0275attributeInterpolate8(attrName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer, namespace) {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolatedValue, sanitizer, namespace);\n    ngDevMode && storePropertyBindingMetadata(getTView().data, tNode, \"attr.\" + attrName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6, suffix);\n  }\n  return \\u0275\\u0275attributeInterpolate8;\n}\nfunction \\u0275\\u0275attributeInterpolateV(attrName, values, sanitizer, namespace) {\n  const lView = getLView();\n  const interpolated = interpolationV(lView, values);\n  if (interpolated !== NO_CHANGE) {\n    const tNode = getSelectedTNode();\n    elementAttributeInternal(tNode, lView, attrName, interpolated, sanitizer, namespace);\n    if (ngDevMode) {\n      const interpolationInBetween = [values[0]];\n      for (let i = 2; i < values.length; i += 2) {\n        interpolationInBetween.push(values[i]);\n      }\n      storePropertyBindingMetadata(getTView().data, tNode, \"attr.\" + attrName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);\n    }\n  }\n  return \\u0275\\u0275attributeInterpolateV;\n}\nfunction toTStylingRange(prev, next) {\n  ngDevMode && assertNumberInRange(\n    prev,\n    0,\n    32767\n    /* StylingRange.UNSIGNED_MASK */\n  );\n  ngDevMode && assertNumberInRange(\n    next,\n    0,\n    32767\n    /* StylingRange.UNSIGNED_MASK */\n  );\n  return prev << 17 | next << 2;\n}\nfunction getTStylingRangePrev(tStylingRange) {\n  ngDevMode && assertNumber(tStylingRange, \"expected number\");\n  return tStylingRange >> 17 & 32767;\n}\nfunction getTStylingRangePrevDuplicate(tStylingRange) {\n  ngDevMode && assertNumber(tStylingRange, \"expected number\");\n  return (tStylingRange & 2) == 2;\n}\nfunction setTStylingRangePrev(tStylingRange, previous) {\n  ngDevMode && assertNumber(tStylingRange, \"expected number\");\n  ngDevMode && assertNumberInRange(\n    previous,\n    0,\n    32767\n    /* StylingRange.UNSIGNED_MASK */\n  );\n  return tStylingRange & 131071 | previous << 17;\n}\nfunction setTStylingRangePrevDuplicate(tStylingRange) {\n  ngDevMode && assertNumber(tStylingRange, \"expected number\");\n  return tStylingRange | 2;\n}\nfunction getTStylingRangeNext(tStylingRange) {\n  ngDevMode && assertNumber(tStylingRange, \"expected number\");\n  return (tStylingRange & 131068) >> 2;\n}\nfunction setTStylingRangeNext(tStylingRange, next) {\n  ngDevMode && assertNumber(tStylingRange, \"expected number\");\n  ngDevMode && assertNumberInRange(\n    next,\n    0,\n    32767\n    /* StylingRange.UNSIGNED_MASK */\n  );\n  return tStylingRange & -131069 | //\n  next << 2;\n}\nfunction getTStylingRangeNextDuplicate(tStylingRange) {\n  ngDevMode && assertNumber(tStylingRange, \"expected number\");\n  return (tStylingRange & 1) === 1;\n}\nfunction setTStylingRangeNextDuplicate(tStylingRange) {\n  ngDevMode && assertNumber(tStylingRange, \"expected number\");\n  return tStylingRange | 1;\n}\nfunction insertTStylingBinding(tData, tNode, tStylingKeyWithStatic, index, isHostBinding, isClassBinding) {\n  ngDevMode && assertFirstUpdatePass(getTView());\n  let tBindings = isClassBinding ? tNode.classBindings : tNode.styleBindings;\n  let tmplHead = getTStylingRangePrev(tBindings);\n  let tmplTail = getTStylingRangeNext(tBindings);\n  tData[index] = tStylingKeyWithStatic;\n  let isKeyDuplicateOfStatic = false;\n  let tStylingKey;\n  if (Array.isArray(tStylingKeyWithStatic)) {\n    const staticKeyValueArray = tStylingKeyWithStatic;\n    tStylingKey = staticKeyValueArray[1];\n    if (tStylingKey === null || keyValueArrayIndexOf(staticKeyValueArray, tStylingKey) > 0) {\n      isKeyDuplicateOfStatic = true;\n    }\n  } else {\n    tStylingKey = tStylingKeyWithStatic;\n  }\n  if (isHostBinding) {\n    const hasTemplateBindings = tmplTail !== 0;\n    if (hasTemplateBindings) {\n      const previousNode = getTStylingRangePrev(tData[tmplHead + 1]);\n      tData[index + 1] = toTStylingRange(previousNode, tmplHead);\n      if (previousNode !== 0) {\n        tData[previousNode + 1] = setTStylingRangeNext(tData[previousNode + 1], index);\n      }\n      tData[tmplHead + 1] = setTStylingRangePrev(tData[tmplHead + 1], index);\n    } else {\n      tData[index + 1] = toTStylingRange(tmplHead, 0);\n      if (tmplHead !== 0) {\n        tData[tmplHead + 1] = setTStylingRangeNext(tData[tmplHead + 1], index);\n      }\n      tmplHead = index;\n    }\n  } else {\n    tData[index + 1] = toTStylingRange(tmplTail, 0);\n    ngDevMode && assertEqual(tmplHead !== 0 && tmplTail === 0, false, \"Adding template bindings after hostBindings is not allowed.\");\n    if (tmplHead === 0) {\n      tmplHead = index;\n    } else {\n      tData[tmplTail + 1] = setTStylingRangeNext(tData[tmplTail + 1], index);\n    }\n    tmplTail = index;\n  }\n  if (isKeyDuplicateOfStatic) {\n    tData[index + 1] = setTStylingRangePrevDuplicate(tData[index + 1]);\n  }\n  markDuplicates(tData, tStylingKey, index, true);\n  markDuplicates(tData, tStylingKey, index, false);\n  markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding);\n  tBindings = toTStylingRange(tmplHead, tmplTail);\n  if (isClassBinding) {\n    tNode.classBindings = tBindings;\n  } else {\n    tNode.styleBindings = tBindings;\n  }\n}\nfunction markDuplicateOfResidualStyling(tNode, tStylingKey, tData, index, isClassBinding) {\n  const residual = isClassBinding ? tNode.residualClasses : tNode.residualStyles;\n  if (residual != null && typeof tStylingKey == \"string\" && keyValueArrayIndexOf(residual, tStylingKey) >= 0) {\n    tData[index + 1] = setTStylingRangeNextDuplicate(tData[index + 1]);\n  }\n}\nfunction markDuplicates(tData, tStylingKey, index, isPrevDir) {\n  const tStylingAtIndex = tData[index + 1];\n  const isMap = tStylingKey === null;\n  let cursor = isPrevDir ? getTStylingRangePrev(tStylingAtIndex) : getTStylingRangeNext(tStylingAtIndex);\n  let foundDuplicate = false;\n  while (cursor !== 0 && (foundDuplicate === false || isMap)) {\n    ngDevMode && assertIndexInRange(tData, cursor);\n    const tStylingValueAtCursor = tData[cursor];\n    const tStyleRangeAtCursor = tData[cursor + 1];\n    if (isStylingMatch(tStylingValueAtCursor, tStylingKey)) {\n      foundDuplicate = true;\n      tData[cursor + 1] = isPrevDir ? setTStylingRangeNextDuplicate(tStyleRangeAtCursor) : setTStylingRangePrevDuplicate(tStyleRangeAtCursor);\n    }\n    cursor = isPrevDir ? getTStylingRangePrev(tStyleRangeAtCursor) : getTStylingRangeNext(tStyleRangeAtCursor);\n  }\n  if (foundDuplicate) {\n    tData[index + 1] = isPrevDir ? setTStylingRangePrevDuplicate(tStylingAtIndex) : setTStylingRangeNextDuplicate(tStylingAtIndex);\n  }\n}\nfunction isStylingMatch(tStylingKeyCursor, tStylingKey) {\n  ngDevMode && assertNotEqual(Array.isArray(tStylingKey), true, \"Expected that 'tStylingKey' has been unwrapped\");\n  if (tStylingKeyCursor === null || // If the cursor is `null` it means that we have map at that\n  // location so we must assume that we have a match.\n  tStylingKey == null || // If `tStylingKey` is `null` then it is a map therefor assume that it\n  // contains a match.\n  (Array.isArray(tStylingKeyCursor) ? tStylingKeyCursor[1] : tStylingKeyCursor) === tStylingKey) {\n    return true;\n  } else if (Array.isArray(tStylingKeyCursor) && typeof tStylingKey === \"string\") {\n    return keyValueArrayIndexOf(tStylingKeyCursor, tStylingKey) >= 0;\n  }\n  return false;\n}\nvar parserState = {\n  textEnd: 0,\n  key: 0,\n  keyEnd: 0,\n  value: 0,\n  valueEnd: 0\n};\nfunction getLastParsedKey(text) {\n  return text.substring(parserState.key, parserState.keyEnd);\n}\nfunction getLastParsedValue(text) {\n  return text.substring(parserState.value, parserState.valueEnd);\n}\nfunction parseClassName(text) {\n  resetParserState(text);\n  return parseClassNameNext(text, consumeWhitespace(text, 0, parserState.textEnd));\n}\nfunction parseClassNameNext(text, index) {\n  const end = parserState.textEnd;\n  if (end === index) {\n    return -1;\n  }\n  index = parserState.keyEnd = consumeClassToken(text, parserState.key = index, end);\n  return consumeWhitespace(text, index, end);\n}\nfunction parseStyle(text) {\n  resetParserState(text);\n  return parseStyleNext(text, consumeWhitespace(text, 0, parserState.textEnd));\n}\nfunction parseStyleNext(text, startIndex) {\n  const end = parserState.textEnd;\n  let index = parserState.key = consumeWhitespace(text, startIndex, end);\n  if (end === index) {\n    return -1;\n  }\n  index = parserState.keyEnd = consumeStyleKey(text, index, end);\n  index = consumeSeparator(\n    text,\n    index,\n    end,\n    58\n    /* CharCode.COLON */\n  );\n  index = parserState.value = consumeWhitespace(text, index, end);\n  index = parserState.valueEnd = consumeStyleValue(text, index, end);\n  return consumeSeparator(\n    text,\n    index,\n    end,\n    59\n    /* CharCode.SEMI_COLON */\n  );\n}\nfunction resetParserState(text) {\n  parserState.key = 0;\n  parserState.keyEnd = 0;\n  parserState.value = 0;\n  parserState.valueEnd = 0;\n  parserState.textEnd = text.length;\n}\nfunction consumeWhitespace(text, startIndex, endIndex) {\n  while (startIndex < endIndex && text.charCodeAt(startIndex) <= 32) {\n    startIndex++;\n  }\n  return startIndex;\n}\nfunction consumeClassToken(text, startIndex, endIndex) {\n  while (startIndex < endIndex && text.charCodeAt(startIndex) > 32) {\n    startIndex++;\n  }\n  return startIndex;\n}\nfunction consumeStyleKey(text, startIndex, endIndex) {\n  let ch;\n  while (startIndex < endIndex && ((ch = text.charCodeAt(startIndex)) === 45 || ch === 95 || (ch & -33) >= 65 && (ch & -33) <= 90 || ch >= 48 && ch <= 57)) {\n    startIndex++;\n  }\n  return startIndex;\n}\nfunction consumeSeparator(text, startIndex, endIndex, separator) {\n  startIndex = consumeWhitespace(text, startIndex, endIndex);\n  if (startIndex < endIndex) {\n    if (ngDevMode && text.charCodeAt(startIndex) !== separator) {\n      malformedStyleError(text, String.fromCharCode(separator), startIndex);\n    }\n    startIndex++;\n  }\n  return startIndex;\n}\nfunction consumeStyleValue(text, startIndex, endIndex) {\n  let ch1 = -1;\n  let ch2 = -1;\n  let ch3 = -1;\n  let i = startIndex;\n  let lastChIndex = i;\n  while (i < endIndex) {\n    const ch = text.charCodeAt(i++);\n    if (ch === 59) {\n      return lastChIndex;\n    } else if (ch === 34 || ch === 39) {\n      lastChIndex = i = consumeQuotedText(text, ch, i, endIndex);\n    } else if (startIndex === i - 4 && // We have seen only 4 characters so far \"URL(\" (Ignore \"foo_URL()\")\n    ch3 === 85 && ch2 === 82 && ch1 === 76 && ch === 40) {\n      lastChIndex = i = consumeQuotedText(text, 41, i, endIndex);\n    } else if (ch > 32) {\n      lastChIndex = i;\n    }\n    ch3 = ch2;\n    ch2 = ch1;\n    ch1 = ch & -33;\n  }\n  return lastChIndex;\n}\nfunction consumeQuotedText(text, quoteCharCode, startIndex, endIndex) {\n  let ch1 = -1;\n  let index = startIndex;\n  while (index < endIndex) {\n    const ch = text.charCodeAt(index++);\n    if (ch == quoteCharCode && ch1 !== 92) {\n      return index;\n    }\n    if (ch == 92 && ch1 === 92) {\n      ch1 = 0;\n    } else {\n      ch1 = ch;\n    }\n  }\n  throw ngDevMode ? malformedStyleError(text, String.fromCharCode(quoteCharCode), endIndex) : new Error();\n}\nfunction malformedStyleError(text, expecting, index) {\n  ngDevMode && assertEqual(typeof text === \"string\", true, \"String expected here\");\n  throw throwError2(`Malformed style at location ${index} in string '` + text.substring(0, index) + \"[>>\" + text.substring(index, index + 1) + \"<<]\" + text.slice(index + 1) + `'. Expecting '${expecting}'.`);\n}\nfunction \\u0275\\u0275property(propName, value, sanitizer) {\n  const lView = getLView();\n  const bindingIndex = nextBindingIndex();\n  if (bindingUpdated(lView, bindingIndex, value)) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);\n  }\n  return \\u0275\\u0275property;\n}\nfunction setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased) {\n  setAllInputsForProperty(tNode, tView, lView, isClassBased ? \"class\" : \"style\", value);\n}\nfunction \\u0275\\u0275styleProp(prop, value, suffix) {\n  checkStylingProperty(prop, value, suffix, false);\n  return \\u0275\\u0275styleProp;\n}\nfunction \\u0275\\u0275classProp(className, value) {\n  checkStylingProperty(className, value, null, true);\n  return \\u0275\\u0275classProp;\n}\nfunction \\u0275\\u0275styleMap(styles) {\n  checkStylingMap(styleKeyValueArraySet, styleStringParser, styles, false);\n}\nfunction styleStringParser(keyValueArray, text) {\n  for (let i = parseStyle(text); i >= 0; i = parseStyleNext(text, i)) {\n    styleKeyValueArraySet(keyValueArray, getLastParsedKey(text), getLastParsedValue(text));\n  }\n}\nfunction \\u0275\\u0275classMap(classes) {\n  checkStylingMap(classKeyValueArraySet, classStringParser, classes, true);\n}\nfunction classStringParser(keyValueArray, text) {\n  for (let i = parseClassName(text); i >= 0; i = parseClassNameNext(text, i)) {\n    keyValueArraySet(keyValueArray, getLastParsedKey(text), true);\n  }\n}\nfunction checkStylingProperty(prop, value, suffix, isClassBased) {\n  const lView = getLView();\n  const tView = getTView();\n  const bindingIndex = incrementBindingIndex(2);\n  if (tView.firstUpdatePass) {\n    stylingFirstUpdatePass(tView, prop, bindingIndex, isClassBased);\n  }\n  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {\n    const tNode = tView.data[getSelectedIndex()];\n    updateStyling(tView, tNode, lView, lView[RENDERER], prop, lView[bindingIndex + 1] = normalizeSuffix(value, suffix), isClassBased, bindingIndex);\n  }\n}\nfunction checkStylingMap(keyValueArraySet2, stringParser, value, isClassBased) {\n  const tView = getTView();\n  const bindingIndex = incrementBindingIndex(2);\n  if (tView.firstUpdatePass) {\n    stylingFirstUpdatePass(tView, null, bindingIndex, isClassBased);\n  }\n  const lView = getLView();\n  if (value !== NO_CHANGE && bindingUpdated(lView, bindingIndex, value)) {\n    const tNode = tView.data[getSelectedIndex()];\n    if (hasStylingInputShadow(tNode, isClassBased) && !isInHostBindings(tView, bindingIndex)) {\n      if (ngDevMode) {\n        const tStylingKey = tView.data[bindingIndex];\n        assertEqual(Array.isArray(tStylingKey) ? tStylingKey[1] : tStylingKey, false, \"Styling linked list shadow input should be marked as 'false'\");\n      }\n      let staticPrefix = isClassBased ? tNode.classesWithoutHost : tNode.stylesWithoutHost;\n      ngDevMode && isClassBased === false && staticPrefix !== null && assertEqual(staticPrefix.endsWith(\";\"), true, \"Expecting static portion to end with ';'\");\n      if (staticPrefix !== null) {\n        value = concatStringsWithSpace(staticPrefix, value ? value : \"\");\n      }\n      setDirectiveInputsWhichShadowsStyling(tView, tNode, lView, value, isClassBased);\n    } else {\n      updateStylingMap(tView, tNode, lView, lView[RENDERER], lView[bindingIndex + 1], lView[bindingIndex + 1] = toStylingKeyValueArray(keyValueArraySet2, stringParser, value), isClassBased, bindingIndex);\n    }\n  }\n}\nfunction isInHostBindings(tView, bindingIndex) {\n  return bindingIndex >= tView.expandoStartIndex;\n}\nfunction stylingFirstUpdatePass(tView, tStylingKey, bindingIndex, isClassBased) {\n  ngDevMode && assertFirstUpdatePass(tView);\n  const tData = tView.data;\n  if (tData[bindingIndex + 1] === null) {\n    const tNode = tData[getSelectedIndex()];\n    ngDevMode && assertDefined(tNode, \"TNode expected\");\n    const isHostBindings = isInHostBindings(tView, bindingIndex);\n    if (hasStylingInputShadow(tNode, isClassBased) && tStylingKey === null && !isHostBindings) {\n      tStylingKey = false;\n    }\n    tStylingKey = wrapInStaticStylingKey(tData, tNode, tStylingKey, isClassBased);\n    insertTStylingBinding(tData, tNode, tStylingKey, bindingIndex, isHostBindings, isClassBased);\n  }\n}\nfunction wrapInStaticStylingKey(tData, tNode, stylingKey, isClassBased) {\n  const hostDirectiveDef = getCurrentDirectiveDef(tData);\n  let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;\n  if (hostDirectiveDef === null) {\n    const isFirstStylingInstructionInTemplate = (isClassBased ? tNode.classBindings : tNode.styleBindings) === 0;\n    if (isFirstStylingInstructionInTemplate) {\n      stylingKey = collectStylingFromDirectives(null, tData, tNode, stylingKey, isClassBased);\n      stylingKey = collectStylingFromTAttrs(stylingKey, tNode.attrs, isClassBased);\n      residual = null;\n    }\n  } else {\n    const directiveStylingLast = tNode.directiveStylingLast;\n    const isFirstStylingInstructionInHostBinding = directiveStylingLast === -1 || tData[directiveStylingLast] !== hostDirectiveDef;\n    if (isFirstStylingInstructionInHostBinding) {\n      stylingKey = collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased);\n      if (residual === null) {\n        let templateStylingKey = getTemplateHeadTStylingKey(tData, tNode, isClassBased);\n        if (templateStylingKey !== void 0 && Array.isArray(templateStylingKey)) {\n          templateStylingKey = collectStylingFromDirectives(null, tData, tNode, templateStylingKey[1], isClassBased);\n          templateStylingKey = collectStylingFromTAttrs(templateStylingKey, tNode.attrs, isClassBased);\n          setTemplateHeadTStylingKey(tData, tNode, isClassBased, templateStylingKey);\n        }\n      } else {\n        residual = collectResidual(tData, tNode, isClassBased);\n      }\n    }\n  }\n  if (residual !== void 0) {\n    isClassBased ? tNode.residualClasses = residual : tNode.residualStyles = residual;\n  }\n  return stylingKey;\n}\nfunction getTemplateHeadTStylingKey(tData, tNode, isClassBased) {\n  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;\n  if (getTStylingRangeNext(bindings) === 0) {\n    return void 0;\n  }\n  return tData[getTStylingRangePrev(bindings)];\n}\nfunction setTemplateHeadTStylingKey(tData, tNode, isClassBased, tStylingKey) {\n  const bindings = isClassBased ? tNode.classBindings : tNode.styleBindings;\n  ngDevMode && assertNotEqual(getTStylingRangeNext(bindings), 0, \"Expecting to have at least one template styling binding.\");\n  tData[getTStylingRangePrev(bindings)] = tStylingKey;\n}\nfunction collectResidual(tData, tNode, isClassBased) {\n  let residual = void 0;\n  const directiveEnd = tNode.directiveEnd;\n  ngDevMode && assertNotEqual(tNode.directiveStylingLast, -1, \"By the time this function gets called at least one hostBindings-node styling instruction must have executed.\");\n  for (let i = 1 + tNode.directiveStylingLast; i < directiveEnd; i++) {\n    const attrs = tData[i].hostAttrs;\n    residual = collectStylingFromTAttrs(residual, attrs, isClassBased);\n  }\n  return collectStylingFromTAttrs(residual, tNode.attrs, isClassBased);\n}\nfunction collectStylingFromDirectives(hostDirectiveDef, tData, tNode, stylingKey, isClassBased) {\n  let currentDirective = null;\n  const directiveEnd = tNode.directiveEnd;\n  let directiveStylingLast = tNode.directiveStylingLast;\n  if (directiveStylingLast === -1) {\n    directiveStylingLast = tNode.directiveStart;\n  } else {\n    directiveStylingLast++;\n  }\n  while (directiveStylingLast < directiveEnd) {\n    currentDirective = tData[directiveStylingLast];\n    ngDevMode && assertDefined(currentDirective, \"expected to be defined\");\n    stylingKey = collectStylingFromTAttrs(stylingKey, currentDirective.hostAttrs, isClassBased);\n    if (currentDirective === hostDirectiveDef) break;\n    directiveStylingLast++;\n  }\n  if (hostDirectiveDef !== null) {\n    tNode.directiveStylingLast = directiveStylingLast;\n  }\n  return stylingKey;\n}\nfunction collectStylingFromTAttrs(stylingKey, attrs, isClassBased) {\n  const desiredMarker = isClassBased ? 1 : 2;\n  let currentMarker = -1;\n  if (attrs !== null) {\n    for (let i = 0; i < attrs.length; i++) {\n      const item = attrs[i];\n      if (typeof item === \"number\") {\n        currentMarker = item;\n      } else {\n        if (currentMarker === desiredMarker) {\n          if (!Array.isArray(stylingKey)) {\n            stylingKey = stylingKey === void 0 ? [] : [\"\", stylingKey];\n          }\n          keyValueArraySet(stylingKey, item, isClassBased ? true : attrs[++i]);\n        }\n      }\n    }\n  }\n  return stylingKey === void 0 ? null : stylingKey;\n}\nfunction toStylingKeyValueArray(keyValueArraySet2, stringParser, value) {\n  if (value == null || value === \"\") return EMPTY_ARRAY;\n  const styleKeyValueArray = [];\n  const unwrappedValue = unwrapSafeValue(value);\n  if (Array.isArray(unwrappedValue)) {\n    for (let i = 0; i < unwrappedValue.length; i++) {\n      keyValueArraySet2(styleKeyValueArray, unwrappedValue[i], true);\n    }\n  } else if (typeof unwrappedValue === \"object\") {\n    for (const key in unwrappedValue) {\n      if (unwrappedValue.hasOwnProperty(key)) {\n        keyValueArraySet2(styleKeyValueArray, key, unwrappedValue[key]);\n      }\n    }\n  } else if (typeof unwrappedValue === \"string\") {\n    stringParser(styleKeyValueArray, unwrappedValue);\n  } else {\n    ngDevMode && throwError2(\"Unsupported styling type \" + typeof unwrappedValue + \": \" + unwrappedValue);\n  }\n  return styleKeyValueArray;\n}\nfunction styleKeyValueArraySet(keyValueArray, key, value) {\n  keyValueArraySet(keyValueArray, key, unwrapSafeValue(value));\n}\nfunction classKeyValueArraySet(keyValueArray, key, value) {\n  const stringKey = String(key);\n  if (stringKey !== \"\" && !stringKey.includes(\" \")) {\n    keyValueArraySet(keyValueArray, stringKey, value);\n  }\n}\nfunction updateStylingMap(tView, tNode, lView, renderer, oldKeyValueArray, newKeyValueArray, isClassBased, bindingIndex) {\n  if (oldKeyValueArray === NO_CHANGE) {\n    oldKeyValueArray = EMPTY_ARRAY;\n  }\n  let oldIndex = 0;\n  let newIndex = 0;\n  let oldKey = 0 < oldKeyValueArray.length ? oldKeyValueArray[0] : null;\n  let newKey = 0 < newKeyValueArray.length ? newKeyValueArray[0] : null;\n  while (oldKey !== null || newKey !== null) {\n    ngDevMode && assertLessThan(oldIndex, 999, \"Are we stuck in infinite loop?\");\n    ngDevMode && assertLessThan(newIndex, 999, \"Are we stuck in infinite loop?\");\n    const oldValue = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex + 1] : void 0;\n    const newValue = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex + 1] : void 0;\n    let setKey = null;\n    let setValue = void 0;\n    if (oldKey === newKey) {\n      oldIndex += 2;\n      newIndex += 2;\n      if (oldValue !== newValue) {\n        setKey = newKey;\n        setValue = newValue;\n      }\n    } else if (newKey === null || oldKey !== null && oldKey < newKey) {\n      oldIndex += 2;\n      setKey = oldKey;\n    } else {\n      ngDevMode && assertDefined(newKey, \"Expecting to have a valid key\");\n      newIndex += 2;\n      setKey = newKey;\n      setValue = newValue;\n    }\n    if (setKey !== null) {\n      updateStyling(tView, tNode, lView, renderer, setKey, setValue, isClassBased, bindingIndex);\n    }\n    oldKey = oldIndex < oldKeyValueArray.length ? oldKeyValueArray[oldIndex] : null;\n    newKey = newIndex < newKeyValueArray.length ? newKeyValueArray[newIndex] : null;\n  }\n}\nfunction updateStyling(tView, tNode, lView, renderer, prop, value, isClassBased, bindingIndex) {\n  if (!(tNode.type & 3)) {\n    return;\n  }\n  const tData = tView.data;\n  const tRange = tData[bindingIndex + 1];\n  const higherPriorityValue = getTStylingRangeNextDuplicate(tRange) ? findStylingValue(tData, tNode, lView, prop, getTStylingRangeNext(tRange), isClassBased) : void 0;\n  if (!isStylingValuePresent(higherPriorityValue)) {\n    if (!isStylingValuePresent(value)) {\n      if (getTStylingRangePrevDuplicate(tRange)) {\n        value = findStylingValue(tData, null, lView, prop, bindingIndex, isClassBased);\n      }\n    }\n    const rNode = getNativeByIndex(getSelectedIndex(), lView);\n    applyStyling(renderer, isClassBased, rNode, prop, value);\n  }\n}\nfunction findStylingValue(tData, tNode, lView, prop, index, isClassBased) {\n  const isPrevDirection = tNode === null;\n  let value = void 0;\n  while (index > 0) {\n    const rawKey = tData[index];\n    const containsStatics = Array.isArray(rawKey);\n    const key = containsStatics ? rawKey[1] : rawKey;\n    const isStylingMap = key === null;\n    let valueAtLViewIndex = lView[index + 1];\n    if (valueAtLViewIndex === NO_CHANGE) {\n      valueAtLViewIndex = isStylingMap ? EMPTY_ARRAY : void 0;\n    }\n    let currentValue = isStylingMap ? keyValueArrayGet(valueAtLViewIndex, prop) : key === prop ? valueAtLViewIndex : void 0;\n    if (containsStatics && !isStylingValuePresent(currentValue)) {\n      currentValue = keyValueArrayGet(rawKey, prop);\n    }\n    if (isStylingValuePresent(currentValue)) {\n      value = currentValue;\n      if (isPrevDirection) {\n        return value;\n      }\n    }\n    const tRange = tData[index + 1];\n    index = isPrevDirection ? getTStylingRangePrev(tRange) : getTStylingRangeNext(tRange);\n  }\n  if (tNode !== null) {\n    let residual = isClassBased ? tNode.residualClasses : tNode.residualStyles;\n    if (residual != null) {\n      value = keyValueArrayGet(residual, prop);\n    }\n  }\n  return value;\n}\nfunction isStylingValuePresent(value) {\n  return value !== void 0;\n}\nfunction normalizeSuffix(value, suffix) {\n  if (value == null || value === \"\") ;\n  else if (typeof suffix === \"string\") {\n    value = value + suffix;\n  } else if (typeof value === \"object\") {\n    value = stringify(unwrapSafeValue(value));\n  }\n  return value;\n}\nfunction hasStylingInputShadow(tNode, isClassBased) {\n  return (tNode.flags & (isClassBased ? 8 : 16)) !== 0;\n}\nfunction \\u0275\\u0275classMapInterpolate1(prefix, v0, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\nfunction \\u0275\\u0275classMapInterpolate2(prefix, v0, i0, v1, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\nfunction \\u0275\\u0275classMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\nfunction \\u0275\\u0275classMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\nfunction \\u0275\\u0275classMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\nfunction \\u0275\\u0275classMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\nfunction \\u0275\\u0275classMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\nfunction \\u0275\\u0275classMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\nfunction \\u0275\\u0275classMapInterpolateV(values) {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  checkStylingMap(keyValueArraySet, classStringParser, interpolatedValue, true);\n}\nfunction \\u0275\\u0275componentInstance() {\n  const instance = getLView()[DECLARATION_COMPONENT_VIEW][CONTEXT];\n  ngDevMode && assertDefined(instance, \"Expected component instance to be defined\");\n  return instance;\n}\nvar LiveCollection = class {\n  destroy(item) {\n  }\n  updateValue(index, value) {\n  }\n  // operations below could be implemented on top of the operations defined so far, but having\n  // them explicitly allow clear expression of intent and potentially more performant\n  // implementations\n  swap(index1, index2) {\n    const startIdx = Math.min(index1, index2);\n    const endIdx = Math.max(index1, index2);\n    const endItem = this.detach(endIdx);\n    if (endIdx - startIdx > 1) {\n      const startItem = this.detach(startIdx);\n      this.attach(startIdx, endItem);\n      this.attach(endIdx, startItem);\n    } else {\n      this.attach(startIdx, endItem);\n    }\n  }\n  move(prevIndex, newIdx) {\n    this.attach(newIdx, this.detach(prevIndex));\n  }\n};\nfunction valuesMatching(liveIdx, liveValue, newIdx, newValue, trackBy) {\n  if (liveIdx === newIdx && Object.is(liveValue, newValue)) {\n    return 1;\n  } else if (Object.is(trackBy(liveIdx, liveValue), trackBy(newIdx, newValue))) {\n    return -1;\n  }\n  return 0;\n}\nfunction recordDuplicateKeys(keyToIdx, key, idx) {\n  const idxSoFar = keyToIdx.get(key);\n  if (idxSoFar !== void 0) {\n    idxSoFar.add(idx);\n  } else {\n    keyToIdx.set(key, /* @__PURE__ */ new Set([idx]));\n  }\n}\nfunction reconcile(liveCollection, newCollection, trackByFn) {\n  let detachedItems = void 0;\n  let liveKeysInTheFuture = void 0;\n  let liveStartIdx = 0;\n  let liveEndIdx = liveCollection.length - 1;\n  const duplicateKeys = ngDevMode ? /* @__PURE__ */ new Map() : void 0;\n  if (Array.isArray(newCollection)) {\n    let newEndIdx = newCollection.length - 1;\n    while (liveStartIdx <= liveEndIdx && liveStartIdx <= newEndIdx) {\n      const liveStartValue = liveCollection.at(liveStartIdx);\n      const newStartValue = newCollection[liveStartIdx];\n      if (ngDevMode) {\n        recordDuplicateKeys(duplicateKeys, trackByFn(liveStartIdx, newStartValue), liveStartIdx);\n      }\n      const isStartMatching = valuesMatching(liveStartIdx, liveStartValue, liveStartIdx, newStartValue, trackByFn);\n      if (isStartMatching !== 0) {\n        if (isStartMatching < 0) {\n          liveCollection.updateValue(liveStartIdx, newStartValue);\n        }\n        liveStartIdx++;\n        continue;\n      }\n      const liveEndValue = liveCollection.at(liveEndIdx);\n      const newEndValue = newCollection[newEndIdx];\n      if (ngDevMode) {\n        recordDuplicateKeys(duplicateKeys, trackByFn(newEndIdx, newEndValue), newEndIdx);\n      }\n      const isEndMatching = valuesMatching(liveEndIdx, liveEndValue, newEndIdx, newEndValue, trackByFn);\n      if (isEndMatching !== 0) {\n        if (isEndMatching < 0) {\n          liveCollection.updateValue(liveEndIdx, newEndValue);\n        }\n        liveEndIdx--;\n        newEndIdx--;\n        continue;\n      }\n      const liveStartKey = trackByFn(liveStartIdx, liveStartValue);\n      const liveEndKey = trackByFn(liveEndIdx, liveEndValue);\n      const newStartKey = trackByFn(liveStartIdx, newStartValue);\n      if (Object.is(newStartKey, liveEndKey)) {\n        const newEndKey = trackByFn(newEndIdx, newEndValue);\n        if (Object.is(newEndKey, liveStartKey)) {\n          liveCollection.swap(liveStartIdx, liveEndIdx);\n          liveCollection.updateValue(liveEndIdx, newEndValue);\n          newEndIdx--;\n          liveEndIdx--;\n        } else {\n          liveCollection.move(liveEndIdx, liveStartIdx);\n        }\n        liveCollection.updateValue(liveStartIdx, newStartValue);\n        liveStartIdx++;\n        continue;\n      }\n      detachedItems ??= new UniqueValueMultiKeyMap();\n      liveKeysInTheFuture ??= initLiveItemsInTheFuture(liveCollection, liveStartIdx, liveEndIdx, trackByFn);\n      if (attachPreviouslyDetached(liveCollection, detachedItems, liveStartIdx, newStartKey)) {\n        liveCollection.updateValue(liveStartIdx, newStartValue);\n        liveStartIdx++;\n        liveEndIdx++;\n      } else if (!liveKeysInTheFuture.has(newStartKey)) {\n        const newItem = liveCollection.create(liveStartIdx, newCollection[liveStartIdx]);\n        liveCollection.attach(liveStartIdx, newItem);\n        liveStartIdx++;\n        liveEndIdx++;\n      } else {\n        detachedItems.set(liveStartKey, liveCollection.detach(liveStartIdx));\n        liveEndIdx--;\n      }\n    }\n    while (liveStartIdx <= newEndIdx) {\n      createOrAttach(liveCollection, detachedItems, trackByFn, liveStartIdx, newCollection[liveStartIdx]);\n      liveStartIdx++;\n    }\n  } else if (newCollection != null) {\n    const newCollectionIterator = newCollection[Symbol.iterator]();\n    let newIterationResult = newCollectionIterator.next();\n    while (!newIterationResult.done && liveStartIdx <= liveEndIdx) {\n      const liveValue = liveCollection.at(liveStartIdx);\n      const newValue = newIterationResult.value;\n      if (ngDevMode) {\n        recordDuplicateKeys(duplicateKeys, trackByFn(liveStartIdx, newValue), liveStartIdx);\n      }\n      const isStartMatching = valuesMatching(liveStartIdx, liveValue, liveStartIdx, newValue, trackByFn);\n      if (isStartMatching !== 0) {\n        if (isStartMatching < 0) {\n          liveCollection.updateValue(liveStartIdx, newValue);\n        }\n        liveStartIdx++;\n        newIterationResult = newCollectionIterator.next();\n      } else {\n        detachedItems ??= new UniqueValueMultiKeyMap();\n        liveKeysInTheFuture ??= initLiveItemsInTheFuture(liveCollection, liveStartIdx, liveEndIdx, trackByFn);\n        const newKey = trackByFn(liveStartIdx, newValue);\n        if (attachPreviouslyDetached(liveCollection, detachedItems, liveStartIdx, newKey)) {\n          liveCollection.updateValue(liveStartIdx, newValue);\n          liveStartIdx++;\n          liveEndIdx++;\n          newIterationResult = newCollectionIterator.next();\n        } else if (!liveKeysInTheFuture.has(newKey)) {\n          liveCollection.attach(liveStartIdx, liveCollection.create(liveStartIdx, newValue));\n          liveStartIdx++;\n          liveEndIdx++;\n          newIterationResult = newCollectionIterator.next();\n        } else {\n          const liveKey = trackByFn(liveStartIdx, liveValue);\n          detachedItems.set(liveKey, liveCollection.detach(liveStartIdx));\n          liveEndIdx--;\n        }\n      }\n    }\n    while (!newIterationResult.done) {\n      createOrAttach(liveCollection, detachedItems, trackByFn, liveCollection.length, newIterationResult.value);\n      newIterationResult = newCollectionIterator.next();\n    }\n  }\n  while (liveStartIdx <= liveEndIdx) {\n    liveCollection.destroy(liveCollection.detach(liveEndIdx--));\n  }\n  detachedItems?.forEach((item) => {\n    liveCollection.destroy(item);\n  });\n  if (ngDevMode) {\n    let duplicatedKeysMsg = [];\n    for (const [key, idxSet] of duplicateKeys) {\n      if (idxSet.size > 1) {\n        const idx = [...idxSet].sort((a, b) => a - b);\n        for (let i = 1; i < idx.length; i++) {\n          duplicatedKeysMsg.push(`key \"${stringifyForError(key)}\" at index \"${idx[i - 1]}\" and \"${idx[i]}\"`);\n        }\n      }\n    }\n    if (duplicatedKeysMsg.length > 0) {\n      const message = formatRuntimeError(-955, \"The provided track expression resulted in duplicated keys for a given collection. Adjust the tracking expression such that it uniquely identifies all the items in the collection. Duplicated keys were: \\n\" + duplicatedKeysMsg.join(\", \\n\") + \".\");\n      console.warn(message);\n    }\n  }\n}\nfunction attachPreviouslyDetached(prevCollection, detachedItems, index, key) {\n  if (detachedItems !== void 0 && detachedItems.has(key)) {\n    prevCollection.attach(index, detachedItems.get(key));\n    detachedItems.delete(key);\n    return true;\n  }\n  return false;\n}\nfunction createOrAttach(liveCollection, detachedItems, trackByFn, index, value) {\n  if (!attachPreviouslyDetached(liveCollection, detachedItems, index, trackByFn(index, value))) {\n    const newItem = liveCollection.create(index, value);\n    liveCollection.attach(index, newItem);\n  } else {\n    liveCollection.updateValue(index, value);\n  }\n}\nfunction initLiveItemsInTheFuture(liveCollection, start, end, trackByFn) {\n  const keys = /* @__PURE__ */ new Set();\n  for (let i = start; i <= end; i++) {\n    keys.add(trackByFn(i, liveCollection.at(i)));\n  }\n  return keys;\n}\nvar UniqueValueMultiKeyMap = class {\n  // A map from a key to the first value corresponding to this key.\n  kvMap = /* @__PURE__ */ new Map();\n  // A map that acts as a linked list of values - each value maps to the next value in this \"linked\n  // list\" (this only works if values are unique). Allocated lazily to avoid memory consumption when\n  // there are no duplicated values.\n  _vMap = void 0;\n  has(key) {\n    return this.kvMap.has(key);\n  }\n  delete(key) {\n    if (!this.has(key)) return false;\n    const value = this.kvMap.get(key);\n    if (this._vMap !== void 0 && this._vMap.has(value)) {\n      this.kvMap.set(key, this._vMap.get(value));\n      this._vMap.delete(value);\n    } else {\n      this.kvMap.delete(key);\n    }\n    return true;\n  }\n  get(key) {\n    return this.kvMap.get(key);\n  }\n  set(key, value) {\n    if (this.kvMap.has(key)) {\n      let prevValue = this.kvMap.get(key);\n      if (ngDevMode && prevValue === value) {\n        throw new Error(`Detected a duplicated value ${value} for the key ${key}`);\n      }\n      if (this._vMap === void 0) {\n        this._vMap = /* @__PURE__ */ new Map();\n      }\n      const vMap = this._vMap;\n      while (vMap.has(prevValue)) {\n        prevValue = vMap.get(prevValue);\n      }\n      vMap.set(prevValue, value);\n    } else {\n      this.kvMap.set(key, value);\n    }\n  }\n  forEach(cb) {\n    for (let [key, value] of this.kvMap) {\n      cb(value, key);\n      if (this._vMap !== void 0) {\n        const vMap = this._vMap;\n        while (vMap.has(value)) {\n          value = vMap.get(value);\n          cb(value, key);\n        }\n      }\n    }\n  }\n};\nfunction \\u0275\\u0275conditional(matchingTemplateIndex, contextValue) {\n  performanceMarkFeature(\"NgControlFlow\");\n  const hostLView = getLView();\n  const bindingIndex = nextBindingIndex();\n  const prevMatchingTemplateIndex = hostLView[bindingIndex] !== NO_CHANGE ? hostLView[bindingIndex] : -1;\n  const prevContainer = prevMatchingTemplateIndex !== -1 ? getLContainer(hostLView, HEADER_OFFSET + prevMatchingTemplateIndex) : void 0;\n  const viewInContainerIdx = 0;\n  if (bindingUpdated(hostLView, bindingIndex, matchingTemplateIndex)) {\n    const prevConsumer = setActiveConsumer(null);\n    try {\n      if (prevContainer !== void 0) {\n        removeLViewFromLContainer(prevContainer, viewInContainerIdx);\n      }\n      if (matchingTemplateIndex !== -1) {\n        const nextLContainerIndex = HEADER_OFFSET + matchingTemplateIndex;\n        const nextContainer = getLContainer(hostLView, nextLContainerIndex);\n        const templateTNode = getExistingTNode(hostLView[TVIEW], nextLContainerIndex);\n        const dehydratedView = findMatchingDehydratedView(nextContainer, templateTNode.tView.ssrId);\n        const embeddedLView = createAndRenderEmbeddedLView(hostLView, templateTNode, contextValue, {\n          dehydratedView\n        });\n        addLViewToLContainer(nextContainer, embeddedLView, viewInContainerIdx, shouldAddViewToDom(templateTNode, dehydratedView));\n      }\n    } finally {\n      setActiveConsumer(prevConsumer);\n    }\n  } else if (prevContainer !== void 0) {\n    const lView = getLViewFromLContainer(prevContainer, viewInContainerIdx);\n    if (lView !== void 0) {\n      lView[CONTEXT] = contextValue;\n    }\n  }\n}\nvar RepeaterContext = class {\n  lContainer;\n  $implicit;\n  $index;\n  constructor(lContainer, $implicit, $index) {\n    this.lContainer = lContainer;\n    this.$implicit = $implicit;\n    this.$index = $index;\n  }\n  get $count() {\n    return this.lContainer.length - CONTAINER_HEADER_OFFSET;\n  }\n};\nfunction \\u0275\\u0275repeaterTrackByIndex(index) {\n  return index;\n}\nfunction \\u0275\\u0275repeaterTrackByIdentity(_, value) {\n  return value;\n}\nvar RepeaterMetadata = class {\n  hasEmptyBlock;\n  trackByFn;\n  liveCollection;\n  constructor(hasEmptyBlock, trackByFn, liveCollection) {\n    this.hasEmptyBlock = hasEmptyBlock;\n    this.trackByFn = trackByFn;\n    this.liveCollection = liveCollection;\n  }\n};\nfunction \\u0275\\u0275repeaterCreate(index, templateFn, decls, vars, tagName, attrsIndex, trackByFn, trackByUsesComponentInstance, emptyTemplateFn, emptyDecls, emptyVars, emptyTagName, emptyAttrsIndex) {\n  performanceMarkFeature(\"NgControlFlow\");\n  ngDevMode && assertFunction(trackByFn, `A track expression must be a function, was ${typeof trackByFn} instead.`);\n  const lView = getLView();\n  const tView = getTView();\n  const hasEmptyBlock = emptyTemplateFn !== void 0;\n  const hostLView = getLView();\n  const boundTrackBy = trackByUsesComponentInstance ? (\n    // We only want to bind when necessary, because it produces a\n    // new function. For pure functions it's not necessary.\n    trackByFn.bind(hostLView[DECLARATION_COMPONENT_VIEW][CONTEXT])\n  ) : trackByFn;\n  const metadata = new RepeaterMetadata(hasEmptyBlock, boundTrackBy);\n  hostLView[HEADER_OFFSET + index] = metadata;\n  declareTemplate(lView, tView, index + 1, templateFn, decls, vars, tagName, getConstant(tView.consts, attrsIndex));\n  if (hasEmptyBlock) {\n    ngDevMode && assertDefined(emptyDecls, \"Missing number of declarations for the empty repeater block.\");\n    ngDevMode && assertDefined(emptyVars, \"Missing number of bindings for the empty repeater block.\");\n    declareTemplate(lView, tView, index + 2, emptyTemplateFn, emptyDecls, emptyVars, emptyTagName, getConstant(tView.consts, emptyAttrsIndex));\n  }\n}\nfunction isViewExpensiveToRecreate(lView) {\n  return lView.length - HEADER_OFFSET > 2;\n}\nvar OperationsCounter = class {\n  created = 0;\n  destroyed = 0;\n  reset() {\n    this.created = 0;\n    this.destroyed = 0;\n  }\n  recordCreate() {\n    this.created++;\n  }\n  recordDestroy() {\n    this.destroyed++;\n  }\n  /**\n   * A method indicating if the entire collection was re-created as part of the reconciliation pass.\n   * Used to warn developers about the usage of a tracking function that might result in excessive\n   * amount of view creation / destroy operations.\n   *\n   * @returns boolean value indicating if a live collection was re-created\n   */\n  wasReCreated(collectionLen) {\n    return collectionLen > 0 && this.created === this.destroyed && this.created === collectionLen;\n  }\n};\nvar LiveCollectionLContainerImpl = class extends LiveCollection {\n  lContainer;\n  hostLView;\n  templateTNode;\n  operationsCounter = ngDevMode ? new OperationsCounter() : void 0;\n  /**\n   Property indicating if indexes in the repeater context need to be updated following the live\n   collection changes. Index updates are necessary if and only if views are inserted / removed in\n   the middle of LContainer. Adds and removals at the end don't require index updates.\n  */\n  needsIndexUpdate = false;\n  constructor(lContainer, hostLView, templateTNode) {\n    super();\n    this.lContainer = lContainer;\n    this.hostLView = hostLView;\n    this.templateTNode = templateTNode;\n  }\n  get length() {\n    return this.lContainer.length - CONTAINER_HEADER_OFFSET;\n  }\n  at(index) {\n    return this.getLView(index)[CONTEXT].$implicit;\n  }\n  attach(index, lView) {\n    const dehydratedView = lView[HYDRATION];\n    this.needsIndexUpdate ||= index !== this.length;\n    addLViewToLContainer(this.lContainer, lView, index, shouldAddViewToDom(this.templateTNode, dehydratedView));\n  }\n  detach(index) {\n    this.needsIndexUpdate ||= index !== this.length - 1;\n    return detachExistingView(this.lContainer, index);\n  }\n  create(index, value) {\n    const dehydratedView = findMatchingDehydratedView(this.lContainer, this.templateTNode.tView.ssrId);\n    const embeddedLView = createAndRenderEmbeddedLView(this.hostLView, this.templateTNode, new RepeaterContext(this.lContainer, value, index), {\n      dehydratedView\n    });\n    this.operationsCounter?.recordCreate();\n    return embeddedLView;\n  }\n  destroy(lView) {\n    destroyLView(lView[TVIEW], lView);\n    this.operationsCounter?.recordDestroy();\n  }\n  updateValue(index, value) {\n    this.getLView(index)[CONTEXT].$implicit = value;\n  }\n  reset() {\n    this.needsIndexUpdate = false;\n    this.operationsCounter?.reset();\n  }\n  updateIndexes() {\n    if (this.needsIndexUpdate) {\n      for (let i = 0; i < this.length; i++) {\n        this.getLView(i)[CONTEXT].$index = i;\n      }\n    }\n  }\n  getLView(index) {\n    return getExistingLViewFromLContainer(this.lContainer, index);\n  }\n};\nfunction \\u0275\\u0275repeater(collection) {\n  const prevConsumer = setActiveConsumer(null);\n  const metadataSlotIdx = getSelectedIndex();\n  try {\n    const hostLView = getLView();\n    const hostTView = hostLView[TVIEW];\n    const metadata = hostLView[metadataSlotIdx];\n    const containerIndex = metadataSlotIdx + 1;\n    const lContainer = getLContainer(hostLView, containerIndex);\n    if (metadata.liveCollection === void 0) {\n      const itemTemplateTNode = getExistingTNode(hostTView, containerIndex);\n      metadata.liveCollection = new LiveCollectionLContainerImpl(lContainer, hostLView, itemTemplateTNode);\n    } else {\n      metadata.liveCollection.reset();\n    }\n    const liveCollection = metadata.liveCollection;\n    reconcile(liveCollection, collection, metadata.trackByFn);\n    if (ngDevMode && metadata.trackByFn === \\u0275\\u0275repeaterTrackByIdentity && liveCollection.operationsCounter?.wasReCreated(liveCollection.length) && isViewExpensiveToRecreate(getExistingLViewFromLContainer(lContainer, 0))) {\n      const message = formatRuntimeError(-956, `The configured tracking expression (track by identity) caused re-creation of the entire collection of size ${liveCollection.length}. This is an expensive operation requiring destruction and subsequent creation of DOM nodes, directives, components etc. Please review the \"track expression\" and make sure that it uniquely identifies items in a collection.`);\n      console.warn(message);\n    }\n    liveCollection.updateIndexes();\n    if (metadata.hasEmptyBlock) {\n      const bindingIndex = nextBindingIndex();\n      const isCollectionEmpty = liveCollection.length === 0;\n      if (bindingUpdated(hostLView, bindingIndex, isCollectionEmpty)) {\n        const emptyTemplateIndex = metadataSlotIdx + 2;\n        const lContainerForEmpty = getLContainer(hostLView, emptyTemplateIndex);\n        if (isCollectionEmpty) {\n          const emptyTemplateTNode = getExistingTNode(hostTView, emptyTemplateIndex);\n          const dehydratedView = findMatchingDehydratedView(lContainerForEmpty, emptyTemplateTNode.tView.ssrId);\n          const embeddedLView = createAndRenderEmbeddedLView(hostLView, emptyTemplateTNode, void 0, {\n            dehydratedView\n          });\n          addLViewToLContainer(lContainerForEmpty, embeddedLView, 0, shouldAddViewToDom(emptyTemplateTNode, dehydratedView));\n        } else {\n          removeLViewFromLContainer(lContainerForEmpty, 0);\n        }\n      }\n    }\n  } finally {\n    setActiveConsumer(prevConsumer);\n  }\n}\nfunction getLContainer(lView, index) {\n  const lContainer = lView[index];\n  ngDevMode && assertLContainer(lContainer);\n  return lContainer;\n}\nfunction detachExistingView(lContainer, index) {\n  const existingLView = detachView(lContainer, index);\n  ngDevMode && assertLView(existingLView);\n  return existingLView;\n}\nfunction getExistingLViewFromLContainer(lContainer, index) {\n  const existingLView = getLViewFromLContainer(lContainer, index);\n  ngDevMode && assertLView(existingLView);\n  return existingLView;\n}\nfunction getExistingTNode(tView, index) {\n  const tNode = getTNode(tView, index);\n  ngDevMode && assertTNode(tNode);\n  return tNode;\n}\nfunction \\u0275\\u0275elementStart(index, name, attrsIndex, localRefsIndex) {\n  const lView = getLView();\n  const tView = getTView();\n  const adjustedIndex = HEADER_OFFSET + index;\n  ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, \"elements should be created before any bindings\");\n  ngDevMode && assertIndexInRange(lView, adjustedIndex);\n  const renderer = lView[RENDERER];\n  const tNode = tView.firstCreatePass ? elementStartFirstCreatePass(adjustedIndex, tView, lView, name, findDirectiveDefMatches, getBindingsEnabled(), attrsIndex, localRefsIndex) : tView.data[adjustedIndex];\n  const native = _locateOrCreateElementNode(tView, lView, tNode, renderer, name, index);\n  lView[adjustedIndex] = native;\n  const hasDirectives = isDirectiveHost(tNode);\n  if (ngDevMode && tView.firstCreatePass) {\n    validateElementIsKnown(native, lView, tNode.value, tView.schemas, hasDirectives);\n  }\n  setCurrentTNode(tNode, true);\n  setupStaticAttributes(renderer, native, tNode);\n  if (!isDetachedByI18n(tNode) && wasLastNodeCreated()) {\n    appendChild(tView, lView, native, tNode);\n  }\n  if (getElementDepthCount() === 0 || hasDirectives) {\n    attachPatchData(native, lView);\n  }\n  increaseElementDepthCount();\n  if (hasDirectives) {\n    createDirectivesInstances(tView, lView, tNode);\n    executeContentQueries(tView, tNode, lView);\n  }\n  if (localRefsIndex !== null) {\n    saveResolvedLocalsInData(lView, tNode);\n  }\n  return \\u0275\\u0275elementStart;\n}\nfunction \\u0275\\u0275elementEnd() {\n  let currentTNode = getCurrentTNode();\n  ngDevMode && assertDefined(currentTNode, \"No parent node to close.\");\n  if (isCurrentTNodeParent()) {\n    setCurrentTNodeAsNotParent();\n  } else {\n    ngDevMode && assertHasParent(getCurrentTNode());\n    currentTNode = currentTNode.parent;\n    setCurrentTNode(currentTNode, false);\n  }\n  const tNode = currentTNode;\n  ngDevMode && assertTNodeType(\n    tNode,\n    3\n    /* TNodeType.AnyRNode */\n  );\n  if (isSkipHydrationRootTNode(tNode)) {\n    leaveSkipHydrationBlock();\n  }\n  decreaseElementDepthCount();\n  const tView = getTView();\n  if (tView.firstCreatePass) {\n    elementEndFirstCreatePass(tView, tNode);\n  }\n  if (tNode.classesWithoutHost != null && hasClassInput(tNode)) {\n    setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.classesWithoutHost, true);\n  }\n  if (tNode.stylesWithoutHost != null && hasStyleInput(tNode)) {\n    setDirectiveInputsWhichShadowsStyling(tView, tNode, getLView(), tNode.stylesWithoutHost, false);\n  }\n  return \\u0275\\u0275elementEnd;\n}\nfunction \\u0275\\u0275element(index, name, attrsIndex, localRefsIndex) {\n  \\u0275\\u0275elementStart(index, name, attrsIndex, localRefsIndex);\n  \\u0275\\u0275elementEnd();\n  return \\u0275\\u0275element;\n}\nvar _locateOrCreateElementNode = (tView, lView, tNode, renderer, name, index) => {\n  lastNodeWasCreated(true);\n  return createElementNode(renderer, name, getNamespace());\n};\nfunction elementContainerStartFirstCreatePass(index, tView, lView, attrsIndex, localRefsIndex) {\n  ngDevMode && ngDevMode.firstCreatePass++;\n  const tViewConsts = tView.consts;\n  const attrs = getConstant(tViewConsts, attrsIndex);\n  const tNode = getOrCreateTNode(tView, index, 8, \"ng-container\", attrs);\n  if (attrs !== null) {\n    computeStaticStyling(tNode, attrs, true);\n  }\n  const localRefs = getConstant(tViewConsts, localRefsIndex);\n  if (getBindingsEnabled()) {\n    resolveDirectives(tView, lView, tNode, localRefs, findDirectiveDefMatches);\n  }\n  tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);\n  if (tView.queries !== null) {\n    tView.queries.elementStart(tView, tNode);\n  }\n  return tNode;\n}\nfunction \\u0275\\u0275elementContainerStart(index, attrsIndex, localRefsIndex) {\n  const lView = getLView();\n  const tView = getTView();\n  const adjustedIndex = index + HEADER_OFFSET;\n  ngDevMode && assertIndexInRange(lView, adjustedIndex);\n  ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, \"element containers should be created before any bindings\");\n  const tNode = tView.firstCreatePass ? elementContainerStartFirstCreatePass(adjustedIndex, tView, lView, attrsIndex, localRefsIndex) : tView.data[adjustedIndex];\n  setCurrentTNode(tNode, true);\n  const comment = _locateOrCreateElementContainerNode(tView, lView, tNode, index);\n  lView[adjustedIndex] = comment;\n  if (wasLastNodeCreated()) {\n    appendChild(tView, lView, comment, tNode);\n  }\n  attachPatchData(comment, lView);\n  if (isDirectiveHost(tNode)) {\n    createDirectivesInstances(tView, lView, tNode);\n    executeContentQueries(tView, tNode, lView);\n  }\n  if (localRefsIndex != null) {\n    saveResolvedLocalsInData(lView, tNode);\n  }\n  return \\u0275\\u0275elementContainerStart;\n}\nfunction \\u0275\\u0275elementContainerEnd() {\n  let currentTNode = getCurrentTNode();\n  const tView = getTView();\n  if (isCurrentTNodeParent()) {\n    setCurrentTNodeAsNotParent();\n  } else {\n    ngDevMode && assertHasParent(currentTNode);\n    currentTNode = currentTNode.parent;\n    setCurrentTNode(currentTNode, false);\n  }\n  ngDevMode && assertTNodeType(\n    currentTNode,\n    8\n    /* TNodeType.ElementContainer */\n  );\n  if (tView.firstCreatePass) {\n    registerPostOrderHooks(tView, currentTNode);\n    if (isContentQueryHost(currentTNode)) {\n      tView.queries.elementEnd(currentTNode);\n    }\n  }\n  return \\u0275\\u0275elementContainerEnd;\n}\nfunction \\u0275\\u0275elementContainer(index, attrsIndex, localRefsIndex) {\n  \\u0275\\u0275elementContainerStart(index, attrsIndex, localRefsIndex);\n  \\u0275\\u0275elementContainerEnd();\n  return \\u0275\\u0275elementContainer;\n}\nvar _locateOrCreateElementContainerNode = (tView, lView, tNode, index) => {\n  lastNodeWasCreated(true);\n  return createCommentNode(lView[RENDERER], ngDevMode ? \"ng-container\" : \"\");\n};\nfunction \\u0275\\u0275getCurrentView() {\n  return getLView();\n}\nfunction \\u0275\\u0275hostProperty(propName, value, sanitizer) {\n  const lView = getLView();\n  const bindingIndex = nextBindingIndex();\n  if (bindingUpdated(lView, bindingIndex, value)) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, true);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);\n  }\n  return \\u0275\\u0275hostProperty;\n}\nfunction \\u0275\\u0275syntheticHostProperty(propName, value, sanitizer) {\n  const lView = getLView();\n  const bindingIndex = nextBindingIndex();\n  if (bindingUpdated(lView, bindingIndex, value)) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    const currentDef = getCurrentDirectiveDef(tView.data);\n    const renderer = loadComponentRenderer(currentDef, tNode, lView);\n    elementPropertyInternal(tView, tNode, lView, propName, value, renderer, sanitizer, true);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);\n  }\n  return \\u0275\\u0275syntheticHostProperty;\n}\nvar u = void 0;\nfunction plural(val) {\n  const i = Math.floor(Math.abs(val)), v = val.toString().replace(/^[^.]*\\.?/, \"\").length;\n  if (i === 1 && v === 0) return 1;\n  return 5;\n}\nvar localeEn = [\"en\", [[\"a\", \"p\"], [\"AM\", \"PM\"], u], [[\"AM\", \"PM\"], u, u], [[\"S\", \"M\", \"T\", \"W\", \"T\", \"F\", \"S\"], [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"], [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"], [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"]], u, [[\"J\", \"F\", \"M\", \"A\", \"M\", \"J\", \"J\", \"A\", \"S\", \"O\", \"N\", \"D\"], [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"], [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]], u, [[\"B\", \"A\"], [\"BC\", \"AD\"], [\"Before Christ\", \"Anno Domini\"]], 0, [6, 0], [\"M/d/yy\", \"MMM d, y\", \"MMMM d, y\", \"EEEE, MMMM d, y\"], [\"h:mm a\", \"h:mm:ss a\", \"h:mm:ss a z\", \"h:mm:ss a zzzz\"], [\"{1}, {0}\", u, \"{1} 'at' {0}\", u], [\".\", \",\", \";\", \"%\", \"+\", \"-\", \"E\", \"\\xD7\", \"\\u2030\", \"\\u221E\", \"NaN\", \":\"], [\"#,##0.###\", \"#,##0%\", \"\\xA4#,##0.00\", \"#E0\"], \"USD\", \"$\", \"US Dollar\", {}, \"ltr\", plural];\nvar LOCALE_DATA = {};\nfunction findLocaleData(locale) {\n  const normalizedLocale = normalizeLocale(locale);\n  let match2 = getLocaleData(normalizedLocale);\n  if (match2) {\n    return match2;\n  }\n  const parentLocale = normalizedLocale.split(\"-\")[0];\n  match2 = getLocaleData(parentLocale);\n  if (match2) {\n    return match2;\n  }\n  if (parentLocale === \"en\") {\n    return localeEn;\n  }\n  throw new RuntimeError(701, ngDevMode && `Missing locale data for the locale \"${locale}\".`);\n}\nfunction getLocalePluralCase(locale) {\n  const data = findLocaleData(locale);\n  return data[LocaleDataIndex.PluralCase];\n}\nfunction getLocaleData(normalizedLocale) {\n  if (!(normalizedLocale in LOCALE_DATA)) {\n    LOCALE_DATA[normalizedLocale] = _global.ng && _global.ng.common && _global.ng.common.locales && _global.ng.common.locales[normalizedLocale];\n  }\n  return LOCALE_DATA[normalizedLocale];\n}\nvar LocaleDataIndex;\n(function(LocaleDataIndex2) {\n  LocaleDataIndex2[LocaleDataIndex2[\"LocaleId\"] = 0] = \"LocaleId\";\n  LocaleDataIndex2[LocaleDataIndex2[\"DayPeriodsFormat\"] = 1] = \"DayPeriodsFormat\";\n  LocaleDataIndex2[LocaleDataIndex2[\"DayPeriodsStandalone\"] = 2] = \"DayPeriodsStandalone\";\n  LocaleDataIndex2[LocaleDataIndex2[\"DaysFormat\"] = 3] = \"DaysFormat\";\n  LocaleDataIndex2[LocaleDataIndex2[\"DaysStandalone\"] = 4] = \"DaysStandalone\";\n  LocaleDataIndex2[LocaleDataIndex2[\"MonthsFormat\"] = 5] = \"MonthsFormat\";\n  LocaleDataIndex2[LocaleDataIndex2[\"MonthsStandalone\"] = 6] = \"MonthsStandalone\";\n  LocaleDataIndex2[LocaleDataIndex2[\"Eras\"] = 7] = \"Eras\";\n  LocaleDataIndex2[LocaleDataIndex2[\"FirstDayOfWeek\"] = 8] = \"FirstDayOfWeek\";\n  LocaleDataIndex2[LocaleDataIndex2[\"WeekendRange\"] = 9] = \"WeekendRange\";\n  LocaleDataIndex2[LocaleDataIndex2[\"DateFormat\"] = 10] = \"DateFormat\";\n  LocaleDataIndex2[LocaleDataIndex2[\"TimeFormat\"] = 11] = \"TimeFormat\";\n  LocaleDataIndex2[LocaleDataIndex2[\"DateTimeFormat\"] = 12] = \"DateTimeFormat\";\n  LocaleDataIndex2[LocaleDataIndex2[\"NumberSymbols\"] = 13] = \"NumberSymbols\";\n  LocaleDataIndex2[LocaleDataIndex2[\"NumberFormats\"] = 14] = \"NumberFormats\";\n  LocaleDataIndex2[LocaleDataIndex2[\"CurrencyCode\"] = 15] = \"CurrencyCode\";\n  LocaleDataIndex2[LocaleDataIndex2[\"CurrencySymbol\"] = 16] = \"CurrencySymbol\";\n  LocaleDataIndex2[LocaleDataIndex2[\"CurrencyName\"] = 17] = \"CurrencyName\";\n  LocaleDataIndex2[LocaleDataIndex2[\"Currencies\"] = 18] = \"Currencies\";\n  LocaleDataIndex2[LocaleDataIndex2[\"Directionality\"] = 19] = \"Directionality\";\n  LocaleDataIndex2[LocaleDataIndex2[\"PluralCase\"] = 20] = \"PluralCase\";\n  LocaleDataIndex2[LocaleDataIndex2[\"ExtraData\"] = 21] = \"ExtraData\";\n})(LocaleDataIndex || (LocaleDataIndex = {}));\nfunction normalizeLocale(locale) {\n  return locale.toLowerCase().replace(/_/g, \"-\");\n}\nvar pluralMapping = [\"zero\", \"one\", \"two\", \"few\", \"many\"];\nfunction getPluralCase(value, locale) {\n  const plural2 = getLocalePluralCase(locale)(parseInt(value, 10));\n  const result = pluralMapping[plural2];\n  return result !== void 0 ? result : \"other\";\n}\nvar DEFAULT_LOCALE_ID = \"en-US\";\nvar USD_CURRENCY_CODE = \"USD\";\nvar ELEMENT_MARKER = {\n  marker: \"element\"\n};\nvar ICU_MARKER = {\n  marker: \"ICU\"\n};\nvar I18nCreateOpCode;\n(function(I18nCreateOpCode2) {\n  I18nCreateOpCode2[I18nCreateOpCode2[\"SHIFT\"] = 2] = \"SHIFT\";\n  I18nCreateOpCode2[I18nCreateOpCode2[\"APPEND_EAGERLY\"] = 1] = \"APPEND_EAGERLY\";\n  I18nCreateOpCode2[I18nCreateOpCode2[\"COMMENT\"] = 2] = \"COMMENT\";\n})(I18nCreateOpCode || (I18nCreateOpCode = {}));\nvar LOCALE_ID$1 = DEFAULT_LOCALE_ID;\nfunction setLocaleId(localeId) {\n  ngDevMode && assertDefined(localeId, `Expected localeId to be defined`);\n  if (typeof localeId === \"string\") {\n    LOCALE_ID$1 = localeId.toLowerCase().replace(/_/g, \"-\");\n  }\n}\nfunction getLocaleId() {\n  return LOCALE_ID$1;\n}\nvar changeMask = 0;\nvar changeMaskCounter = 0;\nfunction setMaskBit(hasChange) {\n  if (hasChange) {\n    changeMask = changeMask | 1 << Math.min(changeMaskCounter, 31);\n  }\n  changeMaskCounter++;\n}\nfunction applyI18n(tView, lView, index) {\n  if (changeMaskCounter > 0) {\n    ngDevMode && assertDefined(tView, `tView should be defined`);\n    const tI18n = tView.data[index];\n    const updateOpCodes = Array.isArray(tI18n) ? tI18n : tI18n.update;\n    const bindingsStartIndex = getBindingIndex() - changeMaskCounter - 1;\n    applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask);\n  }\n  changeMask = 0;\n  changeMaskCounter = 0;\n}\nfunction createNodeWithoutHydration(lView, textOrName, nodeType) {\n  const renderer = lView[RENDERER];\n  switch (nodeType) {\n    case Node.COMMENT_NODE:\n      return createCommentNode(renderer, textOrName);\n    case Node.TEXT_NODE:\n      return createTextNode(renderer, textOrName);\n    case Node.ELEMENT_NODE:\n      return createElementNode(renderer, textOrName, null);\n  }\n}\nvar _locateOrCreateNode = (lView, index, textOrName, nodeType) => {\n  lastNodeWasCreated(true);\n  return createNodeWithoutHydration(lView, textOrName, nodeType);\n};\nfunction applyCreateOpCodes(lView, createOpCodes, parentRNode, insertInFrontOf) {\n  const renderer = lView[RENDERER];\n  for (let i = 0; i < createOpCodes.length; i++) {\n    const opCode = createOpCodes[i++];\n    const text = createOpCodes[i];\n    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;\n    const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;\n    const index = opCode >>> I18nCreateOpCode.SHIFT;\n    let rNode = lView[index];\n    let lastNodeWasCreated2 = false;\n    if (rNode === null) {\n      rNode = lView[index] = _locateOrCreateNode(lView, index, text, isComment ? Node.COMMENT_NODE : Node.TEXT_NODE);\n      lastNodeWasCreated2 = wasLastNodeCreated();\n    }\n    if (appendNow && parentRNode !== null && lastNodeWasCreated2) {\n      nativeInsertBefore(renderer, parentRNode, rNode, insertInFrontOf, false);\n    }\n  }\n}\nfunction applyMutableOpCodes(tView, mutableOpCodes, lView, anchorRNode) {\n  ngDevMode && assertDomNode(anchorRNode);\n  const renderer = lView[RENDERER];\n  let rootIdx = null;\n  let rootRNode;\n  for (let i = 0; i < mutableOpCodes.length; i++) {\n    const opCode = mutableOpCodes[i];\n    if (typeof opCode == \"string\") {\n      const textNodeIndex = mutableOpCodes[++i];\n      if (lView[textNodeIndex] === null) {\n        ngDevMode && ngDevMode.rendererCreateTextNode++;\n        ngDevMode && assertIndexInRange(lView, textNodeIndex);\n        lView[textNodeIndex] = _locateOrCreateNode(lView, textNodeIndex, opCode, Node.TEXT_NODE);\n      }\n    } else if (typeof opCode == \"number\") {\n      switch (opCode & 1) {\n        case 0:\n          const parentIdx = getParentFromIcuCreateOpCode(opCode);\n          if (rootIdx === null) {\n            rootIdx = parentIdx;\n            rootRNode = renderer.parentNode(anchorRNode);\n          }\n          let insertInFrontOf;\n          let parentRNode;\n          if (parentIdx === rootIdx) {\n            insertInFrontOf = anchorRNode;\n            parentRNode = rootRNode;\n          } else {\n            insertInFrontOf = null;\n            parentRNode = unwrapRNode(lView[parentIdx]);\n          }\n          if (parentRNode !== null) {\n            ngDevMode && assertDomNode(parentRNode);\n            const refIdx = getRefFromIcuCreateOpCode(opCode);\n            ngDevMode && assertGreaterThan(refIdx, HEADER_OFFSET, \"Missing ref\");\n            const child = lView[refIdx];\n            ngDevMode && assertDomNode(child);\n            nativeInsertBefore(renderer, parentRNode, child, insertInFrontOf, false);\n            const tIcu = getTIcu(tView, refIdx);\n            if (tIcu !== null && typeof tIcu === \"object\") {\n              ngDevMode && assertTIcu(tIcu);\n              const caseIndex = getCurrentICUCaseIndex(tIcu, lView);\n              if (caseIndex !== null) {\n                applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, lView[tIcu.anchorIdx]);\n              }\n            }\n          }\n          break;\n        case 1:\n          const elementNodeIndex = opCode >>> 1;\n          const attrName = mutableOpCodes[++i];\n          const attrValue = mutableOpCodes[++i];\n          setElementAttribute(renderer, getNativeByIndex(elementNodeIndex, lView), null, null, attrName, attrValue, null);\n          break;\n        default:\n          if (ngDevMode) {\n            throw new RuntimeError(700, `Unable to determine the type of mutate operation for \"${opCode}\"`);\n          }\n      }\n    } else {\n      switch (opCode) {\n        case ICU_MARKER:\n          const commentValue = mutableOpCodes[++i];\n          const commentNodeIndex = mutableOpCodes[++i];\n          if (lView[commentNodeIndex] === null) {\n            ngDevMode && assertEqual(typeof commentValue, \"string\", `Expected \"${commentValue}\" to be a comment node value`);\n            ngDevMode && ngDevMode.rendererCreateComment++;\n            ngDevMode && assertIndexInExpandoRange(lView, commentNodeIndex);\n            const commentRNode = lView[commentNodeIndex] = _locateOrCreateNode(lView, commentNodeIndex, commentValue, Node.COMMENT_NODE);\n            attachPatchData(commentRNode, lView);\n          }\n          break;\n        case ELEMENT_MARKER:\n          const tagName = mutableOpCodes[++i];\n          const elementNodeIndex = mutableOpCodes[++i];\n          if (lView[elementNodeIndex] === null) {\n            ngDevMode && assertEqual(typeof tagName, \"string\", `Expected \"${tagName}\" to be an element node tag name`);\n            ngDevMode && ngDevMode.rendererCreateElement++;\n            ngDevMode && assertIndexInExpandoRange(lView, elementNodeIndex);\n            const elementRNode = lView[elementNodeIndex] = _locateOrCreateNode(lView, elementNodeIndex, tagName, Node.ELEMENT_NODE);\n            attachPatchData(elementRNode, lView);\n          }\n          break;\n        default:\n          ngDevMode && throwError2(`Unable to determine the type of mutate operation for \"${opCode}\"`);\n      }\n    }\n  }\n}\nfunction applyUpdateOpCodes(tView, lView, updateOpCodes, bindingsStartIndex, changeMask2) {\n  for (let i = 0; i < updateOpCodes.length; i++) {\n    const checkBit = updateOpCodes[i];\n    const skipCodes = updateOpCodes[++i];\n    if (checkBit & changeMask2) {\n      let value = \"\";\n      for (let j = i + 1; j <= i + skipCodes; j++) {\n        const opCode = updateOpCodes[j];\n        if (typeof opCode == \"string\") {\n          value += opCode;\n        } else if (typeof opCode == \"number\") {\n          if (opCode < 0) {\n            value += renderStringify(lView[bindingsStartIndex - opCode]);\n          } else {\n            const nodeIndex = opCode >>> 2;\n            switch (opCode & 3) {\n              case 1:\n                const propName = updateOpCodes[++j];\n                const sanitizeFn = updateOpCodes[++j];\n                const tNodeOrTagName = tView.data[nodeIndex];\n                ngDevMode && assertDefined(tNodeOrTagName, \"Experting TNode or string\");\n                if (typeof tNodeOrTagName === \"string\") {\n                  setElementAttribute(lView[RENDERER], lView[nodeIndex], null, tNodeOrTagName, propName, value, sanitizeFn);\n                } else {\n                  elementPropertyInternal(tView, tNodeOrTagName, lView, propName, value, lView[RENDERER], sanitizeFn, false);\n                }\n                break;\n              case 0:\n                const rText = lView[nodeIndex];\n                rText !== null && updateTextNode(lView[RENDERER], rText, value);\n                break;\n              case 2:\n                applyIcuSwitchCase(tView, getTIcu(tView, nodeIndex), lView, value);\n                break;\n              case 3:\n                applyIcuUpdateCase(tView, getTIcu(tView, nodeIndex), bindingsStartIndex, lView);\n                break;\n            }\n          }\n        }\n      }\n    } else {\n      const opCode = updateOpCodes[i + 1];\n      if (opCode > 0 && (opCode & 3) === 3) {\n        const nodeIndex = opCode >>> 2;\n        const tIcu = getTIcu(tView, nodeIndex);\n        const currentIndex = lView[tIcu.currentCaseLViewIndex];\n        if (currentIndex < 0) {\n          applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView);\n        }\n      }\n    }\n    i += skipCodes;\n  }\n}\nfunction applyIcuUpdateCase(tView, tIcu, bindingsStartIndex, lView) {\n  ngDevMode && assertIndexInRange(lView, tIcu.currentCaseLViewIndex);\n  let activeCaseIndex = lView[tIcu.currentCaseLViewIndex];\n  if (activeCaseIndex !== null) {\n    let mask = changeMask;\n    if (activeCaseIndex < 0) {\n      activeCaseIndex = lView[tIcu.currentCaseLViewIndex] = ~activeCaseIndex;\n      mask = -1;\n    }\n    applyUpdateOpCodes(tView, lView, tIcu.update[activeCaseIndex], bindingsStartIndex, mask);\n  }\n}\nfunction applyIcuSwitchCase(tView, tIcu, lView, value) {\n  const caseIndex = getCaseIndex(tIcu, value);\n  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);\n  if (activeCaseIndex !== caseIndex) {\n    applyIcuSwitchCaseRemove(tView, tIcu, lView);\n    lView[tIcu.currentCaseLViewIndex] = caseIndex === null ? null : ~caseIndex;\n    if (caseIndex !== null) {\n      const anchorRNode = lView[tIcu.anchorIdx];\n      if (anchorRNode) {\n        ngDevMode && assertDomNode(anchorRNode);\n        applyMutableOpCodes(tView, tIcu.create[caseIndex], lView, anchorRNode);\n      }\n      claimDehydratedIcuCase(lView, tIcu.anchorIdx, caseIndex);\n    }\n  }\n}\nfunction applyIcuSwitchCaseRemove(tView, tIcu, lView) {\n  let activeCaseIndex = getCurrentICUCaseIndex(tIcu, lView);\n  if (activeCaseIndex !== null) {\n    const removeCodes = tIcu.remove[activeCaseIndex];\n    for (let i = 0; i < removeCodes.length; i++) {\n      const nodeOrIcuIndex = removeCodes[i];\n      if (nodeOrIcuIndex > 0) {\n        const rNode = getNativeByIndex(nodeOrIcuIndex, lView);\n        rNode !== null && nativeRemoveNode(lView[RENDERER], rNode);\n      } else {\n        applyIcuSwitchCaseRemove(tView, getTIcu(tView, ~nodeOrIcuIndex), lView);\n      }\n    }\n  }\n}\nfunction getCaseIndex(icuExpression, bindingValue) {\n  let index = icuExpression.cases.indexOf(bindingValue);\n  if (index === -1) {\n    switch (icuExpression.type) {\n      case 1: {\n        const resolvedCase = getPluralCase(bindingValue, getLocaleId());\n        index = icuExpression.cases.indexOf(resolvedCase);\n        if (index === -1 && resolvedCase !== \"other\") {\n          index = icuExpression.cases.indexOf(\"other\");\n        }\n        break;\n      }\n      case 0: {\n        index = icuExpression.cases.indexOf(\"other\");\n        break;\n      }\n    }\n  }\n  return index === -1 ? null : index;\n}\nfunction i18nCreateOpCodesToString(opcodes) {\n  const createOpCodes = opcodes || (Array.isArray(this) ? this : []);\n  let lines = [];\n  for (let i = 0; i < createOpCodes.length; i++) {\n    const opCode = createOpCodes[i++];\n    const text = createOpCodes[i];\n    const isComment = (opCode & I18nCreateOpCode.COMMENT) === I18nCreateOpCode.COMMENT;\n    const appendNow = (opCode & I18nCreateOpCode.APPEND_EAGERLY) === I18nCreateOpCode.APPEND_EAGERLY;\n    const index = opCode >>> I18nCreateOpCode.SHIFT;\n    lines.push(`lView[${index}] = document.${isComment ? \"createComment\" : \"createText\"}(${JSON.stringify(text)});`);\n    if (appendNow) {\n      lines.push(`parent.appendChild(lView[${index}]);`);\n    }\n  }\n  return lines;\n}\nfunction i18nUpdateOpCodesToString(opcodes) {\n  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));\n  let lines = [];\n  function consumeOpCode(value) {\n    const ref = value >>> 2;\n    const opCode = value & 3;\n    switch (opCode) {\n      case 0:\n        return `(lView[${ref}] as Text).textContent = $$$`;\n      case 1:\n        const attrName = parser.consumeString();\n        const sanitizationFn = parser.consumeFunction();\n        const value2 = sanitizationFn ? `(${sanitizationFn})($$$)` : \"$$$\";\n        return `(lView[${ref}] as Element).setAttribute('${attrName}', ${value2})`;\n      case 2:\n        return `icuSwitchCase(${ref}, $$$)`;\n      case 3:\n        return `icuUpdateCase(${ref})`;\n    }\n    throw new Error(\"unexpected OpCode\");\n  }\n  while (parser.hasMore()) {\n    let mask = parser.consumeNumber();\n    let size = parser.consumeNumber();\n    const end = parser.i + size;\n    const statements = [];\n    let statement = \"\";\n    while (parser.i < end) {\n      let value = parser.consumeNumberOrString();\n      if (typeof value === \"string\") {\n        statement += value;\n      } else if (value < 0) {\n        statement += \"${lView[i\" + value + \"]}\";\n      } else {\n        const opCodeText = consumeOpCode(value);\n        statements.push(opCodeText.replace(\"$$$\", \"`\" + statement + \"`\") + \";\");\n        statement = \"\";\n      }\n    }\n    lines.push(`if (mask & 0b${mask.toString(2)}) { ${statements.join(\" \")} }`);\n  }\n  return lines;\n}\nfunction icuCreateOpCodesToString(opcodes) {\n  const parser = new OpCodeParser(opcodes || (Array.isArray(this) ? this : []));\n  let lines = [];\n  function consumeOpCode(opCode) {\n    const parent = getParentFromIcuCreateOpCode(opCode);\n    const ref = getRefFromIcuCreateOpCode(opCode);\n    switch (getInstructionFromIcuCreateOpCode(opCode)) {\n      case 0:\n        return `(lView[${parent}] as Element).appendChild(lView[${lastRef}])`;\n      case 1:\n        return `(lView[${ref}] as Element).setAttribute(\"${parser.consumeString()}\", \"${parser.consumeString()}\")`;\n    }\n    throw new Error(\"Unexpected OpCode: \" + getInstructionFromIcuCreateOpCode(opCode));\n  }\n  let lastRef = -1;\n  while (parser.hasMore()) {\n    let value = parser.consumeNumberStringOrMarker();\n    if (value === ICU_MARKER) {\n      const text = parser.consumeString();\n      lastRef = parser.consumeNumber();\n      lines.push(`lView[${lastRef}] = document.createComment(\"${text}\")`);\n    } else if (value === ELEMENT_MARKER) {\n      const text = parser.consumeString();\n      lastRef = parser.consumeNumber();\n      lines.push(`lView[${lastRef}] = document.createElement(\"${text}\")`);\n    } else if (typeof value === \"string\") {\n      lastRef = parser.consumeNumber();\n      lines.push(`lView[${lastRef}] = document.createTextNode(\"${value}\")`);\n    } else if (typeof value === \"number\") {\n      const line = consumeOpCode(value);\n      line && lines.push(line);\n    } else {\n      throw new Error(\"Unexpected value\");\n    }\n  }\n  return lines;\n}\nfunction i18nRemoveOpCodesToString(opcodes) {\n  const removeCodes = opcodes || (Array.isArray(this) ? this : []);\n  let lines = [];\n  for (let i = 0; i < removeCodes.length; i++) {\n    const nodeOrIcuIndex = removeCodes[i];\n    if (nodeOrIcuIndex > 0) {\n      lines.push(`remove(lView[${nodeOrIcuIndex}])`);\n    } else {\n      lines.push(`removeNestedICU(${~nodeOrIcuIndex})`);\n    }\n  }\n  return lines;\n}\nvar OpCodeParser = class {\n  i = 0;\n  codes;\n  constructor(codes) {\n    this.codes = codes;\n  }\n  hasMore() {\n    return this.i < this.codes.length;\n  }\n  consumeNumber() {\n    let value = this.codes[this.i++];\n    assertNumber(value, \"expecting number in OpCode\");\n    return value;\n  }\n  consumeString() {\n    let value = this.codes[this.i++];\n    assertString(value, \"expecting string in OpCode\");\n    return value;\n  }\n  consumeFunction() {\n    let value = this.codes[this.i++];\n    if (value === null || typeof value === \"function\") {\n      return value;\n    }\n    throw new Error(\"expecting function in OpCode\");\n  }\n  consumeNumberOrString() {\n    let value = this.codes[this.i++];\n    if (typeof value === \"string\") {\n      return value;\n    }\n    assertNumber(value, \"expecting number or string in OpCode\");\n    return value;\n  }\n  consumeNumberStringOrMarker() {\n    let value = this.codes[this.i++];\n    if (typeof value === \"string\" || typeof value === \"number\" || value == ICU_MARKER || value == ELEMENT_MARKER) {\n      return value;\n    }\n    assertNumber(value, \"expecting number, string, ICU_MARKER or ELEMENT_MARKER in OpCode\");\n    return value;\n  }\n};\nvar BINDING_REGEXP = /�(\\d+):?\\d*�/gi;\nvar ICU_REGEXP = /({\\s*�\\d+:?\\d*�\\s*,\\s*\\S{6}\\s*,[\\s\\S]*})/gi;\nvar NESTED_ICU = /�(\\d+)�/;\nvar ICU_BLOCK_REGEXP = /^\\s*(�\\d+:?\\d*�)\\s*,\\s*(select|plural)\\s*,/;\nvar MARKER = `\\uFFFD`;\nvar SUBTEMPLATE_REGEXP = /�\\/?\\*(\\d+:\\d+)�/gi;\nvar PH_REGEXP = /�(\\/?[#*]\\d+):?\\d*�/gi;\nvar NGSP_UNICODE_REGEXP = /\\uE500/g;\nfunction replaceNgsp(value) {\n  return value.replace(NGSP_UNICODE_REGEXP, \" \");\n}\nfunction attachDebugGetter(obj, debugGetter) {\n  if (ngDevMode) {\n    Object.defineProperty(obj, \"debug\", {\n      get: debugGetter,\n      enumerable: false\n    });\n  } else {\n    throw new Error(\"This method should be guarded with `ngDevMode` so that it can be tree shaken in production!\");\n  }\n}\nfunction i18nStartFirstCreatePass(tView, parentTNodeIndex, lView, index, message, subTemplateIndex) {\n  const rootTNode = getCurrentParentTNode();\n  const createOpCodes = [];\n  const updateOpCodes = [];\n  const existingTNodeStack = [[]];\n  const astStack = [[]];\n  if (ngDevMode) {\n    attachDebugGetter(createOpCodes, i18nCreateOpCodesToString);\n    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n  }\n  message = getTranslationForTemplate(message, subTemplateIndex);\n  const msgParts = replaceNgsp(message).split(PH_REGEXP);\n  for (let i = 0; i < msgParts.length; i++) {\n    let value = msgParts[i];\n    if ((i & 1) === 0) {\n      const parts = i18nParseTextIntoPartsAndICU(value);\n      for (let j = 0; j < parts.length; j++) {\n        let part = parts[j];\n        if ((j & 1) === 0) {\n          const text = part;\n          ngDevMode && assertString(text, \"Parsed ICU part should be string\");\n          if (text !== \"\") {\n            i18nStartFirstCreatePassProcessTextNode(astStack[0], tView, rootTNode, existingTNodeStack[0], createOpCodes, updateOpCodes, lView, text);\n          }\n        } else {\n          const icuExpression = part;\n          if (typeof icuExpression !== \"object\") {\n            throw new Error(`Unable to parse ICU expression in \"${message}\" message.`);\n          }\n          const icuContainerTNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodeStack[0], lView, createOpCodes, ngDevMode ? `ICU ${index}:${icuExpression.mainBinding}` : \"\", true);\n          const icuNodeIndex = icuContainerTNode.index;\n          ngDevMode && assertGreaterThanOrEqual(icuNodeIndex, HEADER_OFFSET, \"Index must be in absolute LView offset\");\n          icuStart(astStack[0], tView, lView, updateOpCodes, parentTNodeIndex, icuExpression, icuNodeIndex);\n        }\n      }\n    } else {\n      const isClosing = value.charCodeAt(0) === 47;\n      const type = value.charCodeAt(isClosing ? 1 : 0);\n      ngDevMode && assertOneOf(\n        type,\n        42,\n        35\n        /* CharCode.HASH */\n      );\n      const index2 = HEADER_OFFSET + Number.parseInt(value.substring(isClosing ? 2 : 1));\n      if (isClosing) {\n        existingTNodeStack.shift();\n        astStack.shift();\n        setCurrentTNode(getCurrentParentTNode(), false);\n      } else {\n        const tNode = createTNodePlaceholder(tView, existingTNodeStack[0], index2);\n        existingTNodeStack.unshift([]);\n        setCurrentTNode(tNode, true);\n        const placeholderNode = {\n          kind: 2,\n          index: index2,\n          children: [],\n          type: type === 35 ? 0 : 1\n          /* I18nPlaceholderType.SUBTEMPLATE */\n        };\n        astStack[0].push(placeholderNode);\n        astStack.unshift(placeholderNode.children);\n      }\n    }\n  }\n  tView.data[index] = {\n    create: createOpCodes,\n    update: updateOpCodes,\n    ast: astStack[0],\n    parentTNodeIndex\n  };\n}\nfunction createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, text, isICU) {\n  const i18nNodeIdx = allocExpando(tView, lView, 1, null);\n  let opCode = i18nNodeIdx << I18nCreateOpCode.SHIFT;\n  let parentTNode = getCurrentParentTNode();\n  if (rootTNode === parentTNode) {\n    parentTNode = null;\n  }\n  if (parentTNode === null) {\n    opCode |= I18nCreateOpCode.APPEND_EAGERLY;\n  }\n  if (isICU) {\n    opCode |= I18nCreateOpCode.COMMENT;\n    ensureIcuContainerVisitorLoaded(loadIcuContainerVisitor);\n  }\n  createOpCodes.push(opCode, text === null ? \"\" : text);\n  const tNode = createTNodeAtIndex(tView, i18nNodeIdx, isICU ? 32 : 1, text === null ? ngDevMode ? \"{{?}}\" : \"\" : text, null);\n  addTNodeAndUpdateInsertBeforeIndex(existingTNodes, tNode);\n  const tNodeIdx = tNode.index;\n  setCurrentTNode(\n    tNode,\n    false\n    /* Text nodes are self closing */\n  );\n  if (parentTNode !== null && rootTNode !== parentTNode) {\n    setTNodeInsertBeforeIndex(parentTNode, tNodeIdx);\n  }\n  return tNode;\n}\nfunction i18nStartFirstCreatePassProcessTextNode(ast, tView, rootTNode, existingTNodes, createOpCodes, updateOpCodes, lView, text) {\n  const hasBinding = text.match(BINDING_REGEXP);\n  const tNode = createTNodeAndAddOpCode(tView, rootTNode, existingTNodes, lView, createOpCodes, hasBinding ? null : text, false);\n  const index = tNode.index;\n  if (hasBinding) {\n    generateBindingUpdateOpCodes(updateOpCodes, text, index, null, 0, null);\n  }\n  ast.push({\n    kind: 0,\n    index\n  });\n}\nfunction i18nAttributesFirstPass(tView, index, values) {\n  const previousElement = getCurrentTNode();\n  const previousElementIndex = previousElement.index;\n  const updateOpCodes = [];\n  if (ngDevMode) {\n    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n  }\n  if (tView.firstCreatePass && tView.data[index] === null) {\n    for (let i = 0; i < values.length; i += 2) {\n      const attrName = values[i];\n      const message = values[i + 1];\n      if (message !== \"\") {\n        if (ICU_REGEXP.test(message)) {\n          throw new Error(`ICU expressions are not supported in attributes. Message: \"${message}\".`);\n        }\n        generateBindingUpdateOpCodes(updateOpCodes, message, previousElementIndex, attrName, countBindings(updateOpCodes), null);\n      }\n    }\n    tView.data[index] = updateOpCodes;\n  }\n}\nfunction generateBindingUpdateOpCodes(updateOpCodes, str, destinationNode, attrName, bindingStart, sanitizeFn) {\n  ngDevMode && assertGreaterThanOrEqual(destinationNode, HEADER_OFFSET, \"Index must be in absolute LView offset\");\n  const maskIndex = updateOpCodes.length;\n  const sizeIndex = maskIndex + 1;\n  updateOpCodes.push(null, null);\n  const startIndex = maskIndex + 2;\n  if (ngDevMode) {\n    attachDebugGetter(updateOpCodes, i18nUpdateOpCodesToString);\n  }\n  const textParts = str.split(BINDING_REGEXP);\n  let mask = 0;\n  for (let j = 0; j < textParts.length; j++) {\n    const textValue = textParts[j];\n    if (j & 1) {\n      const bindingIndex = bindingStart + parseInt(textValue, 10);\n      updateOpCodes.push(-1 - bindingIndex);\n      mask = mask | toMaskBit(bindingIndex);\n    } else if (textValue !== \"\") {\n      updateOpCodes.push(textValue);\n    }\n  }\n  updateOpCodes.push(destinationNode << 2 | (attrName ? 1 : 0));\n  if (attrName) {\n    updateOpCodes.push(attrName, sanitizeFn);\n  }\n  updateOpCodes[maskIndex] = mask;\n  updateOpCodes[sizeIndex] = updateOpCodes.length - startIndex;\n  return mask;\n}\nfunction countBindings(opCodes) {\n  let count = 0;\n  for (let i = 0; i < opCodes.length; i++) {\n    const opCode = opCodes[i];\n    if (typeof opCode === \"number\" && opCode < 0) {\n      count++;\n    }\n  }\n  return count;\n}\nfunction toMaskBit(bindingIndex) {\n  return 1 << Math.min(bindingIndex, 31);\n}\nfunction removeInnerTemplateTranslation(message) {\n  let match2;\n  let res = \"\";\n  let index = 0;\n  let inTemplate = false;\n  let tagMatched;\n  while ((match2 = SUBTEMPLATE_REGEXP.exec(message)) !== null) {\n    if (!inTemplate) {\n      res += message.substring(index, match2.index + match2[0].length);\n      tagMatched = match2[1];\n      inTemplate = true;\n    } else {\n      if (match2[0] === `${MARKER}/*${tagMatched}${MARKER}`) {\n        index = match2.index;\n        inTemplate = false;\n      }\n    }\n  }\n  ngDevMode && assertEqual(inTemplate, false, `Tag mismatch: unable to find the end of the sub-template in the translation \"${message}\"`);\n  res += message.slice(index);\n  return res;\n}\nfunction getTranslationForTemplate(message, subTemplateIndex) {\n  if (isRootTemplateMessage(subTemplateIndex)) {\n    return removeInnerTemplateTranslation(message);\n  } else {\n    const start = message.indexOf(`:${subTemplateIndex}${MARKER}`) + 2 + subTemplateIndex.toString().length;\n    const end = message.search(new RegExp(`${MARKER}\\\\/\\\\*\\\\d+:${subTemplateIndex}${MARKER}`));\n    return removeInnerTemplateTranslation(message.substring(start, end));\n  }\n}\nfunction icuStart(ast, tView, lView, updateOpCodes, parentIdx, icuExpression, anchorIdx) {\n  ngDevMode && assertDefined(icuExpression, \"ICU expression must be defined\");\n  let bindingMask = 0;\n  const tIcu = {\n    type: icuExpression.type,\n    currentCaseLViewIndex: allocExpando(tView, lView, 1, null),\n    anchorIdx,\n    cases: [],\n    create: [],\n    remove: [],\n    update: []\n  };\n  addUpdateIcuSwitch(updateOpCodes, icuExpression, anchorIdx);\n  setTIcu(tView, anchorIdx, tIcu);\n  const values = icuExpression.values;\n  const cases = [];\n  for (let i = 0; i < values.length; i++) {\n    const valueArr = values[i];\n    const nestedIcus = [];\n    for (let j = 0; j < valueArr.length; j++) {\n      const value = valueArr[j];\n      if (typeof value !== \"string\") {\n        const icuIndex = nestedIcus.push(value) - 1;\n        valueArr[j] = `<!--\\uFFFD${icuIndex}\\uFFFD-->`;\n      }\n    }\n    const caseAst = [];\n    cases.push(caseAst);\n    bindingMask = parseIcuCase(caseAst, tView, tIcu, lView, updateOpCodes, parentIdx, icuExpression.cases[i], valueArr.join(\"\"), nestedIcus) | bindingMask;\n  }\n  if (bindingMask) {\n    addUpdateIcuUpdate(updateOpCodes, bindingMask, anchorIdx);\n  }\n  ast.push({\n    kind: 3,\n    index: anchorIdx,\n    cases,\n    currentCaseLViewIndex: tIcu.currentCaseLViewIndex\n  });\n}\nfunction parseICUBlock(pattern) {\n  const cases = [];\n  const values = [];\n  let icuType = 1;\n  let mainBinding = 0;\n  pattern = pattern.replace(ICU_BLOCK_REGEXP, function(str, binding, type) {\n    if (type === \"select\") {\n      icuType = 0;\n    } else {\n      icuType = 1;\n    }\n    mainBinding = parseInt(binding.slice(1), 10);\n    return \"\";\n  });\n  const parts = i18nParseTextIntoPartsAndICU(pattern);\n  for (let pos = 0; pos < parts.length; ) {\n    let key = parts[pos++].trim();\n    if (icuType === 1) {\n      key = key.replace(/\\s*(?:=)?(\\w+)\\s*/, \"$1\");\n    }\n    if (key.length) {\n      cases.push(key);\n    }\n    const blocks = i18nParseTextIntoPartsAndICU(parts[pos++]);\n    if (cases.length > values.length) {\n      values.push(blocks);\n    }\n  }\n  return {\n    type: icuType,\n    mainBinding,\n    cases,\n    values\n  };\n}\nfunction i18nParseTextIntoPartsAndICU(pattern) {\n  if (!pattern) {\n    return [];\n  }\n  let prevPos = 0;\n  const braceStack = [];\n  const results = [];\n  const braces = /[{}]/g;\n  braces.lastIndex = 0;\n  let match2;\n  while (match2 = braces.exec(pattern)) {\n    const pos = match2.index;\n    if (match2[0] == \"}\") {\n      braceStack.pop();\n      if (braceStack.length == 0) {\n        const block = pattern.substring(prevPos, pos);\n        if (ICU_BLOCK_REGEXP.test(block)) {\n          results.push(parseICUBlock(block));\n        } else {\n          results.push(block);\n        }\n        prevPos = pos + 1;\n      }\n    } else {\n      if (braceStack.length == 0) {\n        const substring2 = pattern.substring(prevPos, pos);\n        results.push(substring2);\n        prevPos = pos + 1;\n      }\n      braceStack.push(\"{\");\n    }\n  }\n  const substring = pattern.substring(prevPos);\n  results.push(substring);\n  return results;\n}\nfunction parseIcuCase(ast, tView, tIcu, lView, updateOpCodes, parentIdx, caseName, unsafeCaseHtml, nestedIcus) {\n  const create = [];\n  const remove2 = [];\n  const update = [];\n  if (ngDevMode) {\n    attachDebugGetter(create, icuCreateOpCodesToString);\n    attachDebugGetter(remove2, i18nRemoveOpCodesToString);\n    attachDebugGetter(update, i18nUpdateOpCodesToString);\n  }\n  tIcu.cases.push(caseName);\n  tIcu.create.push(create);\n  tIcu.remove.push(remove2);\n  tIcu.update.push(update);\n  const inertBodyHelper2 = getInertBodyHelper(getDocument());\n  const inertBodyElement = inertBodyHelper2.getInertBodyElement(unsafeCaseHtml);\n  ngDevMode && assertDefined(inertBodyElement, \"Unable to generate inert body element\");\n  const inertRootNode = getTemplateContent(inertBodyElement) || inertBodyElement;\n  if (inertRootNode) {\n    return walkIcuTree(ast, tView, tIcu, lView, updateOpCodes, create, remove2, update, inertRootNode, parentIdx, nestedIcus, 0);\n  } else {\n    return 0;\n  }\n}\nfunction walkIcuTree(ast, tView, tIcu, lView, sharedUpdateOpCodes, create, remove2, update, parentNode, parentIdx, nestedIcus, depth) {\n  let bindingMask = 0;\n  let currentNode = parentNode.firstChild;\n  while (currentNode) {\n    const newIndex = allocExpando(tView, lView, 1, null);\n    switch (currentNode.nodeType) {\n      case Node.ELEMENT_NODE:\n        const element = currentNode;\n        const tagName = element.tagName.toLowerCase();\n        if (VALID_ELEMENTS.hasOwnProperty(tagName)) {\n          addCreateNodeAndAppend(create, ELEMENT_MARKER, tagName, parentIdx, newIndex);\n          tView.data[newIndex] = tagName;\n          const elAttrs = element.attributes;\n          for (let i = 0; i < elAttrs.length; i++) {\n            const attr = elAttrs.item(i);\n            const lowerAttrName = attr.name.toLowerCase();\n            const hasBinding2 = !!attr.value.match(BINDING_REGEXP);\n            if (hasBinding2) {\n              if (VALID_ATTRS.hasOwnProperty(lowerAttrName)) {\n                if (URI_ATTRS[lowerAttrName]) {\n                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, _sanitizeUrl);\n                } else {\n                  generateBindingUpdateOpCodes(update, attr.value, newIndex, attr.name, 0, null);\n                }\n              } else {\n                ngDevMode && console.warn(`WARNING: ignoring unsafe attribute value ${lowerAttrName} on element ${tagName} (see ${XSS_SECURITY_URL})`);\n              }\n            } else {\n              addCreateAttribute(create, newIndex, attr);\n            }\n          }\n          const elementNode = {\n            kind: 1,\n            index: newIndex,\n            children: []\n          };\n          ast.push(elementNode);\n          bindingMask = walkIcuTree(elementNode.children, tView, tIcu, lView, sharedUpdateOpCodes, create, remove2, update, currentNode, newIndex, nestedIcus, depth + 1) | bindingMask;\n          addRemoveNode(remove2, newIndex, depth);\n        }\n        break;\n      case Node.TEXT_NODE:\n        const value = currentNode.textContent || \"\";\n        const hasBinding = value.match(BINDING_REGEXP);\n        addCreateNodeAndAppend(create, null, hasBinding ? \"\" : value, parentIdx, newIndex);\n        addRemoveNode(remove2, newIndex, depth);\n        if (hasBinding) {\n          bindingMask = generateBindingUpdateOpCodes(update, value, newIndex, null, 0, null) | bindingMask;\n        }\n        ast.push({\n          kind: 0,\n          index: newIndex\n        });\n        break;\n      case Node.COMMENT_NODE:\n        const isNestedIcu = NESTED_ICU.exec(currentNode.textContent || \"\");\n        if (isNestedIcu) {\n          const nestedIcuIndex = parseInt(isNestedIcu[1], 10);\n          const icuExpression = nestedIcus[nestedIcuIndex];\n          addCreateNodeAndAppend(create, ICU_MARKER, ngDevMode ? `nested ICU ${nestedIcuIndex}` : \"\", parentIdx, newIndex);\n          icuStart(ast, tView, lView, sharedUpdateOpCodes, parentIdx, icuExpression, newIndex);\n          addRemoveNestedIcu(remove2, newIndex, depth);\n        }\n        break;\n    }\n    currentNode = currentNode.nextSibling;\n  }\n  return bindingMask;\n}\nfunction addRemoveNode(remove2, index, depth) {\n  if (depth === 0) {\n    remove2.push(index);\n  }\n}\nfunction addRemoveNestedIcu(remove2, index, depth) {\n  if (depth === 0) {\n    remove2.push(~index);\n    remove2.push(index);\n  }\n}\nfunction addUpdateIcuSwitch(update, icuExpression, index) {\n  update.push(\n    toMaskBit(icuExpression.mainBinding),\n    2,\n    -1 - icuExpression.mainBinding,\n    index << 2 | 2\n    /* I18nUpdateOpCode.IcuSwitch */\n  );\n}\nfunction addUpdateIcuUpdate(update, bindingMask, index) {\n  update.push(\n    bindingMask,\n    1,\n    index << 2 | 3\n    /* I18nUpdateOpCode.IcuUpdate */\n  );\n}\nfunction addCreateNodeAndAppend(create, marker, text, appendToParentIdx, createAtIdx) {\n  if (marker !== null) {\n    create.push(marker);\n  }\n  create.push(text, createAtIdx, icuCreateOpCode(0, appendToParentIdx, createAtIdx));\n}\nfunction addCreateAttribute(create, newIndex, attr) {\n  create.push(newIndex << 1 | 1, attr.name, attr.value);\n}\nvar ROOT_TEMPLATE_ID = 0;\nvar PP_MULTI_VALUE_PLACEHOLDERS_REGEXP = /\\[(�.+?�?)\\]/;\nvar PP_PLACEHOLDERS_REGEXP = /\\[(�.+?�?)\\]|(�\\/?\\*\\d+:\\d+�)/g;\nvar PP_ICU_VARS_REGEXP = /({\\s*)(VAR_(PLURAL|SELECT)(_\\d+)?)(\\s*,)/g;\nvar PP_ICU_PLACEHOLDERS_REGEXP = /{([A-Z0-9_]+)}/g;\nvar PP_ICUS_REGEXP = /�I18N_EXP_(ICU(_\\d+)?)�/g;\nvar PP_CLOSE_TEMPLATE_REGEXP = /\\/\\*/;\nvar PP_TEMPLATE_ID_REGEXP = /\\d+\\:(\\d+)/;\nfunction i18nPostprocess(message, replacements = {}) {\n  let result = message;\n  if (PP_MULTI_VALUE_PLACEHOLDERS_REGEXP.test(message)) {\n    const matches = {};\n    const templateIdsStack = [ROOT_TEMPLATE_ID];\n    result = result.replace(PP_PLACEHOLDERS_REGEXP, (m, phs, tmpl) => {\n      const content = phs || tmpl;\n      const placeholders = matches[content] || [];\n      if (!placeholders.length) {\n        content.split(\"|\").forEach((placeholder2) => {\n          const match2 = placeholder2.match(PP_TEMPLATE_ID_REGEXP);\n          const templateId2 = match2 ? parseInt(match2[1], 10) : ROOT_TEMPLATE_ID;\n          const isCloseTemplateTag2 = PP_CLOSE_TEMPLATE_REGEXP.test(placeholder2);\n          placeholders.push([templateId2, isCloseTemplateTag2, placeholder2]);\n        });\n        matches[content] = placeholders;\n      }\n      if (!placeholders.length) {\n        throw new Error(`i18n postprocess: unmatched placeholder - ${content}`);\n      }\n      const currentTemplateId = templateIdsStack[templateIdsStack.length - 1];\n      let idx = 0;\n      for (let i = 0; i < placeholders.length; i++) {\n        if (placeholders[i][0] === currentTemplateId) {\n          idx = i;\n          break;\n        }\n      }\n      const [templateId, isCloseTemplateTag, placeholder] = placeholders[idx];\n      if (isCloseTemplateTag) {\n        templateIdsStack.pop();\n      } else if (currentTemplateId !== templateId) {\n        templateIdsStack.push(templateId);\n      }\n      placeholders.splice(idx, 1);\n      return placeholder;\n    });\n  }\n  if (!Object.keys(replacements).length) {\n    return result;\n  }\n  result = result.replace(PP_ICU_VARS_REGEXP, (match2, start, key, _type, _idx, end) => {\n    return replacements.hasOwnProperty(key) ? `${start}${replacements[key]}${end}` : match2;\n  });\n  result = result.replace(PP_ICU_PLACEHOLDERS_REGEXP, (match2, key) => {\n    return replacements.hasOwnProperty(key) ? replacements[key] : match2;\n  });\n  result = result.replace(PP_ICUS_REGEXP, (match2, key) => {\n    if (replacements.hasOwnProperty(key)) {\n      const list = replacements[key];\n      if (!list.length) {\n        throw new Error(`i18n postprocess: unmatched ICU - ${match2} with key: ${key}`);\n      }\n      return list.shift();\n    }\n    return match2;\n  });\n  return result;\n}\nfunction \\u0275\\u0275i18nStart(index, messageIndex, subTemplateIndex = -1) {\n  const tView = getTView();\n  const lView = getLView();\n  const adjustedIndex = HEADER_OFFSET + index;\n  ngDevMode && assertDefined(tView, `tView should be defined`);\n  const message = getConstant(tView.consts, messageIndex);\n  const parentTNode = getCurrentParentTNode();\n  if (tView.firstCreatePass) {\n    i18nStartFirstCreatePass(tView, parentTNode === null ? 0 : parentTNode.index, lView, adjustedIndex, message, subTemplateIndex);\n  }\n  if (tView.type === 2) {\n    const componentLView = lView[DECLARATION_COMPONENT_VIEW];\n    componentLView[FLAGS] |= 32;\n  } else {\n    lView[FLAGS] |= 32;\n  }\n  const tI18n = tView.data[adjustedIndex];\n  const sameViewParentTNode = parentTNode === lView[T_HOST] ? null : parentTNode;\n  const parentRNode = getClosestRElement(tView, sameViewParentTNode, lView);\n  const insertInFrontOf = parentTNode && parentTNode.type & 8 ? lView[parentTNode.index] : null;\n  prepareI18nBlockForHydration(lView, adjustedIndex, parentTNode, subTemplateIndex);\n  applyCreateOpCodes(lView, tI18n.create, parentRNode, insertInFrontOf);\n  setInI18nBlock(true);\n}\nfunction \\u0275\\u0275i18nEnd() {\n  setInI18nBlock(false);\n}\nfunction \\u0275\\u0275i18n(index, messageIndex, subTemplateIndex) {\n  \\u0275\\u0275i18nStart(index, messageIndex, subTemplateIndex);\n  \\u0275\\u0275i18nEnd();\n}\nfunction \\u0275\\u0275i18nAttributes(index, attrsIndex) {\n  const tView = getTView();\n  ngDevMode && assertDefined(tView, `tView should be defined`);\n  const attrs = getConstant(tView.consts, attrsIndex);\n  i18nAttributesFirstPass(tView, index + HEADER_OFFSET, attrs);\n}\nfunction \\u0275\\u0275i18nExp(value) {\n  const lView = getLView();\n  setMaskBit(bindingUpdated(lView, nextBindingIndex(), value));\n  return \\u0275\\u0275i18nExp;\n}\nfunction \\u0275\\u0275i18nApply(index) {\n  applyI18n(getTView(), getLView(), index + HEADER_OFFSET);\n}\nfunction \\u0275\\u0275i18nPostprocess(message, replacements = {}) {\n  return i18nPostprocess(message, replacements);\n}\nvar stashEventListener = (el, eventName, listenerFn) => {\n};\nfunction \\u0275\\u0275listener(eventName, listenerFn, useCapture, eventTargetResolver) {\n  const lView = getLView();\n  const tView = getTView();\n  const tNode = getCurrentTNode();\n  listenerInternal(tView, lView, lView[RENDERER], tNode, eventName, listenerFn, eventTargetResolver);\n  return \\u0275\\u0275listener;\n}\nfunction \\u0275\\u0275syntheticHostListener(eventName, listenerFn) {\n  const tNode = getCurrentTNode();\n  const lView = getLView();\n  const tView = getTView();\n  const currentDef = getCurrentDirectiveDef(tView.data);\n  const renderer = loadComponentRenderer(currentDef, tNode, lView);\n  listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn);\n  return \\u0275\\u0275syntheticHostListener;\n}\nfunction findExistingListener(tView, lView, eventName, tNodeIdx) {\n  const tCleanup = tView.cleanup;\n  if (tCleanup != null) {\n    for (let i = 0; i < tCleanup.length - 1; i += 2) {\n      const cleanupEventName = tCleanup[i];\n      if (cleanupEventName === eventName && tCleanup[i + 1] === tNodeIdx) {\n        const lCleanup = lView[CLEANUP];\n        const listenerIdxInLCleanup = tCleanup[i + 2];\n        return lCleanup.length > listenerIdxInLCleanup ? lCleanup[listenerIdxInLCleanup] : null;\n      }\n      if (typeof cleanupEventName === \"string\") {\n        i += 2;\n      }\n    }\n  }\n  return null;\n}\nfunction listenerInternal(tView, lView, renderer, tNode, eventName, listenerFn, eventTargetResolver) {\n  const isTNodeDirectiveHost = isDirectiveHost(tNode);\n  const firstCreatePass = tView.firstCreatePass;\n  const tCleanup = firstCreatePass ? getOrCreateTViewCleanup(tView) : null;\n  const context2 = lView[CONTEXT];\n  const lCleanup = getOrCreateLViewCleanup(lView);\n  ngDevMode && assertTNodeType(\n    tNode,\n    3 | 12\n    /* TNodeType.AnyContainer */\n  );\n  let processOutputs = true;\n  if (tNode.type & 3 || eventTargetResolver) {\n    const native = getNativeByTNode(tNode, lView);\n    const target = eventTargetResolver ? eventTargetResolver(native) : native;\n    const lCleanupIndex = lCleanup.length;\n    const idxOrTargetGetter = eventTargetResolver ? (_lView) => eventTargetResolver(unwrapRNode(_lView[tNode.index])) : tNode.index;\n    let existingListener = null;\n    if (!eventTargetResolver && isTNodeDirectiveHost) {\n      existingListener = findExistingListener(tView, lView, eventName, tNode.index);\n    }\n    if (existingListener !== null) {\n      const lastListenerFn = existingListener.__ngLastListenerFn__ || existingListener;\n      lastListenerFn.__ngNextListenerFn__ = listenerFn;\n      existingListener.__ngLastListenerFn__ = listenerFn;\n      processOutputs = false;\n    } else {\n      listenerFn = wrapListener(tNode, lView, context2, listenerFn);\n      stashEventListener(target, eventName, listenerFn);\n      const cleanupFn = renderer.listen(target, eventName, listenerFn);\n      ngDevMode && ngDevMode.rendererAddEventListener++;\n      lCleanup.push(listenerFn, cleanupFn);\n      tCleanup && tCleanup.push(eventName, idxOrTargetGetter, lCleanupIndex, lCleanupIndex + 1);\n    }\n  } else {\n    listenerFn = wrapListener(tNode, lView, context2, listenerFn);\n  }\n  if (processOutputs) {\n    const outputConfig = tNode.outputs?.[eventName];\n    const hostDirectiveOutputConfig = tNode.hostDirectiveOutputs?.[eventName];\n    if (hostDirectiveOutputConfig && hostDirectiveOutputConfig.length) {\n      for (let i = 0; i < hostDirectiveOutputConfig.length; i += 2) {\n        const index = hostDirectiveOutputConfig[i];\n        const lookupName = hostDirectiveOutputConfig[i + 1];\n        listenToOutput(tNode, tView, lView, index, lookupName, eventName, listenerFn, lCleanup, tCleanup);\n      }\n    }\n    if (outputConfig && outputConfig.length) {\n      for (const index of outputConfig) {\n        listenToOutput(tNode, tView, lView, index, eventName, eventName, listenerFn, lCleanup, tCleanup);\n      }\n    }\n  }\n}\nfunction listenToOutput(tNode, tView, lView, index, lookupName, eventName, listenerFn, lCleanup, tCleanup) {\n  ngDevMode && assertIndexInRange(lView, index);\n  const instance = lView[index];\n  const def = tView.data[index];\n  const propertyName = def.outputs[lookupName];\n  const output = instance[propertyName];\n  if (ngDevMode && !isOutputSubscribable(output)) {\n    throw new Error(`@Output ${propertyName} not initialized in '${instance.constructor.name}'.`);\n  }\n  const subscription = output.subscribe(listenerFn);\n  const idx = lCleanup.length;\n  lCleanup.push(listenerFn, subscription);\n  tCleanup && tCleanup.push(eventName, tNode.index, idx, -(idx + 1));\n}\nfunction executeListenerWithErrorHandling(lView, context2, listenerFn, e) {\n  const prevConsumer = setActiveConsumer(null);\n  try {\n    profiler(6, context2, listenerFn);\n    return listenerFn(e) !== false;\n  } catch (error) {\n    handleError(lView, error);\n    return false;\n  } finally {\n    profiler(7, context2, listenerFn);\n    setActiveConsumer(prevConsumer);\n  }\n}\nfunction wrapListener(tNode, lView, context2, listenerFn) {\n  return function wrapListenerIn_markDirtyAndPreventDefault(e) {\n    if (e === Function) {\n      return listenerFn;\n    }\n    const startView = isComponentHost(tNode) ? getComponentLViewByIndex(tNode.index, lView) : lView;\n    markViewDirty(\n      startView,\n      5\n      /* NotificationSource.Listener */\n    );\n    let result = executeListenerWithErrorHandling(lView, context2, listenerFn, e);\n    let nextListenerFn = wrapListenerIn_markDirtyAndPreventDefault.__ngNextListenerFn__;\n    while (nextListenerFn) {\n      result = executeListenerWithErrorHandling(lView, context2, nextListenerFn, e) && result;\n      nextListenerFn = nextListenerFn.__ngNextListenerFn__;\n    }\n    return result;\n  };\n}\nfunction isOutputSubscribable(value) {\n  return value != null && typeof value.subscribe === \"function\";\n}\nfunction \\u0275\\u0275nextContext(level = 1) {\n  return nextContextImpl(level);\n}\nfunction matchingProjectionSlotIndex(tNode, projectionSlots) {\n  let wildcardNgContentIndex = null;\n  const ngProjectAsAttrVal = getProjectAsAttrValue(tNode);\n  for (let i = 0; i < projectionSlots.length; i++) {\n    const slotValue = projectionSlots[i];\n    if (slotValue === \"*\") {\n      wildcardNgContentIndex = i;\n      continue;\n    }\n    if (ngProjectAsAttrVal === null ? isNodeMatchingSelectorList(\n      tNode,\n      slotValue,\n      /* isProjectionMode */\n      true\n    ) : isSelectorInSelectorList(ngProjectAsAttrVal, slotValue)) {\n      return i;\n    }\n  }\n  return wildcardNgContentIndex;\n}\nfunction \\u0275\\u0275projectionDef(projectionSlots) {\n  const componentNode = getLView()[DECLARATION_COMPONENT_VIEW][T_HOST];\n  if (!componentNode.projection) {\n    const numProjectionSlots = projectionSlots ? projectionSlots.length : 1;\n    const projectionHeads = componentNode.projection = newArray(numProjectionSlots, null);\n    const tails = projectionHeads.slice();\n    let componentChild = componentNode.child;\n    while (componentChild !== null) {\n      if (componentChild.type !== 128) {\n        const slotIndex = projectionSlots ? matchingProjectionSlotIndex(componentChild, projectionSlots) : 0;\n        if (slotIndex !== null) {\n          if (tails[slotIndex]) {\n            tails[slotIndex].projectionNext = componentChild;\n          } else {\n            projectionHeads[slotIndex] = componentChild;\n          }\n          tails[slotIndex] = componentChild;\n        }\n      }\n      componentChild = componentChild.next;\n    }\n  }\n}\nfunction \\u0275\\u0275projection(nodeIndex, selectorIndex = 0, attrs, fallbackTemplateFn, fallbackDecls, fallbackVars) {\n  const lView = getLView();\n  const tView = getTView();\n  const fallbackIndex = fallbackTemplateFn ? nodeIndex + 1 : null;\n  if (fallbackIndex !== null) {\n    declareTemplate(lView, tView, fallbackIndex, fallbackTemplateFn, fallbackDecls, fallbackVars, null, attrs);\n  }\n  const tProjectionNode = getOrCreateTNode(tView, HEADER_OFFSET + nodeIndex, 16, null, attrs || null);\n  if (tProjectionNode.projection === null) {\n    tProjectionNode.projection = selectorIndex;\n  }\n  setCurrentTNodeAsNotParent();\n  const hydrationInfo = lView[HYDRATION];\n  const isNodeCreationMode = !hydrationInfo || isInSkipHydrationBlock$1();\n  const componentHostNode = lView[DECLARATION_COMPONENT_VIEW][T_HOST];\n  const isEmpty = componentHostNode.projection[tProjectionNode.projection] === null;\n  if (isEmpty && fallbackIndex !== null) {\n    insertFallbackContent(lView, tView, fallbackIndex);\n  } else if (isNodeCreationMode && !isDetachedByI18n(tProjectionNode)) {\n    applyProjection(tView, lView, tProjectionNode);\n  }\n}\nfunction insertFallbackContent(lView, tView, fallbackIndex) {\n  const adjustedIndex = HEADER_OFFSET + fallbackIndex;\n  const fallbackTNode = tView.data[adjustedIndex];\n  const fallbackLContainer = lView[adjustedIndex];\n  ngDevMode && assertTNode(fallbackTNode);\n  ngDevMode && assertLContainer(fallbackLContainer);\n  const dehydratedView = findMatchingDehydratedView(fallbackLContainer, fallbackTNode.tView.ssrId);\n  const fallbackLView = createAndRenderEmbeddedLView(lView, fallbackTNode, void 0, {\n    dehydratedView\n  });\n  addLViewToLContainer(fallbackLContainer, fallbackLView, 0, shouldAddViewToDom(fallbackTNode, dehydratedView));\n}\nfunction \\u0275\\u0275propertyInterpolate(propName, v0, sanitizer) {\n  \\u0275\\u0275propertyInterpolate1(propName, \"\", v0, \"\", sanitizer);\n  return \\u0275\\u0275propertyInterpolate;\n}\nfunction \\u0275\\u0275propertyInterpolate1(propName, prefix, v0, suffix, sanitizer) {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 1, prefix, suffix);\n  }\n  return \\u0275\\u0275propertyInterpolate1;\n}\nfunction \\u0275\\u0275propertyInterpolate2(propName, prefix, v0, i0, v1, suffix, sanitizer) {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 2, prefix, i0, suffix);\n  }\n  return \\u0275\\u0275propertyInterpolate2;\n}\nfunction \\u0275\\u0275propertyInterpolate3(propName, prefix, v0, i0, v1, i1, v2, suffix, sanitizer) {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 3, prefix, i0, i1, suffix);\n  }\n  return \\u0275\\u0275propertyInterpolate3;\n}\nfunction \\u0275\\u0275propertyInterpolate4(propName, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, sanitizer) {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 4, prefix, i0, i1, i2, suffix);\n  }\n  return \\u0275\\u0275propertyInterpolate4;\n}\nfunction \\u0275\\u0275propertyInterpolate5(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, sanitizer) {\n  const lView = getLView();\n  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 5, prefix, i0, i1, i2, i3, suffix);\n  }\n  return \\u0275\\u0275propertyInterpolate5;\n}\nfunction \\u0275\\u0275propertyInterpolate6(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, sanitizer) {\n  const lView = getLView();\n  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 6, prefix, i0, i1, i2, i3, i4, suffix);\n  }\n  return \\u0275\\u0275propertyInterpolate6;\n}\nfunction \\u0275\\u0275propertyInterpolate7(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, sanitizer) {\n  const lView = getLView();\n  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 7, prefix, i0, i1, i2, i3, i4, i5, suffix);\n  }\n  return \\u0275\\u0275propertyInterpolate7;\n}\nfunction \\u0275\\u0275propertyInterpolate8(propName, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, sanitizer) {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - 8, prefix, i0, i1, i2, i3, i4, i5, i6, suffix);\n  }\n  return \\u0275\\u0275propertyInterpolate8;\n}\nfunction \\u0275\\u0275propertyInterpolateV(propName, values, sanitizer) {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  if (interpolatedValue !== NO_CHANGE) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, interpolatedValue, lView[RENDERER], sanitizer, false);\n    if (ngDevMode) {\n      const interpolationInBetween = [values[0]];\n      for (let i = 2; i < values.length; i += 2) {\n        interpolationInBetween.push(values[i]);\n      }\n      storePropertyBindingMetadata(tView.data, tNode, propName, getBindingIndex() - interpolationInBetween.length + 1, ...interpolationInBetween);\n    }\n  }\n  return \\u0275\\u0275propertyInterpolateV;\n}\nfunction \\u0275\\u0275contentQuery(directiveIndex, predicate, flags, read) {\n  createContentQuery(directiveIndex, predicate, flags, read);\n}\nfunction \\u0275\\u0275viewQuery(predicate, flags, read) {\n  createViewQuery(predicate, flags, read);\n}\nfunction \\u0275\\u0275queryRefresh(queryList) {\n  const lView = getLView();\n  const tView = getTView();\n  const queryIndex = getCurrentQueryIndex();\n  setCurrentQueryIndex(queryIndex + 1);\n  const tQuery = getTQuery(tView, queryIndex);\n  if (queryList.dirty && isCreationMode(lView) === ((tQuery.metadata.flags & 2) === 2)) {\n    if (tQuery.matches === null) {\n      queryList.reset([]);\n    } else {\n      const result = getQueryResults(lView, queryIndex);\n      queryList.reset(result, unwrapElementRef);\n      queryList.notifyOnChanges();\n    }\n    return true;\n  }\n  return false;\n}\nfunction \\u0275\\u0275loadQuery() {\n  return loadQueryInternal(getLView(), getCurrentQueryIndex());\n}\nfunction \\u0275\\u0275contentQuerySignal(directiveIndex, target, predicate, flags, read) {\n  bindQueryToSignal(target, createContentQuery(directiveIndex, predicate, flags, read));\n}\nfunction \\u0275\\u0275viewQuerySignal(target, predicate, flags, read) {\n  bindQueryToSignal(target, createViewQuery(predicate, flags, read));\n}\nfunction \\u0275\\u0275queryAdvance(indexOffset = 1) {\n  setCurrentQueryIndex(getCurrentQueryIndex() + indexOffset);\n}\nfunction store(tView, lView, index, value) {\n  if (index >= tView.data.length) {\n    tView.data[index] = null;\n    tView.blueprint[index] = null;\n  }\n  lView[index] = value;\n}\nfunction \\u0275\\u0275reference(index) {\n  const contextLView = getContextLView();\n  return load(contextLView, HEADER_OFFSET + index);\n}\nfunction \\u0275\\u0275styleMapInterpolate1(prefix, v0, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  \\u0275\\u0275styleMap(interpolatedValue);\n}\nfunction \\u0275\\u0275styleMapInterpolate2(prefix, v0, i0, v1, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  \\u0275\\u0275styleMap(interpolatedValue);\n}\nfunction \\u0275\\u0275styleMapInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  \\u0275\\u0275styleMap(interpolatedValue);\n}\nfunction \\u0275\\u0275styleMapInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  \\u0275\\u0275styleMap(interpolatedValue);\n}\nfunction \\u0275\\u0275styleMapInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  \\u0275\\u0275styleMap(interpolatedValue);\n}\nfunction \\u0275\\u0275styleMapInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  \\u0275\\u0275styleMap(interpolatedValue);\n}\nfunction \\u0275\\u0275styleMapInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  \\u0275\\u0275styleMap(interpolatedValue);\n}\nfunction \\u0275\\u0275styleMapInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  \\u0275\\u0275styleMap(interpolatedValue);\n}\nfunction \\u0275\\u0275styleMapInterpolateV(values) {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  \\u0275\\u0275styleMap(interpolatedValue);\n}\nfunction \\u0275\\u0275stylePropInterpolate1(prop, prefix, v0, suffix, valueSuffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation1(lView, prefix, v0, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return \\u0275\\u0275stylePropInterpolate1;\n}\nfunction \\u0275\\u0275stylePropInterpolate2(prop, prefix, v0, i0, v1, suffix, valueSuffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return \\u0275\\u0275stylePropInterpolate2;\n}\nfunction \\u0275\\u0275stylePropInterpolate3(prop, prefix, v0, i0, v1, i1, v2, suffix, valueSuffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return \\u0275\\u0275stylePropInterpolate3;\n}\nfunction \\u0275\\u0275stylePropInterpolate4(prop, prefix, v0, i0, v1, i1, v2, i2, v3, suffix, valueSuffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return \\u0275\\u0275stylePropInterpolate4;\n}\nfunction \\u0275\\u0275stylePropInterpolate5(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix, valueSuffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return \\u0275\\u0275stylePropInterpolate5;\n}\nfunction \\u0275\\u0275stylePropInterpolate6(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix, valueSuffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return \\u0275\\u0275stylePropInterpolate6;\n}\nfunction \\u0275\\u0275stylePropInterpolate7(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix, valueSuffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return \\u0275\\u0275stylePropInterpolate7;\n}\nfunction \\u0275\\u0275stylePropInterpolate8(prop, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix, valueSuffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return \\u0275\\u0275stylePropInterpolate8;\n}\nfunction \\u0275\\u0275stylePropInterpolateV(prop, values, valueSuffix) {\n  const lView = getLView();\n  const interpolatedValue = interpolationV(lView, values);\n  checkStylingProperty(prop, interpolatedValue, valueSuffix, false);\n  return \\u0275\\u0275stylePropInterpolateV;\n}\nfunction \\u0275\\u0275text(index, value = \"\") {\n  const lView = getLView();\n  const tView = getTView();\n  const adjustedIndex = index + HEADER_OFFSET;\n  ngDevMode && assertEqual(getBindingIndex(), tView.bindingStartIndex, \"text nodes should be created before any bindings\");\n  ngDevMode && assertIndexInRange(lView, adjustedIndex);\n  const tNode = tView.firstCreatePass ? getOrCreateTNode(tView, adjustedIndex, 1, value, null) : tView.data[adjustedIndex];\n  const textNative = _locateOrCreateTextNode(tView, lView, tNode, value, index);\n  lView[adjustedIndex] = textNative;\n  if (wasLastNodeCreated()) {\n    appendChild(tView, lView, textNative, tNode);\n  }\n  setCurrentTNode(tNode, false);\n}\nvar _locateOrCreateTextNode = (tView, lView, tNode, value, index) => {\n  lastNodeWasCreated(true);\n  return createTextNode(lView[RENDERER], value);\n};\nfunction \\u0275\\u0275textInterpolate(v0) {\n  \\u0275\\u0275textInterpolate1(\"\", v0, \"\");\n  return \\u0275\\u0275textInterpolate;\n}\nfunction \\u0275\\u0275textInterpolate1(prefix, v0, suffix) {\n  const lView = getLView();\n  const interpolated = interpolation1(lView, prefix, v0, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated);\n  }\n  return \\u0275\\u0275textInterpolate1;\n}\nfunction \\u0275\\u0275textInterpolate2(prefix, v0, i0, v1, suffix) {\n  const lView = getLView();\n  const interpolated = interpolation2(lView, prefix, v0, i0, v1, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated);\n  }\n  return \\u0275\\u0275textInterpolate2;\n}\nfunction \\u0275\\u0275textInterpolate3(prefix, v0, i0, v1, i1, v2, suffix) {\n  const lView = getLView();\n  const interpolated = interpolation3(lView, prefix, v0, i0, v1, i1, v2, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated);\n  }\n  return \\u0275\\u0275textInterpolate3;\n}\nfunction \\u0275\\u0275textInterpolate4(prefix, v0, i0, v1, i1, v2, i2, v3, suffix) {\n  const lView = getLView();\n  const interpolated = interpolation4(lView, prefix, v0, i0, v1, i1, v2, i2, v3, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated);\n  }\n  return \\u0275\\u0275textInterpolate4;\n}\nfunction \\u0275\\u0275textInterpolate5(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix) {\n  const lView = getLView();\n  const interpolated = interpolation5(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated);\n  }\n  return \\u0275\\u0275textInterpolate5;\n}\nfunction \\u0275\\u0275textInterpolate6(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix) {\n  const lView = getLView();\n  const interpolated = interpolation6(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated);\n  }\n  return \\u0275\\u0275textInterpolate6;\n}\nfunction \\u0275\\u0275textInterpolate7(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix) {\n  const lView = getLView();\n  const interpolated = interpolation7(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated);\n  }\n  return \\u0275\\u0275textInterpolate7;\n}\nfunction \\u0275\\u0275textInterpolate8(prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix) {\n  const lView = getLView();\n  const interpolated = interpolation8(lView, prefix, v0, i0, v1, i1, v2, i2, v3, i3, v4, i4, v5, i5, v6, i6, v7, suffix);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated);\n  }\n  return \\u0275\\u0275textInterpolate8;\n}\nfunction \\u0275\\u0275textInterpolateV(values) {\n  const lView = getLView();\n  const interpolated = interpolationV(lView, values);\n  if (interpolated !== NO_CHANGE) {\n    textBindingInternal(lView, getSelectedIndex(), interpolated);\n  }\n  return \\u0275\\u0275textInterpolateV;\n}\nfunction textBindingInternal(lView, index, value) {\n  ngDevMode && assertString(value, \"Value should be a string\");\n  ngDevMode && assertNotSame(value, NO_CHANGE, \"value should not be NO_CHANGE\");\n  ngDevMode && assertIndexInRange(lView, index);\n  const element = getNativeByIndex(index, lView);\n  ngDevMode && assertDefined(element, \"native element should exist\");\n  updateTextNode(lView[RENDERER], element, value);\n}\nfunction \\u0275\\u0275twoWayProperty(propName, value, sanitizer) {\n  if (isWritableSignal(value)) {\n    value = value();\n  }\n  const lView = getLView();\n  const bindingIndex = nextBindingIndex();\n  if (bindingUpdated(lView, bindingIndex, value)) {\n    const tView = getTView();\n    const tNode = getSelectedTNode();\n    elementPropertyInternal(tView, tNode, lView, propName, value, lView[RENDERER], sanitizer, false);\n    ngDevMode && storePropertyBindingMetadata(tView.data, tNode, propName, bindingIndex);\n  }\n  return \\u0275\\u0275twoWayProperty;\n}\nfunction \\u0275\\u0275twoWayBindingSet(target, value) {\n  const canWrite = isWritableSignal(target);\n  canWrite && target.set(value);\n  return canWrite;\n}\nfunction \\u0275\\u0275twoWayListener(eventName, listenerFn) {\n  const lView = getLView();\n  const tView = getTView();\n  const tNode = getCurrentTNode();\n  listenerInternal(tView, lView, lView[RENDERER], tNode, eventName, listenerFn);\n  return \\u0275\\u0275twoWayListener;\n}\nvar UNINITIALIZED_LET = {};\nfunction \\u0275\\u0275declareLet(index) {\n  const tView = getTView();\n  const lView = getLView();\n  const adjustedIndex = index + HEADER_OFFSET;\n  const tNode = getOrCreateTNode(tView, adjustedIndex, 128, null, null);\n  setCurrentTNode(tNode, false);\n  store(tView, lView, adjustedIndex, UNINITIALIZED_LET);\n  return \\u0275\\u0275declareLet;\n}\nfunction \\u0275\\u0275storeLet(value) {\n  performanceMarkFeature(\"NgLet\");\n  const tView = getTView();\n  const lView = getLView();\n  const index = getSelectedIndex();\n  store(tView, lView, index, value);\n  return value;\n}\nfunction \\u0275\\u0275readContextLet(index) {\n  const contextLView = getContextLView();\n  const value = load(contextLView, HEADER_OFFSET + index);\n  if (value === UNINITIALIZED_LET) {\n    throw new RuntimeError(314, ngDevMode && \"Attempting to access a @let declaration whose value is not available yet\");\n  }\n  return value;\n}\nfunction \\u0275\\u0275attachSourceLocations(templatePath, locations) {\n  const tView = getTView();\n  const lView = getLView();\n  const renderer = lView[RENDERER];\n  const attributeName = \"data-ng-source-location\";\n  for (const [index, offset, line, column] of locations) {\n    const tNode = getTNode(tView, index + HEADER_OFFSET);\n    ngDevMode && assertTNodeType(\n      tNode,\n      2\n      /* TNodeType.Element */\n    );\n    const node = getNativeByIndex(index + HEADER_OFFSET, lView);\n    if (!node.hasAttribute(attributeName)) {\n      const attributeValue = `${templatePath}@o:${offset},l:${line},c:${column}`;\n      renderer.setAttribute(node, attributeName, attributeValue);\n    }\n  }\n}\nfunction providersResolver(def, providers, viewProviders) {\n  const tView = getTView();\n  if (tView.firstCreatePass) {\n    const isComponent3 = isComponentDef(def);\n    resolveProvider(viewProviders, tView.data, tView.blueprint, isComponent3, true);\n    resolveProvider(providers, tView.data, tView.blueprint, isComponent3, false);\n  }\n}\nfunction resolveProvider(provider, tInjectables, lInjectablesBlueprint, isComponent3, isViewProvider) {\n  provider = resolveForwardRef(provider);\n  if (Array.isArray(provider)) {\n    for (let i = 0; i < provider.length; i++) {\n      resolveProvider(provider[i], tInjectables, lInjectablesBlueprint, isComponent3, isViewProvider);\n    }\n  } else {\n    const tView = getTView();\n    const lView = getLView();\n    const tNode = getCurrentTNode();\n    let token = isTypeProvider(provider) ? provider : resolveForwardRef(provider.provide);\n    const providerFactory = providerToFactory(provider);\n    if (ngDevMode) {\n      const injector = new NodeInjector(tNode, lView);\n      runInInjectorProfilerContext(injector, token, () => {\n        emitProviderConfiguredEvent(provider, isViewProvider);\n      });\n    }\n    const beginIndex = tNode.providerIndexes & 1048575;\n    const endIndex = tNode.directiveStart;\n    const cptViewProvidersCount = tNode.providerIndexes >> 20;\n    if (isTypeProvider(provider) || !provider.multi) {\n      const factory = new NodeInjectorFactory(providerFactory, isViewProvider, \\u0275\\u0275directiveInject);\n      const existingFactoryIndex = indexOf(token, tInjectables, isViewProvider ? beginIndex : beginIndex + cptViewProvidersCount, endIndex);\n      if (existingFactoryIndex === -1) {\n        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);\n        registerDestroyHooksIfSupported(tView, provider, tInjectables.length);\n        tInjectables.push(token);\n        tNode.directiveStart++;\n        tNode.directiveEnd++;\n        if (isViewProvider) {\n          tNode.providerIndexes += 1048576;\n        }\n        lInjectablesBlueprint.push(factory);\n        lView.push(factory);\n      } else {\n        lInjectablesBlueprint[existingFactoryIndex] = factory;\n        lView[existingFactoryIndex] = factory;\n      }\n    } else {\n      const existingProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex + cptViewProvidersCount, endIndex);\n      const existingViewProvidersFactoryIndex = indexOf(token, tInjectables, beginIndex, beginIndex + cptViewProvidersCount);\n      const doesProvidersFactoryExist = existingProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingProvidersFactoryIndex];\n      const doesViewProvidersFactoryExist = existingViewProvidersFactoryIndex >= 0 && lInjectablesBlueprint[existingViewProvidersFactoryIndex];\n      if (isViewProvider && !doesViewProvidersFactoryExist || !isViewProvider && !doesProvidersFactoryExist) {\n        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, lView), tView, token);\n        const factory = multiFactory(isViewProvider ? multiViewProvidersFactoryResolver : multiProvidersFactoryResolver, lInjectablesBlueprint.length, isViewProvider, isComponent3, providerFactory);\n        if (!isViewProvider && doesViewProvidersFactoryExist) {\n          lInjectablesBlueprint[existingViewProvidersFactoryIndex].providerFactory = factory;\n        }\n        registerDestroyHooksIfSupported(tView, provider, tInjectables.length, 0);\n        tInjectables.push(token);\n        tNode.directiveStart++;\n        tNode.directiveEnd++;\n        if (isViewProvider) {\n          tNode.providerIndexes += 1048576;\n        }\n        lInjectablesBlueprint.push(factory);\n        lView.push(factory);\n      } else {\n        const indexInFactory = multiFactoryAdd(lInjectablesBlueprint[isViewProvider ? existingViewProvidersFactoryIndex : existingProvidersFactoryIndex], providerFactory, !isViewProvider && isComponent3);\n        registerDestroyHooksIfSupported(tView, provider, existingProvidersFactoryIndex > -1 ? existingProvidersFactoryIndex : existingViewProvidersFactoryIndex, indexInFactory);\n      }\n      if (!isViewProvider && isComponent3 && doesViewProvidersFactoryExist) {\n        lInjectablesBlueprint[existingViewProvidersFactoryIndex].componentProviders++;\n      }\n    }\n  }\n}\nfunction registerDestroyHooksIfSupported(tView, provider, contextIndex, indexInFactory) {\n  const providerIsTypeProvider = isTypeProvider(provider);\n  const providerIsClassProvider = isClassProvider(provider);\n  if (providerIsTypeProvider || providerIsClassProvider) {\n    const classToken = providerIsClassProvider ? resolveForwardRef(provider.useClass) : provider;\n    const prototype = classToken.prototype;\n    const ngOnDestroy = prototype.ngOnDestroy;\n    if (ngOnDestroy) {\n      const hooks = tView.destroyHooks || (tView.destroyHooks = []);\n      if (!providerIsTypeProvider && provider.multi) {\n        ngDevMode && assertDefined(indexInFactory, \"indexInFactory when registering multi factory destroy hook\");\n        const existingCallbacksIndex = hooks.indexOf(contextIndex);\n        if (existingCallbacksIndex === -1) {\n          hooks.push(contextIndex, [indexInFactory, ngOnDestroy]);\n        } else {\n          hooks[existingCallbacksIndex + 1].push(indexInFactory, ngOnDestroy);\n        }\n      } else {\n        hooks.push(contextIndex, ngOnDestroy);\n      }\n    }\n  }\n}\nfunction multiFactoryAdd(multiFactory2, factory, isComponentProvider) {\n  if (isComponentProvider) {\n    multiFactory2.componentProviders++;\n  }\n  return multiFactory2.multi.push(factory) - 1;\n}\nfunction indexOf(item, arr, begin, end) {\n  for (let i = begin; i < end; i++) {\n    if (arr[i] === item) return i;\n  }\n  return -1;\n}\nfunction multiProvidersFactoryResolver(_, tData, lData, tNode) {\n  return multiResolve(this.multi, []);\n}\nfunction multiViewProvidersFactoryResolver(_, tData, lView, tNode) {\n  const factories = this.multi;\n  let result;\n  if (this.providerFactory) {\n    const componentCount = this.providerFactory.componentProviders;\n    const multiProviders = getNodeInjectable(lView, lView[TVIEW], this.providerFactory.index, tNode);\n    result = multiProviders.slice(0, componentCount);\n    multiResolve(factories, result);\n    for (let i = componentCount; i < multiProviders.length; i++) {\n      result.push(multiProviders[i]);\n    }\n  } else {\n    result = [];\n    multiResolve(factories, result);\n  }\n  return result;\n}\nfunction multiResolve(factories, result) {\n  for (let i = 0; i < factories.length; i++) {\n    const factory = factories[i];\n    result.push(factory());\n  }\n  return result;\n}\nfunction multiFactory(factoryFn, index, isViewProvider, isComponent3, f) {\n  const factory = new NodeInjectorFactory(factoryFn, isViewProvider, \\u0275\\u0275directiveInject);\n  factory.multi = [];\n  factory.index = index;\n  factory.componentProviders = 0;\n  multiFactoryAdd(factory, f, isComponent3 && !isViewProvider);\n  return factory;\n}\nfunction \\u0275\\u0275ProvidersFeature(providers, viewProviders = []) {\n  return (definition) => {\n    definition.providersResolver = (def, processProvidersFn) => {\n      return providersResolver(\n        def,\n        //\n        processProvidersFn ? processProvidersFn(providers) : providers,\n        //\n        viewProviders\n      );\n    };\n  };\n}\nfunction \\u0275\\u0275ExternalStylesFeature(styleUrls) {\n  return (definition) => {\n    if (styleUrls.length < 1) {\n      return;\n    }\n    definition.getExternalStyles = (encapsulationId) => {\n      const urls = styleUrls.map((value) => value + \"?ngcomp\" + (encapsulationId ? \"=\" + encodeURIComponent(encapsulationId) : \"\") + \"&e=\" + definition.encapsulation);\n      return urls;\n    };\n  };\n}\nfunction \\u0275\\u0275setComponentScope(type, directives, pipes) {\n  const def = type.\\u0275cmp;\n  def.directiveDefs = extractDefListOrFactory(\n    directives,\n    /* pipeDef */\n    false\n  );\n  def.pipeDefs = extractDefListOrFactory(\n    pipes,\n    /* pipeDef */\n    true\n  );\n}\nfunction \\u0275\\u0275setNgModuleScope(type, scope) {\n  return noSideEffects(() => {\n    const ngModuleDef = getNgModuleDef(type, true);\n    ngModuleDef.declarations = convertToTypeArray(scope.declarations || EMPTY_ARRAY);\n    ngModuleDef.imports = convertToTypeArray(scope.imports || EMPTY_ARRAY);\n    ngModuleDef.exports = convertToTypeArray(scope.exports || EMPTY_ARRAY);\n    if (scope.bootstrap) {\n      ngModuleDef.bootstrap = convertToTypeArray(scope.bootstrap);\n    }\n    depsTracker.registerNgModule(type, scope);\n  });\n}\nfunction convertToTypeArray(values) {\n  if (typeof values === \"function\") {\n    return values;\n  }\n  const flattenValues = flatten(values);\n  if (flattenValues.some(isForwardRef)) {\n    return () => flattenValues.map(resolveForwardRef).map(maybeUnwrapModuleWithProviders);\n  } else {\n    return flattenValues.map(maybeUnwrapModuleWithProviders);\n  }\n}\nfunction maybeUnwrapModuleWithProviders(value) {\n  return isModuleWithProviders(value) ? value.ngModule : value;\n}\nfunction \\u0275\\u0275pureFunction0(slotOffset, pureFn, thisArg) {\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  return lView[bindingIndex] === NO_CHANGE ? updateBinding(lView, bindingIndex, thisArg ? pureFn.call(thisArg) : pureFn()) : getBinding(lView, bindingIndex);\n}\nfunction \\u0275\\u0275pureFunction1(slotOffset, pureFn, exp, thisArg) {\n  return pureFunction1Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp, thisArg);\n}\nfunction \\u0275\\u0275pureFunction2(slotOffset, pureFn, exp1, exp2, thisArg) {\n  return pureFunction2Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, thisArg);\n}\nfunction \\u0275\\u0275pureFunction3(slotOffset, pureFn, exp1, exp2, exp3, thisArg) {\n  return pureFunction3Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, thisArg);\n}\nfunction \\u0275\\u0275pureFunction4(slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {\n  return pureFunction4Internal(getLView(), getBindingRoot(), slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg);\n}\nfunction \\u0275\\u0275pureFunction5(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, thisArg) {\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n  return bindingUpdated(lView, bindingIndex + 4, exp5) || different ? updateBinding(lView, bindingIndex + 5, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5) : pureFn(exp1, exp2, exp3, exp4, exp5)) : getBinding(lView, bindingIndex + 5);\n}\nfunction \\u0275\\u0275pureFunction6(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, thisArg) {\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n  return bindingUpdated2(lView, bindingIndex + 4, exp5, exp6) || different ? updateBinding(lView, bindingIndex + 6, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6)) : getBinding(lView, bindingIndex + 6);\n}\nfunction \\u0275\\u0275pureFunction7(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, thisArg) {\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  let different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n  return bindingUpdated3(lView, bindingIndex + 4, exp5, exp6, exp7) || different ? updateBinding(lView, bindingIndex + 7, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7)) : getBinding(lView, bindingIndex + 7);\n}\nfunction \\u0275\\u0275pureFunction8(slotOffset, pureFn, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8, thisArg) {\n  const bindingIndex = getBindingRoot() + slotOffset;\n  const lView = getLView();\n  const different = bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4);\n  return bindingUpdated4(lView, bindingIndex + 4, exp5, exp6, exp7, exp8) || different ? updateBinding(lView, bindingIndex + 8, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8) : pureFn(exp1, exp2, exp3, exp4, exp5, exp6, exp7, exp8)) : getBinding(lView, bindingIndex + 8);\n}\nfunction \\u0275\\u0275pureFunctionV(slotOffset, pureFn, exps, thisArg) {\n  return pureFunctionVInternal(getLView(), getBindingRoot(), slotOffset, pureFn, exps, thisArg);\n}\nfunction getPureFunctionReturnValue(lView, returnValueIndex) {\n  ngDevMode && assertIndexInRange(lView, returnValueIndex);\n  const lastReturnValue = lView[returnValueIndex];\n  return lastReturnValue === NO_CHANGE ? void 0 : lastReturnValue;\n}\nfunction pureFunction1Internal(lView, bindingRoot, slotOffset, pureFn, exp, thisArg) {\n  const bindingIndex = bindingRoot + slotOffset;\n  return bindingUpdated(lView, bindingIndex, exp) ? updateBinding(lView, bindingIndex + 1, thisArg ? pureFn.call(thisArg, exp) : pureFn(exp)) : getPureFunctionReturnValue(lView, bindingIndex + 1);\n}\nfunction pureFunction2Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, thisArg) {\n  const bindingIndex = bindingRoot + slotOffset;\n  return bindingUpdated2(lView, bindingIndex, exp1, exp2) ? updateBinding(lView, bindingIndex + 2, thisArg ? pureFn.call(thisArg, exp1, exp2) : pureFn(exp1, exp2)) : getPureFunctionReturnValue(lView, bindingIndex + 2);\n}\nfunction pureFunction3Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, thisArg) {\n  const bindingIndex = bindingRoot + slotOffset;\n  return bindingUpdated3(lView, bindingIndex, exp1, exp2, exp3) ? updateBinding(lView, bindingIndex + 3, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3) : pureFn(exp1, exp2, exp3)) : getPureFunctionReturnValue(lView, bindingIndex + 3);\n}\nfunction pureFunction4Internal(lView, bindingRoot, slotOffset, pureFn, exp1, exp2, exp3, exp4, thisArg) {\n  const bindingIndex = bindingRoot + slotOffset;\n  return bindingUpdated4(lView, bindingIndex, exp1, exp2, exp3, exp4) ? updateBinding(lView, bindingIndex + 4, thisArg ? pureFn.call(thisArg, exp1, exp2, exp3, exp4) : pureFn(exp1, exp2, exp3, exp4)) : getPureFunctionReturnValue(lView, bindingIndex + 4);\n}\nfunction pureFunctionVInternal(lView, bindingRoot, slotOffset, pureFn, exps, thisArg) {\n  let bindingIndex = bindingRoot + slotOffset;\n  let different = false;\n  for (let i = 0; i < exps.length; i++) {\n    bindingUpdated(lView, bindingIndex++, exps[i]) && (different = true);\n  }\n  return different ? updateBinding(lView, bindingIndex, pureFn.apply(thisArg, exps)) : getPureFunctionReturnValue(lView, bindingIndex);\n}\nfunction \\u0275\\u0275pipe(index, pipeName) {\n  const tView = getTView();\n  let pipeDef;\n  const adjustedIndex = index + HEADER_OFFSET;\n  if (tView.firstCreatePass) {\n    pipeDef = getPipeDef(pipeName, tView.pipeRegistry);\n    tView.data[adjustedIndex] = pipeDef;\n    if (pipeDef.onDestroy) {\n      (tView.destroyHooks ??= []).push(adjustedIndex, pipeDef.onDestroy);\n    }\n  } else {\n    pipeDef = tView.data[adjustedIndex];\n  }\n  const pipeFactory = pipeDef.factory || (pipeDef.factory = getFactoryDef(pipeDef.type, true));\n  let previousInjectorProfilerContext;\n  if (ngDevMode) {\n    previousInjectorProfilerContext = setInjectorProfilerContext({\n      injector: new NodeInjector(getCurrentTNode(), getLView()),\n      token: pipeDef.type\n    });\n  }\n  const previousInjectImplementation = setInjectImplementation(\\u0275\\u0275directiveInject);\n  try {\n    const previousIncludeViewProviders = setIncludeViewProviders(false);\n    const pipeInstance = pipeFactory();\n    setIncludeViewProviders(previousIncludeViewProviders);\n    store(tView, getLView(), adjustedIndex, pipeInstance);\n    return pipeInstance;\n  } finally {\n    setInjectImplementation(previousInjectImplementation);\n    ngDevMode && setInjectorProfilerContext(previousInjectorProfilerContext);\n  }\n}\nfunction getPipeDef(name, registry) {\n  if (registry) {\n    if (ngDevMode) {\n      const pipes = registry.filter((pipe2) => pipe2.name === name);\n      if (pipes.length > 1) {\n        console.warn(formatRuntimeError(313, getMultipleMatchingPipesMessage(name)));\n      }\n    }\n    for (let i = registry.length - 1; i >= 0; i--) {\n      const pipeDef = registry[i];\n      if (name === pipeDef.name) {\n        return pipeDef;\n      }\n    }\n  }\n  if (ngDevMode) {\n    throw new RuntimeError(-302, getPipeNotFoundErrorMessage(name));\n  }\n  return;\n}\nfunction getMultipleMatchingPipesMessage(name) {\n  const lView = getLView();\n  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];\n  const context2 = declarationLView[CONTEXT];\n  const hostIsStandalone = isHostComponentStandalone(lView);\n  const componentInfoMessage = context2 ? ` in the '${context2.constructor.name}' component` : \"\";\n  const verifyMessage = `check ${hostIsStandalone ? \"'@Component.imports' of this component\" : \"the imports of this module\"}`;\n  const errorMessage = `Multiple pipes match the name \\`${name}\\`${componentInfoMessage}. ${verifyMessage}`;\n  return errorMessage;\n}\nfunction getPipeNotFoundErrorMessage(name) {\n  const lView = getLView();\n  const declarationLView = lView[DECLARATION_COMPONENT_VIEW];\n  const context2 = declarationLView[CONTEXT];\n  const hostIsStandalone = isHostComponentStandalone(lView);\n  const componentInfoMessage = context2 ? ` in the '${context2.constructor.name}' component` : \"\";\n  const verifyMessage = `Verify that it is ${hostIsStandalone ? \"included in the '@Component.imports' of this component\" : \"declared or imported in this module\"}`;\n  const errorMessage = `The pipe '${name}' could not be found${componentInfoMessage}. ${verifyMessage}`;\n  return errorMessage;\n}\nfunction \\u0275\\u0275pipeBind1(index, offset, v1) {\n  const adjustedIndex = index + HEADER_OFFSET;\n  const lView = getLView();\n  const pipeInstance = load(lView, adjustedIndex);\n  return isPure(lView, adjustedIndex) ? pureFunction1Internal(lView, getBindingRoot(), offset, pipeInstance.transform, v1, pipeInstance) : pipeInstance.transform(v1);\n}\nfunction \\u0275\\u0275pipeBind2(index, slotOffset, v1, v2) {\n  const adjustedIndex = index + HEADER_OFFSET;\n  const lView = getLView();\n  const pipeInstance = load(lView, adjustedIndex);\n  return isPure(lView, adjustedIndex) ? pureFunction2Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, pipeInstance) : pipeInstance.transform(v1, v2);\n}\nfunction \\u0275\\u0275pipeBind3(index, slotOffset, v1, v2, v3) {\n  const adjustedIndex = index + HEADER_OFFSET;\n  const lView = getLView();\n  const pipeInstance = load(lView, adjustedIndex);\n  return isPure(lView, adjustedIndex) ? pureFunction3Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, pipeInstance) : pipeInstance.transform(v1, v2, v3);\n}\nfunction \\u0275\\u0275pipeBind4(index, slotOffset, v1, v2, v3, v4) {\n  const adjustedIndex = index + HEADER_OFFSET;\n  const lView = getLView();\n  const pipeInstance = load(lView, adjustedIndex);\n  return isPure(lView, adjustedIndex) ? pureFunction4Internal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, v1, v2, v3, v4, pipeInstance) : pipeInstance.transform(v1, v2, v3, v4);\n}\nfunction \\u0275\\u0275pipeBindV(index, slotOffset, values) {\n  const adjustedIndex = index + HEADER_OFFSET;\n  const lView = getLView();\n  const pipeInstance = load(lView, adjustedIndex);\n  return isPure(lView, adjustedIndex) ? pureFunctionVInternal(lView, getBindingRoot(), slotOffset, pipeInstance.transform, values, pipeInstance) : pipeInstance.transform.apply(pipeInstance, values);\n}\nfunction isPure(lView, index) {\n  return lView[TVIEW].data[index].pure;\n}\nfunction \\u0275\\u0275templateRefExtractor(tNode, lView) {\n  return createTemplateRef(tNode, lView);\n}\nfunction \\u0275\\u0275getComponentDepsFactory(type, rawImports) {\n  return () => {\n    try {\n      return depsTracker.getComponentDependencies(type, rawImports).dependencies;\n    } catch (e) {\n      console.error(`Computing dependencies in local compilation mode for the component \"${type.name}\" failed with the exception:`, e);\n      throw e;\n    }\n  };\n}\nfunction \\u0275setClassDebugInfo(type, debugInfo) {\n  const def = getComponentDef(type);\n  if (def !== null) {\n    def.debugInfo = debugInfo;\n  }\n}\nfunction \\u0275\\u0275replaceMetadata(type, applyMetadata, namespaces, locals, importMeta = null, id = null) {\n  ngDevMode && assertComponentDef(type);\n  const currentDef = getComponentDef(type);\n  applyMetadata.apply(null, [type, namespaces, ...locals]);\n  const {\n    newDef,\n    oldDef\n  } = mergeWithExistingDefinition(currentDef, getComponentDef(type));\n  type[NG_COMP_DEF] = newDef;\n  if (oldDef.tView) {\n    const trackedViews = getTrackedLViews().values();\n    for (const root of trackedViews) {\n      if (isRootView(root) && root[PARENT] === null) {\n        recreateMatchingLViews(importMeta, id, newDef, oldDef, root);\n      }\n    }\n  }\n}\nfunction mergeWithExistingDefinition(currentDef, newDef) {\n  const clone = __spreadValues({}, currentDef);\n  const replacement = Object.assign(currentDef, newDef, {\n    // We need to keep the existing directive and pipe defs, because they can get patched on\n    // by a call to `setComponentScope` from a module file. That call won't make it into the\n    // HMR replacement function, because it lives in an entirely different file.\n    directiveDefs: clone.directiveDefs,\n    pipeDefs: clone.pipeDefs,\n    // Preserve the old `setInput` function, because it has some state.\n    // This is fine, because the component instance is preserved as well.\n    setInput: clone.setInput,\n    // Externally this is redundant since we redeclare the definition using the original type.\n    // Internally we may receive a definition with an alternate, but identical, type so we have\n    // to ensure that the original one is preserved.\n    type: clone.type\n  });\n  ngDevMode && assertEqual(replacement, currentDef, \"Expected definition to be merged in place\");\n  return {\n    newDef: replacement,\n    oldDef: clone\n  };\n}\nfunction recreateMatchingLViews(importMeta, id, newDef, oldDef, rootLView) {\n  ngDevMode && assertDefined(oldDef.tView, \"Expected a component definition that has been instantiated at least once\");\n  const tView = rootLView[TVIEW];\n  if (tView === oldDef.tView) {\n    ngDevMode && assertComponentDef(oldDef.type);\n    recreateLView(importMeta, id, newDef, oldDef, rootLView);\n    return;\n  }\n  for (let i = HEADER_OFFSET; i < tView.bindingStartIndex; i++) {\n    const current = rootLView[i];\n    if (isLContainer(current)) {\n      if (isLView(current[HOST])) {\n        recreateMatchingLViews(importMeta, id, newDef, oldDef, current[HOST]);\n      }\n      for (let j = CONTAINER_HEADER_OFFSET; j < current.length; j++) {\n        recreateMatchingLViews(importMeta, id, newDef, oldDef, current[j]);\n      }\n    } else if (isLView(current)) {\n      recreateMatchingLViews(importMeta, id, newDef, oldDef, current);\n    }\n  }\n}\nfunction clearRendererCache(factory, def) {\n  factory.componentReplaced?.(def.id);\n}\nfunction recreateLView(importMeta, id, newDef, oldDef, lView) {\n  const instance = lView[CONTEXT];\n  let host = lView[HOST];\n  const parentLView = lView[PARENT];\n  ngDevMode && assertLView(parentLView);\n  const tNode = lView[T_HOST];\n  ngDevMode && assertTNodeType(\n    tNode,\n    2\n    /* TNodeType.Element */\n  );\n  ngDevMode && assertNotEqual(newDef, oldDef, \"Expected different component definition\");\n  const zone = lView[INJECTOR].get(NgZone, null);\n  const recreate = () => {\n    if (oldDef.encapsulation === ViewEncapsulation.ShadowDom) {\n      const newHost = host.cloneNode(false);\n      host.replaceWith(newHost);\n      host = newHost;\n    }\n    const newTView = getOrCreateComponentTView(newDef);\n    const newLView = createLView(\n      parentLView,\n      newTView,\n      instance,\n      getInitialLViewFlagsFromDef(newDef),\n      host,\n      tNode,\n      null,\n      null,\n      // The renderer will be created a bit further down once the old one is destroyed.\n      null,\n      null,\n      null\n    );\n    replaceLViewInTree(parentLView, lView, newLView, tNode.index);\n    destroyLView(lView[TVIEW], lView);\n    const rendererFactory = lView[ENVIRONMENT].rendererFactory;\n    clearRendererCache(rendererFactory, oldDef);\n    newLView[RENDERER] = rendererFactory.createRenderer(host, newDef);\n    removeViewFromDOM(lView[TVIEW], lView);\n    resetProjectionState(tNode);\n    renderView(newTView, newLView, instance);\n    refreshView(newTView, newLView, newTView.template, instance);\n  };\n  if (zone === null) {\n    executeWithInvalidateFallback(importMeta, id, recreate);\n  } else {\n    zone.run(() => executeWithInvalidateFallback(importMeta, id, recreate));\n  }\n}\nfunction executeWithInvalidateFallback(importMeta, id, callback) {\n  try {\n    callback();\n  } catch (e) {\n    const error = e;\n    if (id !== null && error.message) {\n      const toLog = error.message + (error.stack ? \"\\n\" + error.stack : \"\");\n      importMeta?.hot?.send?.(\"angular:invalidate\", {\n        id,\n        message: toLog,\n        error: true\n      });\n    }\n    throw e;\n  }\n}\nfunction replaceLViewInTree(parentLView, oldLView, newLView, index) {\n  for (let i = HEADER_OFFSET; i < parentLView[TVIEW].bindingStartIndex; i++) {\n    const current = parentLView[i];\n    if ((isLView(current) || isLContainer(current)) && current[NEXT] === oldLView) {\n      current[NEXT] = newLView;\n      break;\n    }\n  }\n  if (parentLView[CHILD_HEAD] === oldLView) {\n    parentLView[CHILD_HEAD] = newLView;\n  }\n  if (parentLView[CHILD_TAIL] === oldLView) {\n    parentLView[CHILD_TAIL] = newLView;\n  }\n  newLView[NEXT] = oldLView[NEXT];\n  oldLView[NEXT] = null;\n  parentLView[index] = newLView;\n}\nfunction resetProjectionState(tNode) {\n  if (tNode.projection !== null) {\n    for (const current of tNode.projection) {\n      if (isTNodeShape(current)) {\n        current.projectionNext = null;\n        current.flags &= -3;\n      }\n    }\n    tNode.projection = null;\n  }\n}\nvar angularCoreEnv = /* @__PURE__ */ (() => ({\n  \"\\u0275\\u0275attribute\": \\u0275\\u0275attribute,\n  \"\\u0275\\u0275attributeInterpolate1\": \\u0275\\u0275attributeInterpolate1,\n  \"\\u0275\\u0275attributeInterpolate2\": \\u0275\\u0275attributeInterpolate2,\n  \"\\u0275\\u0275attributeInterpolate3\": \\u0275\\u0275attributeInterpolate3,\n  \"\\u0275\\u0275attributeInterpolate4\": \\u0275\\u0275attributeInterpolate4,\n  \"\\u0275\\u0275attributeInterpolate5\": \\u0275\\u0275attributeInterpolate5,\n  \"\\u0275\\u0275attributeInterpolate6\": \\u0275\\u0275attributeInterpolate6,\n  \"\\u0275\\u0275attributeInterpolate7\": \\u0275\\u0275attributeInterpolate7,\n  \"\\u0275\\u0275attributeInterpolate8\": \\u0275\\u0275attributeInterpolate8,\n  \"\\u0275\\u0275attributeInterpolateV\": \\u0275\\u0275attributeInterpolateV,\n  \"\\u0275\\u0275defineComponent\": \\u0275\\u0275defineComponent,\n  \"\\u0275\\u0275defineDirective\": \\u0275\\u0275defineDirective,\n  \"\\u0275\\u0275defineInjectable\": \\u0275\\u0275defineInjectable,\n  \"\\u0275\\u0275defineInjector\": \\u0275\\u0275defineInjector,\n  \"\\u0275\\u0275defineNgModule\": \\u0275\\u0275defineNgModule,\n  \"\\u0275\\u0275definePipe\": \\u0275\\u0275definePipe,\n  \"\\u0275\\u0275directiveInject\": \\u0275\\u0275directiveInject,\n  \"\\u0275\\u0275getInheritedFactory\": \\u0275\\u0275getInheritedFactory,\n  \"\\u0275\\u0275inject\": \\u0275\\u0275inject,\n  \"\\u0275\\u0275injectAttribute\": \\u0275\\u0275injectAttribute,\n  \"\\u0275\\u0275invalidFactory\": \\u0275\\u0275invalidFactory,\n  \"\\u0275\\u0275invalidFactoryDep\": \\u0275\\u0275invalidFactoryDep,\n  \"\\u0275\\u0275templateRefExtractor\": \\u0275\\u0275templateRefExtractor,\n  \"\\u0275\\u0275resetView\": \\u0275\\u0275resetView,\n  \"\\u0275\\u0275HostDirectivesFeature\": \\u0275\\u0275HostDirectivesFeature,\n  \"\\u0275\\u0275NgOnChangesFeature\": \\u0275\\u0275NgOnChangesFeature,\n  \"\\u0275\\u0275ProvidersFeature\": \\u0275\\u0275ProvidersFeature,\n  \"\\u0275\\u0275CopyDefinitionFeature\": \\u0275\\u0275CopyDefinitionFeature,\n  \"\\u0275\\u0275InheritDefinitionFeature\": \\u0275\\u0275InheritDefinitionFeature,\n  \"\\u0275\\u0275ExternalStylesFeature\": \\u0275\\u0275ExternalStylesFeature,\n  \"\\u0275\\u0275nextContext\": \\u0275\\u0275nextContext,\n  \"\\u0275\\u0275namespaceHTML\": \\u0275\\u0275namespaceHTML,\n  \"\\u0275\\u0275namespaceMathML\": \\u0275\\u0275namespaceMathML,\n  \"\\u0275\\u0275namespaceSVG\": \\u0275\\u0275namespaceSVG,\n  \"\\u0275\\u0275enableBindings\": \\u0275\\u0275enableBindings,\n  \"\\u0275\\u0275disableBindings\": \\u0275\\u0275disableBindings,\n  \"\\u0275\\u0275elementStart\": \\u0275\\u0275elementStart,\n  \"\\u0275\\u0275elementEnd\": \\u0275\\u0275elementEnd,\n  \"\\u0275\\u0275element\": \\u0275\\u0275element,\n  \"\\u0275\\u0275elementContainerStart\": \\u0275\\u0275elementContainerStart,\n  \"\\u0275\\u0275elementContainerEnd\": \\u0275\\u0275elementContainerEnd,\n  \"\\u0275\\u0275elementContainer\": \\u0275\\u0275elementContainer,\n  \"\\u0275\\u0275pureFunction0\": \\u0275\\u0275pureFunction0,\n  \"\\u0275\\u0275pureFunction1\": \\u0275\\u0275pureFunction1,\n  \"\\u0275\\u0275pureFunction2\": \\u0275\\u0275pureFunction2,\n  \"\\u0275\\u0275pureFunction3\": \\u0275\\u0275pureFunction3,\n  \"\\u0275\\u0275pureFunction4\": \\u0275\\u0275pureFunction4,\n  \"\\u0275\\u0275pureFunction5\": \\u0275\\u0275pureFunction5,\n  \"\\u0275\\u0275pureFunction6\": \\u0275\\u0275pureFunction6,\n  \"\\u0275\\u0275pureFunction7\": \\u0275\\u0275pureFunction7,\n  \"\\u0275\\u0275pureFunction8\": \\u0275\\u0275pureFunction8,\n  \"\\u0275\\u0275pureFunctionV\": \\u0275\\u0275pureFunctionV,\n  \"\\u0275\\u0275getCurrentView\": \\u0275\\u0275getCurrentView,\n  \"\\u0275\\u0275restoreView\": \\u0275\\u0275restoreView,\n  \"\\u0275\\u0275listener\": \\u0275\\u0275listener,\n  \"\\u0275\\u0275projection\": \\u0275\\u0275projection,\n  \"\\u0275\\u0275syntheticHostProperty\": \\u0275\\u0275syntheticHostProperty,\n  \"\\u0275\\u0275syntheticHostListener\": \\u0275\\u0275syntheticHostListener,\n  \"\\u0275\\u0275pipeBind1\": \\u0275\\u0275pipeBind1,\n  \"\\u0275\\u0275pipeBind2\": \\u0275\\u0275pipeBind2,\n  \"\\u0275\\u0275pipeBind3\": \\u0275\\u0275pipeBind3,\n  \"\\u0275\\u0275pipeBind4\": \\u0275\\u0275pipeBind4,\n  \"\\u0275\\u0275pipeBindV\": \\u0275\\u0275pipeBindV,\n  \"\\u0275\\u0275projectionDef\": \\u0275\\u0275projectionDef,\n  \"\\u0275\\u0275hostProperty\": \\u0275\\u0275hostProperty,\n  \"\\u0275\\u0275property\": \\u0275\\u0275property,\n  \"\\u0275\\u0275propertyInterpolate\": \\u0275\\u0275propertyInterpolate,\n  \"\\u0275\\u0275propertyInterpolate1\": \\u0275\\u0275propertyInterpolate1,\n  \"\\u0275\\u0275propertyInterpolate2\": \\u0275\\u0275propertyInterpolate2,\n  \"\\u0275\\u0275propertyInterpolate3\": \\u0275\\u0275propertyInterpolate3,\n  \"\\u0275\\u0275propertyInterpolate4\": \\u0275\\u0275propertyInterpolate4,\n  \"\\u0275\\u0275propertyInterpolate5\": \\u0275\\u0275propertyInterpolate5,\n  \"\\u0275\\u0275propertyInterpolate6\": \\u0275\\u0275propertyInterpolate6,\n  \"\\u0275\\u0275propertyInterpolate7\": \\u0275\\u0275propertyInterpolate7,\n  \"\\u0275\\u0275propertyInterpolate8\": \\u0275\\u0275propertyInterpolate8,\n  \"\\u0275\\u0275propertyInterpolateV\": \\u0275\\u0275propertyInterpolateV,\n  \"\\u0275\\u0275pipe\": \\u0275\\u0275pipe,\n  \"\\u0275\\u0275queryRefresh\": \\u0275\\u0275queryRefresh,\n  \"\\u0275\\u0275queryAdvance\": \\u0275\\u0275queryAdvance,\n  \"\\u0275\\u0275viewQuery\": \\u0275\\u0275viewQuery,\n  \"\\u0275\\u0275viewQuerySignal\": \\u0275\\u0275viewQuerySignal,\n  \"\\u0275\\u0275loadQuery\": \\u0275\\u0275loadQuery,\n  \"\\u0275\\u0275contentQuery\": \\u0275\\u0275contentQuery,\n  \"\\u0275\\u0275contentQuerySignal\": \\u0275\\u0275contentQuerySignal,\n  \"\\u0275\\u0275reference\": \\u0275\\u0275reference,\n  \"\\u0275\\u0275classMap\": \\u0275\\u0275classMap,\n  \"\\u0275\\u0275classMapInterpolate1\": \\u0275\\u0275classMapInterpolate1,\n  \"\\u0275\\u0275classMapInterpolate2\": \\u0275\\u0275classMapInterpolate2,\n  \"\\u0275\\u0275classMapInterpolate3\": \\u0275\\u0275classMapInterpolate3,\n  \"\\u0275\\u0275classMapInterpolate4\": \\u0275\\u0275classMapInterpolate4,\n  \"\\u0275\\u0275classMapInterpolate5\": \\u0275\\u0275classMapInterpolate5,\n  \"\\u0275\\u0275classMapInterpolate6\": \\u0275\\u0275classMapInterpolate6,\n  \"\\u0275\\u0275classMapInterpolate7\": \\u0275\\u0275classMapInterpolate7,\n  \"\\u0275\\u0275classMapInterpolate8\": \\u0275\\u0275classMapInterpolate8,\n  \"\\u0275\\u0275classMapInterpolateV\": \\u0275\\u0275classMapInterpolateV,\n  \"\\u0275\\u0275styleMap\": \\u0275\\u0275styleMap,\n  \"\\u0275\\u0275styleMapInterpolate1\": \\u0275\\u0275styleMapInterpolate1,\n  \"\\u0275\\u0275styleMapInterpolate2\": \\u0275\\u0275styleMapInterpolate2,\n  \"\\u0275\\u0275styleMapInterpolate3\": \\u0275\\u0275styleMapInterpolate3,\n  \"\\u0275\\u0275styleMapInterpolate4\": \\u0275\\u0275styleMapInterpolate4,\n  \"\\u0275\\u0275styleMapInterpolate5\": \\u0275\\u0275styleMapInterpolate5,\n  \"\\u0275\\u0275styleMapInterpolate6\": \\u0275\\u0275styleMapInterpolate6,\n  \"\\u0275\\u0275styleMapInterpolate7\": \\u0275\\u0275styleMapInterpolate7,\n  \"\\u0275\\u0275styleMapInterpolate8\": \\u0275\\u0275styleMapInterpolate8,\n  \"\\u0275\\u0275styleMapInterpolateV\": \\u0275\\u0275styleMapInterpolateV,\n  \"\\u0275\\u0275styleProp\": \\u0275\\u0275styleProp,\n  \"\\u0275\\u0275stylePropInterpolate1\": \\u0275\\u0275stylePropInterpolate1,\n  \"\\u0275\\u0275stylePropInterpolate2\": \\u0275\\u0275stylePropInterpolate2,\n  \"\\u0275\\u0275stylePropInterpolate3\": \\u0275\\u0275stylePropInterpolate3,\n  \"\\u0275\\u0275stylePropInterpolate4\": \\u0275\\u0275stylePropInterpolate4,\n  \"\\u0275\\u0275stylePropInterpolate5\": \\u0275\\u0275stylePropInterpolate5,\n  \"\\u0275\\u0275stylePropInterpolate6\": \\u0275\\u0275stylePropInterpolate6,\n  \"\\u0275\\u0275stylePropInterpolate7\": \\u0275\\u0275stylePropInterpolate7,\n  \"\\u0275\\u0275stylePropInterpolate8\": \\u0275\\u0275stylePropInterpolate8,\n  \"\\u0275\\u0275stylePropInterpolateV\": \\u0275\\u0275stylePropInterpolateV,\n  \"\\u0275\\u0275classProp\": \\u0275\\u0275classProp,\n  \"\\u0275\\u0275advance\": \\u0275\\u0275advance,\n  \"\\u0275\\u0275template\": \\u0275\\u0275template,\n  \"\\u0275\\u0275conditional\": \\u0275\\u0275conditional,\n  \"\\u0275\\u0275defer\": \\u0275\\u0275defer,\n  \"\\u0275\\u0275deferWhen\": \\u0275\\u0275deferWhen,\n  \"\\u0275\\u0275deferOnIdle\": \\u0275\\u0275deferOnIdle,\n  \"\\u0275\\u0275deferOnImmediate\": \\u0275\\u0275deferOnImmediate,\n  \"\\u0275\\u0275deferOnTimer\": \\u0275\\u0275deferOnTimer,\n  \"\\u0275\\u0275deferOnHover\": \\u0275\\u0275deferOnHover,\n  \"\\u0275\\u0275deferOnInteraction\": \\u0275\\u0275deferOnInteraction,\n  \"\\u0275\\u0275deferOnViewport\": \\u0275\\u0275deferOnViewport,\n  \"\\u0275\\u0275deferPrefetchWhen\": \\u0275\\u0275deferPrefetchWhen,\n  \"\\u0275\\u0275deferPrefetchOnIdle\": \\u0275\\u0275deferPrefetchOnIdle,\n  \"\\u0275\\u0275deferPrefetchOnImmediate\": \\u0275\\u0275deferPrefetchOnImmediate,\n  \"\\u0275\\u0275deferPrefetchOnTimer\": \\u0275\\u0275deferPrefetchOnTimer,\n  \"\\u0275\\u0275deferPrefetchOnHover\": \\u0275\\u0275deferPrefetchOnHover,\n  \"\\u0275\\u0275deferPrefetchOnInteraction\": \\u0275\\u0275deferPrefetchOnInteraction,\n  \"\\u0275\\u0275deferPrefetchOnViewport\": \\u0275\\u0275deferPrefetchOnViewport,\n  \"\\u0275\\u0275deferHydrateWhen\": \\u0275\\u0275deferHydrateWhen,\n  \"\\u0275\\u0275deferHydrateNever\": \\u0275\\u0275deferHydrateNever,\n  \"\\u0275\\u0275deferHydrateOnIdle\": \\u0275\\u0275deferHydrateOnIdle,\n  \"\\u0275\\u0275deferHydrateOnImmediate\": \\u0275\\u0275deferHydrateOnImmediate,\n  \"\\u0275\\u0275deferHydrateOnTimer\": \\u0275\\u0275deferHydrateOnTimer,\n  \"\\u0275\\u0275deferHydrateOnHover\": \\u0275\\u0275deferHydrateOnHover,\n  \"\\u0275\\u0275deferHydrateOnInteraction\": \\u0275\\u0275deferHydrateOnInteraction,\n  \"\\u0275\\u0275deferHydrateOnViewport\": \\u0275\\u0275deferHydrateOnViewport,\n  \"\\u0275\\u0275deferEnableTimerScheduling\": \\u0275\\u0275deferEnableTimerScheduling,\n  \"\\u0275\\u0275repeater\": \\u0275\\u0275repeater,\n  \"\\u0275\\u0275repeaterCreate\": \\u0275\\u0275repeaterCreate,\n  \"\\u0275\\u0275repeaterTrackByIndex\": \\u0275\\u0275repeaterTrackByIndex,\n  \"\\u0275\\u0275repeaterTrackByIdentity\": \\u0275\\u0275repeaterTrackByIdentity,\n  \"\\u0275\\u0275componentInstance\": \\u0275\\u0275componentInstance,\n  \"\\u0275\\u0275text\": \\u0275\\u0275text,\n  \"\\u0275\\u0275textInterpolate\": \\u0275\\u0275textInterpolate,\n  \"\\u0275\\u0275textInterpolate1\": \\u0275\\u0275textInterpolate1,\n  \"\\u0275\\u0275textInterpolate2\": \\u0275\\u0275textInterpolate2,\n  \"\\u0275\\u0275textInterpolate3\": \\u0275\\u0275textInterpolate3,\n  \"\\u0275\\u0275textInterpolate4\": \\u0275\\u0275textInterpolate4,\n  \"\\u0275\\u0275textInterpolate5\": \\u0275\\u0275textInterpolate5,\n  \"\\u0275\\u0275textInterpolate6\": \\u0275\\u0275textInterpolate6,\n  \"\\u0275\\u0275textInterpolate7\": \\u0275\\u0275textInterpolate7,\n  \"\\u0275\\u0275textInterpolate8\": \\u0275\\u0275textInterpolate8,\n  \"\\u0275\\u0275textInterpolateV\": \\u0275\\u0275textInterpolateV,\n  \"\\u0275\\u0275i18n\": \\u0275\\u0275i18n,\n  \"\\u0275\\u0275i18nAttributes\": \\u0275\\u0275i18nAttributes,\n  \"\\u0275\\u0275i18nExp\": \\u0275\\u0275i18nExp,\n  \"\\u0275\\u0275i18nStart\": \\u0275\\u0275i18nStart,\n  \"\\u0275\\u0275i18nEnd\": \\u0275\\u0275i18nEnd,\n  \"\\u0275\\u0275i18nApply\": \\u0275\\u0275i18nApply,\n  \"\\u0275\\u0275i18nPostprocess\": \\u0275\\u0275i18nPostprocess,\n  \"\\u0275\\u0275resolveWindow\": \\u0275\\u0275resolveWindow,\n  \"\\u0275\\u0275resolveDocument\": \\u0275\\u0275resolveDocument,\n  \"\\u0275\\u0275resolveBody\": \\u0275\\u0275resolveBody,\n  \"\\u0275\\u0275setComponentScope\": \\u0275\\u0275setComponentScope,\n  \"\\u0275\\u0275setNgModuleScope\": \\u0275\\u0275setNgModuleScope,\n  \"\\u0275\\u0275registerNgModuleType\": registerNgModuleType,\n  \"\\u0275\\u0275getComponentDepsFactory\": \\u0275\\u0275getComponentDepsFactory,\n  \"\\u0275setClassDebugInfo\": \\u0275setClassDebugInfo,\n  \"\\u0275\\u0275declareLet\": \\u0275\\u0275declareLet,\n  \"\\u0275\\u0275storeLet\": \\u0275\\u0275storeLet,\n  \"\\u0275\\u0275readContextLet\": \\u0275\\u0275readContextLet,\n  \"\\u0275\\u0275attachSourceLocations\": \\u0275\\u0275attachSourceLocations,\n  \"\\u0275\\u0275sanitizeHtml\": \\u0275\\u0275sanitizeHtml,\n  \"\\u0275\\u0275sanitizeStyle\": \\u0275\\u0275sanitizeStyle,\n  \"\\u0275\\u0275sanitizeResourceUrl\": \\u0275\\u0275sanitizeResourceUrl,\n  \"\\u0275\\u0275sanitizeScript\": \\u0275\\u0275sanitizeScript,\n  \"\\u0275\\u0275sanitizeUrl\": \\u0275\\u0275sanitizeUrl,\n  \"\\u0275\\u0275sanitizeUrlOrResourceUrl\": \\u0275\\u0275sanitizeUrlOrResourceUrl,\n  \"\\u0275\\u0275trustConstantHtml\": \\u0275\\u0275trustConstantHtml,\n  \"\\u0275\\u0275trustConstantResourceUrl\": \\u0275\\u0275trustConstantResourceUrl,\n  \"\\u0275\\u0275validateIframeAttribute\": \\u0275\\u0275validateIframeAttribute,\n  \"forwardRef\": forwardRef,\n  \"resolveForwardRef\": resolveForwardRef,\n  \"\\u0275\\u0275twoWayProperty\": \\u0275\\u0275twoWayProperty,\n  \"\\u0275\\u0275twoWayBindingSet\": \\u0275\\u0275twoWayBindingSet,\n  \"\\u0275\\u0275twoWayListener\": \\u0275\\u0275twoWayListener,\n  \"\\u0275\\u0275replaceMetadata\": \\u0275\\u0275replaceMetadata\n}))();\nvar jitOptions = null;\nfunction setJitOptions(options) {\n  if (jitOptions !== null) {\n    if (options.defaultEncapsulation !== jitOptions.defaultEncapsulation) {\n      ngDevMode && console.error(\"Provided value for `defaultEncapsulation` can not be changed once it has been set.\");\n      return;\n    }\n    if (options.preserveWhitespaces !== jitOptions.preserveWhitespaces) {\n      ngDevMode && console.error(\"Provided value for `preserveWhitespaces` can not be changed once it has been set.\");\n      return;\n    }\n  }\n  jitOptions = options;\n}\nfunction getJitOptions() {\n  return jitOptions;\n}\nvar moduleQueue = [];\nfunction enqueueModuleForDelayedScoping(moduleType, ngModule) {\n  moduleQueue.push({\n    moduleType,\n    ngModule\n  });\n}\nvar flushingModuleQueue = false;\nfunction flushModuleScopingQueueAsMuchAsPossible() {\n  if (!flushingModuleQueue) {\n    flushingModuleQueue = true;\n    try {\n      for (let i = moduleQueue.length - 1; i >= 0; i--) {\n        const {\n          moduleType,\n          ngModule\n        } = moduleQueue[i];\n        if (ngModule.declarations && ngModule.declarations.every(isResolvedDeclaration)) {\n          moduleQueue.splice(i, 1);\n          setScopeOnDeclaredComponents(moduleType, ngModule);\n        }\n      }\n    } finally {\n      flushingModuleQueue = false;\n    }\n  }\n}\nfunction isResolvedDeclaration(declaration) {\n  if (Array.isArray(declaration)) {\n    return declaration.every(isResolvedDeclaration);\n  }\n  return !!resolveForwardRef(declaration);\n}\nfunction compileNgModule(moduleType, ngModule = {}) {\n  compileNgModuleDefs(moduleType, ngModule);\n  if (ngModule.id !== void 0) {\n    registerNgModuleType(moduleType, ngModule.id);\n  }\n  enqueueModuleForDelayedScoping(moduleType, ngModule);\n}\nfunction compileNgModuleDefs(moduleType, ngModule, allowDuplicateDeclarationsInRoot = false) {\n  ngDevMode && assertDefined(moduleType, \"Required value moduleType\");\n  ngDevMode && assertDefined(ngModule, \"Required value ngModule\");\n  const declarations = flatten(ngModule.declarations || EMPTY_ARRAY);\n  let ngModuleDef = null;\n  Object.defineProperty(moduleType, NG_MOD_DEF, {\n    configurable: true,\n    get: () => {\n      if (ngModuleDef === null) {\n        if (ngDevMode && ngModule.imports && ngModule.imports.indexOf(moduleType) > -1) {\n          throw new Error(`'${stringifyForError(moduleType)}' module can't import itself`);\n        }\n        const compiler = getCompilerFacade({\n          usage: 0,\n          kind: \"NgModule\",\n          type: moduleType\n        });\n        ngModuleDef = compiler.compileNgModule(angularCoreEnv, `ng:///${moduleType.name}/\\u0275mod.js`, {\n          type: moduleType,\n          bootstrap: flatten(ngModule.bootstrap || EMPTY_ARRAY).map(resolveForwardRef),\n          declarations: declarations.map(resolveForwardRef),\n          imports: flatten(ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),\n          exports: flatten(ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef).map(expandModuleWithProviders),\n          schemas: ngModule.schemas ? flatten(ngModule.schemas) : null,\n          id: ngModule.id || null\n        });\n        if (!ngModuleDef.schemas) {\n          ngModuleDef.schemas = [];\n        }\n      }\n      return ngModuleDef;\n    }\n  });\n  let ngFactoryDef = null;\n  Object.defineProperty(moduleType, NG_FACTORY_DEF, {\n    get: () => {\n      if (ngFactoryDef === null) {\n        const compiler = getCompilerFacade({\n          usage: 0,\n          kind: \"NgModule\",\n          type: moduleType\n        });\n        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${moduleType.name}/\\u0275fac.js`, {\n          name: moduleType.name,\n          type: moduleType,\n          deps: reflectDependencies(moduleType),\n          target: compiler.FactoryTarget.NgModule,\n          typeArgumentCount: 0\n        });\n      }\n      return ngFactoryDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode\n  });\n  let ngInjectorDef = null;\n  Object.defineProperty(moduleType, NG_INJ_DEF, {\n    get: () => {\n      if (ngInjectorDef === null) {\n        ngDevMode && verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot);\n        const meta = {\n          name: moduleType.name,\n          type: moduleType,\n          providers: ngModule.providers || EMPTY_ARRAY,\n          imports: [(ngModule.imports || EMPTY_ARRAY).map(resolveForwardRef), (ngModule.exports || EMPTY_ARRAY).map(resolveForwardRef)]\n        };\n        const compiler = getCompilerFacade({\n          usage: 0,\n          kind: \"NgModule\",\n          type: moduleType\n        });\n        ngInjectorDef = compiler.compileInjector(angularCoreEnv, `ng:///${moduleType.name}/\\u0275inj.js`, meta);\n      }\n      return ngInjectorDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode\n  });\n}\nfunction generateStandaloneInDeclarationsError(type, location2) {\n  const prefix = `Unexpected \"${stringifyForError(type)}\" found in the \"declarations\" array of the`;\n  const suffix = `\"${stringifyForError(type)}\" is marked as standalone and can't be declared in any NgModule - did you intend to import it instead (by adding it to the \"imports\" array)?`;\n  return `${prefix} ${location2}, ${suffix}`;\n}\nfunction verifySemanticsOfNgModuleDef(moduleType, allowDuplicateDeclarationsInRoot, importingModule) {\n  if (verifiedNgModule.get(moduleType)) return;\n  if (isStandalone(moduleType)) return;\n  verifiedNgModule.set(moduleType, true);\n  moduleType = resolveForwardRef(moduleType);\n  let ngModuleDef;\n  if (importingModule) {\n    ngModuleDef = getNgModuleDef(moduleType);\n    if (!ngModuleDef) {\n      throw new Error(`Unexpected value '${moduleType.name}' imported by the module '${importingModule.name}'. Please add an @NgModule annotation.`);\n    }\n  } else {\n    ngModuleDef = getNgModuleDef(moduleType, true);\n  }\n  const errors = [];\n  const declarations = maybeUnwrapFn(ngModuleDef.declarations);\n  const imports = maybeUnwrapFn(ngModuleDef.imports);\n  flatten(imports).map(unwrapModuleWithProvidersImports).forEach((modOrStandaloneCmpt) => {\n    verifySemanticsOfNgModuleImport(modOrStandaloneCmpt, moduleType);\n    verifySemanticsOfNgModuleDef(modOrStandaloneCmpt, false, moduleType);\n  });\n  const exports = maybeUnwrapFn(ngModuleDef.exports);\n  declarations.forEach(verifyDeclarationsHaveDefinitions);\n  declarations.forEach(verifyDirectivesHaveSelector);\n  declarations.forEach((declarationType) => verifyNotStandalone(declarationType, moduleType));\n  const combinedDeclarations = [...declarations.map(resolveForwardRef), ...flatten(imports.map(computeCombinedExports)).map(resolveForwardRef)];\n  exports.forEach(verifyExportsAreDeclaredOrReExported);\n  declarations.forEach((decl) => verifyDeclarationIsUnique(decl, allowDuplicateDeclarationsInRoot));\n  const ngModule = getAnnotation(moduleType, \"NgModule\");\n  if (ngModule) {\n    ngModule.imports && flatten(ngModule.imports).map(unwrapModuleWithProvidersImports).forEach((mod) => {\n      verifySemanticsOfNgModuleImport(mod, moduleType);\n      verifySemanticsOfNgModuleDef(mod, false, moduleType);\n    });\n    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyCorrectBootstrapType);\n    ngModule.bootstrap && deepForEach(ngModule.bootstrap, verifyComponentIsPartOfNgModule);\n  }\n  if (errors.length) {\n    throw new Error(errors.join(\"\\n\"));\n  }\n  function verifyDeclarationsHaveDefinitions(type) {\n    type = resolveForwardRef(type);\n    const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef$1(type);\n    if (!def) {\n      errors.push(`Unexpected value '${stringifyForError(type)}' declared by the module '${stringifyForError(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`);\n    }\n  }\n  function verifyDirectivesHaveSelector(type) {\n    type = resolveForwardRef(type);\n    const def = getDirectiveDef(type);\n    if (!getComponentDef(type) && def && def.selectors.length == 0) {\n      errors.push(`Directive ${stringifyForError(type)} has no selector, please add it!`);\n    }\n  }\n  function verifyNotStandalone(type, moduleType2) {\n    type = resolveForwardRef(type);\n    const def = getComponentDef(type) || getDirectiveDef(type) || getPipeDef$1(type);\n    if (def?.standalone) {\n      const location2 = `\"${stringifyForError(moduleType2)}\" NgModule`;\n      errors.push(generateStandaloneInDeclarationsError(type, location2));\n    }\n  }\n  function verifyExportsAreDeclaredOrReExported(type) {\n    type = resolveForwardRef(type);\n    const kind = getComponentDef(type) && \"component\" || getDirectiveDef(type) && \"directive\" || getPipeDef$1(type) && \"pipe\";\n    if (kind) {\n      if (combinedDeclarations.lastIndexOf(type) === -1) {\n        errors.push(`Can't export ${kind} ${stringifyForError(type)} from ${stringifyForError(moduleType)} as it was neither declared nor imported!`);\n      }\n    }\n  }\n  function verifyDeclarationIsUnique(type, suppressErrors) {\n    type = resolveForwardRef(type);\n    const existingModule = ownerNgModule.get(type);\n    if (existingModule && existingModule !== moduleType) {\n      if (!suppressErrors) {\n        const modules2 = [existingModule, moduleType].map(stringifyForError).sort();\n        errors.push(`Type ${stringifyForError(type)} is part of the declarations of 2 modules: ${modules2[0]} and ${modules2[1]}! Please consider moving ${stringifyForError(type)} to a higher module that imports ${modules2[0]} and ${modules2[1]}. You can also create a new NgModule that exports and includes ${stringifyForError(type)} then import that NgModule in ${modules2[0]} and ${modules2[1]}.`);\n      }\n    } else {\n      ownerNgModule.set(type, moduleType);\n    }\n  }\n  function verifyComponentIsPartOfNgModule(type) {\n    type = resolveForwardRef(type);\n    const existingModule = ownerNgModule.get(type);\n    if (!existingModule && !isStandalone(type)) {\n      errors.push(`Component ${stringifyForError(type)} is not part of any NgModule or the module has not been imported into your module.`);\n    }\n  }\n  function verifyCorrectBootstrapType(type) {\n    type = resolveForwardRef(type);\n    if (!getComponentDef(type)) {\n      errors.push(`${stringifyForError(type)} cannot be used as an entry component.`);\n    }\n    if (isStandalone(type)) {\n      errors.push(`The \\`${stringifyForError(type)}\\` class is a standalone component, which can not be used in the \\`@NgModule.bootstrap\\` array. Use the \\`bootstrapApplication\\` function for bootstrap instead.`);\n    }\n  }\n  function verifySemanticsOfNgModuleImport(type, importingModule2) {\n    type = resolveForwardRef(type);\n    const directiveDef = getComponentDef(type) || getDirectiveDef(type);\n    if (directiveDef !== null && !directiveDef.standalone) {\n      throw new Error(`Unexpected directive '${type.name}' imported by the module '${importingModule2.name}'. Please add an @NgModule annotation.`);\n    }\n    const pipeDef = getPipeDef$1(type);\n    if (pipeDef !== null && !pipeDef.standalone) {\n      throw new Error(`Unexpected pipe '${type.name}' imported by the module '${importingModule2.name}'. Please add an @NgModule annotation.`);\n    }\n  }\n}\nfunction unwrapModuleWithProvidersImports(typeOrWithProviders) {\n  typeOrWithProviders = resolveForwardRef(typeOrWithProviders);\n  return typeOrWithProviders.ngModule || typeOrWithProviders;\n}\nfunction getAnnotation(type, name) {\n  let annotation = null;\n  collect(type.__annotations__);\n  collect(type.decorators);\n  return annotation;\n  function collect(annotations) {\n    if (annotations) {\n      annotations.forEach(readAnnotation);\n    }\n  }\n  function readAnnotation(decorator) {\n    if (!annotation) {\n      const proto = Object.getPrototypeOf(decorator);\n      if (proto.ngMetadataName == name) {\n        annotation = decorator;\n      } else if (decorator.type) {\n        const proto2 = Object.getPrototypeOf(decorator.type);\n        if (proto2.ngMetadataName == name) {\n          annotation = decorator.args[0];\n        }\n      }\n    }\n  }\n}\nvar ownerNgModule = /* @__PURE__ */ new WeakMap();\nvar verifiedNgModule = /* @__PURE__ */ new WeakMap();\nfunction computeCombinedExports(type) {\n  type = resolveForwardRef(type);\n  const ngModuleDef = getNgModuleDef(type);\n  if (ngModuleDef === null) {\n    return [type];\n  }\n  return flatten(maybeUnwrapFn(ngModuleDef.exports).map((type2) => {\n    const ngModuleDef2 = getNgModuleDef(type2);\n    if (ngModuleDef2) {\n      verifySemanticsOfNgModuleDef(type2, false);\n      return computeCombinedExports(type2);\n    } else {\n      return type2;\n    }\n  }));\n}\nfunction setScopeOnDeclaredComponents(moduleType, ngModule) {\n  const declarations = flatten(ngModule.declarations || EMPTY_ARRAY);\n  const transitiveScopes = transitiveScopesFor(moduleType);\n  declarations.forEach((declaration) => {\n    declaration = resolveForwardRef(declaration);\n    if (declaration.hasOwnProperty(NG_COMP_DEF)) {\n      const component = declaration;\n      const componentDef = getComponentDef(component);\n      patchComponentDefWithScope(componentDef, transitiveScopes);\n    } else if (!declaration.hasOwnProperty(NG_DIR_DEF) && !declaration.hasOwnProperty(NG_PIPE_DEF)) {\n      declaration.ngSelectorScope = moduleType;\n    }\n  });\n}\nfunction patchComponentDefWithScope(componentDef, transitiveScopes) {\n  componentDef.directiveDefs = () => Array.from(transitiveScopes.compilation.directives).map((dir) => dir.hasOwnProperty(NG_COMP_DEF) ? getComponentDef(dir) : getDirectiveDef(dir)).filter((def) => !!def);\n  componentDef.pipeDefs = () => Array.from(transitiveScopes.compilation.pipes).map((pipe2) => getPipeDef$1(pipe2));\n  componentDef.schemas = transitiveScopes.schemas;\n  componentDef.tView = null;\n}\nfunction transitiveScopesFor(type) {\n  if (isNgModule(type)) {\n    {\n      const scope = depsTracker.getNgModuleScope(type);\n      const def = getNgModuleDef(type, true);\n      return __spreadValues({\n        schemas: def.schemas || null\n      }, scope);\n    }\n  } else if (isStandalone(type)) {\n    const directiveDef = getComponentDef(type) || getDirectiveDef(type);\n    if (directiveDef !== null) {\n      return {\n        schemas: null,\n        compilation: {\n          directives: /* @__PURE__ */ new Set(),\n          pipes: /* @__PURE__ */ new Set()\n        },\n        exported: {\n          directives: /* @__PURE__ */ new Set([type]),\n          pipes: /* @__PURE__ */ new Set()\n        }\n      };\n    }\n    const pipeDef = getPipeDef$1(type);\n    if (pipeDef !== null) {\n      return {\n        schemas: null,\n        compilation: {\n          directives: /* @__PURE__ */ new Set(),\n          pipes: /* @__PURE__ */ new Set()\n        },\n        exported: {\n          directives: /* @__PURE__ */ new Set(),\n          pipes: /* @__PURE__ */ new Set([type])\n        }\n      };\n    }\n  }\n  throw new Error(`${type.name} does not have a module def (\\u0275mod property)`);\n}\nfunction expandModuleWithProviders(value) {\n  if (isModuleWithProviders(value)) {\n    return value.ngModule;\n  }\n  return value;\n}\nvar compilationDepth = 0;\nfunction compileComponent(type, metadata) {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && initNgDevMode();\n  let ngComponentDef = null;\n  maybeQueueResolutionOfComponentResources(type, metadata);\n  addDirectiveFactoryDef(type, metadata);\n  Object.defineProperty(type, NG_COMP_DEF, {\n    get: () => {\n      if (ngComponentDef === null) {\n        const compiler = getCompilerFacade({\n          usage: 0,\n          kind: \"component\",\n          type\n        });\n        if (componentNeedsResolution(metadata)) {\n          const error = [`Component '${type.name}' is not resolved:`];\n          if (metadata.templateUrl) {\n            error.push(` - templateUrl: ${metadata.templateUrl}`);\n          }\n          if (metadata.styleUrls && metadata.styleUrls.length) {\n            error.push(` - styleUrls: ${JSON.stringify(metadata.styleUrls)}`);\n          }\n          if (metadata.styleUrl) {\n            error.push(` - styleUrl: ${metadata.styleUrl}`);\n          }\n          error.push(`Did you run and wait for 'resolveComponentResources()'?`);\n          throw new Error(error.join(\"\\n\"));\n        }\n        const options = getJitOptions();\n        let preserveWhitespaces = metadata.preserveWhitespaces;\n        if (preserveWhitespaces === void 0) {\n          if (options !== null && options.preserveWhitespaces !== void 0) {\n            preserveWhitespaces = options.preserveWhitespaces;\n          } else {\n            preserveWhitespaces = false;\n          }\n        }\n        let encapsulation = metadata.encapsulation;\n        if (encapsulation === void 0) {\n          if (options !== null && options.defaultEncapsulation !== void 0) {\n            encapsulation = options.defaultEncapsulation;\n          } else {\n            encapsulation = ViewEncapsulation.Emulated;\n          }\n        }\n        const templateUrl = metadata.templateUrl || `ng:///${type.name}/template.html`;\n        const meta = __spreadProps(__spreadValues({}, directiveMetadata(type, metadata)), {\n          typeSourceSpan: compiler.createParseSourceSpan(\"Component\", type.name, templateUrl),\n          template: metadata.template || \"\",\n          preserveWhitespaces,\n          styles: typeof metadata.styles === \"string\" ? [metadata.styles] : metadata.styles || EMPTY_ARRAY,\n          animations: metadata.animations,\n          // JIT components are always compiled against an empty set of `declarations`. Instead, the\n          // `directiveDefs` and `pipeDefs` are updated at a later point:\n          //  * for NgModule-based components, they're set when the NgModule which declares the\n          //    component resolves in the module scoping queue\n          //  * for standalone components, they're set just below, after `compileComponent`.\n          declarations: [],\n          changeDetection: metadata.changeDetection,\n          encapsulation,\n          interpolation: metadata.interpolation,\n          viewProviders: metadata.viewProviders || null\n        });\n        compilationDepth++;\n        try {\n          if (meta.usesInheritance) {\n            addDirectiveDefToUndecoratedParents(type);\n          }\n          ngComponentDef = compiler.compileComponent(angularCoreEnv, templateUrl, meta);\n          if (meta.isStandalone) {\n            const imports = flatten(metadata.imports || EMPTY_ARRAY);\n            const {\n              directiveDefs,\n              pipeDefs\n            } = getStandaloneDefFunctions(type, imports);\n            ngComponentDef.directiveDefs = directiveDefs;\n            ngComponentDef.pipeDefs = pipeDefs;\n            ngComponentDef.dependencies = () => imports.map(resolveForwardRef);\n          }\n        } finally {\n          compilationDepth--;\n        }\n        if (compilationDepth === 0) {\n          flushModuleScopingQueueAsMuchAsPossible();\n        }\n        if (hasSelectorScope(type)) {\n          const scopes = transitiveScopesFor(type.ngSelectorScope);\n          patchComponentDefWithScope(ngComponentDef, scopes);\n        }\n        if (metadata.schemas) {\n          if (meta.isStandalone) {\n            ngComponentDef.schemas = metadata.schemas;\n          } else {\n            throw new Error(`The 'schemas' was specified for the ${stringifyForError(type)} but is only valid on a component that is standalone.`);\n          }\n        } else if (meta.isStandalone) {\n          ngComponentDef.schemas = [];\n        }\n      }\n      return ngComponentDef;\n    },\n    set: (def) => {\n      ngComponentDef = def;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode\n  });\n}\nfunction getStandaloneDefFunctions(type, imports) {\n  const directiveDefs = () => {\n    {\n      if (ngDevMode) {\n        for (const rawDep of imports) {\n          verifyStandaloneImport(rawDep, type);\n        }\n      }\n      if (!isComponent(type)) {\n        return [];\n      }\n      const scope = depsTracker.getStandaloneComponentScope(type, imports);\n      return [...scope.compilation.directives].map((p) => getComponentDef(p) || getDirectiveDef(p)).filter((d) => d !== null);\n    }\n  };\n  const pipeDefs = () => {\n    {\n      if (ngDevMode) {\n        for (const rawDep of imports) {\n          verifyStandaloneImport(rawDep, type);\n        }\n      }\n      if (!isComponent(type)) {\n        return [];\n      }\n      const scope = depsTracker.getStandaloneComponentScope(type, imports);\n      return [...scope.compilation.pipes].map((p) => getPipeDef$1(p)).filter((d) => d !== null);\n    }\n  };\n  return {\n    directiveDefs,\n    pipeDefs\n  };\n}\nfunction hasSelectorScope(component) {\n  return component.ngSelectorScope !== void 0;\n}\nfunction compileDirective(type, directive) {\n  let ngDirectiveDef = null;\n  addDirectiveFactoryDef(type, directive || {});\n  Object.defineProperty(type, NG_DIR_DEF, {\n    get: () => {\n      if (ngDirectiveDef === null) {\n        const meta = getDirectiveMetadata(type, directive || {});\n        const compiler = getCompilerFacade({\n          usage: 0,\n          kind: \"directive\",\n          type\n        });\n        ngDirectiveDef = compiler.compileDirective(angularCoreEnv, meta.sourceMapUrl, meta.metadata);\n      }\n      return ngDirectiveDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode\n  });\n}\nfunction getDirectiveMetadata(type, metadata) {\n  const name = type && type.name;\n  const sourceMapUrl = `ng:///${name}/\\u0275dir.js`;\n  const compiler = getCompilerFacade({\n    usage: 0,\n    kind: \"directive\",\n    type\n  });\n  const facade = directiveMetadata(type, metadata);\n  facade.typeSourceSpan = compiler.createParseSourceSpan(\"Directive\", name, sourceMapUrl);\n  if (facade.usesInheritance) {\n    addDirectiveDefToUndecoratedParents(type);\n  }\n  return {\n    metadata: facade,\n    sourceMapUrl\n  };\n}\nfunction addDirectiveFactoryDef(type, metadata) {\n  let ngFactoryDef = null;\n  Object.defineProperty(type, NG_FACTORY_DEF, {\n    get: () => {\n      if (ngFactoryDef === null) {\n        const meta = getDirectiveMetadata(type, metadata);\n        const compiler = getCompilerFacade({\n          usage: 0,\n          kind: \"directive\",\n          type\n        });\n        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${type.name}/\\u0275fac.js`, {\n          name: meta.metadata.name,\n          type: meta.metadata.type,\n          typeArgumentCount: 0,\n          deps: reflectDependencies(type),\n          target: compiler.FactoryTarget.Directive\n        });\n      }\n      return ngFactoryDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode\n  });\n}\nfunction extendsDirectlyFromObject(type) {\n  return Object.getPrototypeOf(type.prototype) === Object.prototype;\n}\nfunction directiveMetadata(type, metadata) {\n  const reflect = getReflect();\n  const propMetadata = reflect.ownPropMetadata(type);\n  return {\n    name: type.name,\n    type,\n    selector: metadata.selector !== void 0 ? metadata.selector : null,\n    host: metadata.host || EMPTY_OBJ,\n    propMetadata,\n    inputs: metadata.inputs || EMPTY_ARRAY,\n    outputs: metadata.outputs || EMPTY_ARRAY,\n    queries: extractQueriesMetadata(type, propMetadata, isContentQuery),\n    lifecycle: {\n      usesOnChanges: reflect.hasLifecycleHook(type, \"ngOnChanges\")\n    },\n    typeSourceSpan: null,\n    usesInheritance: !extendsDirectlyFromObject(type),\n    exportAs: extractExportAs(metadata.exportAs),\n    providers: metadata.providers || null,\n    viewQueries: extractQueriesMetadata(type, propMetadata, isViewQuery),\n    isStandalone: metadata.standalone === void 0 ? true : !!metadata.standalone,\n    isSignal: !!metadata.signals,\n    hostDirectives: metadata.hostDirectives?.map((directive) => typeof directive === \"function\" ? {\n      directive\n    } : directive) || null\n  };\n}\nfunction addDirectiveDefToUndecoratedParents(type) {\n  const objPrototype = Object.prototype;\n  let parent = Object.getPrototypeOf(type.prototype).constructor;\n  while (parent && parent !== objPrototype) {\n    if (!getDirectiveDef(parent) && !getComponentDef(parent) && shouldAddAbstractDirective(parent)) {\n      compileDirective(parent, null);\n    }\n    parent = Object.getPrototypeOf(parent);\n  }\n}\nfunction convertToR3QueryPredicate(selector) {\n  return typeof selector === \"string\" ? splitByComma(selector) : resolveForwardRef(selector);\n}\nfunction convertToR3QueryMetadata(propertyName, ann) {\n  return {\n    propertyName,\n    predicate: convertToR3QueryPredicate(ann.selector),\n    descendants: ann.descendants,\n    first: ann.first,\n    read: ann.read ? ann.read : null,\n    static: !!ann.static,\n    emitDistinctChangesOnly: !!ann.emitDistinctChangesOnly,\n    isSignal: !!ann.isSignal\n  };\n}\nfunction extractQueriesMetadata(type, propMetadata, isQueryAnn) {\n  const queriesMeta = [];\n  for (const field in propMetadata) {\n    if (propMetadata.hasOwnProperty(field)) {\n      const annotations = propMetadata[field];\n      annotations.forEach((ann) => {\n        if (isQueryAnn(ann)) {\n          if (!ann.selector) {\n            throw new Error(`Can't construct a query for the property \"${field}\" of \"${stringifyForError(type)}\" since the query selector wasn't defined.`);\n          }\n          if (annotations.some(isInputAnnotation)) {\n            throw new Error(`Cannot combine @Input decorators with query decorators`);\n          }\n          queriesMeta.push(convertToR3QueryMetadata(field, ann));\n        }\n      });\n    }\n  }\n  return queriesMeta;\n}\nfunction extractExportAs(exportAs) {\n  return exportAs === void 0 ? null : splitByComma(exportAs);\n}\nfunction isContentQuery(value) {\n  const name = value.ngMetadataName;\n  return name === \"ContentChild\" || name === \"ContentChildren\";\n}\nfunction isViewQuery(value) {\n  const name = value.ngMetadataName;\n  return name === \"ViewChild\" || name === \"ViewChildren\";\n}\nfunction isInputAnnotation(value) {\n  return value.ngMetadataName === \"Input\";\n}\nfunction splitByComma(value) {\n  return value.split(\",\").map((piece) => piece.trim());\n}\nvar LIFECYCLE_HOOKS = [\"ngOnChanges\", \"ngOnInit\", \"ngOnDestroy\", \"ngDoCheck\", \"ngAfterViewInit\", \"ngAfterViewChecked\", \"ngAfterContentInit\", \"ngAfterContentChecked\"];\nfunction shouldAddAbstractDirective(type) {\n  const reflect = getReflect();\n  if (LIFECYCLE_HOOKS.some((hookName) => reflect.hasLifecycleHook(type, hookName))) {\n    return true;\n  }\n  const propMetadata = reflect.propMetadata(type);\n  for (const field in propMetadata) {\n    const annotations = propMetadata[field];\n    for (let i = 0; i < annotations.length; i++) {\n      const current = annotations[i];\n      const metadataName = current.ngMetadataName;\n      if (isInputAnnotation(current) || isContentQuery(current) || isViewQuery(current) || metadataName === \"Output\" || metadataName === \"HostBinding\" || metadataName === \"HostListener\") {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction compilePipe(type, meta) {\n  let ngPipeDef = null;\n  let ngFactoryDef = null;\n  Object.defineProperty(type, NG_FACTORY_DEF, {\n    get: () => {\n      if (ngFactoryDef === null) {\n        const metadata = getPipeMetadata(type, meta);\n        const compiler = getCompilerFacade({\n          usage: 0,\n          kind: \"pipe\",\n          type: metadata.type\n        });\n        ngFactoryDef = compiler.compileFactory(angularCoreEnv, `ng:///${metadata.name}/\\u0275fac.js`, {\n          name: metadata.name,\n          type: metadata.type,\n          typeArgumentCount: 0,\n          deps: reflectDependencies(type),\n          target: compiler.FactoryTarget.Pipe\n        });\n      }\n      return ngFactoryDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode\n  });\n  Object.defineProperty(type, NG_PIPE_DEF, {\n    get: () => {\n      if (ngPipeDef === null) {\n        const metadata = getPipeMetadata(type, meta);\n        const compiler = getCompilerFacade({\n          usage: 0,\n          kind: \"pipe\",\n          type: metadata.type\n        });\n        ngPipeDef = compiler.compilePipe(angularCoreEnv, `ng:///${metadata.name}/\\u0275pipe.js`, metadata);\n      }\n      return ngPipeDef;\n    },\n    // Make the property configurable in dev mode to allow overriding in tests\n    configurable: !!ngDevMode\n  });\n}\nfunction getPipeMetadata(type, meta) {\n  return {\n    type,\n    name: type.name,\n    pipeName: meta.name,\n    pure: meta.pure !== void 0 ? meta.pure : true,\n    isStandalone: meta.standalone === void 0 ? true : !!meta.standalone\n  };\n}\nvar Directive = makeDecorator(\"Directive\", (dir = {}) => dir, void 0, void 0, (type, meta) => compileDirective(type, meta));\nvar Component = makeDecorator(\"Component\", (c = {}) => __spreadValues({\n  changeDetection: ChangeDetectionStrategy.Default\n}, c), Directive, void 0, (type, meta) => compileComponent(type, meta));\nvar Pipe = makeDecorator(\"Pipe\", (p) => __spreadValues({\n  pure: true\n}, p), void 0, void 0, (type, meta) => compilePipe(type, meta));\nvar Input = makePropDecorator(\"Input\", (arg) => {\n  if (!arg) {\n    return {};\n  }\n  return typeof arg === \"string\" ? {\n    alias: arg\n  } : arg;\n});\nvar Output = makePropDecorator(\"Output\", (alias) => ({\n  alias\n}));\nvar HostBinding = makePropDecorator(\"HostBinding\", (hostPropertyName) => ({\n  hostPropertyName\n}));\nvar HostListener = makePropDecorator(\"HostListener\", (eventName, args) => ({\n  eventName,\n  args\n}));\nvar NgModule = makeDecorator(\n  \"NgModule\",\n  (ngModule) => ngModule,\n  void 0,\n  void 0,\n  /**\n   * Decorator that marks the following class as an NgModule, and supplies\n   * configuration metadata for it.\n   *\n   * * The `declarations` option configures the compiler\n   * with information about what belongs to the NgModule.\n   * * The `providers` options configures the NgModule's injector to provide\n   * dependencies the NgModule members.\n   * * The `imports` and `exports` options bring in members from other modules, and make\n   * this module's members available to others.\n   */\n  (type, meta) => compileNgModule(type, meta)\n);\nvar Version = class {\n  full;\n  major;\n  minor;\n  patch;\n  constructor(full) {\n    this.full = full;\n    const parts = full.split(\".\");\n    this.major = parts[0];\n    this.minor = parts[1];\n    this.patch = parts.slice(2).join(\".\");\n  }\n};\nvar VERSION = new Version(\"19.2.3\");\nvar ModuleWithComponentFactories = class {\n  ngModuleFactory;\n  componentFactories;\n  constructor(ngModuleFactory, componentFactories) {\n    this.ngModuleFactory = ngModuleFactory;\n    this.componentFactories = componentFactories;\n  }\n};\nvar Compiler = class _Compiler {\n  /**\n   * Compiles the given NgModule and all of its components. All templates of the components\n   * have to be inlined.\n   */\n  compileModuleSync(moduleType) {\n    return new NgModuleFactory2(moduleType);\n  }\n  /**\n   * Compiles the given NgModule and all of its components\n   */\n  compileModuleAsync(moduleType) {\n    return Promise.resolve(this.compileModuleSync(moduleType));\n  }\n  /**\n   * Same as {@link Compiler#compileModuleSync compileModuleSync} but also creates ComponentFactories for all components.\n   */\n  compileModuleAndAllComponentsSync(moduleType) {\n    const ngModuleFactory = this.compileModuleSync(moduleType);\n    const moduleDef = getNgModuleDef(moduleType);\n    const componentFactories = maybeUnwrapFn(moduleDef.declarations).reduce((factories, declaration) => {\n      const componentDef = getComponentDef(declaration);\n      componentDef && factories.push(new ComponentFactory2(componentDef));\n      return factories;\n    }, []);\n    return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n  }\n  /**\n   * Same as {@link Compiler#compileModuleAsync compileModuleAsync} but also creates ComponentFactories for all components.\n   */\n  compileModuleAndAllComponentsAsync(moduleType) {\n    return Promise.resolve(this.compileModuleAndAllComponentsSync(moduleType));\n  }\n  /**\n   * Clears all caches.\n   */\n  clearCache() {\n  }\n  /**\n   * Clears the cache for the given component/ngModule.\n   */\n  clearCacheFor(type) {\n  }\n  /**\n   * Returns the id for a given NgModule, if one is defined and known to the compiler.\n   */\n  getModuleId(moduleType) {\n    return void 0;\n  }\n  static \\u0275fac = function Compiler_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _Compiler)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _Compiler,\n    factory: _Compiler.\\u0275fac,\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(Compiler, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], null, null);\n})();\nvar COMPILER_OPTIONS = new InjectionToken(ngDevMode ? \"compilerOptions\" : \"\");\nfunction compileNgModuleFactory(injector, options, moduleType) {\n  ngDevMode && assertNgModuleType(moduleType);\n  const moduleFactory = new NgModuleFactory2(moduleType);\n  if (true) {\n    return Promise.resolve(moduleFactory);\n  }\n  const compilerOptions = injector.get(COMPILER_OPTIONS, []).concat(options);\n  setJitOptions({\n    defaultEncapsulation: _lastDefined(compilerOptions.map((opts) => opts.defaultEncapsulation)),\n    preserveWhitespaces: _lastDefined(compilerOptions.map((opts) => opts.preserveWhitespaces))\n  });\n  if (isComponentResourceResolutionQueueEmpty()) {\n    return Promise.resolve(moduleFactory);\n  }\n  const compilerProviders = compilerOptions.flatMap((option) => option.providers ?? []);\n  if (compilerProviders.length === 0) {\n    return Promise.resolve(moduleFactory);\n  }\n  const compiler = getCompilerFacade({\n    usage: 0,\n    kind: \"NgModule\",\n    type: moduleType\n  });\n  const compilerInjector = Injector.create({\n    providers: compilerProviders\n  });\n  const resourceLoader = compilerInjector.get(compiler.ResourceLoader);\n  return resolveComponentResources((url) => Promise.resolve(resourceLoader.get(url))).then(() => moduleFactory);\n}\nfunction _lastDefined(args) {\n  for (let i = args.length - 1; i >= 0; i--) {\n    if (args[i] !== void 0) {\n      return args[i];\n    }\n  }\n  return void 0;\n}\nvar NgZoneChangeDetectionScheduler = class _NgZoneChangeDetectionScheduler {\n  zone = inject(NgZone);\n  changeDetectionScheduler = inject(ChangeDetectionScheduler);\n  applicationRef = inject(ApplicationRef);\n  _onMicrotaskEmptySubscription;\n  initialize() {\n    if (this._onMicrotaskEmptySubscription) {\n      return;\n    }\n    this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({\n      next: () => {\n        if (this.changeDetectionScheduler.runningTick) {\n          return;\n        }\n        this.zone.run(() => {\n          this.applicationRef.tick();\n        });\n      }\n    });\n  }\n  ngOnDestroy() {\n    this._onMicrotaskEmptySubscription?.unsubscribe();\n  }\n  static \\u0275fac = function NgZoneChangeDetectionScheduler_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _NgZoneChangeDetectionScheduler)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _NgZoneChangeDetectionScheduler,\n    factory: _NgZoneChangeDetectionScheduler.\\u0275fac,\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(NgZoneChangeDetectionScheduler, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], null, null);\n})();\nvar PROVIDED_NG_ZONE = new InjectionToken(typeof ngDevMode === \"undefined\" || ngDevMode ? \"provideZoneChangeDetection token\" : \"\", {\n  factory: () => false\n});\nfunction internalProvideZoneChangeDetection({\n  ngZoneFactory,\n  ignoreChangesOutsideZone,\n  scheduleInRootZone\n}) {\n  ngZoneFactory ??= () => new NgZone(__spreadProps(__spreadValues({}, getNgZoneOptions()), {\n    scheduleInRootZone\n  }));\n  return [\n    {\n      provide: NgZone,\n      useFactory: ngZoneFactory\n    },\n    {\n      provide: ENVIRONMENT_INITIALIZER,\n      multi: true,\n      useFactory: () => {\n        const ngZoneChangeDetectionScheduler = inject(NgZoneChangeDetectionScheduler, {\n          optional: true\n        });\n        if ((typeof ngDevMode === \"undefined\" || ngDevMode) && ngZoneChangeDetectionScheduler === null) {\n          throw new RuntimeError(402, `A required Injectable was not found in the dependency injection tree. If you are bootstrapping an NgModule, make sure that the \\`BrowserModule\\` is imported.`);\n        }\n        return () => ngZoneChangeDetectionScheduler.initialize();\n      }\n    },\n    {\n      provide: ENVIRONMENT_INITIALIZER,\n      multi: true,\n      useFactory: () => {\n        const service = inject(ZoneStablePendingTask);\n        return () => {\n          service.initialize();\n        };\n      }\n    },\n    // Always disable scheduler whenever explicitly disabled, even if another place called\n    // `provideZoneChangeDetection` without the 'ignore' option.\n    ignoreChangesOutsideZone === true ? {\n      provide: ZONELESS_SCHEDULER_DISABLED,\n      useValue: true\n    } : [],\n    {\n      provide: SCHEDULE_IN_ROOT_ZONE,\n      useValue: scheduleInRootZone ?? SCHEDULE_IN_ROOT_ZONE_DEFAULT\n    }\n  ];\n}\nfunction provideZoneChangeDetection(options) {\n  const ignoreChangesOutsideZone = options?.ignoreChangesOutsideZone;\n  const scheduleInRootZone = options?.scheduleInRootZone;\n  const zoneProviders = internalProvideZoneChangeDetection({\n    ngZoneFactory: () => {\n      const ngZoneOptions = getNgZoneOptions(options);\n      ngZoneOptions.scheduleInRootZone = scheduleInRootZone;\n      if (ngZoneOptions.shouldCoalesceEventChangeDetection) {\n        performanceMarkFeature(\"NgZone_CoalesceEvent\");\n      }\n      return new NgZone(ngZoneOptions);\n    },\n    ignoreChangesOutsideZone,\n    scheduleInRootZone\n  });\n  return makeEnvironmentProviders([{\n    provide: PROVIDED_NG_ZONE,\n    useValue: true\n  }, {\n    provide: ZONELESS_ENABLED,\n    useValue: false\n  }, zoneProviders]);\n}\nfunction getNgZoneOptions(options) {\n  return {\n    enableLongStackTrace: typeof ngDevMode === \"undefined\" ? false : !!ngDevMode,\n    shouldCoalesceEventChangeDetection: options?.eventCoalescing ?? false,\n    shouldCoalesceRunChangeDetection: options?.runCoalescing ?? false\n  };\n}\nvar ZoneStablePendingTask = class _ZoneStablePendingTask {\n  subscription = new Subscription();\n  initialized = false;\n  zone = inject(NgZone);\n  pendingTasks = inject(PendingTasksInternal);\n  initialize() {\n    if (this.initialized) {\n      return;\n    }\n    this.initialized = true;\n    let task = null;\n    if (!this.zone.isStable && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks) {\n      task = this.pendingTasks.add();\n    }\n    this.zone.runOutsideAngular(() => {\n      this.subscription.add(this.zone.onStable.subscribe(() => {\n        NgZone.assertNotInAngularZone();\n        queueMicrotask(() => {\n          if (task !== null && !this.zone.hasPendingMacrotasks && !this.zone.hasPendingMicrotasks) {\n            this.pendingTasks.remove(task);\n            task = null;\n          }\n        });\n      }));\n    });\n    this.subscription.add(this.zone.onUnstable.subscribe(() => {\n      NgZone.assertInAngularZone();\n      task ??= this.pendingTasks.add();\n    }));\n  }\n  ngOnDestroy() {\n    this.subscription.unsubscribe();\n  }\n  static \\u0275fac = function ZoneStablePendingTask_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _ZoneStablePendingTask)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _ZoneStablePendingTask,\n    factory: _ZoneStablePendingTask.\\u0275fac,\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(ZoneStablePendingTask, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], null, null);\n})();\nvar CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT = 100;\nvar consecutiveMicrotaskNotifications = 0;\nvar stackFromLastFewNotifications = [];\nfunction trackMicrotaskNotificationForDebugging() {\n  consecutiveMicrotaskNotifications++;\n  if (CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT - consecutiveMicrotaskNotifications < 5) {\n    const stack = new Error().stack;\n    if (stack) {\n      stackFromLastFewNotifications.push(stack);\n    }\n  }\n  if (consecutiveMicrotaskNotifications === CONSECUTIVE_MICROTASK_NOTIFICATION_LIMIT) {\n    throw new RuntimeError(103, \"Angular could not stabilize because there were endless change notifications within the browser event loop. The stack from the last several notifications: \\n\" + stackFromLastFewNotifications.join(\"\\n\"));\n  }\n}\nvar ChangeDetectionSchedulerImpl = class _ChangeDetectionSchedulerImpl {\n  appRef = inject(ApplicationRef);\n  taskService = inject(PendingTasksInternal);\n  ngZone = inject(NgZone);\n  zonelessEnabled = inject(ZONELESS_ENABLED);\n  tracing = inject(TracingService, {\n    optional: true\n  });\n  disableScheduling = inject(ZONELESS_SCHEDULER_DISABLED, {\n    optional: true\n  }) ?? false;\n  zoneIsDefined = typeof Zone !== \"undefined\" && !!Zone.root.run;\n  schedulerTickApplyArgs = [{\n    data: {\n      \"__scheduler_tick__\": true\n    }\n  }];\n  subscriptions = new Subscription();\n  angularZoneId = this.zoneIsDefined ? this.ngZone._inner?.get(angularZoneInstanceIdProperty) : null;\n  scheduleInRootZone = !this.zonelessEnabled && this.zoneIsDefined && (inject(SCHEDULE_IN_ROOT_ZONE, {\n    optional: true\n  }) ?? false);\n  cancelScheduledCallback = null;\n  useMicrotaskScheduler = false;\n  runningTick = false;\n  pendingRenderTaskId = null;\n  constructor() {\n    this.subscriptions.add(this.appRef.afterTick.subscribe(() => {\n      if (!this.runningTick) {\n        this.cleanup();\n      }\n    }));\n    this.subscriptions.add(this.ngZone.onUnstable.subscribe(() => {\n      if (!this.runningTick) {\n        this.cleanup();\n      }\n    }));\n    this.disableScheduling ||= !this.zonelessEnabled && // NoopNgZone without enabling zoneless means no scheduling whatsoever\n    (this.ngZone instanceof NoopNgZone || // The same goes for the lack of Zone without enabling zoneless scheduling\n    !this.zoneIsDefined);\n  }\n  notify(source) {\n    if (!this.zonelessEnabled && source === 5) {\n      return;\n    }\n    let force = false;\n    switch (source) {\n      case 0: {\n        this.appRef.dirtyFlags |= 2;\n        break;\n      }\n      case 3:\n      case 2:\n      case 4:\n      case 5:\n      case 1: {\n        this.appRef.dirtyFlags |= 4;\n        break;\n      }\n      case 6: {\n        this.appRef.dirtyFlags |= 2;\n        force = true;\n        break;\n      }\n      case 12: {\n        this.appRef.dirtyFlags |= 16;\n        force = true;\n        break;\n      }\n      case 13: {\n        this.appRef.dirtyFlags |= 2;\n        force = true;\n        break;\n      }\n      case 11: {\n        force = true;\n        break;\n      }\n      case 9:\n      case 8:\n      case 7:\n      case 10:\n      default: {\n        this.appRef.dirtyFlags |= 8;\n      }\n    }\n    this.appRef.tracingSnapshot = this.tracing?.snapshot(this.appRef.tracingSnapshot) ?? null;\n    if (!this.shouldScheduleTick(force)) {\n      return;\n    }\n    if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n      if (this.useMicrotaskScheduler) {\n        trackMicrotaskNotificationForDebugging();\n      } else {\n        consecutiveMicrotaskNotifications = 0;\n        stackFromLastFewNotifications.length = 0;\n      }\n    }\n    const scheduleCallback = this.useMicrotaskScheduler ? scheduleCallbackWithMicrotask : scheduleCallbackWithRafRace;\n    this.pendingRenderTaskId = this.taskService.add();\n    if (this.scheduleInRootZone) {\n      this.cancelScheduledCallback = Zone.root.run(() => scheduleCallback(() => this.tick()));\n    } else {\n      this.cancelScheduledCallback = this.ngZone.runOutsideAngular(() => scheduleCallback(() => this.tick()));\n    }\n  }\n  shouldScheduleTick(force) {\n    if (this.disableScheduling && !force || this.appRef.destroyed) {\n      return false;\n    }\n    if (this.pendingRenderTaskId !== null || this.runningTick || this.appRef._runningTick) {\n      return false;\n    }\n    if (!this.zonelessEnabled && this.zoneIsDefined && Zone.current.get(angularZoneInstanceIdProperty + this.angularZoneId)) {\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Calls ApplicationRef._tick inside the `NgZone`.\n   *\n   * Calling `tick` directly runs change detection and cancels any change detection that had been\n   * scheduled previously.\n   *\n   * @param shouldRefreshViews Passed directly to `ApplicationRef._tick` and skips straight to\n   *     render hooks when `false`.\n   */\n  tick() {\n    if (this.runningTick || this.appRef.destroyed) {\n      return;\n    }\n    if (this.appRef.dirtyFlags === 0) {\n      this.cleanup();\n      return;\n    }\n    if (!this.zonelessEnabled && this.appRef.dirtyFlags & 7) {\n      this.appRef.dirtyFlags |= 1;\n    }\n    const task = this.taskService.add();\n    try {\n      this.ngZone.run(() => {\n        this.runningTick = true;\n        this.appRef._tick();\n      }, void 0, this.schedulerTickApplyArgs);\n    } catch (e) {\n      this.taskService.remove(task);\n      throw e;\n    } finally {\n      this.cleanup();\n    }\n    this.useMicrotaskScheduler = true;\n    scheduleCallbackWithMicrotask(() => {\n      this.useMicrotaskScheduler = false;\n      this.taskService.remove(task);\n    });\n  }\n  ngOnDestroy() {\n    this.subscriptions.unsubscribe();\n    this.cleanup();\n  }\n  cleanup() {\n    this.runningTick = false;\n    this.cancelScheduledCallback?.();\n    this.cancelScheduledCallback = null;\n    if (this.pendingRenderTaskId !== null) {\n      const taskId = this.pendingRenderTaskId;\n      this.pendingRenderTaskId = null;\n      this.taskService.remove(taskId);\n    }\n  }\n  static \\u0275fac = function ChangeDetectionSchedulerImpl_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _ChangeDetectionSchedulerImpl)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _ChangeDetectionSchedulerImpl,\n    factory: _ChangeDetectionSchedulerImpl.\\u0275fac,\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(ChangeDetectionSchedulerImpl, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], () => [], null);\n})();\nfunction getGlobalLocale() {\n  if (false) {\n    return goog.LOCALE;\n  } else {\n    return typeof $localize !== \"undefined\" && $localize.locale || DEFAULT_LOCALE_ID;\n  }\n}\nvar LOCALE_ID = new InjectionToken(ngDevMode ? \"LocaleId\" : \"\", {\n  providedIn: \"root\",\n  factory: () => inject(LOCALE_ID, InjectFlags.Optional | InjectFlags.SkipSelf) || getGlobalLocale()\n});\nvar DEFAULT_CURRENCY_CODE = new InjectionToken(ngDevMode ? \"DefaultCurrencyCode\" : \"\", {\n  providedIn: \"root\",\n  factory: () => USD_CURRENCY_CODE\n});\nvar TRANSLATIONS = new InjectionToken(ngDevMode ? \"Translations\" : \"\");\nvar TRANSLATIONS_FORMAT = new InjectionToken(ngDevMode ? \"TranslationsFormat\" : \"\");\nvar MissingTranslationStrategy;\n(function(MissingTranslationStrategy2) {\n  MissingTranslationStrategy2[MissingTranslationStrategy2[\"Error\"] = 0] = \"Error\";\n  MissingTranslationStrategy2[MissingTranslationStrategy2[\"Warning\"] = 1] = \"Warning\";\n  MissingTranslationStrategy2[MissingTranslationStrategy2[\"Ignore\"] = 2] = \"Ignore\";\n})(MissingTranslationStrategy || (MissingTranslationStrategy = {}));\nvar SCAN_DELAY = 200;\nvar OVERSIZED_IMAGE_TOLERANCE = 1200;\nvar ImagePerformanceWarning = class _ImagePerformanceWarning {\n  // Map of full image URLs -> original `ngSrc` values.\n  window = null;\n  observer = null;\n  options = inject(IMAGE_CONFIG);\n  lcpImageUrl;\n  start() {\n    if (typeof PerformanceObserver === \"undefined\" || this.options?.disableImageSizeWarning && this.options?.disableImageLazyLoadWarning) {\n      return;\n    }\n    this.observer = this.initPerformanceObserver();\n    const doc = getDocument();\n    const win = doc.defaultView;\n    if (win) {\n      this.window = win;\n      const waitToScan = () => {\n        setTimeout(this.scanImages.bind(this), SCAN_DELAY);\n      };\n      const setup = () => {\n        if (doc.readyState === \"complete\") {\n          waitToScan();\n        } else {\n          this.window?.addEventListener(\"load\", waitToScan, {\n            once: true\n          });\n        }\n      };\n      if (typeof Zone !== \"undefined\") {\n        Zone.root.run(() => setup());\n      } else {\n        setup();\n      }\n    }\n  }\n  ngOnDestroy() {\n    this.observer?.disconnect();\n  }\n  initPerformanceObserver() {\n    if (typeof PerformanceObserver === \"undefined\") {\n      return null;\n    }\n    const observer = new PerformanceObserver((entryList) => {\n      const entries = entryList.getEntries();\n      if (entries.length === 0) return;\n      const lcpElement = entries[entries.length - 1];\n      const imgSrc = lcpElement.element?.src ?? \"\";\n      if (imgSrc.startsWith(\"data:\") || imgSrc.startsWith(\"blob:\")) return;\n      this.lcpImageUrl = imgSrc;\n    });\n    observer.observe({\n      type: \"largest-contentful-paint\",\n      buffered: true\n    });\n    return observer;\n  }\n  scanImages() {\n    const images = getDocument().querySelectorAll(\"img\");\n    let lcpElementFound, lcpElementLoadedCorrectly = false;\n    images.forEach((image) => {\n      if (!this.options?.disableImageSizeWarning) {\n        if (!image.getAttribute(\"ng-img\") && this.isOversized(image)) {\n          logOversizedImageWarning(image.src);\n        }\n      }\n      if (!this.options?.disableImageLazyLoadWarning && this.lcpImageUrl) {\n        if (image.src === this.lcpImageUrl) {\n          lcpElementFound = true;\n          if (image.loading !== \"lazy\" || image.getAttribute(\"ng-img\")) {\n            lcpElementLoadedCorrectly = true;\n          }\n        }\n      }\n    });\n    if (lcpElementFound && !lcpElementLoadedCorrectly && this.lcpImageUrl && !this.options?.disableImageLazyLoadWarning) {\n      logLazyLCPWarning(this.lcpImageUrl);\n    }\n  }\n  isOversized(image) {\n    if (!this.window) {\n      return false;\n    }\n    const nonOversizedImageExtentions = [\n      // SVG images are vector-based, which means they can scale\n      // to any size without losing quality.\n      \".svg\"\n    ];\n    const imageSource = (image.src || \"\").toLowerCase();\n    if (nonOversizedImageExtentions.some((extension) => imageSource.endsWith(extension))) {\n      return false;\n    }\n    const computedStyle = this.window.getComputedStyle(image);\n    let renderedWidth = parseFloat(computedStyle.getPropertyValue(\"width\"));\n    let renderedHeight = parseFloat(computedStyle.getPropertyValue(\"height\"));\n    const boxSizing = computedStyle.getPropertyValue(\"box-sizing\");\n    const objectFit = computedStyle.getPropertyValue(\"object-fit\");\n    if (objectFit === `cover`) {\n      return false;\n    }\n    if (boxSizing === \"border-box\") {\n      const paddingTop = computedStyle.getPropertyValue(\"padding-top\");\n      const paddingRight = computedStyle.getPropertyValue(\"padding-right\");\n      const paddingBottom = computedStyle.getPropertyValue(\"padding-bottom\");\n      const paddingLeft = computedStyle.getPropertyValue(\"padding-left\");\n      renderedWidth -= parseFloat(paddingRight) + parseFloat(paddingLeft);\n      renderedHeight -= parseFloat(paddingTop) + parseFloat(paddingBottom);\n    }\n    const intrinsicWidth = image.naturalWidth;\n    const intrinsicHeight = image.naturalHeight;\n    const recommendedWidth = this.window.devicePixelRatio * renderedWidth;\n    const recommendedHeight = this.window.devicePixelRatio * renderedHeight;\n    const oversizedWidth = intrinsicWidth - recommendedWidth >= OVERSIZED_IMAGE_TOLERANCE;\n    const oversizedHeight = intrinsicHeight - recommendedHeight >= OVERSIZED_IMAGE_TOLERANCE;\n    return oversizedWidth || oversizedHeight;\n  }\n  static \\u0275fac = function ImagePerformanceWarning_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _ImagePerformanceWarning)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _ImagePerformanceWarning,\n    factory: _ImagePerformanceWarning.\\u0275fac,\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(ImagePerformanceWarning, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], null, null);\n})();\nfunction logLazyLCPWarning(src) {\n  console.warn(formatRuntimeError(-913, `An image with src ${src} is the Largest Contentful Paint (LCP) element but was given a \"loading\" value of \"lazy\", which can negatively impact application loading performance. This warning can be addressed by changing the loading value of the LCP image to \"eager\", or by using the NgOptimizedImage directive's prioritization utilities. For more information about addressing or disabling this warning, see https://angular.dev/errors/NG0913`));\n}\nfunction logOversizedImageWarning(src) {\n  console.warn(formatRuntimeError(-913, `An image with src ${src} has intrinsic file dimensions much larger than its rendered size. This can negatively impact application loading performance. For more information about addressing or disabling this warning, see https://angular.dev/errors/NG0913`));\n}\nvar PLATFORM_DESTROY_LISTENERS = new InjectionToken(ngDevMode ? \"PlatformDestroyListeners\" : \"\");\nvar ENABLE_ROOT_COMPONENT_BOOTSTRAP = new InjectionToken(ngDevMode ? \"ENABLE_ROOT_COMPONENT_BOOTSTRAP\" : \"\");\nfunction isApplicationBootstrapConfig(config2) {\n  return !config2.moduleRef;\n}\nfunction bootstrap(config2) {\n  const envInjector = isApplicationBootstrapConfig(config2) ? config2.r3Injector : config2.moduleRef.injector;\n  const ngZone = envInjector.get(NgZone);\n  return ngZone.run(() => {\n    if (isApplicationBootstrapConfig(config2)) {\n      config2.r3Injector.resolveInjectorInitializers();\n    } else {\n      config2.moduleRef.resolveInjectorInitializers();\n    }\n    const exceptionHandler = envInjector.get(ErrorHandler, null);\n    if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n      if (exceptionHandler === null) {\n        const errorMessage = isApplicationBootstrapConfig(config2) ? \"No `ErrorHandler` found in the Dependency Injection tree.\" : \"No ErrorHandler. Is platform module (BrowserModule) included\";\n        throw new RuntimeError(402, errorMessage);\n      }\n      if (envInjector.get(PROVIDED_ZONELESS) && envInjector.get(PROVIDED_NG_ZONE)) {\n        throw new RuntimeError(408, \"Invalid change detection configuration: provideZoneChangeDetection and provideExperimentalZonelessChangeDetection cannot be used together.\");\n      }\n    }\n    let onErrorSubscription;\n    ngZone.runOutsideAngular(() => {\n      onErrorSubscription = ngZone.onError.subscribe({\n        next: (error) => {\n          exceptionHandler.handleError(error);\n        }\n      });\n    });\n    if (isApplicationBootstrapConfig(config2)) {\n      const destroyListener = () => envInjector.destroy();\n      const onPlatformDestroyListeners = config2.platformInjector.get(PLATFORM_DESTROY_LISTENERS);\n      onPlatformDestroyListeners.add(destroyListener);\n      envInjector.onDestroy(() => {\n        onErrorSubscription.unsubscribe();\n        onPlatformDestroyListeners.delete(destroyListener);\n      });\n    } else {\n      const destroyListener = () => config2.moduleRef.destroy();\n      const onPlatformDestroyListeners = config2.platformInjector.get(PLATFORM_DESTROY_LISTENERS);\n      onPlatformDestroyListeners.add(destroyListener);\n      config2.moduleRef.onDestroy(() => {\n        remove(config2.allPlatformModules, config2.moduleRef);\n        onErrorSubscription.unsubscribe();\n        onPlatformDestroyListeners.delete(destroyListener);\n      });\n    }\n    return _callAndReportToErrorHandler(exceptionHandler, ngZone, () => {\n      const initStatus = envInjector.get(ApplicationInitStatus);\n      initStatus.runInitializers();\n      return initStatus.donePromise.then(() => {\n        const localeId = envInjector.get(LOCALE_ID, DEFAULT_LOCALE_ID);\n        setLocaleId(localeId || DEFAULT_LOCALE_ID);\n        const enableRootComponentBoostrap = envInjector.get(ENABLE_ROOT_COMPONENT_BOOTSTRAP, true);\n        if (!enableRootComponentBoostrap) {\n          if (isApplicationBootstrapConfig(config2)) {\n            return envInjector.get(ApplicationRef);\n          }\n          config2.allPlatformModules.push(config2.moduleRef);\n          return config2.moduleRef;\n        }\n        if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n          const imagePerformanceService = envInjector.get(ImagePerformanceWarning);\n          imagePerformanceService.start();\n        }\n        if (isApplicationBootstrapConfig(config2)) {\n          const appRef = envInjector.get(ApplicationRef);\n          if (config2.rootComponent !== void 0) {\n            appRef.bootstrap(config2.rootComponent);\n          }\n          return appRef;\n        } else {\n          moduleDoBootstrap(config2.moduleRef, config2.allPlatformModules);\n          return config2.moduleRef;\n        }\n      });\n    });\n  });\n}\nfunction moduleDoBootstrap(moduleRef, allPlatformModules) {\n  const appRef = moduleRef.injector.get(ApplicationRef);\n  if (moduleRef._bootstrapComponents.length > 0) {\n    moduleRef._bootstrapComponents.forEach((f) => appRef.bootstrap(f));\n  } else if (moduleRef.instance.ngDoBootstrap) {\n    moduleRef.instance.ngDoBootstrap(appRef);\n  } else {\n    throw new RuntimeError(-403, ngDevMode && `The module ${stringify(moduleRef.instance.constructor)} was bootstrapped, but it does not declare \"@NgModule.bootstrap\" components nor a \"ngDoBootstrap\" method. Please define one of these.`);\n  }\n  allPlatformModules.push(moduleRef);\n}\nfunction _callAndReportToErrorHandler(errorHandler2, ngZone, callback) {\n  try {\n    const result = callback();\n    if (isPromise2(result)) {\n      return result.catch((e) => {\n        ngZone.runOutsideAngular(() => errorHandler2.handleError(e));\n        throw e;\n      });\n    }\n    return result;\n  } catch (e) {\n    ngZone.runOutsideAngular(() => errorHandler2.handleError(e));\n    throw e;\n  }\n}\nvar PlatformRef = class _PlatformRef {\n  _injector;\n  _modules = [];\n  _destroyListeners = [];\n  _destroyed = false;\n  /** @internal */\n  constructor(_injector) {\n    this._injector = _injector;\n  }\n  /**\n   * Creates an instance of an `@NgModule` for the given platform.\n   *\n   * @deprecated Passing NgModule factories as the `PlatformRef.bootstrapModuleFactory` function\n   *     argument is deprecated. Use the `PlatformRef.bootstrapModule` API instead.\n   */\n  bootstrapModuleFactory(moduleFactory, options) {\n    const scheduleInRootZone = options?.scheduleInRootZone;\n    const ngZoneFactory = () => getNgZone(options?.ngZone, __spreadProps(__spreadValues({}, getNgZoneOptions({\n      eventCoalescing: options?.ngZoneEventCoalescing,\n      runCoalescing: options?.ngZoneRunCoalescing\n    })), {\n      scheduleInRootZone\n    }));\n    const ignoreChangesOutsideZone = options?.ignoreChangesOutsideZone;\n    const allAppProviders = [internalProvideZoneChangeDetection({\n      ngZoneFactory,\n      ignoreChangesOutsideZone\n    }), {\n      provide: ChangeDetectionScheduler,\n      useExisting: ChangeDetectionSchedulerImpl\n    }];\n    const moduleRef = createNgModuleRefWithProviders(moduleFactory.moduleType, this.injector, allAppProviders);\n    return bootstrap({\n      moduleRef,\n      allPlatformModules: this._modules,\n      platformInjector: this.injector\n    });\n  }\n  /**\n   * Creates an instance of an `@NgModule` for a given platform.\n   *\n   * @usageNotes\n   * ### Simple Example\n   *\n   * ```ts\n   * @NgModule({\n   *   imports: [BrowserModule]\n   * })\n   * class MyModule {}\n   *\n   * let moduleRef = platformBrowser().bootstrapModule(MyModule);\n   * ```\n   *\n   */\n  bootstrapModule(moduleType, compilerOptions = []) {\n    const options = optionsReducer({}, compilerOptions);\n    return compileNgModuleFactory(this.injector, options, moduleType).then((moduleFactory) => this.bootstrapModuleFactory(moduleFactory, options));\n  }\n  /**\n   * Registers a listener to be called when the platform is destroyed.\n   */\n  onDestroy(callback) {\n    this._destroyListeners.push(callback);\n  }\n  /**\n   * Retrieves the platform {@link Injector}, which is the parent injector for\n   * every Angular application on the page and provides singleton providers.\n   */\n  get injector() {\n    return this._injector;\n  }\n  /**\n   * Destroys the current Angular platform and all Angular applications on the page.\n   * Destroys all modules and listeners registered with the platform.\n   */\n  destroy() {\n    if (this._destroyed) {\n      throw new RuntimeError(404, ngDevMode && \"The platform has already been destroyed!\");\n    }\n    this._modules.slice().forEach((module) => module.destroy());\n    this._destroyListeners.forEach((listener) => listener());\n    const destroyListeners = this._injector.get(PLATFORM_DESTROY_LISTENERS, null);\n    if (destroyListeners) {\n      destroyListeners.forEach((listener) => listener());\n      destroyListeners.clear();\n    }\n    this._destroyed = true;\n  }\n  /**\n   * Indicates whether this instance was destroyed.\n   */\n  get destroyed() {\n    return this._destroyed;\n  }\n  static \\u0275fac = function PlatformRef_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _PlatformRef)(\\u0275\\u0275inject(Injector));\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _PlatformRef,\n    factory: _PlatformRef.\\u0275fac,\n    providedIn: \"platform\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(PlatformRef, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"platform\"\n    }]\n  }], () => [{\n    type: Injector\n  }], null);\n})();\nvar _platformInjector = null;\nvar ALLOW_MULTIPLE_PLATFORMS = new InjectionToken(ngDevMode ? \"AllowMultipleToken\" : \"\");\nfunction createPlatform(injector) {\n  if (_platformInjector && !_platformInjector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {\n    throw new RuntimeError(400, ngDevMode && \"There can be only one platform. Destroy the previous one to create a new one.\");\n  }\n  publishDefaultGlobalUtils();\n  publishSignalConfiguration();\n  _platformInjector = injector;\n  const platform = injector.get(PlatformRef);\n  runPlatformInitializers(injector);\n  return platform;\n}\nfunction createPlatformFactory(parentPlatformFactory, name, providers = []) {\n  const desc = `Platform: ${name}`;\n  const marker = new InjectionToken(desc);\n  return (extraProviders = []) => {\n    let platform = getPlatform();\n    if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, false)) {\n      const platformProviders = [...providers, ...extraProviders, {\n        provide: marker,\n        useValue: true\n      }];\n      if (parentPlatformFactory) {\n        parentPlatformFactory(platformProviders);\n      } else {\n        createPlatform(createPlatformInjector(platformProviders, desc));\n      }\n    }\n    return assertPlatform(marker);\n  };\n}\nfunction createPlatformInjector(providers = [], name) {\n  return Injector.create({\n    name,\n    providers: [{\n      provide: INJECTOR_SCOPE,\n      useValue: \"platform\"\n    }, {\n      provide: PLATFORM_DESTROY_LISTENERS,\n      useValue: /* @__PURE__ */ new Set([() => _platformInjector = null])\n    }, ...providers]\n  });\n}\nfunction assertPlatform(requiredToken) {\n  const platform = getPlatform();\n  if (!platform) {\n    throw new RuntimeError(401, ngDevMode && \"No platform exists!\");\n  }\n  if ((typeof ngDevMode === \"undefined\" || ngDevMode) && !platform.injector.get(requiredToken, null)) {\n    throw new RuntimeError(400, \"A platform with a different configuration has been created. Please destroy it first.\");\n  }\n  return platform;\n}\nfunction getPlatform() {\n  return _platformInjector?.get(PlatformRef) ?? null;\n}\nfunction createOrReusePlatformInjector(providers = []) {\n  if (_platformInjector) return _platformInjector;\n  publishDefaultGlobalUtils();\n  const injector = createPlatformInjector(providers);\n  _platformInjector = injector;\n  publishSignalConfiguration();\n  runPlatformInitializers(injector);\n  return injector;\n}\nfunction runPlatformInitializers(injector) {\n  const inits = injector.get(PLATFORM_INITIALIZER, null);\n  runInInjectionContext(injector, () => {\n    inits?.forEach((init) => init());\n  });\n}\nfunction isDevMode() {\n  return typeof ngDevMode === \"undefined\" || !!ngDevMode;\n}\nvar ChangeDetectorRef = class {\n  /**\n   * @internal\n   * @nocollapse\n   */\n  static __NG_ELEMENT_ID__ = injectChangeDetectorRef;\n};\nfunction injectChangeDetectorRef(flags) {\n  return createViewRef(\n    getCurrentTNode(),\n    getLView(),\n    (flags & 16) === 16\n    /* InternalInjectFlags.ForPipe */\n  );\n}\nfunction createViewRef(tNode, lView, isPipe2) {\n  if (isComponentHost(tNode) && !isPipe2) {\n    const componentView = getComponentLViewByIndex(tNode.index, lView);\n    return new ViewRef$1(componentView, componentView);\n  } else if (tNode.type & (3 | 12 | 32 | 128)) {\n    const hostComponentView = lView[DECLARATION_COMPONENT_VIEW];\n    return new ViewRef$1(hostComponentView, lView);\n  }\n  return null;\n}\nvar DefaultIterableDifferFactory = class {\n  constructor() {\n  }\n  supports(obj) {\n    return isListLikeIterable(obj);\n  }\n  create(trackByFn) {\n    return new DefaultIterableDiffer(trackByFn);\n  }\n};\nvar trackByIdentity = (index, item) => item;\nvar DefaultIterableDiffer = class {\n  length = 0;\n  // TODO: confirm the usage of `collection` as it's unused, readonly and on a non public API.\n  collection;\n  // Keeps track of the used records at any point in time (during & across `_check()` calls)\n  _linkedRecords = null;\n  // Keeps track of the removed records at any point in time during `_check()` calls.\n  _unlinkedRecords = null;\n  _previousItHead = null;\n  _itHead = null;\n  _itTail = null;\n  _additionsHead = null;\n  _additionsTail = null;\n  _movesHead = null;\n  _movesTail = null;\n  _removalsHead = null;\n  _removalsTail = null;\n  // Keeps track of records where custom track by is the same, but item identity has changed\n  _identityChangesHead = null;\n  _identityChangesTail = null;\n  _trackByFn;\n  constructor(trackByFn) {\n    this._trackByFn = trackByFn || trackByIdentity;\n  }\n  forEachItem(fn) {\n    let record;\n    for (record = this._itHead; record !== null; record = record._next) {\n      fn(record);\n    }\n  }\n  forEachOperation(fn) {\n    let nextIt = this._itHead;\n    let nextRemove = this._removalsHead;\n    let addRemoveOffset = 0;\n    let moveOffsets = null;\n    while (nextIt || nextRemove) {\n      const record = !nextRemove || nextIt && nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ? nextIt : nextRemove;\n      const adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);\n      const currentIndex = record.currentIndex;\n      if (record === nextRemove) {\n        addRemoveOffset--;\n        nextRemove = nextRemove._nextRemoved;\n      } else {\n        nextIt = nextIt._next;\n        if (record.previousIndex == null) {\n          addRemoveOffset++;\n        } else {\n          if (!moveOffsets) moveOffsets = [];\n          const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;\n          const localCurrentIndex = currentIndex - addRemoveOffset;\n          if (localMovePreviousIndex != localCurrentIndex) {\n            for (let i = 0; i < localMovePreviousIndex; i++) {\n              const offset = i < moveOffsets.length ? moveOffsets[i] : moveOffsets[i] = 0;\n              const index = offset + i;\n              if (localCurrentIndex <= index && index < localMovePreviousIndex) {\n                moveOffsets[i] = offset + 1;\n              }\n            }\n            const previousIndex = record.previousIndex;\n            moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;\n          }\n        }\n      }\n      if (adjPreviousIndex !== currentIndex) {\n        fn(record, adjPreviousIndex, currentIndex);\n      }\n    }\n  }\n  forEachPreviousItem(fn) {\n    let record;\n    for (record = this._previousItHead; record !== null; record = record._nextPrevious) {\n      fn(record);\n    }\n  }\n  forEachAddedItem(fn) {\n    let record;\n    for (record = this._additionsHead; record !== null; record = record._nextAdded) {\n      fn(record);\n    }\n  }\n  forEachMovedItem(fn) {\n    let record;\n    for (record = this._movesHead; record !== null; record = record._nextMoved) {\n      fn(record);\n    }\n  }\n  forEachRemovedItem(fn) {\n    let record;\n    for (record = this._removalsHead; record !== null; record = record._nextRemoved) {\n      fn(record);\n    }\n  }\n  forEachIdentityChange(fn) {\n    let record;\n    for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {\n      fn(record);\n    }\n  }\n  diff(collection) {\n    if (collection == null) collection = [];\n    if (!isListLikeIterable(collection)) {\n      throw new RuntimeError(900, ngDevMode && `Error trying to diff '${stringify(collection)}'. Only arrays and iterables are allowed`);\n    }\n    if (this.check(collection)) {\n      return this;\n    } else {\n      return null;\n    }\n  }\n  onDestroy() {\n  }\n  check(collection) {\n    this._reset();\n    let record = this._itHead;\n    let mayBeDirty = false;\n    let index;\n    let item;\n    let itemTrackBy;\n    if (Array.isArray(collection)) {\n      this.length = collection.length;\n      for (let index2 = 0; index2 < this.length; index2++) {\n        item = collection[index2];\n        itemTrackBy = this._trackByFn(index2, item);\n        if (record === null || !Object.is(record.trackById, itemTrackBy)) {\n          record = this._mismatch(record, item, itemTrackBy, index2);\n          mayBeDirty = true;\n        } else {\n          if (mayBeDirty) {\n            record = this._verifyReinsertion(record, item, itemTrackBy, index2);\n          }\n          if (!Object.is(record.item, item)) this._addIdentityChange(record, item);\n        }\n        record = record._next;\n      }\n    } else {\n      index = 0;\n      iterateListLike(collection, (item2) => {\n        itemTrackBy = this._trackByFn(index, item2);\n        if (record === null || !Object.is(record.trackById, itemTrackBy)) {\n          record = this._mismatch(record, item2, itemTrackBy, index);\n          mayBeDirty = true;\n        } else {\n          if (mayBeDirty) {\n            record = this._verifyReinsertion(record, item2, itemTrackBy, index);\n          }\n          if (!Object.is(record.item, item2)) this._addIdentityChange(record, item2);\n        }\n        record = record._next;\n        index++;\n      });\n      this.length = index;\n    }\n    this._truncate(record);\n    this.collection = collection;\n    return this.isDirty;\n  }\n  /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity\n   * changes.\n   */\n  get isDirty() {\n    return this._additionsHead !== null || this._movesHead !== null || this._removalsHead !== null || this._identityChangesHead !== null;\n  }\n  /**\n   * Reset the state of the change objects to show no changes. This means set previousKey to\n   * currentKey, and clear all of the queues (additions, moves, removals).\n   * Set the previousIndexes of moved and added items to their currentIndexes\n   * Reset the list of additions, moves and removals\n   *\n   * @internal\n   */\n  _reset() {\n    if (this.isDirty) {\n      let record;\n      for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {\n        record._nextPrevious = record._next;\n      }\n      for (record = this._additionsHead; record !== null; record = record._nextAdded) {\n        record.previousIndex = record.currentIndex;\n      }\n      this._additionsHead = this._additionsTail = null;\n      for (record = this._movesHead; record !== null; record = record._nextMoved) {\n        record.previousIndex = record.currentIndex;\n      }\n      this._movesHead = this._movesTail = null;\n      this._removalsHead = this._removalsTail = null;\n      this._identityChangesHead = this._identityChangesTail = null;\n    }\n  }\n  /**\n   * This is the core function which handles differences between collections.\n   *\n   * - `record` is the record which we saw at this position last time. If null then it is a new\n   *   item.\n   * - `item` is the current item in the collection\n   * - `index` is the position of the item in the collection\n   *\n   * @internal\n   */\n  _mismatch(record, item, itemTrackBy, index) {\n    let previousRecord;\n    if (record === null) {\n      previousRecord = this._itTail;\n    } else {\n      previousRecord = record._prev;\n      this._remove(record);\n    }\n    record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);\n    if (record !== null) {\n      if (!Object.is(record.item, item)) this._addIdentityChange(record, item);\n      this._reinsertAfter(record, previousRecord, index);\n    } else {\n      record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);\n      if (record !== null) {\n        if (!Object.is(record.item, item)) this._addIdentityChange(record, item);\n        this._moveAfter(record, previousRecord, index);\n      } else {\n        record = this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index);\n      }\n    }\n    return record;\n  }\n  /**\n   * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)\n   *\n   * Use case: `[a, a]` => `[b, a, a]`\n   *\n   * If we did not have this check then the insertion of `b` would:\n   *   1) evict first `a`\n   *   2) insert `b` at `0` index.\n   *   3) leave `a` at index `1` as is. <-- this is wrong!\n   *   3) reinsert `a` at index 2. <-- this is wrong!\n   *\n   * The correct behavior is:\n   *   1) evict first `a`\n   *   2) insert `b` at `0` index.\n   *   3) reinsert `a` at index 1.\n   *   3) move `a` at from `1` to `2`.\n   *\n   *\n   * Double check that we have not evicted a duplicate item. We need to check if the item type may\n   * have already been removed:\n   * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted\n   * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a\n   * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'\n   * at the end.\n   *\n   * @internal\n   */\n  _verifyReinsertion(record, item, itemTrackBy, index) {\n    let reinsertRecord = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);\n    if (reinsertRecord !== null) {\n      record = this._reinsertAfter(reinsertRecord, record._prev, index);\n    } else if (record.currentIndex != index) {\n      record.currentIndex = index;\n      this._addToMoves(record, index);\n    }\n    return record;\n  }\n  /**\n   * Get rid of any excess {@link IterableChangeRecord_}s from the previous collection\n   *\n   * - `record` The first excess {@link IterableChangeRecord_}.\n   *\n   * @internal\n   */\n  _truncate(record) {\n    while (record !== null) {\n      const nextRecord = record._next;\n      this._addToRemovals(this._unlink(record));\n      record = nextRecord;\n    }\n    if (this._unlinkedRecords !== null) {\n      this._unlinkedRecords.clear();\n    }\n    if (this._additionsTail !== null) {\n      this._additionsTail._nextAdded = null;\n    }\n    if (this._movesTail !== null) {\n      this._movesTail._nextMoved = null;\n    }\n    if (this._itTail !== null) {\n      this._itTail._next = null;\n    }\n    if (this._removalsTail !== null) {\n      this._removalsTail._nextRemoved = null;\n    }\n    if (this._identityChangesTail !== null) {\n      this._identityChangesTail._nextIdentityChange = null;\n    }\n  }\n  /** @internal */\n  _reinsertAfter(record, prevRecord, index) {\n    if (this._unlinkedRecords !== null) {\n      this._unlinkedRecords.remove(record);\n    }\n    const prev = record._prevRemoved;\n    const next = record._nextRemoved;\n    if (prev === null) {\n      this._removalsHead = next;\n    } else {\n      prev._nextRemoved = next;\n    }\n    if (next === null) {\n      this._removalsTail = prev;\n    } else {\n      next._prevRemoved = prev;\n    }\n    this._insertAfter(record, prevRecord, index);\n    this._addToMoves(record, index);\n    return record;\n  }\n  /** @internal */\n  _moveAfter(record, prevRecord, index) {\n    this._unlink(record);\n    this._insertAfter(record, prevRecord, index);\n    this._addToMoves(record, index);\n    return record;\n  }\n  /** @internal */\n  _addAfter(record, prevRecord, index) {\n    this._insertAfter(record, prevRecord, index);\n    if (this._additionsTail === null) {\n      this._additionsTail = this._additionsHead = record;\n    } else {\n      this._additionsTail = this._additionsTail._nextAdded = record;\n    }\n    return record;\n  }\n  /** @internal */\n  _insertAfter(record, prevRecord, index) {\n    const next = prevRecord === null ? this._itHead : prevRecord._next;\n    record._next = next;\n    record._prev = prevRecord;\n    if (next === null) {\n      this._itTail = record;\n    } else {\n      next._prev = record;\n    }\n    if (prevRecord === null) {\n      this._itHead = record;\n    } else {\n      prevRecord._next = record;\n    }\n    if (this._linkedRecords === null) {\n      this._linkedRecords = new _DuplicateMap();\n    }\n    this._linkedRecords.put(record);\n    record.currentIndex = index;\n    return record;\n  }\n  /** @internal */\n  _remove(record) {\n    return this._addToRemovals(this._unlink(record));\n  }\n  /** @internal */\n  _unlink(record) {\n    if (this._linkedRecords !== null) {\n      this._linkedRecords.remove(record);\n    }\n    const prev = record._prev;\n    const next = record._next;\n    if (prev === null) {\n      this._itHead = next;\n    } else {\n      prev._next = next;\n    }\n    if (next === null) {\n      this._itTail = prev;\n    } else {\n      next._prev = prev;\n    }\n    return record;\n  }\n  /** @internal */\n  _addToMoves(record, toIndex) {\n    if (record.previousIndex === toIndex) {\n      return record;\n    }\n    if (this._movesTail === null) {\n      this._movesTail = this._movesHead = record;\n    } else {\n      this._movesTail = this._movesTail._nextMoved = record;\n    }\n    return record;\n  }\n  _addToRemovals(record) {\n    if (this._unlinkedRecords === null) {\n      this._unlinkedRecords = new _DuplicateMap();\n    }\n    this._unlinkedRecords.put(record);\n    record.currentIndex = null;\n    record._nextRemoved = null;\n    if (this._removalsTail === null) {\n      this._removalsTail = this._removalsHead = record;\n      record._prevRemoved = null;\n    } else {\n      record._prevRemoved = this._removalsTail;\n      this._removalsTail = this._removalsTail._nextRemoved = record;\n    }\n    return record;\n  }\n  /** @internal */\n  _addIdentityChange(record, item) {\n    record.item = item;\n    if (this._identityChangesTail === null) {\n      this._identityChangesTail = this._identityChangesHead = record;\n    } else {\n      this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;\n    }\n    return record;\n  }\n};\nvar IterableChangeRecord_ = class {\n  item;\n  trackById;\n  currentIndex = null;\n  previousIndex = null;\n  /** @internal */\n  _nextPrevious = null;\n  /** @internal */\n  _prev = null;\n  /** @internal */\n  _next = null;\n  /** @internal */\n  _prevDup = null;\n  /** @internal */\n  _nextDup = null;\n  /** @internal */\n  _prevRemoved = null;\n  /** @internal */\n  _nextRemoved = null;\n  /** @internal */\n  _nextAdded = null;\n  /** @internal */\n  _nextMoved = null;\n  /** @internal */\n  _nextIdentityChange = null;\n  constructor(item, trackById) {\n    this.item = item;\n    this.trackById = trackById;\n  }\n};\nvar _DuplicateItemRecordList = class {\n  /** @internal */\n  _head = null;\n  /** @internal */\n  _tail = null;\n  /**\n   * Append the record to the list of duplicates.\n   *\n   * Note: by design all records in the list of duplicates hold the same value in record.item.\n   */\n  add(record) {\n    if (this._head === null) {\n      this._head = this._tail = record;\n      record._nextDup = null;\n      record._prevDup = null;\n    } else {\n      this._tail._nextDup = record;\n      record._prevDup = this._tail;\n      record._nextDup = null;\n      this._tail = record;\n    }\n  }\n  // Returns a IterableChangeRecord_ having IterableChangeRecord_.trackById == trackById and\n  // IterableChangeRecord_.currentIndex >= atOrAfterIndex\n  get(trackById, atOrAfterIndex) {\n    let record;\n    for (record = this._head; record !== null; record = record._nextDup) {\n      if ((atOrAfterIndex === null || atOrAfterIndex <= record.currentIndex) && Object.is(record.trackById, trackById)) {\n        return record;\n      }\n    }\n    return null;\n  }\n  /**\n   * Remove one {@link IterableChangeRecord_} from the list of duplicates.\n   *\n   * Returns whether the list of duplicates is empty.\n   */\n  remove(record) {\n    const prev = record._prevDup;\n    const next = record._nextDup;\n    if (prev === null) {\n      this._head = next;\n    } else {\n      prev._nextDup = next;\n    }\n    if (next === null) {\n      this._tail = prev;\n    } else {\n      next._prevDup = prev;\n    }\n    return this._head === null;\n  }\n};\nvar _DuplicateMap = class {\n  map = /* @__PURE__ */ new Map();\n  put(record) {\n    const key = record.trackById;\n    let duplicates = this.map.get(key);\n    if (!duplicates) {\n      duplicates = new _DuplicateItemRecordList();\n      this.map.set(key, duplicates);\n    }\n    duplicates.add(record);\n  }\n  /**\n   * Retrieve the `value` using key. Because the IterableChangeRecord_ value may be one which we\n   * have already iterated over, we use the `atOrAfterIndex` to pretend it is not there.\n   *\n   * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we\n   * have any more `a`s needs to return the second `a`.\n   */\n  get(trackById, atOrAfterIndex) {\n    const key = trackById;\n    const recordList = this.map.get(key);\n    return recordList ? recordList.get(trackById, atOrAfterIndex) : null;\n  }\n  /**\n   * Removes a {@link IterableChangeRecord_} from the list of duplicates.\n   *\n   * The list of duplicates also is removed from the map if it gets empty.\n   */\n  remove(record) {\n    const key = record.trackById;\n    const recordList = this.map.get(key);\n    if (recordList.remove(record)) {\n      this.map.delete(key);\n    }\n    return record;\n  }\n  get isEmpty() {\n    return this.map.size === 0;\n  }\n  clear() {\n    this.map.clear();\n  }\n};\nfunction getPreviousIndex(item, addRemoveOffset, moveOffsets) {\n  const previousIndex = item.previousIndex;\n  if (previousIndex === null) return previousIndex;\n  let moveOffset = 0;\n  if (moveOffsets && previousIndex < moveOffsets.length) {\n    moveOffset = moveOffsets[previousIndex];\n  }\n  return previousIndex + addRemoveOffset + moveOffset;\n}\nvar DefaultKeyValueDifferFactory = class {\n  constructor() {\n  }\n  supports(obj) {\n    return obj instanceof Map || isJsObject(obj);\n  }\n  create() {\n    return new DefaultKeyValueDiffer();\n  }\n};\nvar DefaultKeyValueDiffer = class {\n  _records = /* @__PURE__ */ new Map();\n  _mapHead = null;\n  // _appendAfter is used in the check loop\n  _appendAfter = null;\n  _previousMapHead = null;\n  _changesHead = null;\n  _changesTail = null;\n  _additionsHead = null;\n  _additionsTail = null;\n  _removalsHead = null;\n  _removalsTail = null;\n  get isDirty() {\n    return this._additionsHead !== null || this._changesHead !== null || this._removalsHead !== null;\n  }\n  forEachItem(fn) {\n    let record;\n    for (record = this._mapHead; record !== null; record = record._next) {\n      fn(record);\n    }\n  }\n  forEachPreviousItem(fn) {\n    let record;\n    for (record = this._previousMapHead; record !== null; record = record._nextPrevious) {\n      fn(record);\n    }\n  }\n  forEachChangedItem(fn) {\n    let record;\n    for (record = this._changesHead; record !== null; record = record._nextChanged) {\n      fn(record);\n    }\n  }\n  forEachAddedItem(fn) {\n    let record;\n    for (record = this._additionsHead; record !== null; record = record._nextAdded) {\n      fn(record);\n    }\n  }\n  forEachRemovedItem(fn) {\n    let record;\n    for (record = this._removalsHead; record !== null; record = record._nextRemoved) {\n      fn(record);\n    }\n  }\n  diff(map2) {\n    if (!map2) {\n      map2 = /* @__PURE__ */ new Map();\n    } else if (!(map2 instanceof Map || isJsObject(map2))) {\n      throw new RuntimeError(900, ngDevMode && `Error trying to diff '${stringify(map2)}'. Only maps and objects are allowed`);\n    }\n    return this.check(map2) ? this : null;\n  }\n  onDestroy() {\n  }\n  /**\n   * Check the current state of the map vs the previous.\n   * The algorithm is optimised for when the keys do no change.\n   */\n  check(map2) {\n    this._reset();\n    let insertBefore = this._mapHead;\n    this._appendAfter = null;\n    this._forEach(map2, (value, key) => {\n      if (insertBefore && insertBefore.key === key) {\n        this._maybeAddToChanges(insertBefore, value);\n        this._appendAfter = insertBefore;\n        insertBefore = insertBefore._next;\n      } else {\n        const record = this._getOrCreateRecordForKey(key, value);\n        insertBefore = this._insertBeforeOrAppend(insertBefore, record);\n      }\n    });\n    if (insertBefore) {\n      if (insertBefore._prev) {\n        insertBefore._prev._next = null;\n      }\n      this._removalsHead = insertBefore;\n      for (let record = insertBefore; record !== null; record = record._nextRemoved) {\n        if (record === this._mapHead) {\n          this._mapHead = null;\n        }\n        this._records.delete(record.key);\n        record._nextRemoved = record._next;\n        record.previousValue = record.currentValue;\n        record.currentValue = null;\n        record._prev = null;\n        record._next = null;\n      }\n    }\n    if (this._changesTail) this._changesTail._nextChanged = null;\n    if (this._additionsTail) this._additionsTail._nextAdded = null;\n    return this.isDirty;\n  }\n  /**\n   * Inserts a record before `before` or append at the end of the list when `before` is null.\n   *\n   * Notes:\n   * - This method appends at `this._appendAfter`,\n   * - This method updates `this._appendAfter`,\n   * - The return value is the new value for the insertion pointer.\n   */\n  _insertBeforeOrAppend(before, record) {\n    if (before) {\n      const prev = before._prev;\n      record._next = before;\n      record._prev = prev;\n      before._prev = record;\n      if (prev) {\n        prev._next = record;\n      }\n      if (before === this._mapHead) {\n        this._mapHead = record;\n      }\n      this._appendAfter = before;\n      return before;\n    }\n    if (this._appendAfter) {\n      this._appendAfter._next = record;\n      record._prev = this._appendAfter;\n    } else {\n      this._mapHead = record;\n    }\n    this._appendAfter = record;\n    return null;\n  }\n  _getOrCreateRecordForKey(key, value) {\n    if (this._records.has(key)) {\n      const record2 = this._records.get(key);\n      this._maybeAddToChanges(record2, value);\n      const prev = record2._prev;\n      const next = record2._next;\n      if (prev) {\n        prev._next = next;\n      }\n      if (next) {\n        next._prev = prev;\n      }\n      record2._next = null;\n      record2._prev = null;\n      return record2;\n    }\n    const record = new KeyValueChangeRecord_(key);\n    this._records.set(key, record);\n    record.currentValue = value;\n    this._addToAdditions(record);\n    return record;\n  }\n  /** @internal */\n  _reset() {\n    if (this.isDirty) {\n      let record;\n      this._previousMapHead = this._mapHead;\n      for (record = this._previousMapHead; record !== null; record = record._next) {\n        record._nextPrevious = record._next;\n      }\n      for (record = this._changesHead; record !== null; record = record._nextChanged) {\n        record.previousValue = record.currentValue;\n      }\n      for (record = this._additionsHead; record != null; record = record._nextAdded) {\n        record.previousValue = record.currentValue;\n      }\n      this._changesHead = this._changesTail = null;\n      this._additionsHead = this._additionsTail = null;\n      this._removalsHead = null;\n    }\n  }\n  // Add the record or a given key to the list of changes only when the value has actually changed\n  _maybeAddToChanges(record, newValue) {\n    if (!Object.is(newValue, record.currentValue)) {\n      record.previousValue = record.currentValue;\n      record.currentValue = newValue;\n      this._addToChanges(record);\n    }\n  }\n  _addToAdditions(record) {\n    if (this._additionsHead === null) {\n      this._additionsHead = this._additionsTail = record;\n    } else {\n      this._additionsTail._nextAdded = record;\n      this._additionsTail = record;\n    }\n  }\n  _addToChanges(record) {\n    if (this._changesHead === null) {\n      this._changesHead = this._changesTail = record;\n    } else {\n      this._changesTail._nextChanged = record;\n      this._changesTail = record;\n    }\n  }\n  /** @internal */\n  _forEach(obj, fn) {\n    if (obj instanceof Map) {\n      obj.forEach(fn);\n    } else {\n      Object.keys(obj).forEach((k) => fn(obj[k], k));\n    }\n  }\n};\nvar KeyValueChangeRecord_ = class {\n  key;\n  previousValue = null;\n  currentValue = null;\n  /** @internal */\n  _nextPrevious = null;\n  /** @internal */\n  _next = null;\n  /** @internal */\n  _prev = null;\n  /** @internal */\n  _nextAdded = null;\n  /** @internal */\n  _nextRemoved = null;\n  /** @internal */\n  _nextChanged = null;\n  constructor(key) {\n    this.key = key;\n  }\n};\nfunction defaultIterableDiffersFactory() {\n  return new IterableDiffers([new DefaultIterableDifferFactory()]);\n}\nvar IterableDiffers = class _IterableDiffers {\n  factories;\n  /** @nocollapse */\n  static \\u0275prov = (\n    /** @pureOrBreakMyCode */\n    /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n      token: _IterableDiffers,\n      providedIn: \"root\",\n      factory: defaultIterableDiffersFactory\n    })\n  );\n  constructor(factories) {\n    this.factories = factories;\n  }\n  static create(factories, parent) {\n    if (parent != null) {\n      const copied = parent.factories.slice();\n      factories = factories.concat(copied);\n    }\n    return new _IterableDiffers(factories);\n  }\n  /**\n   * Takes an array of {@link IterableDifferFactory} and returns a provider used to extend the\n   * inherited {@link IterableDiffers} instance with the provided factories and return a new\n   * {@link IterableDiffers} instance.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example shows how to extend an existing list of factories,\n   * which will only be applied to the injector for this component and its children.\n   * This step is all that's required to make a new {@link IterableDiffer} available.\n   *\n   * ```ts\n   * @Component({\n   *   viewProviders: [\n   *     IterableDiffers.extend([new ImmutableListDiffer()])\n   *   ]\n   * })\n   * ```\n   */\n  static extend(factories) {\n    return {\n      provide: _IterableDiffers,\n      useFactory: (parent) => {\n        return _IterableDiffers.create(factories, parent || defaultIterableDiffersFactory());\n      },\n      // Dependency technically isn't optional, but we can provide a better error message this way.\n      deps: [[_IterableDiffers, new SkipSelf(), new Optional()]]\n    };\n  }\n  find(iterable) {\n    const factory = this.factories.find((f) => f.supports(iterable));\n    if (factory != null) {\n      return factory;\n    } else {\n      throw new RuntimeError(901, ngDevMode && `Cannot find a differ supporting object '${iterable}' of type '${getTypeNameForDebugging(iterable)}'`);\n    }\n  }\n};\nfunction getTypeNameForDebugging(type) {\n  return type[\"name\"] || typeof type;\n}\nfunction defaultKeyValueDiffersFactory() {\n  return new KeyValueDiffers([new DefaultKeyValueDifferFactory()]);\n}\nvar KeyValueDiffers = class _KeyValueDiffers {\n  /** @nocollapse */\n  static \\u0275prov = (\n    /** @pureOrBreakMyCode */\n    /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n      token: _KeyValueDiffers,\n      providedIn: \"root\",\n      factory: defaultKeyValueDiffersFactory\n    })\n  );\n  factories;\n  constructor(factories) {\n    this.factories = factories;\n  }\n  static create(factories, parent) {\n    if (parent) {\n      const copied = parent.factories.slice();\n      factories = factories.concat(copied);\n    }\n    return new _KeyValueDiffers(factories);\n  }\n  /**\n   * Takes an array of {@link KeyValueDifferFactory} and returns a provider used to extend the\n   * inherited {@link KeyValueDiffers} instance with the provided factories and return a new\n   * {@link KeyValueDiffers} instance.\n   *\n   * @usageNotes\n   * ### Example\n   *\n   * The following example shows how to extend an existing list of factories,\n   * which will only be applied to the injector for this component and its children.\n   * This step is all that's required to make a new {@link KeyValueDiffer} available.\n   *\n   * ```ts\n   * @Component({\n   *   viewProviders: [\n   *     KeyValueDiffers.extend([new ImmutableMapDiffer()])\n   *   ]\n   * })\n   * ```\n   */\n  static extend(factories) {\n    return {\n      provide: _KeyValueDiffers,\n      useFactory: (parent) => {\n        return _KeyValueDiffers.create(factories, parent || defaultKeyValueDiffersFactory());\n      },\n      // Dependency technically isn't optional, but we can provide a better error message this way.\n      deps: [[_KeyValueDiffers, new SkipSelf(), new Optional()]]\n    };\n  }\n  find(kv) {\n    const factory = this.factories.find((f) => f.supports(kv));\n    if (factory) {\n      return factory;\n    }\n    throw new RuntimeError(901, ngDevMode && `Cannot find a differ supporting object '${kv}'`);\n  }\n};\nvar keyValDiff = [new DefaultKeyValueDifferFactory()];\nvar iterableDiff = [new DefaultIterableDifferFactory()];\nvar defaultIterableDiffers = new IterableDiffers(iterableDiff);\nvar defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff);\nvar platformCore = createPlatformFactory(null, \"core\", []);\nvar ApplicationModule = class _ApplicationModule {\n  // Inject ApplicationRef to make it eager...\n  constructor(appRef) {\n  }\n  static \\u0275fac = function ApplicationModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _ApplicationModule)(\\u0275\\u0275inject(ApplicationRef));\n  };\n  static \\u0275mod = /* @__PURE__ */ \\u0275\\u0275defineNgModule({\n    type: _ApplicationModule\n  });\n  static \\u0275inj = /* @__PURE__ */ \\u0275\\u0275defineInjector({});\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(ApplicationModule, [{\n    type: NgModule\n  }], () => [{\n    type: ApplicationRef\n  }], null);\n})();\nfunction internalCreateApplication(config2) {\n  profiler(\n    8\n    /* ProfilerEvent.BootstrapApplicationStart */\n  );\n  try {\n    const {\n      rootComponent,\n      appProviders,\n      platformProviders\n    } = config2;\n    if ((typeof ngDevMode === \"undefined\" || ngDevMode) && rootComponent !== void 0) {\n      assertStandaloneComponentType(rootComponent);\n    }\n    const platformInjector = createOrReusePlatformInjector(platformProviders);\n    const allAppProviders = [internalProvideZoneChangeDetection({}), {\n      provide: ChangeDetectionScheduler,\n      useExisting: ChangeDetectionSchedulerImpl\n    }, ...appProviders || []];\n    const adapter = new EnvironmentNgModuleRefAdapter({\n      providers: allAppProviders,\n      parent: platformInjector,\n      debugName: typeof ngDevMode === \"undefined\" || ngDevMode ? \"Environment Injector\" : \"\",\n      // We skip environment initializers because we need to run them inside the NgZone, which\n      // happens after we get the NgZone instance from the Injector.\n      runEnvironmentInitializers: false\n    });\n    return bootstrap({\n      r3Injector: adapter.injector,\n      platformInjector,\n      rootComponent\n    });\n  } catch (e) {\n    return Promise.reject(e);\n  } finally {\n    profiler(\n      9\n      /* ProfilerEvent.BootstrapApplicationEnd */\n    );\n  }\n}\nfunction booleanAttribute(value) {\n  return typeof value === \"boolean\" ? value : value != null && value !== \"false\";\n}\nfunction numberAttribute(value, fallbackValue = NaN) {\n  const isNumberValue = !isNaN(parseFloat(value)) && !isNaN(Number(value));\n  return isNumberValue ? Number(value) : fallbackValue;\n}\nfunction untracked2(nonReactiveReadsFn) {\n  return untracked(nonReactiveReadsFn);\n}\nfunction computed(computation, options) {\n  const getter = createComputed(computation, options?.equal);\n  if (ngDevMode) {\n    getter.toString = () => `[Computed: ${getter()}]`;\n    getter[SIGNAL].debugName = options?.debugName;\n  }\n  return getter;\n}\nvar EffectRefImpl = class {\n  [SIGNAL];\n  constructor(node) {\n    this[SIGNAL] = node;\n  }\n  destroy() {\n    this[SIGNAL].destroy();\n  }\n};\nfunction effect(effectFn, options) {\n  ngDevMode && assertNotInReactiveContext(effect, \"Call `effect` outside of a reactive context. For example, schedule the effect inside the component constructor.\");\n  !options?.injector && assertInInjectionContext(effect);\n  if (ngDevMode && options?.allowSignalWrites !== void 0) {\n    console.warn(`The 'allowSignalWrites' flag is deprecated and no longer impacts effect() (writes are always allowed)`);\n  }\n  const injector = options?.injector ?? inject(Injector);\n  let destroyRef = options?.manualCleanup !== true ? injector.get(DestroyRef) : null;\n  let node;\n  const viewContext = injector.get(ViewContext, null, {\n    optional: true\n  });\n  const notifier = injector.get(ChangeDetectionScheduler);\n  if (viewContext !== null && !options?.forceRoot) {\n    node = createViewEffect(viewContext.view, notifier, effectFn);\n    if (destroyRef instanceof NodeInjectorDestroyRef && destroyRef._lView === viewContext.view) {\n      destroyRef = null;\n    }\n  } else {\n    node = createRootEffect(effectFn, injector.get(EffectScheduler), notifier);\n  }\n  node.injector = injector;\n  if (destroyRef !== null) {\n    node.onDestroyFn = destroyRef.onDestroy(() => node.destroy());\n  }\n  const effectRef = new EffectRefImpl(node);\n  if (ngDevMode) {\n    node.debugName = options?.debugName ?? \"\";\n    const prevInjectorProfilerContext = setInjectorProfilerContext({\n      injector,\n      token: null\n    });\n    try {\n      emitEffectCreatedEvent(effectRef);\n    } finally {\n      setInjectorProfilerContext(prevInjectorProfilerContext);\n    }\n  }\n  return effectRef;\n}\nvar BASE_EFFECT_NODE = /* @__PURE__ */ (() => __spreadProps(__spreadValues({}, REACTIVE_NODE), {\n  consumerIsAlwaysLive: true,\n  consumerAllowSignalWrites: true,\n  dirty: true,\n  hasRun: false,\n  cleanupFns: void 0,\n  zone: null,\n  kind: \"effect\",\n  onDestroyFn: noop2,\n  run() {\n    this.dirty = false;\n    if (ngDevMode && isInNotificationPhase()) {\n      throw new Error(`Schedulers cannot synchronously execute watches while scheduling.`);\n    }\n    if (this.hasRun && !consumerPollProducersForChange(this)) {\n      return;\n    }\n    this.hasRun = true;\n    const registerCleanupFn = (cleanupFn) => (this.cleanupFns ??= []).push(cleanupFn);\n    const prevNode = consumerBeforeComputation(this);\n    const prevRefreshingViews = setIsRefreshingViews(false);\n    try {\n      this.maybeCleanup();\n      this.fn(registerCleanupFn);\n    } finally {\n      setIsRefreshingViews(prevRefreshingViews);\n      consumerAfterComputation(this, prevNode);\n    }\n  },\n  maybeCleanup() {\n    if (!this.cleanupFns?.length) {\n      return;\n    }\n    try {\n      while (this.cleanupFns.length) {\n        this.cleanupFns.pop()();\n      }\n    } finally {\n      this.cleanupFns = [];\n    }\n  }\n}))();\nvar ROOT_EFFECT_NODE = /* @__PURE__ */ (() => __spreadProps(__spreadValues({}, BASE_EFFECT_NODE), {\n  consumerMarkedDirty() {\n    this.scheduler.schedule(this);\n    this.notifier.notify(\n      12\n      /* NotificationSource.RootEffect */\n    );\n  },\n  destroy() {\n    consumerDestroy(this);\n    this.onDestroyFn();\n    this.maybeCleanup();\n    this.scheduler.remove(this);\n  }\n}))();\nvar VIEW_EFFECT_NODE = /* @__PURE__ */ (() => __spreadProps(__spreadValues({}, BASE_EFFECT_NODE), {\n  consumerMarkedDirty() {\n    this.view[FLAGS] |= 8192;\n    markAncestorsForTraversal(this.view);\n    this.notifier.notify(\n      13\n      /* NotificationSource.ViewEffect */\n    );\n  },\n  destroy() {\n    consumerDestroy(this);\n    this.onDestroyFn();\n    this.maybeCleanup();\n    this.view[EFFECTS]?.delete(this);\n  }\n}))();\nfunction createViewEffect(view, notifier, fn) {\n  const node = Object.create(VIEW_EFFECT_NODE);\n  node.view = view;\n  node.zone = typeof Zone !== \"undefined\" ? Zone.current : null;\n  node.notifier = notifier;\n  node.fn = fn;\n  view[EFFECTS] ??= /* @__PURE__ */ new Set();\n  view[EFFECTS].add(node);\n  node.consumerMarkedDirty(node);\n  return node;\n}\nfunction createRootEffect(fn, scheduler, notifier) {\n  const node = Object.create(ROOT_EFFECT_NODE);\n  node.fn = fn;\n  node.scheduler = scheduler;\n  node.notifier = notifier;\n  node.zone = typeof Zone !== \"undefined\" ? Zone.current : null;\n  node.scheduler.schedule(node);\n  node.notifier.notify(\n    12\n    /* NotificationSource.RootEffect */\n  );\n  return node;\n}\nvar ResourceStatus;\n(function(ResourceStatus2) {\n  ResourceStatus2[ResourceStatus2[\"Idle\"] = 0] = \"Idle\";\n  ResourceStatus2[ResourceStatus2[\"Error\"] = 1] = \"Error\";\n  ResourceStatus2[ResourceStatus2[\"Loading\"] = 2] = \"Loading\";\n  ResourceStatus2[ResourceStatus2[\"Reloading\"] = 3] = \"Reloading\";\n  ResourceStatus2[ResourceStatus2[\"Resolved\"] = 4] = \"Resolved\";\n  ResourceStatus2[ResourceStatus2[\"Local\"] = 5] = \"Local\";\n})(ResourceStatus || (ResourceStatus = {}));\nvar identityFn = (v) => v;\nfunction linkedSignal(optionsOrComputation, options) {\n  if (typeof optionsOrComputation === \"function\") {\n    const getter = createLinkedSignal(optionsOrComputation, identityFn, options?.equal);\n    return upgradeLinkedSignalGetter(getter);\n  } else {\n    const getter = createLinkedSignal(optionsOrComputation.source, optionsOrComputation.computation, optionsOrComputation.equal);\n    return upgradeLinkedSignalGetter(getter);\n  }\n}\nfunction upgradeLinkedSignalGetter(getter) {\n  if (ngDevMode) {\n    getter.toString = () => `[LinkedSignal: ${getter()}]`;\n  }\n  const node = getter[SIGNAL];\n  const upgradedGetter = getter;\n  upgradedGetter.set = (newValue) => linkedSignalSetFn(node, newValue);\n  upgradedGetter.update = (updateFn) => linkedSignalUpdateFn(node, updateFn);\n  upgradedGetter.asReadonly = signalAsReadonlyFn.bind(getter);\n  return upgradedGetter;\n}\nvar BaseWritableResource = class {\n  value;\n  constructor(value) {\n    this.value = value;\n    this.value.set = this.set.bind(this);\n    this.value.update = this.update.bind(this);\n    this.value.asReadonly = signalAsReadonlyFn;\n  }\n  update(updateFn) {\n    this.set(updateFn(untracked2(this.value)));\n  }\n  isLoading = computed(() => this.status() === ResourceStatus.Loading || this.status() === ResourceStatus.Reloading);\n  hasValue() {\n    return this.value() !== void 0;\n  }\n  asReadonly() {\n    return this;\n  }\n};\nvar ResourceImpl = class extends BaseWritableResource {\n  loaderFn;\n  defaultValue;\n  equal;\n  pendingTasks;\n  /**\n   * The current state of the resource. Status, value, and error are derived from this.\n   */\n  state;\n  /**\n   * Combines the current request with a reload counter which allows the resource to be reloaded on\n   * imperative command.\n   */\n  extRequest;\n  effectRef;\n  pendingController;\n  resolvePendingTask = void 0;\n  destroyed = false;\n  constructor(request, loaderFn, defaultValue, equal, injector) {\n    super(\n      // Feed a computed signal for the value to `BaseWritableResource`, which will upgrade it to a\n      // `WritableSignal` that delegates to `ResourceImpl.set`.\n      computed(() => {\n        const streamValue = this.state().stream?.();\n        return streamValue && isResolved(streamValue) ? streamValue.value : this.defaultValue;\n      }, {\n        equal\n      })\n    );\n    this.loaderFn = loaderFn;\n    this.defaultValue = defaultValue;\n    this.equal = equal;\n    this.extRequest = linkedSignal({\n      source: request,\n      computation: (request2) => ({\n        request: request2,\n        reload: 0\n      })\n    });\n    this.state = linkedSignal({\n      // Whenever the request changes,\n      source: this.extRequest,\n      // Compute the state of the resource given a change in status.\n      computation: (extRequest, previous) => {\n        const status = extRequest.request === void 0 ? ResourceStatus.Idle : ResourceStatus.Loading;\n        if (!previous) {\n          return {\n            extRequest,\n            status,\n            previousStatus: ResourceStatus.Idle,\n            stream: void 0\n          };\n        } else {\n          return {\n            extRequest,\n            status,\n            previousStatus: projectStatusOfState(previous.value),\n            // If the request hasn't changed, keep the previous stream.\n            stream: previous.value.extRequest.request === extRequest.request ? previous.value.stream : void 0\n          };\n        }\n      }\n    });\n    this.effectRef = effect(this.loadEffect.bind(this), {\n      injector,\n      manualCleanup: true\n    });\n    this.pendingTasks = injector.get(PendingTasks);\n    injector.get(DestroyRef).onDestroy(() => this.destroy());\n  }\n  status = computed(() => projectStatusOfState(this.state()));\n  error = computed(() => {\n    const stream = this.state().stream?.();\n    return stream && !isResolved(stream) ? stream.error : void 0;\n  });\n  /**\n   * Called either directly via `WritableResource.set` or via `.value.set()`.\n   */\n  set(value) {\n    if (this.destroyed) {\n      return;\n    }\n    const current = untracked2(this.value);\n    const state = untracked2(this.state);\n    if (state.status === ResourceStatus.Local && (this.equal ? this.equal(current, value) : current === value)) {\n      return;\n    }\n    this.state.set({\n      extRequest: state.extRequest,\n      status: ResourceStatus.Local,\n      previousStatus: ResourceStatus.Local,\n      stream: signal({\n        value\n      })\n    });\n    this.abortInProgressLoad();\n  }\n  reload() {\n    const {\n      status\n    } = untracked2(this.state);\n    if (status === ResourceStatus.Idle || status === ResourceStatus.Loading) {\n      return false;\n    }\n    this.extRequest.update(({\n      request,\n      reload\n    }) => ({\n      request,\n      reload: reload + 1\n    }));\n    return true;\n  }\n  destroy() {\n    this.destroyed = true;\n    this.effectRef.destroy();\n    this.abortInProgressLoad();\n    this.state.set({\n      extRequest: {\n        request: void 0,\n        reload: 0\n      },\n      status: ResourceStatus.Idle,\n      previousStatus: ResourceStatus.Idle,\n      stream: void 0\n    });\n  }\n  loadEffect() {\n    return __async(this, null, function* () {\n      const extRequest = this.extRequest();\n      const {\n        status: currentStatus,\n        previousStatus\n      } = untracked2(this.state);\n      if (extRequest.request === void 0) {\n        return;\n      } else if (currentStatus !== ResourceStatus.Loading) {\n        return;\n      }\n      this.abortInProgressLoad();\n      let resolvePendingTask = this.resolvePendingTask = this.pendingTasks.add();\n      const {\n        signal: abortSignal\n      } = this.pendingController = new AbortController();\n      try {\n        const stream = yield untracked2(() => {\n          return this.loaderFn({\n            request: extRequest.request,\n            abortSignal,\n            previous: {\n              status: previousStatus\n            }\n          });\n        });\n        if (abortSignal.aborted || untracked2(this.extRequest) !== extRequest) {\n          return;\n        }\n        this.state.set({\n          extRequest,\n          status: ResourceStatus.Resolved,\n          previousStatus: ResourceStatus.Resolved,\n          stream\n        });\n      } catch (err) {\n        if (abortSignal.aborted || untracked2(this.extRequest) !== extRequest) {\n          return;\n        }\n        this.state.set({\n          extRequest,\n          status: ResourceStatus.Resolved,\n          previousStatus: ResourceStatus.Error,\n          stream: signal({\n            error: err\n          })\n        });\n      } finally {\n        resolvePendingTask?.();\n        resolvePendingTask = void 0;\n      }\n    });\n  }\n  abortInProgressLoad() {\n    untracked2(() => this.pendingController?.abort());\n    this.pendingController = void 0;\n    this.resolvePendingTask?.();\n    this.resolvePendingTask = void 0;\n  }\n};\nfunction projectStatusOfState(state) {\n  switch (state.status) {\n    case ResourceStatus.Loading:\n      return state.extRequest.reload === 0 ? ResourceStatus.Loading : ResourceStatus.Reloading;\n    case ResourceStatus.Resolved:\n      return isResolved(untracked2(state.stream)) ? ResourceStatus.Resolved : ResourceStatus.Error;\n    default:\n      return state.status;\n  }\n}\nfunction isResolved(state) {\n  return state.error === void 0;\n}\nvar NOT_SET = Symbol(\"NOT_SET\");\nfunction reflectComponentType(component) {\n  const componentDef = getComponentDef(component);\n  if (!componentDef) return null;\n  const factory = new ComponentFactory2(componentDef);\n  return {\n    get selector() {\n      return factory.selector;\n    },\n    get type() {\n      return factory.componentType;\n    },\n    get inputs() {\n      return factory.inputs;\n    },\n    get outputs() {\n      return factory.outputs;\n    },\n    get ngContentSelectors() {\n      return factory.ngContentSelectors;\n    },\n    get isStandalone() {\n      return componentDef.standalone;\n    },\n    get isSignal() {\n      return componentDef.signals;\n    }\n  };\n}\nvar REQUEST = new InjectionToken(typeof ngDevMode === \"undefined\" || ngDevMode ? \"REQUEST\" : \"\", {\n  providedIn: \"platform\",\n  factory: () => null\n});\nvar RESPONSE_INIT = new InjectionToken(typeof ngDevMode === \"undefined\" || ngDevMode ? \"RESPONSE_INIT\" : \"\", {\n  providedIn: \"platform\",\n  factory: () => null\n});\nvar REQUEST_CONTEXT = new InjectionToken(typeof ngDevMode === \"undefined\" || ngDevMode ? \"REQUEST_CONTEXT\" : \"\", {\n  providedIn: \"platform\",\n  factory: () => null\n});\n\n// node_modules/@angular/common/fesm2022/common.mjs\nvar _DOM = null;\nfunction getDOM() {\n  return _DOM;\n}\nfunction setRootDomAdapter(adapter) {\n  _DOM ??= adapter;\n}\nvar DomAdapter = class {\n};\nvar PlatformNavigation = class _PlatformNavigation {\n  static \\u0275fac = function PlatformNavigation_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _PlatformNavigation)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _PlatformNavigation,\n    factory: () => (() => window.navigation)(),\n    providedIn: \"platform\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(PlatformNavigation, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"platform\",\n      useFactory: () => window.navigation\n    }]\n  }], null, null);\n})();\nvar DOCUMENT2 = new InjectionToken(ngDevMode ? \"DocumentToken\" : \"\");\nvar PlatformLocation = class _PlatformLocation {\n  historyGo(relativePosition) {\n    throw new Error(ngDevMode ? \"Not implemented\" : \"\");\n  }\n  static \\u0275fac = function PlatformLocation_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _PlatformLocation)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _PlatformLocation,\n    factory: () => (() => inject(BrowserPlatformLocation))(),\n    providedIn: \"platform\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(PlatformLocation, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"platform\",\n      useFactory: () => inject(BrowserPlatformLocation)\n    }]\n  }], null, null);\n})();\nvar LOCATION_INITIALIZED = new InjectionToken(ngDevMode ? \"Location Initialized\" : \"\");\nvar BrowserPlatformLocation = class _BrowserPlatformLocation extends PlatformLocation {\n  _location;\n  _history;\n  _doc = inject(DOCUMENT2);\n  constructor() {\n    super();\n    this._location = window.location;\n    this._history = window.history;\n  }\n  getBaseHrefFromDOM() {\n    return getDOM().getBaseHref(this._doc);\n  }\n  onPopState(fn) {\n    const window2 = getDOM().getGlobalEventTarget(this._doc, \"window\");\n    window2.addEventListener(\"popstate\", fn, false);\n    return () => window2.removeEventListener(\"popstate\", fn);\n  }\n  onHashChange(fn) {\n    const window2 = getDOM().getGlobalEventTarget(this._doc, \"window\");\n    window2.addEventListener(\"hashchange\", fn, false);\n    return () => window2.removeEventListener(\"hashchange\", fn);\n  }\n  get href() {\n    return this._location.href;\n  }\n  get protocol() {\n    return this._location.protocol;\n  }\n  get hostname() {\n    return this._location.hostname;\n  }\n  get port() {\n    return this._location.port;\n  }\n  get pathname() {\n    return this._location.pathname;\n  }\n  get search() {\n    return this._location.search;\n  }\n  get hash() {\n    return this._location.hash;\n  }\n  set pathname(newPath) {\n    this._location.pathname = newPath;\n  }\n  pushState(state, title, url) {\n    this._history.pushState(state, title, url);\n  }\n  replaceState(state, title, url) {\n    this._history.replaceState(state, title, url);\n  }\n  forward() {\n    this._history.forward();\n  }\n  back() {\n    this._history.back();\n  }\n  historyGo(relativePosition = 0) {\n    this._history.go(relativePosition);\n  }\n  getState() {\n    return this._history.state;\n  }\n  static \\u0275fac = function BrowserPlatformLocation_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _BrowserPlatformLocation)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _BrowserPlatformLocation,\n    factory: () => (() => new _BrowserPlatformLocation())(),\n    providedIn: \"platform\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(BrowserPlatformLocation, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"platform\",\n      useFactory: () => new BrowserPlatformLocation()\n    }]\n  }], () => [], null);\n})();\nfunction joinWithSlash(start, end) {\n  if (!start) return end;\n  if (!end) return start;\n  if (start.endsWith(\"/\")) {\n    return end.startsWith(\"/\") ? start + end.slice(1) : start + end;\n  }\n  return end.startsWith(\"/\") ? start + end : `${start}/${end}`;\n}\nfunction stripTrailingSlash(url) {\n  const pathEndIdx = url.search(/#|\\?|$/);\n  return url[pathEndIdx - 1] === \"/\" ? url.slice(0, pathEndIdx - 1) + url.slice(pathEndIdx) : url;\n}\nfunction normalizeQueryParams(params) {\n  return params && params[0] !== \"?\" ? `?${params}` : params;\n}\nvar LocationStrategy = class _LocationStrategy {\n  historyGo(relativePosition) {\n    throw new Error(ngDevMode ? \"Not implemented\" : \"\");\n  }\n  static \\u0275fac = function LocationStrategy_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _LocationStrategy)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _LocationStrategy,\n    factory: () => (() => inject(PathLocationStrategy))(),\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(LocationStrategy, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\",\n      useFactory: () => inject(PathLocationStrategy)\n    }]\n  }], null, null);\n})();\nvar APP_BASE_HREF = new InjectionToken(ngDevMode ? \"appBaseHref\" : \"\");\nvar PathLocationStrategy = class _PathLocationStrategy extends LocationStrategy {\n  _platformLocation;\n  _baseHref;\n  _removeListenerFns = [];\n  constructor(_platformLocation, href) {\n    super();\n    this._platformLocation = _platformLocation;\n    this._baseHref = href ?? this._platformLocation.getBaseHrefFromDOM() ?? inject(DOCUMENT2).location?.origin ?? \"\";\n  }\n  /** @nodoc */\n  ngOnDestroy() {\n    while (this._removeListenerFns.length) {\n      this._removeListenerFns.pop()();\n    }\n  }\n  onPopState(fn) {\n    this._removeListenerFns.push(this._platformLocation.onPopState(fn), this._platformLocation.onHashChange(fn));\n  }\n  getBaseHref() {\n    return this._baseHref;\n  }\n  prepareExternalUrl(internal) {\n    return joinWithSlash(this._baseHref, internal);\n  }\n  path(includeHash = false) {\n    const pathname = this._platformLocation.pathname + normalizeQueryParams(this._platformLocation.search);\n    const hash = this._platformLocation.hash;\n    return hash && includeHash ? `${pathname}${hash}` : pathname;\n  }\n  pushState(state, title, url, queryParams) {\n    const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));\n    this._platformLocation.pushState(state, title, externalUrl);\n  }\n  replaceState(state, title, url, queryParams) {\n    const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));\n    this._platformLocation.replaceState(state, title, externalUrl);\n  }\n  forward() {\n    this._platformLocation.forward();\n  }\n  back() {\n    this._platformLocation.back();\n  }\n  getState() {\n    return this._platformLocation.getState();\n  }\n  historyGo(relativePosition = 0) {\n    this._platformLocation.historyGo?.(relativePosition);\n  }\n  static \\u0275fac = function PathLocationStrategy_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _PathLocationStrategy)(\\u0275\\u0275inject(PlatformLocation), \\u0275\\u0275inject(APP_BASE_HREF, 8));\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _PathLocationStrategy,\n    factory: _PathLocationStrategy.\\u0275fac,\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(PathLocationStrategy, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], () => [{\n    type: PlatformLocation\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [APP_BASE_HREF]\n    }]\n  }], null);\n})();\nvar HashLocationStrategy = class _HashLocationStrategy extends LocationStrategy {\n  _platformLocation;\n  _baseHref = \"\";\n  _removeListenerFns = [];\n  constructor(_platformLocation, _baseHref) {\n    super();\n    this._platformLocation = _platformLocation;\n    if (_baseHref != null) {\n      this._baseHref = _baseHref;\n    }\n  }\n  /** @nodoc */\n  ngOnDestroy() {\n    while (this._removeListenerFns.length) {\n      this._removeListenerFns.pop()();\n    }\n  }\n  onPopState(fn) {\n    this._removeListenerFns.push(this._platformLocation.onPopState(fn), this._platformLocation.onHashChange(fn));\n  }\n  getBaseHref() {\n    return this._baseHref;\n  }\n  path(includeHash = false) {\n    const path = this._platformLocation.hash ?? \"#\";\n    return path.length > 0 ? path.substring(1) : path;\n  }\n  prepareExternalUrl(internal) {\n    const url = joinWithSlash(this._baseHref, internal);\n    return url.length > 0 ? \"#\" + url : url;\n  }\n  pushState(state, title, path, queryParams) {\n    const url = this.prepareExternalUrl(path + normalizeQueryParams(queryParams)) || this._platformLocation.pathname;\n    this._platformLocation.pushState(state, title, url);\n  }\n  replaceState(state, title, path, queryParams) {\n    const url = this.prepareExternalUrl(path + normalizeQueryParams(queryParams)) || this._platformLocation.pathname;\n    this._platformLocation.replaceState(state, title, url);\n  }\n  forward() {\n    this._platformLocation.forward();\n  }\n  back() {\n    this._platformLocation.back();\n  }\n  getState() {\n    return this._platformLocation.getState();\n  }\n  historyGo(relativePosition = 0) {\n    this._platformLocation.historyGo?.(relativePosition);\n  }\n  static \\u0275fac = function HashLocationStrategy_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _HashLocationStrategy)(\\u0275\\u0275inject(PlatformLocation), \\u0275\\u0275inject(APP_BASE_HREF, 8));\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _HashLocationStrategy,\n    factory: _HashLocationStrategy.\\u0275fac\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(HashLocationStrategy, [{\n    type: Injectable\n  }], () => [{\n    type: PlatformLocation\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [APP_BASE_HREF]\n    }]\n  }], null);\n})();\nvar Location = class _Location {\n  /** @internal */\n  _subject = new Subject();\n  /** @internal */\n  _basePath;\n  /** @internal */\n  _locationStrategy;\n  /** @internal */\n  _urlChangeListeners = [];\n  /** @internal */\n  _urlChangeSubscription = null;\n  constructor(locationStrategy) {\n    this._locationStrategy = locationStrategy;\n    const baseHref = this._locationStrategy.getBaseHref();\n    this._basePath = _stripOrigin(stripTrailingSlash(_stripIndexHtml(baseHref)));\n    this._locationStrategy.onPopState((ev) => {\n      this._subject.next({\n        \"url\": this.path(true),\n        \"pop\": true,\n        \"state\": ev.state,\n        \"type\": ev.type\n      });\n    });\n  }\n  /** @nodoc */\n  ngOnDestroy() {\n    this._urlChangeSubscription?.unsubscribe();\n    this._urlChangeListeners = [];\n  }\n  /**\n   * Normalizes the URL path for this location.\n   *\n   * @param includeHash True to include an anchor fragment in the path.\n   *\n   * @returns The normalized URL path.\n   */\n  // TODO: vsavkin. Remove the boolean flag and always include hash once the deprecated router is\n  // removed.\n  path(includeHash = false) {\n    return this.normalize(this._locationStrategy.path(includeHash));\n  }\n  /**\n   * Reports the current state of the location history.\n   * @returns The current value of the `history.state` object.\n   */\n  getState() {\n    return this._locationStrategy.getState();\n  }\n  /**\n   * Normalizes the given path and compares to the current normalized path.\n   *\n   * @param path The given URL path.\n   * @param query Query parameters.\n   *\n   * @returns True if the given URL path is equal to the current normalized path, false\n   * otherwise.\n   */\n  isCurrentPathEqualTo(path, query = \"\") {\n    return this.path() == this.normalize(path + normalizeQueryParams(query));\n  }\n  /**\n   * Normalizes a URL path by stripping any trailing slashes.\n   *\n   * @param url String representing a URL.\n   *\n   * @returns The normalized URL string.\n   */\n  normalize(url) {\n    return _Location.stripTrailingSlash(_stripBasePath(this._basePath, _stripIndexHtml(url)));\n  }\n  /**\n   * Normalizes an external URL path.\n   * If the given URL doesn't begin with a leading slash (`'/'`), adds one\n   * before normalizing. Adds a hash if `HashLocationStrategy` is\n   * in use, or the `APP_BASE_HREF` if the `PathLocationStrategy` is in use.\n   *\n   * @param url String representing a URL.\n   *\n   * @returns  A normalized platform-specific URL.\n   */\n  prepareExternalUrl(url) {\n    if (url && url[0] !== \"/\") {\n      url = \"/\" + url;\n    }\n    return this._locationStrategy.prepareExternalUrl(url);\n  }\n  // TODO: rename this method to pushState\n  /**\n   * Changes the browser's URL to a normalized version of a given URL, and pushes a\n   * new item onto the platform's history.\n   *\n   * @param path  URL path to normalize.\n   * @param query Query parameters.\n   * @param state Location history state.\n   *\n   */\n  go(path, query = \"\", state = null) {\n    this._locationStrategy.pushState(state, \"\", path, query);\n    this._notifyUrlChangeListeners(this.prepareExternalUrl(path + normalizeQueryParams(query)), state);\n  }\n  /**\n   * Changes the browser's URL to a normalized version of the given URL, and replaces\n   * the top item on the platform's history stack.\n   *\n   * @param path  URL path to normalize.\n   * @param query Query parameters.\n   * @param state Location history state.\n   */\n  replaceState(path, query = \"\", state = null) {\n    this._locationStrategy.replaceState(state, \"\", path, query);\n    this._notifyUrlChangeListeners(this.prepareExternalUrl(path + normalizeQueryParams(query)), state);\n  }\n  /**\n   * Navigates forward in the platform's history.\n   */\n  forward() {\n    this._locationStrategy.forward();\n  }\n  /**\n   * Navigates back in the platform's history.\n   */\n  back() {\n    this._locationStrategy.back();\n  }\n  /**\n   * Navigate to a specific page from session history, identified by its relative position to the\n   * current page.\n   *\n   * @param relativePosition  Position of the target page in the history relative to the current\n   *     page.\n   * A negative value moves backwards, a positive value moves forwards, e.g. `location.historyGo(2)`\n   * moves forward two pages and `location.historyGo(-2)` moves back two pages. When we try to go\n   * beyond what's stored in the history session, we stay in the current page. Same behaviour occurs\n   * when `relativePosition` equals 0.\n   * @see https://developer.mozilla.org/en-US/docs/Web/API/History_API#Moving_to_a_specific_point_in_history\n   */\n  historyGo(relativePosition = 0) {\n    this._locationStrategy.historyGo?.(relativePosition);\n  }\n  /**\n   * Registers a URL change listener. Use to catch updates performed by the Angular\n   * framework that are not detectible through \"popstate\" or \"hashchange\" events.\n   *\n   * @param fn The change handler function, which take a URL and a location history state.\n   * @returns A function that, when executed, unregisters a URL change listener.\n   */\n  onUrlChange(fn) {\n    this._urlChangeListeners.push(fn);\n    this._urlChangeSubscription ??= this.subscribe((v) => {\n      this._notifyUrlChangeListeners(v.url, v.state);\n    });\n    return () => {\n      const fnIndex = this._urlChangeListeners.indexOf(fn);\n      this._urlChangeListeners.splice(fnIndex, 1);\n      if (this._urlChangeListeners.length === 0) {\n        this._urlChangeSubscription?.unsubscribe();\n        this._urlChangeSubscription = null;\n      }\n    };\n  }\n  /** @internal */\n  _notifyUrlChangeListeners(url = \"\", state) {\n    this._urlChangeListeners.forEach((fn) => fn(url, state));\n  }\n  /**\n   * Subscribes to the platform's `popState` events.\n   *\n   * Note: `Location.go()` does not trigger the `popState` event in the browser. Use\n   * `Location.onUrlChange()` to subscribe to URL changes instead.\n   *\n   * @param value Event that is triggered when the state history changes.\n   * @param exception The exception to throw.\n   *\n   * @see [onpopstate](https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate)\n   *\n   * @returns Subscribed events.\n   */\n  subscribe(onNext, onThrow, onReturn) {\n    return this._subject.subscribe({\n      next: onNext,\n      error: onThrow ?? void 0,\n      complete: onReturn ?? void 0\n    });\n  }\n  /**\n   * Normalizes URL parameters by prepending with `?` if needed.\n   *\n   * @param  params String of URL parameters.\n   *\n   * @returns The normalized URL parameters string.\n   */\n  static normalizeQueryParams = normalizeQueryParams;\n  /**\n   * Joins two parts of a URL with a slash if needed.\n   *\n   * @param start  URL string\n   * @param end    URL string\n   *\n   *\n   * @returns The joined URL string.\n   */\n  static joinWithSlash = joinWithSlash;\n  /**\n   * Removes a trailing slash from a URL string if needed.\n   * Looks for the first occurrence of either `#`, `?`, or the end of the\n   * line as `/` characters and removes the trailing slash if one exists.\n   *\n   * @param url URL string.\n   *\n   * @returns The URL string, modified if needed.\n   */\n  static stripTrailingSlash = stripTrailingSlash;\n  static \\u0275fac = function Location_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _Location)(\\u0275\\u0275inject(LocationStrategy));\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _Location,\n    factory: () => createLocation(),\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(Location, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\",\n      // See #23917\n      useFactory: createLocation\n    }]\n  }], () => [{\n    type: LocationStrategy\n  }], null);\n})();\nfunction createLocation() {\n  return new Location(\\u0275\\u0275inject(LocationStrategy));\n}\nfunction _stripBasePath(basePath, url) {\n  if (!basePath || !url.startsWith(basePath)) {\n    return url;\n  }\n  const strippedUrl = url.substring(basePath.length);\n  if (strippedUrl === \"\" || [\"/\", \";\", \"?\", \"#\"].includes(strippedUrl[0])) {\n    return strippedUrl;\n  }\n  return url;\n}\nfunction _stripIndexHtml(url) {\n  return url.replace(/\\/index.html$/, \"\");\n}\nfunction _stripOrigin(baseHref) {\n  const isAbsoluteUrl2 = new RegExp(\"^(https?:)?//\").test(baseHref);\n  if (isAbsoluteUrl2) {\n    const [, pathname] = baseHref.split(/\\/\\/[^\\/]+/);\n    return pathname;\n  }\n  return baseHref;\n}\nvar CURRENCIES_EN = {\n  \"ADP\": [void 0, void 0, 0],\n  \"AFN\": [void 0, \"\\u060B\", 0],\n  \"ALL\": [void 0, void 0, 0],\n  \"AMD\": [void 0, \"\\u058F\", 2],\n  \"AOA\": [void 0, \"Kz\"],\n  \"ARS\": [void 0, \"$\"],\n  \"AUD\": [\"A$\", \"$\"],\n  \"AZN\": [void 0, \"\\u20BC\"],\n  \"BAM\": [void 0, \"KM\"],\n  \"BBD\": [void 0, \"$\"],\n  \"BDT\": [void 0, \"\\u09F3\"],\n  \"BHD\": [void 0, void 0, 3],\n  \"BIF\": [void 0, void 0, 0],\n  \"BMD\": [void 0, \"$\"],\n  \"BND\": [void 0, \"$\"],\n  \"BOB\": [void 0, \"Bs\"],\n  \"BRL\": [\"R$\"],\n  \"BSD\": [void 0, \"$\"],\n  \"BWP\": [void 0, \"P\"],\n  \"BYN\": [void 0, void 0, 2],\n  \"BYR\": [void 0, void 0, 0],\n  \"BZD\": [void 0, \"$\"],\n  \"CAD\": [\"CA$\", \"$\", 2],\n  \"CHF\": [void 0, void 0, 2],\n  \"CLF\": [void 0, void 0, 4],\n  \"CLP\": [void 0, \"$\", 0],\n  \"CNY\": [\"CN\\xA5\", \"\\xA5\"],\n  \"COP\": [void 0, \"$\", 2],\n  \"CRC\": [void 0, \"\\u20A1\", 2],\n  \"CUC\": [void 0, \"$\"],\n  \"CUP\": [void 0, \"$\"],\n  \"CZK\": [void 0, \"K\\u010D\", 2],\n  \"DJF\": [void 0, void 0, 0],\n  \"DKK\": [void 0, \"kr\", 2],\n  \"DOP\": [void 0, \"$\"],\n  \"EGP\": [void 0, \"E\\xA3\"],\n  \"ESP\": [void 0, \"\\u20A7\", 0],\n  \"EUR\": [\"\\u20AC\"],\n  \"FJD\": [void 0, \"$\"],\n  \"FKP\": [void 0, \"\\xA3\"],\n  \"GBP\": [\"\\xA3\"],\n  \"GEL\": [void 0, \"\\u20BE\"],\n  \"GHS\": [void 0, \"GH\\u20B5\"],\n  \"GIP\": [void 0, \"\\xA3\"],\n  \"GNF\": [void 0, \"FG\", 0],\n  \"GTQ\": [void 0, \"Q\"],\n  \"GYD\": [void 0, \"$\", 2],\n  \"HKD\": [\"HK$\", \"$\"],\n  \"HNL\": [void 0, \"L\"],\n  \"HRK\": [void 0, \"kn\"],\n  \"HUF\": [void 0, \"Ft\", 2],\n  \"IDR\": [void 0, \"Rp\", 2],\n  \"ILS\": [\"\\u20AA\"],\n  \"INR\": [\"\\u20B9\"],\n  \"IQD\": [void 0, void 0, 0],\n  \"IRR\": [void 0, void 0, 0],\n  \"ISK\": [void 0, \"kr\", 0],\n  \"ITL\": [void 0, void 0, 0],\n  \"JMD\": [void 0, \"$\"],\n  \"JOD\": [void 0, void 0, 3],\n  \"JPY\": [\"\\xA5\", void 0, 0],\n  \"KHR\": [void 0, \"\\u17DB\"],\n  \"KMF\": [void 0, \"CF\", 0],\n  \"KPW\": [void 0, \"\\u20A9\", 0],\n  \"KRW\": [\"\\u20A9\", void 0, 0],\n  \"KWD\": [void 0, void 0, 3],\n  \"KYD\": [void 0, \"$\"],\n  \"KZT\": [void 0, \"\\u20B8\"],\n  \"LAK\": [void 0, \"\\u20AD\", 0],\n  \"LBP\": [void 0, \"L\\xA3\", 0],\n  \"LKR\": [void 0, \"Rs\"],\n  \"LRD\": [void 0, \"$\"],\n  \"LTL\": [void 0, \"Lt\"],\n  \"LUF\": [void 0, void 0, 0],\n  \"LVL\": [void 0, \"Ls\"],\n  \"LYD\": [void 0, void 0, 3],\n  \"MGA\": [void 0, \"Ar\", 0],\n  \"MGF\": [void 0, void 0, 0],\n  \"MMK\": [void 0, \"K\", 0],\n  \"MNT\": [void 0, \"\\u20AE\", 2],\n  \"MRO\": [void 0, void 0, 0],\n  \"MUR\": [void 0, \"Rs\", 2],\n  \"MXN\": [\"MX$\", \"$\"],\n  \"MYR\": [void 0, \"RM\"],\n  \"NAD\": [void 0, \"$\"],\n  \"NGN\": [void 0, \"\\u20A6\"],\n  \"NIO\": [void 0, \"C$\"],\n  \"NOK\": [void 0, \"kr\", 2],\n  \"NPR\": [void 0, \"Rs\"],\n  \"NZD\": [\"NZ$\", \"$\"],\n  \"OMR\": [void 0, void 0, 3],\n  \"PHP\": [\"\\u20B1\"],\n  \"PKR\": [void 0, \"Rs\", 2],\n  \"PLN\": [void 0, \"z\\u0142\"],\n  \"PYG\": [void 0, \"\\u20B2\", 0],\n  \"RON\": [void 0, \"lei\"],\n  \"RSD\": [void 0, void 0, 0],\n  \"RUB\": [void 0, \"\\u20BD\"],\n  \"RWF\": [void 0, \"RF\", 0],\n  \"SBD\": [void 0, \"$\"],\n  \"SEK\": [void 0, \"kr\", 2],\n  \"SGD\": [void 0, \"$\"],\n  \"SHP\": [void 0, \"\\xA3\"],\n  \"SLE\": [void 0, void 0, 2],\n  \"SLL\": [void 0, void 0, 0],\n  \"SOS\": [void 0, void 0, 0],\n  \"SRD\": [void 0, \"$\"],\n  \"SSP\": [void 0, \"\\xA3\"],\n  \"STD\": [void 0, void 0, 0],\n  \"STN\": [void 0, \"Db\"],\n  \"SYP\": [void 0, \"\\xA3\", 0],\n  \"THB\": [void 0, \"\\u0E3F\"],\n  \"TMM\": [void 0, void 0, 0],\n  \"TND\": [void 0, void 0, 3],\n  \"TOP\": [void 0, \"T$\"],\n  \"TRL\": [void 0, void 0, 0],\n  \"TRY\": [void 0, \"\\u20BA\"],\n  \"TTD\": [void 0, \"$\"],\n  \"TWD\": [\"NT$\", \"$\", 2],\n  \"TZS\": [void 0, void 0, 2],\n  \"UAH\": [void 0, \"\\u20B4\"],\n  \"UGX\": [void 0, void 0, 0],\n  \"USD\": [\"$\"],\n  \"UYI\": [void 0, void 0, 0],\n  \"UYU\": [void 0, \"$\"],\n  \"UYW\": [void 0, void 0, 4],\n  \"UZS\": [void 0, void 0, 2],\n  \"VEF\": [void 0, \"Bs\", 2],\n  \"VND\": [\"\\u20AB\", void 0, 0],\n  \"VUV\": [void 0, void 0, 0],\n  \"XAF\": [\"FCFA\", void 0, 0],\n  \"XCD\": [\"EC$\", \"$\"],\n  \"XOF\": [\"F\\u202FCFA\", void 0, 0],\n  \"XPF\": [\"CFPF\", void 0, 0],\n  \"XXX\": [\"\\xA4\"],\n  \"YER\": [void 0, void 0, 0],\n  \"ZAR\": [void 0, \"R\"],\n  \"ZMK\": [void 0, void 0, 0],\n  \"ZMW\": [void 0, \"ZK\"],\n  \"ZWD\": [void 0, void 0, 0]\n};\nvar NumberFormatStyle;\n(function(NumberFormatStyle2) {\n  NumberFormatStyle2[NumberFormatStyle2[\"Decimal\"] = 0] = \"Decimal\";\n  NumberFormatStyle2[NumberFormatStyle2[\"Percent\"] = 1] = \"Percent\";\n  NumberFormatStyle2[NumberFormatStyle2[\"Currency\"] = 2] = \"Currency\";\n  NumberFormatStyle2[NumberFormatStyle2[\"Scientific\"] = 3] = \"Scientific\";\n})(NumberFormatStyle || (NumberFormatStyle = {}));\nvar Plural;\n(function(Plural2) {\n  Plural2[Plural2[\"Zero\"] = 0] = \"Zero\";\n  Plural2[Plural2[\"One\"] = 1] = \"One\";\n  Plural2[Plural2[\"Two\"] = 2] = \"Two\";\n  Plural2[Plural2[\"Few\"] = 3] = \"Few\";\n  Plural2[Plural2[\"Many\"] = 4] = \"Many\";\n  Plural2[Plural2[\"Other\"] = 5] = \"Other\";\n})(Plural || (Plural = {}));\nvar FormStyle;\n(function(FormStyle2) {\n  FormStyle2[FormStyle2[\"Format\"] = 0] = \"Format\";\n  FormStyle2[FormStyle2[\"Standalone\"] = 1] = \"Standalone\";\n})(FormStyle || (FormStyle = {}));\nvar TranslationWidth;\n(function(TranslationWidth2) {\n  TranslationWidth2[TranslationWidth2[\"Narrow\"] = 0] = \"Narrow\";\n  TranslationWidth2[TranslationWidth2[\"Abbreviated\"] = 1] = \"Abbreviated\";\n  TranslationWidth2[TranslationWidth2[\"Wide\"] = 2] = \"Wide\";\n  TranslationWidth2[TranslationWidth2[\"Short\"] = 3] = \"Short\";\n})(TranslationWidth || (TranslationWidth = {}));\nvar FormatWidth;\n(function(FormatWidth2) {\n  FormatWidth2[FormatWidth2[\"Short\"] = 0] = \"Short\";\n  FormatWidth2[FormatWidth2[\"Medium\"] = 1] = \"Medium\";\n  FormatWidth2[FormatWidth2[\"Long\"] = 2] = \"Long\";\n  FormatWidth2[FormatWidth2[\"Full\"] = 3] = \"Full\";\n})(FormatWidth || (FormatWidth = {}));\nvar NumberSymbol = {\n  /**\n   * Decimal separator.\n   * For `en-US`, the dot character.\n   * Example: 2,345`.`67\n   */\n  Decimal: 0,\n  /**\n   * Grouping separator, typically for thousands.\n   * For `en-US`, the comma character.\n   * Example: 2`,`345.67\n   */\n  Group: 1,\n  /**\n   * List-item separator.\n   * Example: \"one, two, and three\"\n   */\n  List: 2,\n  /**\n   * Sign for percentage (out of 100).\n   * Example: 23.4%\n   */\n  PercentSign: 3,\n  /**\n   * Sign for positive numbers.\n   * Example: +23\n   */\n  PlusSign: 4,\n  /**\n   * Sign for negative numbers.\n   * Example: -23\n   */\n  MinusSign: 5,\n  /**\n   * Computer notation for exponential value (n times a power of 10).\n   * Example: 1.2E3\n   */\n  Exponential: 6,\n  /**\n   * Human-readable format of exponential.\n   * Example: 1.2x103\n   */\n  SuperscriptingExponent: 7,\n  /**\n   * Sign for permille (out of 1000).\n   * Example: 23.4‰\n   */\n  PerMille: 8,\n  /**\n   * Infinity, can be used with plus and minus.\n   * Example: ∞, +∞, -∞\n   */\n  Infinity: 9,\n  /**\n   * Not a number.\n   * Example: NaN\n   */\n  NaN: 10,\n  /**\n   * Symbol used between time units.\n   * Example: 10:52\n   */\n  TimeSeparator: 11,\n  /**\n   * Decimal separator for currency values (fallback to `Decimal`).\n   * Example: $2,345.67\n   */\n  CurrencyDecimal: 12,\n  /**\n   * Group separator for currency values (fallback to `Group`).\n   * Example: $2,345.67\n   */\n  CurrencyGroup: 13\n};\nvar WeekDay;\n(function(WeekDay2) {\n  WeekDay2[WeekDay2[\"Sunday\"] = 0] = \"Sunday\";\n  WeekDay2[WeekDay2[\"Monday\"] = 1] = \"Monday\";\n  WeekDay2[WeekDay2[\"Tuesday\"] = 2] = \"Tuesday\";\n  WeekDay2[WeekDay2[\"Wednesday\"] = 3] = \"Wednesday\";\n  WeekDay2[WeekDay2[\"Thursday\"] = 4] = \"Thursday\";\n  WeekDay2[WeekDay2[\"Friday\"] = 5] = \"Friday\";\n  WeekDay2[WeekDay2[\"Saturday\"] = 6] = \"Saturday\";\n})(WeekDay || (WeekDay = {}));\nfunction getLocaleId2(locale) {\n  return findLocaleData(locale)[LocaleDataIndex.LocaleId];\n}\nfunction getLocaleDayPeriods(locale, formStyle, width) {\n  const data = findLocaleData(locale);\n  const amPmData = [data[LocaleDataIndex.DayPeriodsFormat], data[LocaleDataIndex.DayPeriodsStandalone]];\n  const amPm = getLastDefinedValue(amPmData, formStyle);\n  return getLastDefinedValue(amPm, width);\n}\nfunction getLocaleDayNames(locale, formStyle, width) {\n  const data = findLocaleData(locale);\n  const daysData = [data[LocaleDataIndex.DaysFormat], data[LocaleDataIndex.DaysStandalone]];\n  const days = getLastDefinedValue(daysData, formStyle);\n  return getLastDefinedValue(days, width);\n}\nfunction getLocaleMonthNames(locale, formStyle, width) {\n  const data = findLocaleData(locale);\n  const monthsData = [data[LocaleDataIndex.MonthsFormat], data[LocaleDataIndex.MonthsStandalone]];\n  const months = getLastDefinedValue(monthsData, formStyle);\n  return getLastDefinedValue(months, width);\n}\nfunction getLocaleEraNames(locale, width) {\n  const data = findLocaleData(locale);\n  const erasData = data[LocaleDataIndex.Eras];\n  return getLastDefinedValue(erasData, width);\n}\nfunction getLocaleDateFormat(locale, width) {\n  const data = findLocaleData(locale);\n  return getLastDefinedValue(data[LocaleDataIndex.DateFormat], width);\n}\nfunction getLocaleTimeFormat(locale, width) {\n  const data = findLocaleData(locale);\n  return getLastDefinedValue(data[LocaleDataIndex.TimeFormat], width);\n}\nfunction getLocaleDateTimeFormat(locale, width) {\n  const data = findLocaleData(locale);\n  const dateTimeFormatData = data[LocaleDataIndex.DateTimeFormat];\n  return getLastDefinedValue(dateTimeFormatData, width);\n}\nfunction getLocaleNumberSymbol(locale, symbol) {\n  const data = findLocaleData(locale);\n  const res = data[LocaleDataIndex.NumberSymbols][symbol];\n  if (typeof res === \"undefined\") {\n    if (symbol === NumberSymbol.CurrencyDecimal) {\n      return data[LocaleDataIndex.NumberSymbols][NumberSymbol.Decimal];\n    } else if (symbol === NumberSymbol.CurrencyGroup) {\n      return data[LocaleDataIndex.NumberSymbols][NumberSymbol.Group];\n    }\n  }\n  return res;\n}\nfunction getLocaleNumberFormat(locale, type) {\n  const data = findLocaleData(locale);\n  return data[LocaleDataIndex.NumberFormats][type];\n}\nfunction getLocaleCurrencies(locale) {\n  const data = findLocaleData(locale);\n  return data[LocaleDataIndex.Currencies];\n}\nvar getLocalePluralCase2 = getLocalePluralCase;\nfunction checkFullData(data) {\n  if (!data[LocaleDataIndex.ExtraData]) {\n    throw new Error(`Missing extra locale data for the locale \"${data[LocaleDataIndex.LocaleId]}\". Use \"registerLocaleData\" to load new data. See the \"I18n guide\" on angular.io to know more.`);\n  }\n}\nfunction getLocaleExtraDayPeriodRules(locale) {\n  const data = findLocaleData(locale);\n  checkFullData(data);\n  const rules = data[LocaleDataIndex.ExtraData][\n    2\n    /* ɵExtraLocaleDataIndex.ExtraDayPeriodsRules */\n  ] || [];\n  return rules.map((rule) => {\n    if (typeof rule === \"string\") {\n      return extractTime(rule);\n    }\n    return [extractTime(rule[0]), extractTime(rule[1])];\n  });\n}\nfunction getLocaleExtraDayPeriods(locale, formStyle, width) {\n  const data = findLocaleData(locale);\n  checkFullData(data);\n  const dayPeriodsData = [data[LocaleDataIndex.ExtraData][\n    0\n    /* ɵExtraLocaleDataIndex.ExtraDayPeriodFormats */\n  ], data[LocaleDataIndex.ExtraData][\n    1\n    /* ɵExtraLocaleDataIndex.ExtraDayPeriodStandalone */\n  ]];\n  const dayPeriods = getLastDefinedValue(dayPeriodsData, formStyle) || [];\n  return getLastDefinedValue(dayPeriods, width) || [];\n}\nfunction getLastDefinedValue(data, index) {\n  for (let i = index; i > -1; i--) {\n    if (typeof data[i] !== \"undefined\") {\n      return data[i];\n    }\n  }\n  throw new Error(\"Locale data API: locale data undefined\");\n}\nfunction extractTime(time) {\n  const [h, m] = time.split(\":\");\n  return {\n    hours: +h,\n    minutes: +m\n  };\n}\nfunction getCurrencySymbol(code, format, locale = \"en\") {\n  const currency = getLocaleCurrencies(locale)[code] || CURRENCIES_EN[code] || [];\n  const symbolNarrow = currency[\n    1\n    /* ɵCurrencyIndex.SymbolNarrow */\n  ];\n  if (format === \"narrow\" && typeof symbolNarrow === \"string\") {\n    return symbolNarrow;\n  }\n  return currency[\n    0\n    /* ɵCurrencyIndex.Symbol */\n  ] || code;\n}\nvar DEFAULT_NB_OF_CURRENCY_DIGITS = 2;\nfunction getNumberOfCurrencyDigits(code) {\n  let digits;\n  const currency = CURRENCIES_EN[code];\n  if (currency) {\n    digits = currency[\n      2\n      /* ɵCurrencyIndex.NbOfDigits */\n    ];\n  }\n  return typeof digits === \"number\" ? digits : DEFAULT_NB_OF_CURRENCY_DIGITS;\n}\nvar ISO8601_DATE_REGEX = /^(\\d{4,})-?(\\d\\d)-?(\\d\\d)(?:T(\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:\\.(\\d+))?)?)?(Z|([+-])(\\d\\d):?(\\d\\d))?)?$/;\nvar NAMED_FORMATS = {};\nvar DATE_FORMATS_SPLIT = /((?:[^BEGHLMOSWYZabcdhmswyz']+)|(?:'(?:[^']|'')*')|(?:G{1,5}|y{1,4}|Y{1,4}|M{1,5}|L{1,5}|w{1,2}|W{1}|d{1,2}|E{1,6}|c{1,6}|a{1,5}|b{1,5}|B{1,5}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|O{1,4}))([\\s\\S]*)/;\nfunction formatDate(value, format, locale, timezone) {\n  let date = toDate(value);\n  const namedFormat = getNamedFormat(locale, format);\n  format = namedFormat || format;\n  let parts = [];\n  let match2;\n  while (format) {\n    match2 = DATE_FORMATS_SPLIT.exec(format);\n    if (match2) {\n      parts = parts.concat(match2.slice(1));\n      const part = parts.pop();\n      if (!part) {\n        break;\n      }\n      format = part;\n    } else {\n      parts.push(format);\n      break;\n    }\n  }\n  let dateTimezoneOffset = date.getTimezoneOffset();\n  if (timezone) {\n    dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);\n    date = convertTimezoneToLocal(date, timezone);\n  }\n  let text = \"\";\n  parts.forEach((value2) => {\n    const dateFormatter = getDateFormatter(value2);\n    text += dateFormatter ? dateFormatter(date, locale, dateTimezoneOffset) : value2 === \"''\" ? \"'\" : value2.replace(/(^'|'$)/g, \"\").replace(/''/g, \"'\");\n  });\n  return text;\n}\nfunction createDate(year, month, date) {\n  const newDate = /* @__PURE__ */ new Date(0);\n  newDate.setFullYear(year, month, date);\n  newDate.setHours(0, 0, 0);\n  return newDate;\n}\nfunction getNamedFormat(locale, format) {\n  const localeId = getLocaleId2(locale);\n  NAMED_FORMATS[localeId] ??= {};\n  if (NAMED_FORMATS[localeId][format]) {\n    return NAMED_FORMATS[localeId][format];\n  }\n  let formatValue2 = \"\";\n  switch (format) {\n    case \"shortDate\":\n      formatValue2 = getLocaleDateFormat(locale, FormatWidth.Short);\n      break;\n    case \"mediumDate\":\n      formatValue2 = getLocaleDateFormat(locale, FormatWidth.Medium);\n      break;\n    case \"longDate\":\n      formatValue2 = getLocaleDateFormat(locale, FormatWidth.Long);\n      break;\n    case \"fullDate\":\n      formatValue2 = getLocaleDateFormat(locale, FormatWidth.Full);\n      break;\n    case \"shortTime\":\n      formatValue2 = getLocaleTimeFormat(locale, FormatWidth.Short);\n      break;\n    case \"mediumTime\":\n      formatValue2 = getLocaleTimeFormat(locale, FormatWidth.Medium);\n      break;\n    case \"longTime\":\n      formatValue2 = getLocaleTimeFormat(locale, FormatWidth.Long);\n      break;\n    case \"fullTime\":\n      formatValue2 = getLocaleTimeFormat(locale, FormatWidth.Full);\n      break;\n    case \"short\":\n      const shortTime = getNamedFormat(locale, \"shortTime\");\n      const shortDate = getNamedFormat(locale, \"shortDate\");\n      formatValue2 = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Short), [shortTime, shortDate]);\n      break;\n    case \"medium\":\n      const mediumTime = getNamedFormat(locale, \"mediumTime\");\n      const mediumDate = getNamedFormat(locale, \"mediumDate\");\n      formatValue2 = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Medium), [mediumTime, mediumDate]);\n      break;\n    case \"long\":\n      const longTime = getNamedFormat(locale, \"longTime\");\n      const longDate = getNamedFormat(locale, \"longDate\");\n      formatValue2 = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Long), [longTime, longDate]);\n      break;\n    case \"full\":\n      const fullTime = getNamedFormat(locale, \"fullTime\");\n      const fullDate = getNamedFormat(locale, \"fullDate\");\n      formatValue2 = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Full), [fullTime, fullDate]);\n      break;\n  }\n  if (formatValue2) {\n    NAMED_FORMATS[localeId][format] = formatValue2;\n  }\n  return formatValue2;\n}\nfunction formatDateTime(str, opt_values) {\n  if (opt_values) {\n    str = str.replace(/\\{([^}]+)}/g, function(match2, key) {\n      return opt_values != null && key in opt_values ? opt_values[key] : match2;\n    });\n  }\n  return str;\n}\nfunction padNumber(num, digits, minusSign = \"-\", trim, negWrap) {\n  let neg = \"\";\n  if (num < 0 || negWrap && num <= 0) {\n    if (negWrap) {\n      num = -num + 1;\n    } else {\n      num = -num;\n      neg = minusSign;\n    }\n  }\n  let strNum = String(num);\n  while (strNum.length < digits) {\n    strNum = \"0\" + strNum;\n  }\n  if (trim) {\n    strNum = strNum.slice(strNum.length - digits);\n  }\n  return neg + strNum;\n}\nfunction formatFractionalSeconds(milliseconds, digits) {\n  const strMs = padNumber(milliseconds, 3);\n  return strMs.substring(0, digits);\n}\nfunction dateGetter(name, size, offset = 0, trim = false, negWrap = false) {\n  return function(date, locale) {\n    let part = getDatePart(name, date);\n    if (offset > 0 || part > -offset) {\n      part += offset;\n    }\n    if (name === 3) {\n      if (part === 0 && offset === -12) {\n        part = 12;\n      }\n    } else if (name === 6) {\n      return formatFractionalSeconds(part, size);\n    }\n    const localeMinus = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);\n    return padNumber(part, size, localeMinus, trim, negWrap);\n  };\n}\nfunction getDatePart(part, date) {\n  switch (part) {\n    case 0:\n      return date.getFullYear();\n    case 1:\n      return date.getMonth();\n    case 2:\n      return date.getDate();\n    case 3:\n      return date.getHours();\n    case 4:\n      return date.getMinutes();\n    case 5:\n      return date.getSeconds();\n    case 6:\n      return date.getMilliseconds();\n    case 7:\n      return date.getDay();\n    default:\n      throw new Error(`Unknown DateType value \"${part}\".`);\n  }\n}\nfunction dateStrGetter(name, width, form = FormStyle.Format, extended = false) {\n  return function(date, locale) {\n    return getDateTranslation(date, locale, name, width, form, extended);\n  };\n}\nfunction getDateTranslation(date, locale, name, width, form, extended) {\n  switch (name) {\n    case 2:\n      return getLocaleMonthNames(locale, form, width)[date.getMonth()];\n    case 1:\n      return getLocaleDayNames(locale, form, width)[date.getDay()];\n    case 0:\n      const currentHours = date.getHours();\n      const currentMinutes = date.getMinutes();\n      if (extended) {\n        const rules = getLocaleExtraDayPeriodRules(locale);\n        const dayPeriods = getLocaleExtraDayPeriods(locale, form, width);\n        const index = rules.findIndex((rule) => {\n          if (Array.isArray(rule)) {\n            const [from2, to] = rule;\n            const afterFrom = currentHours >= from2.hours && currentMinutes >= from2.minutes;\n            const beforeTo = currentHours < to.hours || currentHours === to.hours && currentMinutes < to.minutes;\n            if (from2.hours < to.hours) {\n              if (afterFrom && beforeTo) {\n                return true;\n              }\n            } else if (afterFrom || beforeTo) {\n              return true;\n            }\n          } else {\n            if (rule.hours === currentHours && rule.minutes === currentMinutes) {\n              return true;\n            }\n          }\n          return false;\n        });\n        if (index !== -1) {\n          return dayPeriods[index];\n        }\n      }\n      return getLocaleDayPeriods(locale, form, width)[currentHours < 12 ? 0 : 1];\n    case 3:\n      return getLocaleEraNames(locale, width)[date.getFullYear() <= 0 ? 0 : 1];\n    default:\n      const unexpected = name;\n      throw new Error(`unexpected translation type ${unexpected}`);\n  }\n}\nfunction timeZoneGetter(width) {\n  return function(date, locale, offset) {\n    const zone = -1 * offset;\n    const minusSign = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);\n    const hours = zone > 0 ? Math.floor(zone / 60) : Math.ceil(zone / 60);\n    switch (width) {\n      case 0:\n        return (zone >= 0 ? \"+\" : \"\") + padNumber(hours, 2, minusSign) + padNumber(Math.abs(zone % 60), 2, minusSign);\n      case 1:\n        return \"GMT\" + (zone >= 0 ? \"+\" : \"\") + padNumber(hours, 1, minusSign);\n      case 2:\n        return \"GMT\" + (zone >= 0 ? \"+\" : \"\") + padNumber(hours, 2, minusSign) + \":\" + padNumber(Math.abs(zone % 60), 2, minusSign);\n      case 3:\n        if (offset === 0) {\n          return \"Z\";\n        } else {\n          return (zone >= 0 ? \"+\" : \"\") + padNumber(hours, 2, minusSign) + \":\" + padNumber(Math.abs(zone % 60), 2, minusSign);\n        }\n      default:\n        throw new Error(`Unknown zone width \"${width}\"`);\n    }\n  };\n}\nvar JANUARY = 0;\nvar THURSDAY = 4;\nfunction getFirstThursdayOfYear(year) {\n  const firstDayOfYear = createDate(year, JANUARY, 1).getDay();\n  return createDate(year, 0, 1 + (firstDayOfYear <= THURSDAY ? THURSDAY : THURSDAY + 7) - firstDayOfYear);\n}\nfunction getThursdayThisIsoWeek(datetime) {\n  const currentDay = datetime.getDay();\n  const deltaToThursday = currentDay === 0 ? -3 : THURSDAY - currentDay;\n  return createDate(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + deltaToThursday);\n}\nfunction weekGetter(size, monthBased = false) {\n  return function(date, locale) {\n    let result;\n    if (monthBased) {\n      const nbDaysBefore1stDayOfMonth = new Date(date.getFullYear(), date.getMonth(), 1).getDay() - 1;\n      const today = date.getDate();\n      result = 1 + Math.floor((today + nbDaysBefore1stDayOfMonth) / 7);\n    } else {\n      const thisThurs = getThursdayThisIsoWeek(date);\n      const firstThurs = getFirstThursdayOfYear(thisThurs.getFullYear());\n      const diff = thisThurs.getTime() - firstThurs.getTime();\n      result = 1 + Math.round(diff / 6048e5);\n    }\n    return padNumber(result, size, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));\n  };\n}\nfunction weekNumberingYearGetter(size, trim = false) {\n  return function(date, locale) {\n    const thisThurs = getThursdayThisIsoWeek(date);\n    const weekNumberingYear = thisThurs.getFullYear();\n    return padNumber(weekNumberingYear, size, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign), trim);\n  };\n}\nvar DATE_FORMATS = {};\nfunction getDateFormatter(format) {\n  if (DATE_FORMATS[format]) {\n    return DATE_FORMATS[format];\n  }\n  let formatter;\n  switch (format) {\n    // Era name (AD/BC)\n    case \"G\":\n    case \"GG\":\n    case \"GGG\":\n      formatter = dateStrGetter(3, TranslationWidth.Abbreviated);\n      break;\n    case \"GGGG\":\n      formatter = dateStrGetter(3, TranslationWidth.Wide);\n      break;\n    case \"GGGGG\":\n      formatter = dateStrGetter(3, TranslationWidth.Narrow);\n      break;\n    // 1 digit representation of the year, e.g. (AD 1 => 1, AD 199 => 199)\n    case \"y\":\n      formatter = dateGetter(0, 1, 0, false, true);\n      break;\n    // 2 digit representation of the year, padded (00-99). (e.g. AD 2001 => 01, AD 2010 => 10)\n    case \"yy\":\n      formatter = dateGetter(0, 2, 0, true, true);\n      break;\n    // 3 digit representation of the year, padded (000-999). (e.g. AD 2001 => 01, AD 2010 => 10)\n    case \"yyy\":\n      formatter = dateGetter(0, 3, 0, false, true);\n      break;\n    // 4 digit representation of the year (e.g. AD 1 => 0001, AD 2010 => 2010)\n    case \"yyyy\":\n      formatter = dateGetter(0, 4, 0, false, true);\n      break;\n    // 1 digit representation of the week-numbering year, e.g. (AD 1 => 1, AD 199 => 199)\n    case \"Y\":\n      formatter = weekNumberingYearGetter(1);\n      break;\n    // 2 digit representation of the week-numbering year, padded (00-99). (e.g. AD 2001 => 01, AD\n    // 2010 => 10)\n    case \"YY\":\n      formatter = weekNumberingYearGetter(2, true);\n      break;\n    // 3 digit representation of the week-numbering year, padded (000-999). (e.g. AD 1 => 001, AD\n    // 2010 => 2010)\n    case \"YYY\":\n      formatter = weekNumberingYearGetter(3);\n      break;\n    // 4 digit representation of the week-numbering year (e.g. AD 1 => 0001, AD 2010 => 2010)\n    case \"YYYY\":\n      formatter = weekNumberingYearGetter(4);\n      break;\n    // Month of the year (1-12), numeric\n    case \"M\":\n    case \"L\":\n      formatter = dateGetter(1, 1, 1);\n      break;\n    case \"MM\":\n    case \"LL\":\n      formatter = dateGetter(1, 2, 1);\n      break;\n    // Month of the year (January, ...), string, format\n    case \"MMM\":\n      formatter = dateStrGetter(2, TranslationWidth.Abbreviated);\n      break;\n    case \"MMMM\":\n      formatter = dateStrGetter(2, TranslationWidth.Wide);\n      break;\n    case \"MMMMM\":\n      formatter = dateStrGetter(2, TranslationWidth.Narrow);\n      break;\n    // Month of the year (January, ...), string, standalone\n    case \"LLL\":\n      formatter = dateStrGetter(2, TranslationWidth.Abbreviated, FormStyle.Standalone);\n      break;\n    case \"LLLL\":\n      formatter = dateStrGetter(2, TranslationWidth.Wide, FormStyle.Standalone);\n      break;\n    case \"LLLLL\":\n      formatter = dateStrGetter(2, TranslationWidth.Narrow, FormStyle.Standalone);\n      break;\n    // Week of the year (1, ... 52)\n    case \"w\":\n      formatter = weekGetter(1);\n      break;\n    case \"ww\":\n      formatter = weekGetter(2);\n      break;\n    // Week of the month (1, ...)\n    case \"W\":\n      formatter = weekGetter(1, true);\n      break;\n    // Day of the month (1-31)\n    case \"d\":\n      formatter = dateGetter(2, 1);\n      break;\n    case \"dd\":\n      formatter = dateGetter(2, 2);\n      break;\n    // Day of the Week StandAlone (1, 1, Mon, Monday, M, Mo)\n    case \"c\":\n    case \"cc\":\n      formatter = dateGetter(7, 1);\n      break;\n    case \"ccc\":\n      formatter = dateStrGetter(1, TranslationWidth.Abbreviated, FormStyle.Standalone);\n      break;\n    case \"cccc\":\n      formatter = dateStrGetter(1, TranslationWidth.Wide, FormStyle.Standalone);\n      break;\n    case \"ccccc\":\n      formatter = dateStrGetter(1, TranslationWidth.Narrow, FormStyle.Standalone);\n      break;\n    case \"cccccc\":\n      formatter = dateStrGetter(1, TranslationWidth.Short, FormStyle.Standalone);\n      break;\n    // Day of the Week\n    case \"E\":\n    case \"EE\":\n    case \"EEE\":\n      formatter = dateStrGetter(1, TranslationWidth.Abbreviated);\n      break;\n    case \"EEEE\":\n      formatter = dateStrGetter(1, TranslationWidth.Wide);\n      break;\n    case \"EEEEE\":\n      formatter = dateStrGetter(1, TranslationWidth.Narrow);\n      break;\n    case \"EEEEEE\":\n      formatter = dateStrGetter(1, TranslationWidth.Short);\n      break;\n    // Generic period of the day (am-pm)\n    case \"a\":\n    case \"aa\":\n    case \"aaa\":\n      formatter = dateStrGetter(0, TranslationWidth.Abbreviated);\n      break;\n    case \"aaaa\":\n      formatter = dateStrGetter(0, TranslationWidth.Wide);\n      break;\n    case \"aaaaa\":\n      formatter = dateStrGetter(0, TranslationWidth.Narrow);\n      break;\n    // Extended period of the day (midnight, at night, ...), standalone\n    case \"b\":\n    case \"bb\":\n    case \"bbb\":\n      formatter = dateStrGetter(0, TranslationWidth.Abbreviated, FormStyle.Standalone, true);\n      break;\n    case \"bbbb\":\n      formatter = dateStrGetter(0, TranslationWidth.Wide, FormStyle.Standalone, true);\n      break;\n    case \"bbbbb\":\n      formatter = dateStrGetter(0, TranslationWidth.Narrow, FormStyle.Standalone, true);\n      break;\n    // Extended period of the day (midnight, night, ...), standalone\n    case \"B\":\n    case \"BB\":\n    case \"BBB\":\n      formatter = dateStrGetter(0, TranslationWidth.Abbreviated, FormStyle.Format, true);\n      break;\n    case \"BBBB\":\n      formatter = dateStrGetter(0, TranslationWidth.Wide, FormStyle.Format, true);\n      break;\n    case \"BBBBB\":\n      formatter = dateStrGetter(0, TranslationWidth.Narrow, FormStyle.Format, true);\n      break;\n    // Hour in AM/PM, (1-12)\n    case \"h\":\n      formatter = dateGetter(3, 1, -12);\n      break;\n    case \"hh\":\n      formatter = dateGetter(3, 2, -12);\n      break;\n    // Hour of the day (0-23)\n    case \"H\":\n      formatter = dateGetter(3, 1);\n      break;\n    // Hour in day, padded (00-23)\n    case \"HH\":\n      formatter = dateGetter(3, 2);\n      break;\n    // Minute of the hour (0-59)\n    case \"m\":\n      formatter = dateGetter(4, 1);\n      break;\n    case \"mm\":\n      formatter = dateGetter(4, 2);\n      break;\n    // Second of the minute (0-59)\n    case \"s\":\n      formatter = dateGetter(5, 1);\n      break;\n    case \"ss\":\n      formatter = dateGetter(5, 2);\n      break;\n    // Fractional second\n    case \"S\":\n      formatter = dateGetter(6, 1);\n      break;\n    case \"SS\":\n      formatter = dateGetter(6, 2);\n      break;\n    case \"SSS\":\n      formatter = dateGetter(6, 3);\n      break;\n    // Timezone ISO8601 short format (-0430)\n    case \"Z\":\n    case \"ZZ\":\n    case \"ZZZ\":\n      formatter = timeZoneGetter(\n        0\n        /* ZoneWidth.Short */\n      );\n      break;\n    // Timezone ISO8601 extended format (-04:30)\n    case \"ZZZZZ\":\n      formatter = timeZoneGetter(\n        3\n        /* ZoneWidth.Extended */\n      );\n      break;\n    // Timezone GMT short format (GMT+4)\n    case \"O\":\n    case \"OO\":\n    case \"OOO\":\n    // Should be location, but fallback to format O instead because we don't have the data yet\n    case \"z\":\n    case \"zz\":\n    case \"zzz\":\n      formatter = timeZoneGetter(\n        1\n        /* ZoneWidth.ShortGMT */\n      );\n      break;\n    // Timezone GMT long format (GMT+0430)\n    case \"OOOO\":\n    case \"ZZZZ\":\n    // Should be location, but fallback to format O instead because we don't have the data yet\n    case \"zzzz\":\n      formatter = timeZoneGetter(\n        2\n        /* ZoneWidth.Long */\n      );\n      break;\n    default:\n      return null;\n  }\n  DATE_FORMATS[format] = formatter;\n  return formatter;\n}\nfunction timezoneToOffset(timezone, fallback) {\n  timezone = timezone.replace(/:/g, \"\");\n  const requestedTimezoneOffset = Date.parse(\"Jan 01, 1970 00:00:00 \" + timezone) / 6e4;\n  return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;\n}\nfunction addDateMinutes(date, minutes) {\n  date = new Date(date.getTime());\n  date.setMinutes(date.getMinutes() + minutes);\n  return date;\n}\nfunction convertTimezoneToLocal(date, timezone, reverse) {\n  const reverseValue = -1;\n  const dateTimezoneOffset = date.getTimezoneOffset();\n  const timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);\n  return addDateMinutes(date, reverseValue * (timezoneOffset - dateTimezoneOffset));\n}\nfunction toDate(value) {\n  if (isDate(value)) {\n    return value;\n  }\n  if (typeof value === \"number\" && !isNaN(value)) {\n    return new Date(value);\n  }\n  if (typeof value === \"string\") {\n    value = value.trim();\n    if (/^(\\d{4}(-\\d{1,2}(-\\d{1,2})?)?)$/.test(value)) {\n      const [y, m = 1, d = 1] = value.split(\"-\").map((val) => +val);\n      return createDate(y, m - 1, d);\n    }\n    const parsedNb = parseFloat(value);\n    if (!isNaN(value - parsedNb)) {\n      return new Date(parsedNb);\n    }\n    let match2;\n    if (match2 = value.match(ISO8601_DATE_REGEX)) {\n      return isoStringToDate(match2);\n    }\n  }\n  const date = new Date(value);\n  if (!isDate(date)) {\n    throw new Error(`Unable to convert \"${value}\" into a date`);\n  }\n  return date;\n}\nfunction isoStringToDate(match2) {\n  const date = /* @__PURE__ */ new Date(0);\n  let tzHour = 0;\n  let tzMin = 0;\n  const dateSetter = match2[8] ? date.setUTCFullYear : date.setFullYear;\n  const timeSetter = match2[8] ? date.setUTCHours : date.setHours;\n  if (match2[9]) {\n    tzHour = Number(match2[9] + match2[10]);\n    tzMin = Number(match2[9] + match2[11]);\n  }\n  dateSetter.call(date, Number(match2[1]), Number(match2[2]) - 1, Number(match2[3]));\n  const h = Number(match2[4] || 0) - tzHour;\n  const m = Number(match2[5] || 0) - tzMin;\n  const s = Number(match2[6] || 0);\n  const ms = Math.floor(parseFloat(\"0.\" + (match2[7] || 0)) * 1e3);\n  timeSetter.call(date, h, m, s, ms);\n  return date;\n}\nfunction isDate(value) {\n  return value instanceof Date && !isNaN(value.valueOf());\n}\nvar NUMBER_FORMAT_REGEXP = /^(\\d+)?\\.((\\d+)(-(\\d+))?)?$/;\nvar MAX_DIGITS = 22;\nvar DECIMAL_SEP = \".\";\nvar ZERO_CHAR = \"0\";\nvar PATTERN_SEP = \";\";\nvar GROUP_SEP = \",\";\nvar DIGIT_CHAR = \"#\";\nvar CURRENCY_CHAR = \"\\xA4\";\nvar PERCENT_CHAR = \"%\";\nfunction formatNumberToLocaleString(value, pattern, locale, groupSymbol, decimalSymbol, digitsInfo, isPercent = false) {\n  let formattedText = \"\";\n  let isZero = false;\n  if (!isFinite(value)) {\n    formattedText = getLocaleNumberSymbol(locale, NumberSymbol.Infinity);\n  } else {\n    let parsedNumber = parseNumber(value);\n    if (isPercent) {\n      parsedNumber = toPercent(parsedNumber);\n    }\n    let minInt = pattern.minInt;\n    let minFraction = pattern.minFrac;\n    let maxFraction = pattern.maxFrac;\n    if (digitsInfo) {\n      const parts = digitsInfo.match(NUMBER_FORMAT_REGEXP);\n      if (parts === null) {\n        throw new Error(`${digitsInfo} is not a valid digit info`);\n      }\n      const minIntPart = parts[1];\n      const minFractionPart = parts[3];\n      const maxFractionPart = parts[5];\n      if (minIntPart != null) {\n        minInt = parseIntAutoRadix(minIntPart);\n      }\n      if (minFractionPart != null) {\n        minFraction = parseIntAutoRadix(minFractionPart);\n      }\n      if (maxFractionPart != null) {\n        maxFraction = parseIntAutoRadix(maxFractionPart);\n      } else if (minFractionPart != null && minFraction > maxFraction) {\n        maxFraction = minFraction;\n      }\n    }\n    roundNumber(parsedNumber, minFraction, maxFraction);\n    let digits = parsedNumber.digits;\n    let integerLen = parsedNumber.integerLen;\n    const exponent = parsedNumber.exponent;\n    let decimals = [];\n    isZero = digits.every((d) => !d);\n    for (; integerLen < minInt; integerLen++) {\n      digits.unshift(0);\n    }\n    for (; integerLen < 0; integerLen++) {\n      digits.unshift(0);\n    }\n    if (integerLen > 0) {\n      decimals = digits.splice(integerLen, digits.length);\n    } else {\n      decimals = digits;\n      digits = [0];\n    }\n    const groups = [];\n    if (digits.length >= pattern.lgSize) {\n      groups.unshift(digits.splice(-pattern.lgSize, digits.length).join(\"\"));\n    }\n    while (digits.length > pattern.gSize) {\n      groups.unshift(digits.splice(-pattern.gSize, digits.length).join(\"\"));\n    }\n    if (digits.length) {\n      groups.unshift(digits.join(\"\"));\n    }\n    formattedText = groups.join(getLocaleNumberSymbol(locale, groupSymbol));\n    if (decimals.length) {\n      formattedText += getLocaleNumberSymbol(locale, decimalSymbol) + decimals.join(\"\");\n    }\n    if (exponent) {\n      formattedText += getLocaleNumberSymbol(locale, NumberSymbol.Exponential) + \"+\" + exponent;\n    }\n  }\n  if (value < 0 && !isZero) {\n    formattedText = pattern.negPre + formattedText + pattern.negSuf;\n  } else {\n    formattedText = pattern.posPre + formattedText + pattern.posSuf;\n  }\n  return formattedText;\n}\nfunction formatCurrency(value, locale, currency, currencyCode, digitsInfo) {\n  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Currency);\n  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));\n  pattern.minFrac = getNumberOfCurrencyDigits(currencyCode);\n  pattern.maxFrac = pattern.minFrac;\n  const res = formatNumberToLocaleString(value, pattern, locale, NumberSymbol.CurrencyGroup, NumberSymbol.CurrencyDecimal, digitsInfo);\n  return res.replace(CURRENCY_CHAR, currency).replace(CURRENCY_CHAR, \"\").trim();\n}\nfunction formatPercent(value, locale, digitsInfo) {\n  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Percent);\n  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));\n  const res = formatNumberToLocaleString(value, pattern, locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo, true);\n  return res.replace(new RegExp(PERCENT_CHAR, \"g\"), getLocaleNumberSymbol(locale, NumberSymbol.PercentSign));\n}\nfunction formatNumber(value, locale, digitsInfo) {\n  const format = getLocaleNumberFormat(locale, NumberFormatStyle.Decimal);\n  const pattern = parseNumberFormat(format, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));\n  return formatNumberToLocaleString(value, pattern, locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo);\n}\nfunction parseNumberFormat(format, minusSign = \"-\") {\n  const p = {\n    minInt: 1,\n    minFrac: 0,\n    maxFrac: 0,\n    posPre: \"\",\n    posSuf: \"\",\n    negPre: \"\",\n    negSuf: \"\",\n    gSize: 0,\n    lgSize: 0\n  };\n  const patternParts = format.split(PATTERN_SEP);\n  const positive = patternParts[0];\n  const negative = patternParts[1];\n  const positiveParts = positive.indexOf(DECIMAL_SEP) !== -1 ? positive.split(DECIMAL_SEP) : [positive.substring(0, positive.lastIndexOf(ZERO_CHAR) + 1), positive.substring(positive.lastIndexOf(ZERO_CHAR) + 1)], integer = positiveParts[0], fraction = positiveParts[1] || \"\";\n  p.posPre = integer.substring(0, integer.indexOf(DIGIT_CHAR));\n  for (let i = 0; i < fraction.length; i++) {\n    const ch = fraction.charAt(i);\n    if (ch === ZERO_CHAR) {\n      p.minFrac = p.maxFrac = i + 1;\n    } else if (ch === DIGIT_CHAR) {\n      p.maxFrac = i + 1;\n    } else {\n      p.posSuf += ch;\n    }\n  }\n  const groups = integer.split(GROUP_SEP);\n  p.gSize = groups[1] ? groups[1].length : 0;\n  p.lgSize = groups[2] || groups[1] ? (groups[2] || groups[1]).length : 0;\n  if (negative) {\n    const trunkLen = positive.length - p.posPre.length - p.posSuf.length, pos = negative.indexOf(DIGIT_CHAR);\n    p.negPre = negative.substring(0, pos).replace(/'/g, \"\");\n    p.negSuf = negative.slice(pos + trunkLen).replace(/'/g, \"\");\n  } else {\n    p.negPre = minusSign + p.posPre;\n    p.negSuf = p.posSuf;\n  }\n  return p;\n}\nfunction toPercent(parsedNumber) {\n  if (parsedNumber.digits[0] === 0) {\n    return parsedNumber;\n  }\n  const fractionLen = parsedNumber.digits.length - parsedNumber.integerLen;\n  if (parsedNumber.exponent) {\n    parsedNumber.exponent += 2;\n  } else {\n    if (fractionLen === 0) {\n      parsedNumber.digits.push(0, 0);\n    } else if (fractionLen === 1) {\n      parsedNumber.digits.push(0);\n    }\n    parsedNumber.integerLen += 2;\n  }\n  return parsedNumber;\n}\nfunction parseNumber(num) {\n  let numStr = Math.abs(num) + \"\";\n  let exponent = 0, digits, integerLen;\n  let i, j, zeros;\n  if ((integerLen = numStr.indexOf(DECIMAL_SEP)) > -1) {\n    numStr = numStr.replace(DECIMAL_SEP, \"\");\n  }\n  if ((i = numStr.search(/e/i)) > 0) {\n    if (integerLen < 0) integerLen = i;\n    integerLen += +numStr.slice(i + 1);\n    numStr = numStr.substring(0, i);\n  } else if (integerLen < 0) {\n    integerLen = numStr.length;\n  }\n  for (i = 0; numStr.charAt(i) === ZERO_CHAR; i++) {\n  }\n  if (i === (zeros = numStr.length)) {\n    digits = [0];\n    integerLen = 1;\n  } else {\n    zeros--;\n    while (numStr.charAt(zeros) === ZERO_CHAR) zeros--;\n    integerLen -= i;\n    digits = [];\n    for (j = 0; i <= zeros; i++, j++) {\n      digits[j] = Number(numStr.charAt(i));\n    }\n  }\n  if (integerLen > MAX_DIGITS) {\n    digits = digits.splice(0, MAX_DIGITS - 1);\n    exponent = integerLen - 1;\n    integerLen = 1;\n  }\n  return {\n    digits,\n    exponent,\n    integerLen\n  };\n}\nfunction roundNumber(parsedNumber, minFrac, maxFrac) {\n  if (minFrac > maxFrac) {\n    throw new Error(`The minimum number of digits after fraction (${minFrac}) is higher than the maximum (${maxFrac}).`);\n  }\n  let digits = parsedNumber.digits;\n  let fractionLen = digits.length - parsedNumber.integerLen;\n  const fractionSize = Math.min(Math.max(minFrac, fractionLen), maxFrac);\n  let roundAt = fractionSize + parsedNumber.integerLen;\n  let digit = digits[roundAt];\n  if (roundAt > 0) {\n    digits.splice(Math.max(parsedNumber.integerLen, roundAt));\n    for (let j = roundAt; j < digits.length; j++) {\n      digits[j] = 0;\n    }\n  } else {\n    fractionLen = Math.max(0, fractionLen);\n    parsedNumber.integerLen = 1;\n    digits.length = Math.max(1, roundAt = fractionSize + 1);\n    digits[0] = 0;\n    for (let i = 1; i < roundAt; i++) digits[i] = 0;\n  }\n  if (digit >= 5) {\n    if (roundAt - 1 < 0) {\n      for (let k = 0; k > roundAt; k--) {\n        digits.unshift(0);\n        parsedNumber.integerLen++;\n      }\n      digits.unshift(1);\n      parsedNumber.integerLen++;\n    } else {\n      digits[roundAt - 1]++;\n    }\n  }\n  for (; fractionLen < Math.max(0, fractionSize); fractionLen++) digits.push(0);\n  let dropTrailingZeros = fractionSize !== 0;\n  const minLen = minFrac + parsedNumber.integerLen;\n  const carry = digits.reduceRight(function(carry2, d, i, digits2) {\n    d = d + carry2;\n    digits2[i] = d < 10 ? d : d - 10;\n    if (dropTrailingZeros) {\n      if (digits2[i] === 0 && i >= minLen) {\n        digits2.pop();\n      } else {\n        dropTrailingZeros = false;\n      }\n    }\n    return d >= 10 ? 1 : 0;\n  }, 0);\n  if (carry) {\n    digits.unshift(carry);\n    parsedNumber.integerLen++;\n  }\n}\nfunction parseIntAutoRadix(text) {\n  const result = parseInt(text);\n  if (isNaN(result)) {\n    throw new Error(\"Invalid integer literal when parsing \" + text);\n  }\n  return result;\n}\nvar NgLocalization = class _NgLocalization {\n  static \\u0275fac = function NgLocalization_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _NgLocalization)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _NgLocalization,\n    factory: function NgLocalization_Factory(__ngFactoryType__) {\n      let __ngConditionalFactory__ = null;\n      if (__ngFactoryType__) {\n        __ngConditionalFactory__ = new __ngFactoryType__();\n      } else {\n        __ngConditionalFactory__ = ((locale) => new NgLocaleLocalization(locale))(\\u0275\\u0275inject(LOCALE_ID));\n      }\n      return __ngConditionalFactory__;\n    },\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(NgLocalization, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\",\n      useFactory: (locale) => new NgLocaleLocalization(locale),\n      deps: [LOCALE_ID]\n    }]\n  }], null, null);\n})();\nfunction getPluralCategory(value, cases, ngLocalization, locale) {\n  let key = `=${value}`;\n  if (cases.indexOf(key) > -1) {\n    return key;\n  }\n  key = ngLocalization.getPluralCategory(value, locale);\n  if (cases.indexOf(key) > -1) {\n    return key;\n  }\n  if (cases.indexOf(\"other\") > -1) {\n    return \"other\";\n  }\n  throw new Error(`No plural message found for value \"${value}\"`);\n}\nvar NgLocaleLocalization = class _NgLocaleLocalization extends NgLocalization {\n  locale;\n  constructor(locale) {\n    super();\n    this.locale = locale;\n  }\n  getPluralCategory(value, locale) {\n    const plural2 = getLocalePluralCase2(locale || this.locale)(value);\n    switch (plural2) {\n      case Plural.Zero:\n        return \"zero\";\n      case Plural.One:\n        return \"one\";\n      case Plural.Two:\n        return \"two\";\n      case Plural.Few:\n        return \"few\";\n      case Plural.Many:\n        return \"many\";\n      default:\n        return \"other\";\n    }\n  }\n  static \\u0275fac = function NgLocaleLocalization_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _NgLocaleLocalization)(\\u0275\\u0275inject(LOCALE_ID));\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _NgLocaleLocalization,\n    factory: _NgLocaleLocalization.\\u0275fac\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(NgLocaleLocalization, [{\n    type: Injectable\n  }], () => [{\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [LOCALE_ID]\n    }]\n  }], null);\n})();\nfunction parseCookieValue(cookieStr, name) {\n  name = encodeURIComponent(name);\n  for (const cookie of cookieStr.split(\";\")) {\n    const eqIndex = cookie.indexOf(\"=\");\n    const [cookieName, cookieValue] = eqIndex == -1 ? [cookie, \"\"] : [cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1)];\n    if (cookieName.trim() === name) {\n      return decodeURIComponent(cookieValue);\n    }\n  }\n  return null;\n}\nvar WS_REGEXP = /\\s+/;\nvar EMPTY_ARRAY2 = [];\nvar NgClass = class _NgClass {\n  _ngEl;\n  _renderer;\n  initialClasses = EMPTY_ARRAY2;\n  rawClass;\n  stateMap = /* @__PURE__ */ new Map();\n  constructor(_ngEl, _renderer) {\n    this._ngEl = _ngEl;\n    this._renderer = _renderer;\n  }\n  set klass(value) {\n    this.initialClasses = value != null ? value.trim().split(WS_REGEXP) : EMPTY_ARRAY2;\n  }\n  set ngClass(value) {\n    this.rawClass = typeof value === \"string\" ? value.trim().split(WS_REGEXP) : value;\n  }\n  /*\n  The NgClass directive uses the custom change detection algorithm for its inputs. The custom\n  algorithm is necessary since inputs are represented as complex object or arrays that need to be\n  deeply-compared.\n     This algorithm is perf-sensitive since NgClass is used very frequently and its poor performance\n  might negatively impact runtime performance of the entire change detection cycle. The design of\n  this algorithm is making sure that:\n  - there is no unnecessary DOM manipulation (CSS classes are added / removed from the DOM only when\n  needed), even if references to bound objects change;\n  - there is no memory allocation if nothing changes (even relatively modest memory allocation\n  during the change detection cycle can result in GC pauses for some of the CD cycles).\n     The algorithm works by iterating over the set of bound classes, staring with [class] binding and\n  then going over [ngClass] binding. For each CSS class name:\n  - check if it was seen before (this information is tracked in the state map) and if its value\n  changed;\n  - mark it as \"touched\" - names that are not marked are not present in the latest set of binding\n  and we can remove such class name from the internal data structures;\n     After iteration over all the CSS class names we've got data structure with all the information\n  necessary to synchronize changes to the DOM - it is enough to iterate over the state map, flush\n  changes to the DOM and reset internal data structures so those are ready for the next change\n  detection cycle.\n   */\n  ngDoCheck() {\n    for (const klass of this.initialClasses) {\n      this._updateState(klass, true);\n    }\n    const rawClass = this.rawClass;\n    if (Array.isArray(rawClass) || rawClass instanceof Set) {\n      for (const klass of rawClass) {\n        this._updateState(klass, true);\n      }\n    } else if (rawClass != null) {\n      for (const klass of Object.keys(rawClass)) {\n        this._updateState(klass, Boolean(rawClass[klass]));\n      }\n    }\n    this._applyStateDiff();\n  }\n  _updateState(klass, nextEnabled) {\n    const state = this.stateMap.get(klass);\n    if (state !== void 0) {\n      if (state.enabled !== nextEnabled) {\n        state.changed = true;\n        state.enabled = nextEnabled;\n      }\n      state.touched = true;\n    } else {\n      this.stateMap.set(klass, {\n        enabled: nextEnabled,\n        changed: true,\n        touched: true\n      });\n    }\n  }\n  _applyStateDiff() {\n    for (const stateEntry of this.stateMap) {\n      const klass = stateEntry[0];\n      const state = stateEntry[1];\n      if (state.changed) {\n        this._toggleClass(klass, state.enabled);\n        state.changed = false;\n      } else if (!state.touched) {\n        if (state.enabled) {\n          this._toggleClass(klass, false);\n        }\n        this.stateMap.delete(klass);\n      }\n      state.touched = false;\n    }\n  }\n  _toggleClass(klass, enabled) {\n    if (ngDevMode) {\n      if (typeof klass !== \"string\") {\n        throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${stringify(klass)}`);\n      }\n    }\n    klass = klass.trim();\n    if (klass.length > 0) {\n      klass.split(WS_REGEXP).forEach((klass2) => {\n        if (enabled) {\n          this._renderer.addClass(this._ngEl.nativeElement, klass2);\n        } else {\n          this._renderer.removeClass(this._ngEl.nativeElement, klass2);\n        }\n      });\n    }\n  }\n  static \\u0275fac = function NgClass_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _NgClass)(\\u0275\\u0275directiveInject(ElementRef), \\u0275\\u0275directiveInject(Renderer2));\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _NgClass,\n    selectors: [[\"\", \"ngClass\", \"\"]],\n    inputs: {\n      klass: [0, \"class\", \"klass\"],\n      ngClass: \"ngClass\"\n    }\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(NgClass, [{\n    type: Directive,\n    args: [{\n      selector: \"[ngClass]\"\n    }]\n  }], () => [{\n    type: ElementRef\n  }, {\n    type: Renderer2\n  }], {\n    klass: [{\n      type: Input,\n      args: [\"class\"]\n    }],\n    ngClass: [{\n      type: Input,\n      args: [\"ngClass\"]\n    }]\n  });\n})();\nvar NgComponentOutlet = class _NgComponentOutlet {\n  _viewContainerRef;\n  // TODO(crisbeto): this should be `Type<T>`, but doing so broke a few\n  // targets in a TGP so we need to do it in a major version.\n  /** Component that should be rendered in the outlet. */\n  ngComponentOutlet = null;\n  ngComponentOutletInputs;\n  ngComponentOutletInjector;\n  ngComponentOutletContent;\n  ngComponentOutletNgModule;\n  /**\n   * @deprecated This input is deprecated, use `ngComponentOutletNgModule` instead.\n   */\n  ngComponentOutletNgModuleFactory;\n  _componentRef;\n  _moduleRef;\n  /**\n   * A helper data structure that allows us to track inputs that were part of the\n   * ngComponentOutletInputs expression. Tracking inputs is necessary for proper removal of ones\n   * that are no longer referenced.\n   */\n  _inputsUsed = /* @__PURE__ */ new Map();\n  /**\n   * Gets the instance of the currently-rendered component.\n   * Will be null if no component has been rendered.\n   */\n  get componentInstance() {\n    return this._componentRef?.instance ?? null;\n  }\n  constructor(_viewContainerRef) {\n    this._viewContainerRef = _viewContainerRef;\n  }\n  _needToReCreateNgModuleInstance(changes) {\n    return changes[\"ngComponentOutletNgModule\"] !== void 0 || changes[\"ngComponentOutletNgModuleFactory\"] !== void 0;\n  }\n  _needToReCreateComponentInstance(changes) {\n    return changes[\"ngComponentOutlet\"] !== void 0 || changes[\"ngComponentOutletContent\"] !== void 0 || changes[\"ngComponentOutletInjector\"] !== void 0 || this._needToReCreateNgModuleInstance(changes);\n  }\n  /** @nodoc */\n  ngOnChanges(changes) {\n    if (this._needToReCreateComponentInstance(changes)) {\n      this._viewContainerRef.clear();\n      this._inputsUsed.clear();\n      this._componentRef = void 0;\n      if (this.ngComponentOutlet) {\n        const injector = this.ngComponentOutletInjector || this._viewContainerRef.parentInjector;\n        if (this._needToReCreateNgModuleInstance(changes)) {\n          this._moduleRef?.destroy();\n          if (this.ngComponentOutletNgModule) {\n            this._moduleRef = createNgModule(this.ngComponentOutletNgModule, getParentInjector(injector));\n          } else if (this.ngComponentOutletNgModuleFactory) {\n            this._moduleRef = this.ngComponentOutletNgModuleFactory.create(getParentInjector(injector));\n          } else {\n            this._moduleRef = void 0;\n          }\n        }\n        this._componentRef = this._viewContainerRef.createComponent(this.ngComponentOutlet, {\n          injector,\n          ngModuleRef: this._moduleRef,\n          projectableNodes: this.ngComponentOutletContent\n        });\n      }\n    }\n  }\n  /** @nodoc */\n  ngDoCheck() {\n    if (this._componentRef) {\n      if (this.ngComponentOutletInputs) {\n        for (const inputName of Object.keys(this.ngComponentOutletInputs)) {\n          this._inputsUsed.set(inputName, true);\n        }\n      }\n      this._applyInputStateDiff(this._componentRef);\n    }\n  }\n  /** @nodoc */\n  ngOnDestroy() {\n    this._moduleRef?.destroy();\n  }\n  _applyInputStateDiff(componentRef) {\n    for (const [inputName, touched] of this._inputsUsed) {\n      if (!touched) {\n        componentRef.setInput(inputName, void 0);\n        this._inputsUsed.delete(inputName);\n      } else {\n        componentRef.setInput(inputName, this.ngComponentOutletInputs[inputName]);\n        this._inputsUsed.set(inputName, false);\n      }\n    }\n  }\n  static \\u0275fac = function NgComponentOutlet_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _NgComponentOutlet)(\\u0275\\u0275directiveInject(ViewContainerRef));\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _NgComponentOutlet,\n    selectors: [[\"\", \"ngComponentOutlet\", \"\"]],\n    inputs: {\n      ngComponentOutlet: \"ngComponentOutlet\",\n      ngComponentOutletInputs: \"ngComponentOutletInputs\",\n      ngComponentOutletInjector: \"ngComponentOutletInjector\",\n      ngComponentOutletContent: \"ngComponentOutletContent\",\n      ngComponentOutletNgModule: \"ngComponentOutletNgModule\",\n      ngComponentOutletNgModuleFactory: \"ngComponentOutletNgModuleFactory\"\n    },\n    exportAs: [\"ngComponentOutlet\"],\n    features: [\\u0275\\u0275NgOnChangesFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(NgComponentOutlet, [{\n    type: Directive,\n    args: [{\n      selector: \"[ngComponentOutlet]\",\n      exportAs: \"ngComponentOutlet\"\n    }]\n  }], () => [{\n    type: ViewContainerRef\n  }], {\n    ngComponentOutlet: [{\n      type: Input\n    }],\n    ngComponentOutletInputs: [{\n      type: Input\n    }],\n    ngComponentOutletInjector: [{\n      type: Input\n    }],\n    ngComponentOutletContent: [{\n      type: Input\n    }],\n    ngComponentOutletNgModule: [{\n      type: Input\n    }],\n    ngComponentOutletNgModuleFactory: [{\n      type: Input\n    }]\n  });\n})();\nfunction getParentInjector(injector) {\n  const parentNgModule = injector.get(NgModuleRef$1);\n  return parentNgModule.injector;\n}\nvar NgForOfContext = class {\n  $implicit;\n  ngForOf;\n  index;\n  count;\n  constructor($implicit, ngForOf, index, count) {\n    this.$implicit = $implicit;\n    this.ngForOf = ngForOf;\n    this.index = index;\n    this.count = count;\n  }\n  // Indicates whether this is the first item in the collection.\n  get first() {\n    return this.index === 0;\n  }\n  // Indicates whether this is the last item in the collection.\n  get last() {\n    return this.index === this.count - 1;\n  }\n  // Indicates whether an index of this item in the collection is even.\n  get even() {\n    return this.index % 2 === 0;\n  }\n  // Indicates whether an index of this item in the collection is odd.\n  get odd() {\n    return !this.even;\n  }\n};\nvar NgForOf = class _NgForOf {\n  _viewContainer;\n  _template;\n  _differs;\n  /**\n   * The value of the iterable expression, which can be used as a\n   * [template input variable](guide/directives/structural-directives#shorthand).\n   */\n  set ngForOf(ngForOf) {\n    this._ngForOf = ngForOf;\n    this._ngForOfDirty = true;\n  }\n  /**\n   * Specifies a custom `TrackByFunction` to compute the identity of items in an iterable.\n   *\n   * If a custom `TrackByFunction` is not provided, `NgForOf` will use the item's [object\n   * identity](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)\n   * as the key.\n   *\n   * `NgForOf` uses the computed key to associate items in an iterable with DOM elements\n   * it produces for these items.\n   *\n   * A custom `TrackByFunction` is useful to provide good user experience in cases when items in an\n   * iterable rendered using `NgForOf` have a natural identifier (for example, custom ID or a\n   * primary key), and this iterable could be updated with new object instances that still\n   * represent the same underlying entity (for example, when data is re-fetched from the server,\n   * and the iterable is recreated and re-rendered, but most of the data is still the same).\n   *\n   * @see {@link TrackByFunction}\n   */\n  set ngForTrackBy(fn) {\n    if ((typeof ngDevMode === \"undefined\" || ngDevMode) && fn != null && typeof fn !== \"function\") {\n      console.warn(`trackBy must be a function, but received ${JSON.stringify(fn)}. See https://angular.io/api/common/NgForOf#change-propagation for more information.`);\n    }\n    this._trackByFn = fn;\n  }\n  get ngForTrackBy() {\n    return this._trackByFn;\n  }\n  _ngForOf = null;\n  _ngForOfDirty = true;\n  _differ = null;\n  // TODO(issue/24571): remove '!'\n  // waiting for microsoft/typescript#43662 to allow the return type `TrackByFunction|undefined` for\n  // the getter\n  _trackByFn;\n  constructor(_viewContainer, _template, _differs) {\n    this._viewContainer = _viewContainer;\n    this._template = _template;\n    this._differs = _differs;\n  }\n  /**\n   * A reference to the template that is stamped out for each item in the iterable.\n   * @see [template reference variable](guide/templates/variables#template-reference-variables)\n   */\n  set ngForTemplate(value) {\n    if (value) {\n      this._template = value;\n    }\n  }\n  /**\n   * Applies the changes when needed.\n   * @nodoc\n   */\n  ngDoCheck() {\n    if (this._ngForOfDirty) {\n      this._ngForOfDirty = false;\n      const value = this._ngForOf;\n      if (!this._differ && value) {\n        if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n          try {\n            this._differ = this._differs.find(value).create(this.ngForTrackBy);\n          } catch {\n            let errorMessage = `Cannot find a differ supporting object '${value}' of type '${getTypeName(value)}'. NgFor only supports binding to Iterables, such as Arrays.`;\n            if (typeof value === \"object\") {\n              errorMessage += \" Did you mean to use the keyvalue pipe?\";\n            }\n            throw new RuntimeError(-2200, errorMessage);\n          }\n        } else {\n          this._differ = this._differs.find(value).create(this.ngForTrackBy);\n        }\n      }\n    }\n    if (this._differ) {\n      const changes = this._differ.diff(this._ngForOf);\n      if (changes) this._applyChanges(changes);\n    }\n  }\n  _applyChanges(changes) {\n    const viewContainer = this._viewContainer;\n    changes.forEachOperation((item, adjustedPreviousIndex, currentIndex) => {\n      if (item.previousIndex == null) {\n        viewContainer.createEmbeddedView(this._template, new NgForOfContext(item.item, this._ngForOf, -1, -1), currentIndex === null ? void 0 : currentIndex);\n      } else if (currentIndex == null) {\n        viewContainer.remove(adjustedPreviousIndex === null ? void 0 : adjustedPreviousIndex);\n      } else if (adjustedPreviousIndex !== null) {\n        const view = viewContainer.get(adjustedPreviousIndex);\n        viewContainer.move(view, currentIndex);\n        applyViewChange(view, item);\n      }\n    });\n    for (let i = 0, ilen = viewContainer.length; i < ilen; i++) {\n      const viewRef = viewContainer.get(i);\n      const context2 = viewRef.context;\n      context2.index = i;\n      context2.count = ilen;\n      context2.ngForOf = this._ngForOf;\n    }\n    changes.forEachIdentityChange((record) => {\n      const viewRef = viewContainer.get(record.currentIndex);\n      applyViewChange(viewRef, record);\n    });\n  }\n  /**\n   * Asserts the correct type of the context for the template that `NgForOf` will render.\n   *\n   * The presence of this method is a signal to the Ivy template type-check compiler that the\n   * `NgForOf` structural directive renders its template with a specific context type.\n   */\n  static ngTemplateContextGuard(dir, ctx) {\n    return true;\n  }\n  static \\u0275fac = function NgForOf_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _NgForOf)(\\u0275\\u0275directiveInject(ViewContainerRef), \\u0275\\u0275directiveInject(TemplateRef), \\u0275\\u0275directiveInject(IterableDiffers));\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _NgForOf,\n    selectors: [[\"\", \"ngFor\", \"\", \"ngForOf\", \"\"]],\n    inputs: {\n      ngForOf: \"ngForOf\",\n      ngForTrackBy: \"ngForTrackBy\",\n      ngForTemplate: \"ngForTemplate\"\n    }\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(NgForOf, [{\n    type: Directive,\n    args: [{\n      selector: \"[ngFor][ngForOf]\"\n    }]\n  }], () => [{\n    type: ViewContainerRef\n  }, {\n    type: TemplateRef\n  }, {\n    type: IterableDiffers\n  }], {\n    ngForOf: [{\n      type: Input\n    }],\n    ngForTrackBy: [{\n      type: Input\n    }],\n    ngForTemplate: [{\n      type: Input\n    }]\n  });\n})();\nfunction applyViewChange(view, record) {\n  view.context.$implicit = record.item;\n}\nfunction getTypeName(type) {\n  return type[\"name\"] || typeof type;\n}\nvar NgIf = class _NgIf {\n  _viewContainer;\n  _context = new NgIfContext();\n  _thenTemplateRef = null;\n  _elseTemplateRef = null;\n  _thenViewRef = null;\n  _elseViewRef = null;\n  constructor(_viewContainer, templateRef) {\n    this._viewContainer = _viewContainer;\n    this._thenTemplateRef = templateRef;\n  }\n  /**\n   * The Boolean expression to evaluate as the condition for showing a template.\n   */\n  set ngIf(condition) {\n    this._context.$implicit = this._context.ngIf = condition;\n    this._updateView();\n  }\n  /**\n   * A template to show if the condition expression evaluates to true.\n   */\n  set ngIfThen(templateRef) {\n    assertTemplate(templateRef, (typeof ngDevMode === \"undefined\" || ngDevMode) && \"ngIfThen\");\n    this._thenTemplateRef = templateRef;\n    this._thenViewRef = null;\n    this._updateView();\n  }\n  /**\n   * A template to show if the condition expression evaluates to false.\n   */\n  set ngIfElse(templateRef) {\n    assertTemplate(templateRef, (typeof ngDevMode === \"undefined\" || ngDevMode) && \"ngIfElse\");\n    this._elseTemplateRef = templateRef;\n    this._elseViewRef = null;\n    this._updateView();\n  }\n  _updateView() {\n    if (this._context.$implicit) {\n      if (!this._thenViewRef) {\n        this._viewContainer.clear();\n        this._elseViewRef = null;\n        if (this._thenTemplateRef) {\n          this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context);\n        }\n      }\n    } else {\n      if (!this._elseViewRef) {\n        this._viewContainer.clear();\n        this._thenViewRef = null;\n        if (this._elseTemplateRef) {\n          this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context);\n        }\n      }\n    }\n  }\n  /** @internal */\n  static ngIfUseIfTypeGuard;\n  /**\n   * Assert the correct type of the expression bound to the `ngIf` input within the template.\n   *\n   * The presence of this static field is a signal to the Ivy template type check compiler that\n   * when the `NgIf` structural directive renders its template, the type of the expression bound\n   * to `ngIf` should be narrowed in some way. For `NgIf`, the binding expression itself is used to\n   * narrow its type, which allows the strictNullChecks feature of TypeScript to work with `NgIf`.\n   */\n  static ngTemplateGuard_ngIf;\n  /**\n   * Asserts the correct type of the context for the template that `NgIf` will render.\n   *\n   * The presence of this method is a signal to the Ivy template type-check compiler that the\n   * `NgIf` structural directive renders its template with a specific context type.\n   */\n  static ngTemplateContextGuard(dir, ctx) {\n    return true;\n  }\n  static \\u0275fac = function NgIf_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _NgIf)(\\u0275\\u0275directiveInject(ViewContainerRef), \\u0275\\u0275directiveInject(TemplateRef));\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _NgIf,\n    selectors: [[\"\", \"ngIf\", \"\"]],\n    inputs: {\n      ngIf: \"ngIf\",\n      ngIfThen: \"ngIfThen\",\n      ngIfElse: \"ngIfElse\"\n    }\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(NgIf, [{\n    type: Directive,\n    args: [{\n      selector: \"[ngIf]\"\n    }]\n  }], () => [{\n    type: ViewContainerRef\n  }, {\n    type: TemplateRef\n  }], {\n    ngIf: [{\n      type: Input\n    }],\n    ngIfThen: [{\n      type: Input\n    }],\n    ngIfElse: [{\n      type: Input\n    }]\n  });\n})();\nvar NgIfContext = class {\n  $implicit = null;\n  ngIf = null;\n};\nfunction assertTemplate(templateRef, property) {\n  if (templateRef && !templateRef.createEmbeddedView) {\n    throw new RuntimeError(2020, (typeof ngDevMode === \"undefined\" || ngDevMode) && `${property} must be a TemplateRef, but received '${stringify(templateRef)}'.`);\n  }\n}\nvar SwitchView = class {\n  _viewContainerRef;\n  _templateRef;\n  _created = false;\n  constructor(_viewContainerRef, _templateRef) {\n    this._viewContainerRef = _viewContainerRef;\n    this._templateRef = _templateRef;\n  }\n  create() {\n    this._created = true;\n    this._viewContainerRef.createEmbeddedView(this._templateRef);\n  }\n  destroy() {\n    this._created = false;\n    this._viewContainerRef.clear();\n  }\n  enforceState(created) {\n    if (created && !this._created) {\n      this.create();\n    } else if (!created && this._created) {\n      this.destroy();\n    }\n  }\n};\nvar NgSwitch = class _NgSwitch {\n  _defaultViews = [];\n  _defaultUsed = false;\n  _caseCount = 0;\n  _lastCaseCheckIndex = 0;\n  _lastCasesMatched = false;\n  _ngSwitch;\n  set ngSwitch(newValue) {\n    this._ngSwitch = newValue;\n    if (this._caseCount === 0) {\n      this._updateDefaultCases(true);\n    }\n  }\n  /** @internal */\n  _addCase() {\n    return this._caseCount++;\n  }\n  /** @internal */\n  _addDefault(view) {\n    this._defaultViews.push(view);\n  }\n  /** @internal */\n  _matchCase(value) {\n    const matched = value === this._ngSwitch;\n    this._lastCasesMatched ||= matched;\n    this._lastCaseCheckIndex++;\n    if (this._lastCaseCheckIndex === this._caseCount) {\n      this._updateDefaultCases(!this._lastCasesMatched);\n      this._lastCaseCheckIndex = 0;\n      this._lastCasesMatched = false;\n    }\n    return matched;\n  }\n  _updateDefaultCases(useDefault) {\n    if (this._defaultViews.length > 0 && useDefault !== this._defaultUsed) {\n      this._defaultUsed = useDefault;\n      for (const defaultView of this._defaultViews) {\n        defaultView.enforceState(useDefault);\n      }\n    }\n  }\n  static \\u0275fac = function NgSwitch_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _NgSwitch)();\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _NgSwitch,\n    selectors: [[\"\", \"ngSwitch\", \"\"]],\n    inputs: {\n      ngSwitch: \"ngSwitch\"\n    }\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(NgSwitch, [{\n    type: Directive,\n    args: [{\n      selector: \"[ngSwitch]\"\n    }]\n  }], null, {\n    ngSwitch: [{\n      type: Input\n    }]\n  });\n})();\nvar NgSwitchCase = class _NgSwitchCase {\n  ngSwitch;\n  _view;\n  /**\n   * Stores the HTML template to be selected on match.\n   */\n  ngSwitchCase;\n  constructor(viewContainer, templateRef, ngSwitch) {\n    this.ngSwitch = ngSwitch;\n    if ((typeof ngDevMode === \"undefined\" || ngDevMode) && !ngSwitch) {\n      throwNgSwitchProviderNotFoundError(\"ngSwitchCase\", \"NgSwitchCase\");\n    }\n    ngSwitch._addCase();\n    this._view = new SwitchView(viewContainer, templateRef);\n  }\n  /**\n   * Performs case matching. For internal use only.\n   * @nodoc\n   */\n  ngDoCheck() {\n    this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase));\n  }\n  static \\u0275fac = function NgSwitchCase_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _NgSwitchCase)(\\u0275\\u0275directiveInject(ViewContainerRef), \\u0275\\u0275directiveInject(TemplateRef), \\u0275\\u0275directiveInject(NgSwitch, 9));\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _NgSwitchCase,\n    selectors: [[\"\", \"ngSwitchCase\", \"\"]],\n    inputs: {\n      ngSwitchCase: \"ngSwitchCase\"\n    }\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(NgSwitchCase, [{\n    type: Directive,\n    args: [{\n      selector: \"[ngSwitchCase]\"\n    }]\n  }], () => [{\n    type: ViewContainerRef\n  }, {\n    type: TemplateRef\n  }, {\n    type: NgSwitch,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Host\n    }]\n  }], {\n    ngSwitchCase: [{\n      type: Input\n    }]\n  });\n})();\nvar NgSwitchDefault = class _NgSwitchDefault {\n  constructor(viewContainer, templateRef, ngSwitch) {\n    if ((typeof ngDevMode === \"undefined\" || ngDevMode) && !ngSwitch) {\n      throwNgSwitchProviderNotFoundError(\"ngSwitchDefault\", \"NgSwitchDefault\");\n    }\n    ngSwitch._addDefault(new SwitchView(viewContainer, templateRef));\n  }\n  static \\u0275fac = function NgSwitchDefault_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _NgSwitchDefault)(\\u0275\\u0275directiveInject(ViewContainerRef), \\u0275\\u0275directiveInject(TemplateRef), \\u0275\\u0275directiveInject(NgSwitch, 9));\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _NgSwitchDefault,\n    selectors: [[\"\", \"ngSwitchDefault\", \"\"]]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(NgSwitchDefault, [{\n    type: Directive,\n    args: [{\n      selector: \"[ngSwitchDefault]\"\n    }]\n  }], () => [{\n    type: ViewContainerRef\n  }, {\n    type: TemplateRef\n  }, {\n    type: NgSwitch,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Host\n    }]\n  }], null);\n})();\nfunction throwNgSwitchProviderNotFoundError(attrName, directiveName) {\n  throw new RuntimeError(2e3, `An element with the \"${attrName}\" attribute (matching the \"${directiveName}\" directive) must be located inside an element with the \"ngSwitch\" attribute (matching \"NgSwitch\" directive)`);\n}\nvar NgPlural = class _NgPlural {\n  _localization;\n  _activeView;\n  _caseViews = {};\n  constructor(_localization) {\n    this._localization = _localization;\n  }\n  set ngPlural(value) {\n    this._updateView(value);\n  }\n  addCase(value, switchView) {\n    this._caseViews[value] = switchView;\n  }\n  _updateView(switchValue) {\n    this._clearViews();\n    const cases = Object.keys(this._caseViews);\n    const key = getPluralCategory(switchValue, cases, this._localization);\n    this._activateView(this._caseViews[key]);\n  }\n  _clearViews() {\n    if (this._activeView) this._activeView.destroy();\n  }\n  _activateView(view) {\n    if (view) {\n      this._activeView = view;\n      this._activeView.create();\n    }\n  }\n  static \\u0275fac = function NgPlural_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _NgPlural)(\\u0275\\u0275directiveInject(NgLocalization));\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _NgPlural,\n    selectors: [[\"\", \"ngPlural\", \"\"]],\n    inputs: {\n      ngPlural: \"ngPlural\"\n    }\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(NgPlural, [{\n    type: Directive,\n    args: [{\n      selector: \"[ngPlural]\"\n    }]\n  }], () => [{\n    type: NgLocalization\n  }], {\n    ngPlural: [{\n      type: Input\n    }]\n  });\n})();\nvar NgPluralCase = class _NgPluralCase {\n  value;\n  constructor(value, template, viewContainer, ngPlural) {\n    this.value = value;\n    const isANumber = !isNaN(Number(value));\n    ngPlural.addCase(isANumber ? `=${value}` : value, new SwitchView(viewContainer, template));\n  }\n  static \\u0275fac = function NgPluralCase_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _NgPluralCase)(\\u0275\\u0275injectAttribute(\"ngPluralCase\"), \\u0275\\u0275directiveInject(TemplateRef), \\u0275\\u0275directiveInject(ViewContainerRef), \\u0275\\u0275directiveInject(NgPlural, 1));\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _NgPluralCase,\n    selectors: [[\"\", \"ngPluralCase\", \"\"]]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(NgPluralCase, [{\n    type: Directive,\n    args: [{\n      selector: \"[ngPluralCase]\"\n    }]\n  }], () => [{\n    type: void 0,\n    decorators: [{\n      type: Attribute,\n      args: [\"ngPluralCase\"]\n    }]\n  }, {\n    type: TemplateRef\n  }, {\n    type: ViewContainerRef\n  }, {\n    type: NgPlural,\n    decorators: [{\n      type: Host\n    }]\n  }], null);\n})();\nvar NgStyle = class _NgStyle {\n  _ngEl;\n  _differs;\n  _renderer;\n  _ngStyle = null;\n  _differ = null;\n  constructor(_ngEl, _differs, _renderer) {\n    this._ngEl = _ngEl;\n    this._differs = _differs;\n    this._renderer = _renderer;\n  }\n  set ngStyle(values) {\n    this._ngStyle = values;\n    if (!this._differ && values) {\n      this._differ = this._differs.find(values).create();\n    }\n  }\n  ngDoCheck() {\n    if (this._differ) {\n      const changes = this._differ.diff(this._ngStyle);\n      if (changes) {\n        this._applyChanges(changes);\n      }\n    }\n  }\n  _setStyle(nameAndUnit, value) {\n    const [name, unit] = nameAndUnit.split(\".\");\n    const flags = name.indexOf(\"-\") === -1 ? void 0 : RendererStyleFlags2.DashCase;\n    if (value != null) {\n      this._renderer.setStyle(this._ngEl.nativeElement, name, unit ? `${value}${unit}` : value, flags);\n    } else {\n      this._renderer.removeStyle(this._ngEl.nativeElement, name, flags);\n    }\n  }\n  _applyChanges(changes) {\n    changes.forEachRemovedItem((record) => this._setStyle(record.key, null));\n    changes.forEachAddedItem((record) => this._setStyle(record.key, record.currentValue));\n    changes.forEachChangedItem((record) => this._setStyle(record.key, record.currentValue));\n  }\n  static \\u0275fac = function NgStyle_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _NgStyle)(\\u0275\\u0275directiveInject(ElementRef), \\u0275\\u0275directiveInject(KeyValueDiffers), \\u0275\\u0275directiveInject(Renderer2));\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _NgStyle,\n    selectors: [[\"\", \"ngStyle\", \"\"]],\n    inputs: {\n      ngStyle: \"ngStyle\"\n    }\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(NgStyle, [{\n    type: Directive,\n    args: [{\n      selector: \"[ngStyle]\"\n    }]\n  }], () => [{\n    type: ElementRef\n  }, {\n    type: KeyValueDiffers\n  }, {\n    type: Renderer2\n  }], {\n    ngStyle: [{\n      type: Input,\n      args: [\"ngStyle\"]\n    }]\n  });\n})();\nvar NgTemplateOutlet = class _NgTemplateOutlet {\n  _viewContainerRef;\n  _viewRef = null;\n  /**\n   * A context object to attach to the {@link EmbeddedViewRef}. This should be an\n   * object, the object's keys will be available for binding by the local template `let`\n   * declarations.\n   * Using the key `$implicit` in the context object will set its value as default.\n   */\n  ngTemplateOutletContext = null;\n  /**\n   * A string defining the template reference and optionally the context object for the template.\n   */\n  ngTemplateOutlet = null;\n  /** Injector to be used within the embedded view. */\n  ngTemplateOutletInjector = null;\n  constructor(_viewContainerRef) {\n    this._viewContainerRef = _viewContainerRef;\n  }\n  ngOnChanges(changes) {\n    if (this._shouldRecreateView(changes)) {\n      const viewContainerRef = this._viewContainerRef;\n      if (this._viewRef) {\n        viewContainerRef.remove(viewContainerRef.indexOf(this._viewRef));\n      }\n      if (!this.ngTemplateOutlet) {\n        this._viewRef = null;\n        return;\n      }\n      const viewContext = this._createContextForwardProxy();\n      this._viewRef = viewContainerRef.createEmbeddedView(this.ngTemplateOutlet, viewContext, {\n        injector: this.ngTemplateOutletInjector ?? void 0\n      });\n    }\n  }\n  /**\n   * We need to re-create existing embedded view if either is true:\n   * - the outlet changed.\n   * - the injector changed.\n   */\n  _shouldRecreateView(changes) {\n    return !!changes[\"ngTemplateOutlet\"] || !!changes[\"ngTemplateOutletInjector\"];\n  }\n  /**\n   * For a given outlet instance, we create a proxy object that delegates\n   * to the user-specified context. This allows changing, or swapping out\n   * the context object completely without having to destroy/re-create the view.\n   */\n  _createContextForwardProxy() {\n    return new Proxy({}, {\n      set: (_target, prop, newValue) => {\n        if (!this.ngTemplateOutletContext) {\n          return false;\n        }\n        return Reflect.set(this.ngTemplateOutletContext, prop, newValue);\n      },\n      get: (_target, prop, receiver) => {\n        if (!this.ngTemplateOutletContext) {\n          return void 0;\n        }\n        return Reflect.get(this.ngTemplateOutletContext, prop, receiver);\n      }\n    });\n  }\n  static \\u0275fac = function NgTemplateOutlet_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _NgTemplateOutlet)(\\u0275\\u0275directiveInject(ViewContainerRef));\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _NgTemplateOutlet,\n    selectors: [[\"\", \"ngTemplateOutlet\", \"\"]],\n    inputs: {\n      ngTemplateOutletContext: \"ngTemplateOutletContext\",\n      ngTemplateOutlet: \"ngTemplateOutlet\",\n      ngTemplateOutletInjector: \"ngTemplateOutletInjector\"\n    },\n    features: [\\u0275\\u0275NgOnChangesFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(NgTemplateOutlet, [{\n    type: Directive,\n    args: [{\n      selector: \"[ngTemplateOutlet]\"\n    }]\n  }], () => [{\n    type: ViewContainerRef\n  }], {\n    ngTemplateOutletContext: [{\n      type: Input\n    }],\n    ngTemplateOutlet: [{\n      type: Input\n    }],\n    ngTemplateOutletInjector: [{\n      type: Input\n    }]\n  });\n})();\nvar COMMON_DIRECTIVES = [NgClass, NgComponentOutlet, NgForOf, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase];\nfunction invalidPipeArgumentError(type, value) {\n  return new RuntimeError(2100, ngDevMode && `InvalidPipeArgument: '${value}' for pipe '${stringify(type)}'`);\n}\nvar SubscribableStrategy = class {\n  createSubscription(async, updateLatestValue) {\n    return untracked2(() => async.subscribe({\n      next: updateLatestValue,\n      error: (e) => {\n        throw e;\n      }\n    }));\n  }\n  dispose(subscription) {\n    untracked2(() => subscription.unsubscribe());\n  }\n};\nvar PromiseStrategy = class {\n  createSubscription(async, updateLatestValue) {\n    return async.then(updateLatestValue, (e) => {\n      throw e;\n    });\n  }\n  dispose(subscription) {\n  }\n};\nvar _promiseStrategy = new PromiseStrategy();\nvar _subscribableStrategy = new SubscribableStrategy();\nvar AsyncPipe = class _AsyncPipe {\n  _ref;\n  _latestValue = null;\n  markForCheckOnValueUpdate = true;\n  _subscription = null;\n  _obj = null;\n  _strategy = null;\n  constructor(ref) {\n    this._ref = ref;\n  }\n  ngOnDestroy() {\n    if (this._subscription) {\n      this._dispose();\n    }\n    this._ref = null;\n  }\n  transform(obj) {\n    if (!this._obj) {\n      if (obj) {\n        try {\n          this.markForCheckOnValueUpdate = false;\n          this._subscribe(obj);\n        } finally {\n          this.markForCheckOnValueUpdate = true;\n        }\n      }\n      return this._latestValue;\n    }\n    if (obj !== this._obj) {\n      this._dispose();\n      return this.transform(obj);\n    }\n    return this._latestValue;\n  }\n  _subscribe(obj) {\n    this._obj = obj;\n    this._strategy = this._selectStrategy(obj);\n    this._subscription = this._strategy.createSubscription(obj, (value) => this._updateLatestValue(obj, value));\n  }\n  _selectStrategy(obj) {\n    if (isPromise2(obj)) {\n      return _promiseStrategy;\n    }\n    if (isSubscribable(obj)) {\n      return _subscribableStrategy;\n    }\n    throw invalidPipeArgumentError(_AsyncPipe, obj);\n  }\n  _dispose() {\n    this._strategy.dispose(this._subscription);\n    this._latestValue = null;\n    this._subscription = null;\n    this._obj = null;\n  }\n  _updateLatestValue(async, value) {\n    if (async === this._obj) {\n      this._latestValue = value;\n      if (this.markForCheckOnValueUpdate) {\n        this._ref?.markForCheck();\n      }\n    }\n  }\n  static \\u0275fac = function AsyncPipe_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _AsyncPipe)(\\u0275\\u0275directiveInject(ChangeDetectorRef, 16));\n  };\n  static \\u0275pipe = /* @__PURE__ */ \\u0275\\u0275definePipe({\n    name: \"async\",\n    type: _AsyncPipe,\n    pure: false\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(AsyncPipe, [{\n    type: Pipe,\n    args: [{\n      name: \"async\",\n      pure: false\n    }]\n  }], () => [{\n    type: ChangeDetectorRef\n  }], null);\n})();\nvar LowerCasePipe = class _LowerCasePipe {\n  transform(value) {\n    if (value == null) return null;\n    if (typeof value !== \"string\") {\n      throw invalidPipeArgumentError(_LowerCasePipe, value);\n    }\n    return value.toLowerCase();\n  }\n  static \\u0275fac = function LowerCasePipe_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _LowerCasePipe)();\n  };\n  static \\u0275pipe = /* @__PURE__ */ \\u0275\\u0275definePipe({\n    name: \"lowercase\",\n    type: _LowerCasePipe,\n    pure: true\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(LowerCasePipe, [{\n    type: Pipe,\n    args: [{\n      name: \"lowercase\"\n    }]\n  }], null, null);\n})();\nvar unicodeWordMatch = /(?:[0-9A-Za-z\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05D0-\\u05EA\\u05EF-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086A\\u0870-\\u0887\\u0889-\\u088E\\u08A0-\\u08C9\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u09FC\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C5D\\u0C60\\u0C61\\u0C80\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D04-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D54-\\u0D56\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E86-\\u0E8A\\u0E8C-\\u0EA3\\u0EA5\\u0EA7-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16F1-\\u16F8\\u1700-\\u1711\\u171F-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1878\\u1880-\\u1884\\u1887-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4C\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1C80-\\u1C88\\u1C90-\\u1CBA\\u1CBD-\\u1CBF\\u1CE9-\\u1CEC\\u1CEE-\\u1CF3\\u1CF5\\u1CF6\\u1CFA\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u31A0-\\u31BF\\u31F0-\\u31FF\\u3400-\\u4DBF\\u4E00-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7CA\\uA7D0\\uA7D1\\uA7D3\\uA7D5-\\uA7D9\\uA7F2-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA8FE\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB69\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]|\\uD800[\\uDC00-\\uDC0B\\uDC0D-\\uDC26\\uDC28-\\uDC3A\\uDC3C\\uDC3D\\uDC3F-\\uDC4D\\uDC50-\\uDC5D\\uDC80-\\uDCFA\\uDE80-\\uDE9C\\uDEA0-\\uDED0\\uDF00-\\uDF1F\\uDF2D-\\uDF40\\uDF42-\\uDF49\\uDF50-\\uDF75\\uDF80-\\uDF9D\\uDFA0-\\uDFC3\\uDFC8-\\uDFCF]|\\uD801[\\uDC00-\\uDC9D\\uDCB0-\\uDCD3\\uDCD8-\\uDCFB\\uDD00-\\uDD27\\uDD30-\\uDD63\\uDD70-\\uDD7A\\uDD7C-\\uDD8A\\uDD8C-\\uDD92\\uDD94\\uDD95\\uDD97-\\uDDA1\\uDDA3-\\uDDB1\\uDDB3-\\uDDB9\\uDDBB\\uDDBC\\uDE00-\\uDF36\\uDF40-\\uDF55\\uDF60-\\uDF67\\uDF80-\\uDF85\\uDF87-\\uDFB0\\uDFB2-\\uDFBA]|\\uD802[\\uDC00-\\uDC05\\uDC08\\uDC0A-\\uDC35\\uDC37\\uDC38\\uDC3C\\uDC3F-\\uDC55\\uDC60-\\uDC76\\uDC80-\\uDC9E\\uDCE0-\\uDCF2\\uDCF4\\uDCF5\\uDD00-\\uDD15\\uDD20-\\uDD39\\uDD80-\\uDDB7\\uDDBE\\uDDBF\\uDE00\\uDE10-\\uDE13\\uDE15-\\uDE17\\uDE19-\\uDE35\\uDE60-\\uDE7C\\uDE80-\\uDE9C\\uDEC0-\\uDEC7\\uDEC9-\\uDEE4\\uDF00-\\uDF35\\uDF40-\\uDF55\\uDF60-\\uDF72\\uDF80-\\uDF91]|\\uD803[\\uDC00-\\uDC48\\uDC80-\\uDCB2\\uDCC0-\\uDCF2\\uDD00-\\uDD23\\uDE80-\\uDEA9\\uDEB0\\uDEB1\\uDF00-\\uDF1C\\uDF27\\uDF30-\\uDF45\\uDF70-\\uDF81\\uDFB0-\\uDFC4\\uDFE0-\\uDFF6]|\\uD804[\\uDC03-\\uDC37\\uDC71\\uDC72\\uDC75\\uDC83-\\uDCAF\\uDCD0-\\uDCE8\\uDD03-\\uDD26\\uDD44\\uDD47\\uDD50-\\uDD72\\uDD76\\uDD83-\\uDDB2\\uDDC1-\\uDDC4\\uDDDA\\uDDDC\\uDE00-\\uDE11\\uDE13-\\uDE2B\\uDE80-\\uDE86\\uDE88\\uDE8A-\\uDE8D\\uDE8F-\\uDE9D\\uDE9F-\\uDEA8\\uDEB0-\\uDEDE\\uDF05-\\uDF0C\\uDF0F\\uDF10\\uDF13-\\uDF28\\uDF2A-\\uDF30\\uDF32\\uDF33\\uDF35-\\uDF39\\uDF3D\\uDF50\\uDF5D-\\uDF61]|\\uD805[\\uDC00-\\uDC34\\uDC47-\\uDC4A\\uDC5F-\\uDC61\\uDC80-\\uDCAF\\uDCC4\\uDCC5\\uDCC7\\uDD80-\\uDDAE\\uDDD8-\\uDDDB\\uDE00-\\uDE2F\\uDE44\\uDE80-\\uDEAA\\uDEB8\\uDF00-\\uDF1A\\uDF40-\\uDF46]|\\uD806[\\uDC00-\\uDC2B\\uDCA0-\\uDCDF\\uDCFF-\\uDD06\\uDD09\\uDD0C-\\uDD13\\uDD15\\uDD16\\uDD18-\\uDD2F\\uDD3F\\uDD41\\uDDA0-\\uDDA7\\uDDAA-\\uDDD0\\uDDE1\\uDDE3\\uDE00\\uDE0B-\\uDE32\\uDE3A\\uDE50\\uDE5C-\\uDE89\\uDE9D\\uDEB0-\\uDEF8]|\\uD807[\\uDC00-\\uDC08\\uDC0A-\\uDC2E\\uDC40\\uDC72-\\uDC8F\\uDD00-\\uDD06\\uDD08\\uDD09\\uDD0B-\\uDD30\\uDD46\\uDD60-\\uDD65\\uDD67\\uDD68\\uDD6A-\\uDD89\\uDD98\\uDEE0-\\uDEF2\\uDFB0]|\\uD808[\\uDC00-\\uDF99]|\\uD809[\\uDC80-\\uDD43]|\\uD80B[\\uDF90-\\uDFF0]|[\\uD80C\\uD81C-\\uD820\\uD822\\uD840-\\uD868\\uD86A-\\uD86C\\uD86F-\\uD872\\uD874-\\uD879\\uD880-\\uD883][\\uDC00-\\uDFFF]|\\uD80D[\\uDC00-\\uDC2E]|\\uD811[\\uDC00-\\uDE46]|\\uD81A[\\uDC00-\\uDE38\\uDE40-\\uDE5E\\uDE70-\\uDEBE\\uDED0-\\uDEED\\uDF00-\\uDF2F\\uDF40-\\uDF43\\uDF63-\\uDF77\\uDF7D-\\uDF8F]|\\uD81B[\\uDE40-\\uDE7F\\uDF00-\\uDF4A\\uDF50\\uDF93-\\uDF9F\\uDFE0\\uDFE1\\uDFE3]|\\uD821[\\uDC00-\\uDFF7]|\\uD823[\\uDC00-\\uDCD5\\uDD00-\\uDD08]|\\uD82B[\\uDFF0-\\uDFF3\\uDFF5-\\uDFFB\\uDFFD\\uDFFE]|\\uD82C[\\uDC00-\\uDD22\\uDD50-\\uDD52\\uDD64-\\uDD67\\uDD70-\\uDEFB]|\\uD82F[\\uDC00-\\uDC6A\\uDC70-\\uDC7C\\uDC80-\\uDC88\\uDC90-\\uDC99]|\\uD835[\\uDC00-\\uDC54\\uDC56-\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDEA5\\uDEA8-\\uDEC0\\uDEC2-\\uDEDA\\uDEDC-\\uDEFA\\uDEFC-\\uDF14\\uDF16-\\uDF34\\uDF36-\\uDF4E\\uDF50-\\uDF6E\\uDF70-\\uDF88\\uDF8A-\\uDFA8\\uDFAA-\\uDFC2\\uDFC4-\\uDFCB]|\\uD837[\\uDF00-\\uDF1E]|\\uD838[\\uDD00-\\uDD2C\\uDD37-\\uDD3D\\uDD4E\\uDE90-\\uDEAD\\uDEC0-\\uDEEB]|\\uD839[\\uDFE0-\\uDFE6\\uDFE8-\\uDFEB\\uDFED\\uDFEE\\uDFF0-\\uDFFE]|\\uD83A[\\uDC00-\\uDCC4\\uDD00-\\uDD43\\uDD4B]|\\uD83B[\\uDE00-\\uDE03\\uDE05-\\uDE1F\\uDE21\\uDE22\\uDE24\\uDE27\\uDE29-\\uDE32\\uDE34-\\uDE37\\uDE39\\uDE3B\\uDE42\\uDE47\\uDE49\\uDE4B\\uDE4D-\\uDE4F\\uDE51\\uDE52\\uDE54\\uDE57\\uDE59\\uDE5B\\uDE5D\\uDE5F\\uDE61\\uDE62\\uDE64\\uDE67-\\uDE6A\\uDE6C-\\uDE72\\uDE74-\\uDE77\\uDE79-\\uDE7C\\uDE7E\\uDE80-\\uDE89\\uDE8B-\\uDE9B\\uDEA1-\\uDEA3\\uDEA5-\\uDEA9\\uDEAB-\\uDEBB]|\\uD869[\\uDC00-\\uDEDF\\uDF00-\\uDFFF]|\\uD86D[\\uDC00-\\uDF38\\uDF40-\\uDFFF]|\\uD86E[\\uDC00-\\uDC1D\\uDC20-\\uDFFF]|\\uD873[\\uDC00-\\uDEA1\\uDEB0-\\uDFFF]|\\uD87A[\\uDC00-\\uDFE0]|\\uD87E[\\uDC00-\\uDE1D]|\\uD884[\\uDC00-\\uDF4A])\\S*/g;\nvar TitleCasePipe = class _TitleCasePipe {\n  transform(value) {\n    if (value == null) return null;\n    if (typeof value !== \"string\") {\n      throw invalidPipeArgumentError(_TitleCasePipe, value);\n    }\n    return value.replace(unicodeWordMatch, (txt) => txt[0].toUpperCase() + txt.slice(1).toLowerCase());\n  }\n  static \\u0275fac = function TitleCasePipe_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _TitleCasePipe)();\n  };\n  static \\u0275pipe = /* @__PURE__ */ \\u0275\\u0275definePipe({\n    name: \"titlecase\",\n    type: _TitleCasePipe,\n    pure: true\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(TitleCasePipe, [{\n    type: Pipe,\n    args: [{\n      name: \"titlecase\"\n    }]\n  }], null, null);\n})();\nvar UpperCasePipe = class _UpperCasePipe {\n  transform(value) {\n    if (value == null) return null;\n    if (typeof value !== \"string\") {\n      throw invalidPipeArgumentError(_UpperCasePipe, value);\n    }\n    return value.toUpperCase();\n  }\n  static \\u0275fac = function UpperCasePipe_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _UpperCasePipe)();\n  };\n  static \\u0275pipe = /* @__PURE__ */ \\u0275\\u0275definePipe({\n    name: \"uppercase\",\n    type: _UpperCasePipe,\n    pure: true\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(UpperCasePipe, [{\n    type: Pipe,\n    args: [{\n      name: \"uppercase\"\n    }]\n  }], null, null);\n})();\nvar DEFAULT_DATE_FORMAT = \"mediumDate\";\nvar DATE_PIPE_DEFAULT_TIMEZONE = new InjectionToken(ngDevMode ? \"DATE_PIPE_DEFAULT_TIMEZONE\" : \"\");\nvar DATE_PIPE_DEFAULT_OPTIONS = new InjectionToken(ngDevMode ? \"DATE_PIPE_DEFAULT_OPTIONS\" : \"\");\nvar DatePipe = class _DatePipe {\n  locale;\n  defaultTimezone;\n  defaultOptions;\n  constructor(locale, defaultTimezone, defaultOptions) {\n    this.locale = locale;\n    this.defaultTimezone = defaultTimezone;\n    this.defaultOptions = defaultOptions;\n  }\n  transform(value, format, timezone, locale) {\n    if (value == null || value === \"\" || value !== value) return null;\n    try {\n      const _format = format ?? this.defaultOptions?.dateFormat ?? DEFAULT_DATE_FORMAT;\n      const _timezone = timezone ?? this.defaultOptions?.timezone ?? this.defaultTimezone ?? void 0;\n      return formatDate(value, _format, locale || this.locale, _timezone);\n    } catch (error) {\n      throw invalidPipeArgumentError(_DatePipe, error.message);\n    }\n  }\n  static \\u0275fac = function DatePipe_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _DatePipe)(\\u0275\\u0275directiveInject(LOCALE_ID, 16), \\u0275\\u0275directiveInject(DATE_PIPE_DEFAULT_TIMEZONE, 24), \\u0275\\u0275directiveInject(DATE_PIPE_DEFAULT_OPTIONS, 24));\n  };\n  static \\u0275pipe = /* @__PURE__ */ \\u0275\\u0275definePipe({\n    name: \"date\",\n    type: _DatePipe,\n    pure: true\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(DatePipe, [{\n    type: Pipe,\n    args: [{\n      name: \"date\"\n    }]\n  }], () => [{\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [LOCALE_ID]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [DATE_PIPE_DEFAULT_TIMEZONE]\n    }, {\n      type: Optional\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [DATE_PIPE_DEFAULT_OPTIONS]\n    }, {\n      type: Optional\n    }]\n  }], null);\n})();\nvar _INTERPOLATION_REGEXP = /#/g;\nvar I18nPluralPipe = class _I18nPluralPipe {\n  _localization;\n  constructor(_localization) {\n    this._localization = _localization;\n  }\n  /**\n   * @param value the number to be formatted\n   * @param pluralMap an object that mimics the ICU format, see\n   * https://unicode-org.github.io/icu/userguide/format_parse/messages/.\n   * @param locale a `string` defining the locale to use (uses the current {@link LOCALE_ID} by\n   * default).\n   */\n  transform(value, pluralMap, locale) {\n    if (value == null) return \"\";\n    if (typeof pluralMap !== \"object\" || pluralMap === null) {\n      throw invalidPipeArgumentError(_I18nPluralPipe, pluralMap);\n    }\n    const key = getPluralCategory(value, Object.keys(pluralMap), this._localization, locale);\n    return pluralMap[key].replace(_INTERPOLATION_REGEXP, value.toString());\n  }\n  static \\u0275fac = function I18nPluralPipe_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _I18nPluralPipe)(\\u0275\\u0275directiveInject(NgLocalization, 16));\n  };\n  static \\u0275pipe = /* @__PURE__ */ \\u0275\\u0275definePipe({\n    name: \"i18nPlural\",\n    type: _I18nPluralPipe,\n    pure: true\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(I18nPluralPipe, [{\n    type: Pipe,\n    args: [{\n      name: \"i18nPlural\"\n    }]\n  }], () => [{\n    type: NgLocalization\n  }], null);\n})();\nvar I18nSelectPipe = class _I18nSelectPipe {\n  /**\n   * @param value a string to be internationalized.\n   * @param mapping an object that indicates the text that should be displayed\n   * for different values of the provided `value`.\n   */\n  transform(value, mapping) {\n    if (value == null) return \"\";\n    if (typeof mapping !== \"object\" || typeof value !== \"string\") {\n      throw invalidPipeArgumentError(_I18nSelectPipe, mapping);\n    }\n    if (mapping.hasOwnProperty(value)) {\n      return mapping[value];\n    }\n    if (mapping.hasOwnProperty(\"other\")) {\n      return mapping[\"other\"];\n    }\n    return \"\";\n  }\n  static \\u0275fac = function I18nSelectPipe_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _I18nSelectPipe)();\n  };\n  static \\u0275pipe = /* @__PURE__ */ \\u0275\\u0275definePipe({\n    name: \"i18nSelect\",\n    type: _I18nSelectPipe,\n    pure: true\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(I18nSelectPipe, [{\n    type: Pipe,\n    args: [{\n      name: \"i18nSelect\"\n    }]\n  }], null, null);\n})();\nvar JsonPipe = class _JsonPipe {\n  /**\n   * @param value A value of any type to convert into a JSON-format string.\n   */\n  transform(value) {\n    return JSON.stringify(value, null, 2);\n  }\n  static \\u0275fac = function JsonPipe_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _JsonPipe)();\n  };\n  static \\u0275pipe = /* @__PURE__ */ \\u0275\\u0275definePipe({\n    name: \"json\",\n    type: _JsonPipe,\n    pure: false\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(JsonPipe, [{\n    type: Pipe,\n    args: [{\n      name: \"json\",\n      pure: false\n    }]\n  }], null, null);\n})();\nfunction makeKeyValuePair(key, value) {\n  return {\n    key,\n    value\n  };\n}\nvar KeyValuePipe = class _KeyValuePipe {\n  differs;\n  constructor(differs) {\n    this.differs = differs;\n  }\n  differ;\n  keyValues = [];\n  compareFn = defaultComparator;\n  transform(input2, compareFn = defaultComparator) {\n    if (!input2 || !(input2 instanceof Map) && typeof input2 !== \"object\") {\n      return null;\n    }\n    this.differ ??= this.differs.find(input2).create();\n    const differChanges = this.differ.diff(input2);\n    const compareFnChanged = compareFn !== this.compareFn;\n    if (differChanges) {\n      this.keyValues = [];\n      differChanges.forEachItem((r) => {\n        this.keyValues.push(makeKeyValuePair(r.key, r.currentValue));\n      });\n    }\n    if (differChanges || compareFnChanged) {\n      if (compareFn) {\n        this.keyValues.sort(compareFn);\n      }\n      this.compareFn = compareFn;\n    }\n    return this.keyValues;\n  }\n  static \\u0275fac = function KeyValuePipe_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _KeyValuePipe)(\\u0275\\u0275directiveInject(KeyValueDiffers, 16));\n  };\n  static \\u0275pipe = /* @__PURE__ */ \\u0275\\u0275definePipe({\n    name: \"keyvalue\",\n    type: _KeyValuePipe,\n    pure: false\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(KeyValuePipe, [{\n    type: Pipe,\n    args: [{\n      name: \"keyvalue\",\n      pure: false\n    }]\n  }], () => [{\n    type: KeyValueDiffers\n  }], null);\n})();\nfunction defaultComparator(keyValueA, keyValueB) {\n  const a = keyValueA.key;\n  const b = keyValueB.key;\n  if (a === b) return 0;\n  if (a == null) return 1;\n  if (b == null) return -1;\n  if (typeof a == \"string\" && typeof b == \"string\") {\n    return a < b ? -1 : 1;\n  }\n  if (typeof a == \"number\" && typeof b == \"number\") {\n    return a - b;\n  }\n  if (typeof a == \"boolean\" && typeof b == \"boolean\") {\n    return a < b ? -1 : 1;\n  }\n  const aString = String(a);\n  const bString = String(b);\n  return aString == bString ? 0 : aString < bString ? -1 : 1;\n}\nvar DecimalPipe = class _DecimalPipe {\n  _locale;\n  constructor(_locale) {\n    this._locale = _locale;\n  }\n  transform(value, digitsInfo, locale) {\n    if (!isValue(value)) return null;\n    locale ||= this._locale;\n    try {\n      const num = strToNumber(value);\n      return formatNumber(num, locale, digitsInfo);\n    } catch (error) {\n      throw invalidPipeArgumentError(_DecimalPipe, error.message);\n    }\n  }\n  static \\u0275fac = function DecimalPipe_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _DecimalPipe)(\\u0275\\u0275directiveInject(LOCALE_ID, 16));\n  };\n  static \\u0275pipe = /* @__PURE__ */ \\u0275\\u0275definePipe({\n    name: \"number\",\n    type: _DecimalPipe,\n    pure: true\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(DecimalPipe, [{\n    type: Pipe,\n    args: [{\n      name: \"number\"\n    }]\n  }], () => [{\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [LOCALE_ID]\n    }]\n  }], null);\n})();\nvar PercentPipe = class _PercentPipe {\n  _locale;\n  constructor(_locale) {\n    this._locale = _locale;\n  }\n  /**\n   *\n   * @param value The number to be formatted as a percentage.\n   * @param digitsInfo Decimal representation options, specified by a string\n   * in the following format:<br>\n   * <code>{minIntegerDigits}.{minFractionDigits}-{maxFractionDigits}</code>.\n   *   - `minIntegerDigits`: The minimum number of integer digits before the decimal point.\n   * Default is `1`.\n   *   - `minFractionDigits`: The minimum number of digits after the decimal point.\n   * Default is `0`.\n   *   - `maxFractionDigits`: The maximum number of digits after the decimal point.\n   * Default is `0`.\n   * @param locale A locale code for the locale format rules to use.\n   * When not supplied, uses the value of `LOCALE_ID`, which is `en-US` by default.\n   * See [Setting your app locale](guide/i18n/locale-id).\n   */\n  transform(value, digitsInfo, locale) {\n    if (!isValue(value)) return null;\n    locale ||= this._locale;\n    try {\n      const num = strToNumber(value);\n      return formatPercent(num, locale, digitsInfo);\n    } catch (error) {\n      throw invalidPipeArgumentError(_PercentPipe, error.message);\n    }\n  }\n  static \\u0275fac = function PercentPipe_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _PercentPipe)(\\u0275\\u0275directiveInject(LOCALE_ID, 16));\n  };\n  static \\u0275pipe = /* @__PURE__ */ \\u0275\\u0275definePipe({\n    name: \"percent\",\n    type: _PercentPipe,\n    pure: true\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(PercentPipe, [{\n    type: Pipe,\n    args: [{\n      name: \"percent\"\n    }]\n  }], () => [{\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [LOCALE_ID]\n    }]\n  }], null);\n})();\nvar CurrencyPipe = class _CurrencyPipe {\n  _locale;\n  _defaultCurrencyCode;\n  constructor(_locale, _defaultCurrencyCode = \"USD\") {\n    this._locale = _locale;\n    this._defaultCurrencyCode = _defaultCurrencyCode;\n  }\n  transform(value, currencyCode = this._defaultCurrencyCode, display = \"symbol\", digitsInfo, locale) {\n    if (!isValue(value)) return null;\n    locale ||= this._locale;\n    if (typeof display === \"boolean\") {\n      if ((typeof ngDevMode === \"undefined\" || ngDevMode) && console && console.warn) {\n        console.warn(`Warning: the currency pipe has been changed in Angular v5. The symbolDisplay option (third parameter) is now a string instead of a boolean. The accepted values are \"code\", \"symbol\" or \"symbol-narrow\".`);\n      }\n      display = display ? \"symbol\" : \"code\";\n    }\n    let currency = currencyCode || this._defaultCurrencyCode;\n    if (display !== \"code\") {\n      if (display === \"symbol\" || display === \"symbol-narrow\") {\n        currency = getCurrencySymbol(currency, display === \"symbol\" ? \"wide\" : \"narrow\", locale);\n      } else {\n        currency = display;\n      }\n    }\n    try {\n      const num = strToNumber(value);\n      return formatCurrency(num, locale, currency, currencyCode, digitsInfo);\n    } catch (error) {\n      throw invalidPipeArgumentError(_CurrencyPipe, error.message);\n    }\n  }\n  static \\u0275fac = function CurrencyPipe_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _CurrencyPipe)(\\u0275\\u0275directiveInject(LOCALE_ID, 16), \\u0275\\u0275directiveInject(DEFAULT_CURRENCY_CODE, 16));\n  };\n  static \\u0275pipe = /* @__PURE__ */ \\u0275\\u0275definePipe({\n    name: \"currency\",\n    type: _CurrencyPipe,\n    pure: true\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(CurrencyPipe, [{\n    type: Pipe,\n    args: [{\n      name: \"currency\"\n    }]\n  }], () => [{\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [LOCALE_ID]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [DEFAULT_CURRENCY_CODE]\n    }]\n  }], null);\n})();\nfunction isValue(value) {\n  return !(value == null || value === \"\" || value !== value);\n}\nfunction strToNumber(value) {\n  if (typeof value === \"string\" && !isNaN(Number(value) - parseFloat(value))) {\n    return Number(value);\n  }\n  if (typeof value !== \"number\") {\n    throw new Error(`${value} is not a number`);\n  }\n  return value;\n}\nvar SlicePipe = class _SlicePipe {\n  transform(value, start, end) {\n    if (value == null) return null;\n    const supports = typeof value === \"string\" || Array.isArray(value);\n    if (!supports) {\n      throw invalidPipeArgumentError(_SlicePipe, value);\n    }\n    return value.slice(start, end);\n  }\n  static \\u0275fac = function SlicePipe_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _SlicePipe)();\n  };\n  static \\u0275pipe = /* @__PURE__ */ \\u0275\\u0275definePipe({\n    name: \"slice\",\n    type: _SlicePipe,\n    pure: false\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(SlicePipe, [{\n    type: Pipe,\n    args: [{\n      name: \"slice\",\n      pure: false\n    }]\n  }], null, null);\n})();\nvar COMMON_PIPES = [AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, SlicePipe, DecimalPipe, PercentPipe, TitleCasePipe, CurrencyPipe, DatePipe, I18nPluralPipe, I18nSelectPipe, KeyValuePipe];\nvar CommonModule = class _CommonModule {\n  static \\u0275fac = function CommonModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _CommonModule)();\n  };\n  static \\u0275mod = /* @__PURE__ */ \\u0275\\u0275defineNgModule({\n    type: _CommonModule\n  });\n  static \\u0275inj = /* @__PURE__ */ \\u0275\\u0275defineInjector({});\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(CommonModule, [{\n    type: NgModule,\n    args: [{\n      imports: [COMMON_DIRECTIVES, COMMON_PIPES],\n      exports: [COMMON_DIRECTIVES, COMMON_PIPES]\n    }]\n  }], null, null);\n})();\nvar PLATFORM_BROWSER_ID = \"browser\";\nvar PLATFORM_SERVER_ID = \"server\";\nfunction isPlatformBrowser(platformId) {\n  return platformId === PLATFORM_BROWSER_ID;\n}\nfunction isPlatformServer(platformId) {\n  return platformId === PLATFORM_SERVER_ID;\n}\nvar VERSION2 = new Version(\"19.2.3\");\nvar ViewportScroller = class _ViewportScroller {\n  // De-sugared tree-shakable injection\n  // See #23917\n  /** @nocollapse */\n  static \\u0275prov = (\n    /** @pureOrBreakMyCode */\n    /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n      token: _ViewportScroller,\n      providedIn: \"root\",\n      factory: () => false ? new NullViewportScroller() : new BrowserViewportScroller(inject(DOCUMENT2), window)\n    })\n  );\n};\nvar BrowserViewportScroller = class {\n  document;\n  window;\n  offset = () => [0, 0];\n  constructor(document2, window2) {\n    this.document = document2;\n    this.window = window2;\n  }\n  /**\n   * Configures the top offset used when scrolling to an anchor.\n   * @param offset A position in screen coordinates (a tuple with x and y values)\n   * or a function that returns the top offset position.\n   *\n   */\n  setOffset(offset) {\n    if (Array.isArray(offset)) {\n      this.offset = () => offset;\n    } else {\n      this.offset = offset;\n    }\n  }\n  /**\n   * Retrieves the current scroll position.\n   * @returns The position in screen coordinates.\n   */\n  getScrollPosition() {\n    return [this.window.scrollX, this.window.scrollY];\n  }\n  /**\n   * Sets the scroll position.\n   * @param position The new position in screen coordinates.\n   */\n  scrollToPosition(position) {\n    this.window.scrollTo(position[0], position[1]);\n  }\n  /**\n   * Scrolls to an element and attempts to focus the element.\n   *\n   * Note that the function name here is misleading in that the target string may be an ID for a\n   * non-anchor element.\n   *\n   * @param target The ID of an element or name of the anchor.\n   *\n   * @see https://html.spec.whatwg.org/#the-indicated-part-of-the-document\n   * @see https://html.spec.whatwg.org/#scroll-to-fragid\n   */\n  scrollToAnchor(target) {\n    const elSelected = findAnchorFromDocument(this.document, target);\n    if (elSelected) {\n      this.scrollToElement(elSelected);\n      elSelected.focus();\n    }\n  }\n  /**\n   * Disables automatic scroll restoration provided by the browser.\n   */\n  setHistoryScrollRestoration(scrollRestoration) {\n    this.window.history.scrollRestoration = scrollRestoration;\n  }\n  /**\n   * Scrolls to an element using the native offset and the specified offset set on this scroller.\n   *\n   * The offset can be used when we know that there is a floating header and scrolling naively to an\n   * element (ex: `scrollIntoView`) leaves the element hidden behind the floating header.\n   */\n  scrollToElement(el) {\n    const rect = el.getBoundingClientRect();\n    const left = rect.left + this.window.pageXOffset;\n    const top = rect.top + this.window.pageYOffset;\n    const offset = this.offset();\n    this.window.scrollTo(left - offset[0], top - offset[1]);\n  }\n};\nfunction findAnchorFromDocument(document2, target) {\n  const documentResult = document2.getElementById(target) || document2.getElementsByName(target)[0];\n  if (documentResult) {\n    return documentResult;\n  }\n  if (typeof document2.createTreeWalker === \"function\" && document2.body && typeof document2.body.attachShadow === \"function\") {\n    const treeWalker = document2.createTreeWalker(document2.body, NodeFilter.SHOW_ELEMENT);\n    let currentNode = treeWalker.currentNode;\n    while (currentNode) {\n      const shadowRoot = currentNode.shadowRoot;\n      if (shadowRoot) {\n        const result = shadowRoot.getElementById(target) || shadowRoot.querySelector(`[name=\"${target}\"]`);\n        if (result) {\n          return result;\n        }\n      }\n      currentNode = treeWalker.nextNode();\n    }\n  }\n  return null;\n}\nvar XhrFactory = class {\n};\nvar PLACEHOLDER_QUALITY = \"20\";\nfunction getUrl(src, win) {\n  return isAbsoluteUrl(src) ? new URL(src) : new URL(src, win.location.href);\n}\nfunction isAbsoluteUrl(src) {\n  return /^https?:\\/\\//.test(src);\n}\nfunction extractHostname(url) {\n  return isAbsoluteUrl(url) ? new URL(url).hostname : url;\n}\nfunction isValidPath(path) {\n  const isString2 = typeof path === \"string\";\n  if (!isString2 || path.trim() === \"\") {\n    return false;\n  }\n  try {\n    const url = new URL(path);\n    return true;\n  } catch {\n    return false;\n  }\n}\nfunction normalizePath(path) {\n  return path.endsWith(\"/\") ? path.slice(0, -1) : path;\n}\nfunction normalizeSrc(src) {\n  return src.startsWith(\"/\") ? src.slice(1) : src;\n}\nvar noopImageLoader = (config2) => config2.src;\nvar IMAGE_LOADER = new InjectionToken(ngDevMode ? \"ImageLoader\" : \"\", {\n  providedIn: \"root\",\n  factory: () => noopImageLoader\n});\nfunction createImageLoader(buildUrlFn, exampleUrls) {\n  return function provideImageLoader(path) {\n    if (!isValidPath(path)) {\n      throwInvalidPathError(path, exampleUrls || []);\n    }\n    path = normalizePath(path);\n    const loaderFn = (config2) => {\n      if (isAbsoluteUrl(config2.src)) {\n        throwUnexpectedAbsoluteUrlError(path, config2.src);\n      }\n      return buildUrlFn(path, __spreadProps(__spreadValues({}, config2), {\n        src: normalizeSrc(config2.src)\n      }));\n    };\n    const providers = [{\n      provide: IMAGE_LOADER,\n      useValue: loaderFn\n    }];\n    return providers;\n  };\n}\nfunction throwInvalidPathError(path, exampleUrls) {\n  throw new RuntimeError(2959, ngDevMode && `Image loader has detected an invalid path (\\`${path}\\`). To fix this, supply a path using one of the following formats: ${exampleUrls.join(\" or \")}`);\n}\nfunction throwUnexpectedAbsoluteUrlError(path, url) {\n  throw new RuntimeError(2959, ngDevMode && `Image loader has detected a \\`<img>\\` tag with an invalid \\`ngSrc\\` attribute: ${url}. This image loader expects \\`ngSrc\\` to be a relative URL - however the provided value is an absolute URL. To fix this, provide \\`ngSrc\\` as a path relative to the base URL configured for this loader (\\`${path}\\`).`);\n}\nvar provideCloudflareLoader = createImageLoader(createCloudflareUrl, ngDevMode ? [\"https://<ZONE>/cdn-cgi/image/<OPTIONS>/<SOURCE-IMAGE>\"] : void 0);\nfunction createCloudflareUrl(path, config2) {\n  let params = `format=auto`;\n  if (config2.width) {\n    params += `,width=${config2.width}`;\n  }\n  if (config2.isPlaceholder) {\n    params += `,quality=${PLACEHOLDER_QUALITY}`;\n  }\n  return `${path}/cdn-cgi/image/${params}/${config2.src}`;\n}\nvar cloudinaryLoaderInfo = {\n  name: \"Cloudinary\",\n  testUrl: isCloudinaryUrl\n};\nvar CLOUDINARY_LOADER_REGEX = /https?\\:\\/\\/[^\\/]+\\.cloudinary\\.com\\/.+/;\nfunction isCloudinaryUrl(url) {\n  return CLOUDINARY_LOADER_REGEX.test(url);\n}\nvar provideCloudinaryLoader = createImageLoader(createCloudinaryUrl, ngDevMode ? [\"https://res.cloudinary.com/mysite\", \"https://mysite.cloudinary.com\", \"https://subdomain.mysite.com\"] : void 0);\nfunction createCloudinaryUrl(path, config2) {\n  const quality = config2.isPlaceholder ? \"q_auto:low\" : \"q_auto\";\n  let params = `f_auto,${quality}`;\n  if (config2.width) {\n    params += `,w_${config2.width}`;\n  }\n  if (config2.loaderParams?.[\"rounded\"]) {\n    params += `,r_max`;\n  }\n  return `${path}/image/upload/${params}/${config2.src}`;\n}\nvar imageKitLoaderInfo = {\n  name: \"ImageKit\",\n  testUrl: isImageKitUrl\n};\nvar IMAGE_KIT_LOADER_REGEX = /https?\\:\\/\\/[^\\/]+\\.imagekit\\.io\\/.+/;\nfunction isImageKitUrl(url) {\n  return IMAGE_KIT_LOADER_REGEX.test(url);\n}\nvar provideImageKitLoader = createImageLoader(createImagekitUrl, ngDevMode ? [\"https://ik.imagekit.io/mysite\", \"https://subdomain.mysite.com\"] : void 0);\nfunction createImagekitUrl(path, config2) {\n  const {\n    src,\n    width\n  } = config2;\n  const params = [];\n  if (width) {\n    params.push(`w-${width}`);\n  }\n  if (config2.isPlaceholder) {\n    params.push(`q-${PLACEHOLDER_QUALITY}`);\n  }\n  const urlSegments = params.length ? [path, `tr:${params.join(\",\")}`, src] : [path, src];\n  const url = new URL(urlSegments.join(\"/\"));\n  return url.href;\n}\nvar imgixLoaderInfo = {\n  name: \"Imgix\",\n  testUrl: isImgixUrl\n};\nvar IMGIX_LOADER_REGEX = /https?\\:\\/\\/[^\\/]+\\.imgix\\.net\\/.+/;\nfunction isImgixUrl(url) {\n  return IMGIX_LOADER_REGEX.test(url);\n}\nvar provideImgixLoader = createImageLoader(createImgixUrl, ngDevMode ? [\"https://somepath.imgix.net/\"] : void 0);\nfunction createImgixUrl(path, config2) {\n  const url = new URL(`${path}/${config2.src}`);\n  url.searchParams.set(\"auto\", \"format\");\n  if (config2.width) {\n    url.searchParams.set(\"w\", config2.width.toString());\n  }\n  if (config2.isPlaceholder) {\n    url.searchParams.set(\"q\", PLACEHOLDER_QUALITY);\n  }\n  return url.href;\n}\nvar netlifyLoaderInfo = {\n  name: \"Netlify\",\n  testUrl: isNetlifyUrl\n};\nvar NETLIFY_LOADER_REGEX = /https?\\:\\/\\/[^\\/]+\\.netlify\\.app\\/.+/;\nfunction isNetlifyUrl(url) {\n  return NETLIFY_LOADER_REGEX.test(url);\n}\nfunction imgDirectiveDetails(ngSrc, includeNgSrc = true) {\n  const ngSrcInfo = includeNgSrc ? `(activated on an <img> element with the \\`ngSrc=\"${ngSrc}\"\\`) ` : \"\";\n  return `The NgOptimizedImage directive ${ngSrcInfo}has detected that`;\n}\nfunction assertDevMode(checkName) {\n  if (!ngDevMode) {\n    throw new RuntimeError(2958, `Unexpected invocation of the ${checkName} in the prod mode. Please make sure that the prod mode is enabled for production builds.`);\n  }\n}\nvar LCPImageObserver = class _LCPImageObserver {\n  // Map of full image URLs -> original `ngSrc` values.\n  images = /* @__PURE__ */ new Map();\n  window = null;\n  observer = null;\n  constructor() {\n    const isBrowser = isPlatformBrowser(inject(PLATFORM_ID));\n    assertDevMode(\"LCP checker\");\n    const win = inject(DOCUMENT2).defaultView;\n    if (isBrowser && typeof PerformanceObserver !== \"undefined\") {\n      this.window = win;\n      this.observer = this.initPerformanceObserver();\n    }\n  }\n  /**\n   * Inits PerformanceObserver and subscribes to LCP events.\n   * Based on https://web.dev/lcp/#measure-lcp-in-javascript\n   */\n  initPerformanceObserver() {\n    const observer = new PerformanceObserver((entryList) => {\n      const entries = entryList.getEntries();\n      if (entries.length === 0) return;\n      const lcpElement = entries[entries.length - 1];\n      const imgSrc = lcpElement.element?.src ?? \"\";\n      if (imgSrc.startsWith(\"data:\") || imgSrc.startsWith(\"blob:\")) return;\n      const img = this.images.get(imgSrc);\n      if (!img) return;\n      if (!img.priority && !img.alreadyWarnedPriority) {\n        img.alreadyWarnedPriority = true;\n        logMissingPriorityError(imgSrc);\n      }\n      if (img.modified && !img.alreadyWarnedModified) {\n        img.alreadyWarnedModified = true;\n        logModifiedWarning(imgSrc);\n      }\n    });\n    observer.observe({\n      type: \"largest-contentful-paint\",\n      buffered: true\n    });\n    return observer;\n  }\n  registerImage(rewrittenSrc, originalNgSrc, isPriority) {\n    if (!this.observer) return;\n    const newObservedImageState = {\n      priority: isPriority,\n      modified: false,\n      alreadyWarnedModified: false,\n      alreadyWarnedPriority: false\n    };\n    this.images.set(getUrl(rewrittenSrc, this.window).href, newObservedImageState);\n  }\n  unregisterImage(rewrittenSrc) {\n    if (!this.observer) return;\n    this.images.delete(getUrl(rewrittenSrc, this.window).href);\n  }\n  updateImage(originalSrc, newSrc) {\n    if (!this.observer) return;\n    const originalUrl = getUrl(originalSrc, this.window).href;\n    const img = this.images.get(originalUrl);\n    if (img) {\n      img.modified = true;\n      this.images.set(getUrl(newSrc, this.window).href, img);\n      this.images.delete(originalUrl);\n    }\n  }\n  ngOnDestroy() {\n    if (!this.observer) return;\n    this.observer.disconnect();\n    this.images.clear();\n  }\n  static \\u0275fac = function LCPImageObserver_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _LCPImageObserver)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _LCPImageObserver,\n    factory: _LCPImageObserver.\\u0275fac,\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(LCPImageObserver, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], () => [], null);\n})();\nfunction logMissingPriorityError(ngSrc) {\n  const directiveDetails = imgDirectiveDetails(ngSrc);\n  console.error(formatRuntimeError(2955, `${directiveDetails} this image is the Largest Contentful Paint (LCP) element but was not marked \"priority\". This image should be marked \"priority\" in order to prioritize its loading. To fix this, add the \"priority\" attribute.`));\n}\nfunction logModifiedWarning(ngSrc) {\n  const directiveDetails = imgDirectiveDetails(ngSrc);\n  console.warn(formatRuntimeError(2964, `${directiveDetails} this image is the Largest Contentful Paint (LCP) element and has had its \"ngSrc\" attribute modified. This can cause slower loading performance. It is recommended not to modify the \"ngSrc\" property on any image which could be the LCP element.`));\n}\nvar INTERNAL_PRECONNECT_CHECK_BLOCKLIST = /* @__PURE__ */ new Set([\"localhost\", \"127.0.0.1\", \"0.0.0.0\"]);\nvar PRECONNECT_CHECK_BLOCKLIST = new InjectionToken(ngDevMode ? \"PRECONNECT_CHECK_BLOCKLIST\" : \"\");\nvar PreconnectLinkChecker = class _PreconnectLinkChecker {\n  document = inject(DOCUMENT2);\n  /**\n   * Set of <link rel=\"preconnect\"> tags found on this page.\n   * The `null` value indicates that there was no DOM query operation performed.\n   */\n  preconnectLinks = null;\n  /*\n   * Keep track of all already seen origin URLs to avoid repeating the same check.\n   */\n  alreadySeen = /* @__PURE__ */ new Set();\n  window = this.document.defaultView;\n  blocklist = new Set(INTERNAL_PRECONNECT_CHECK_BLOCKLIST);\n  constructor() {\n    assertDevMode(\"preconnect link checker\");\n    const blocklist = inject(PRECONNECT_CHECK_BLOCKLIST, {\n      optional: true\n    });\n    if (blocklist) {\n      this.populateBlocklist(blocklist);\n    }\n  }\n  populateBlocklist(origins) {\n    if (Array.isArray(origins)) {\n      deepForEach2(origins, (origin) => {\n        this.blocklist.add(extractHostname(origin));\n      });\n    } else {\n      this.blocklist.add(extractHostname(origins));\n    }\n  }\n  /**\n   * Checks that a preconnect resource hint exists in the head for the\n   * given src.\n   *\n   * @param rewrittenSrc src formatted with loader\n   * @param originalNgSrc ngSrc value\n   */\n  assertPreconnect(rewrittenSrc, originalNgSrc) {\n    if (false) return;\n    const imgUrl = getUrl(rewrittenSrc, this.window);\n    if (this.blocklist.has(imgUrl.hostname) || this.alreadySeen.has(imgUrl.origin)) return;\n    this.alreadySeen.add(imgUrl.origin);\n    this.preconnectLinks ??= this.queryPreconnectLinks();\n    if (!this.preconnectLinks.has(imgUrl.origin)) {\n      console.warn(formatRuntimeError(2956, `${imgDirectiveDetails(originalNgSrc)} there is no preconnect tag present for this image. Preconnecting to the origin(s) that serve priority images ensures that these images are delivered as soon as possible. To fix this, please add the following element into the <head> of the document:\n  <link rel=\"preconnect\" href=\"${imgUrl.origin}\">`));\n    }\n  }\n  queryPreconnectLinks() {\n    const preconnectUrls = /* @__PURE__ */ new Set();\n    const selector = \"link[rel=preconnect]\";\n    const links = Array.from(this.document.querySelectorAll(selector));\n    for (let link of links) {\n      const url = getUrl(link.href, this.window);\n      preconnectUrls.add(url.origin);\n    }\n    return preconnectUrls;\n  }\n  ngOnDestroy() {\n    this.preconnectLinks?.clear();\n    this.alreadySeen.clear();\n  }\n  static \\u0275fac = function PreconnectLinkChecker_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _PreconnectLinkChecker)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _PreconnectLinkChecker,\n    factory: _PreconnectLinkChecker.\\u0275fac,\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(PreconnectLinkChecker, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], () => [], null);\n})();\nfunction deepForEach2(input2, fn) {\n  for (let value of input2) {\n    Array.isArray(value) ? deepForEach2(value, fn) : fn(value);\n  }\n}\nvar DEFAULT_PRELOADED_IMAGES_LIMIT = 5;\nvar PRELOADED_IMAGES = new InjectionToken(typeof ngDevMode === \"undefined\" || ngDevMode ? \"NG_OPTIMIZED_PRELOADED_IMAGES\" : \"\", {\n  providedIn: \"root\",\n  factory: () => /* @__PURE__ */ new Set()\n});\nvar PreloadLinkCreator = class _PreloadLinkCreator {\n  preloadedImages = inject(PRELOADED_IMAGES);\n  document = inject(DOCUMENT2);\n  /**\n   * @description Add a preload `<link>` to the `<head>` of the `index.html` that is served from the\n   * server while using Angular Universal and SSR to kick off image loads for high priority images.\n   *\n   * The `sizes` (passed in from the user) and `srcset` (parsed and formatted from `ngSrcset`)\n   * properties used to set the corresponding attributes, `imagesizes` and `imagesrcset`\n   * respectively, on the preload `<link>` tag so that the correctly sized image is preloaded from\n   * the CDN.\n   *\n   * {@link https://web.dev/preload-responsive-images/#imagesrcset-and-imagesizes}\n   *\n   * @param renderer The `Renderer2` passed in from the directive\n   * @param src The original src of the image that is set on the `ngSrc` input.\n   * @param srcset The parsed and formatted srcset created from the `ngSrcset` input\n   * @param sizes The value of the `sizes` attribute passed in to the `<img>` tag\n   */\n  createPreloadLinkTag(renderer, src, srcset, sizes) {\n    if (ngDevMode) {\n      if (this.preloadedImages.size >= DEFAULT_PRELOADED_IMAGES_LIMIT) {\n        throw new RuntimeError(2961, ngDevMode && `The \\`NgOptimizedImage\\` directive has detected that more than ${DEFAULT_PRELOADED_IMAGES_LIMIT} images were marked as priority. This might negatively affect an overall performance of the page. To fix this, remove the \"priority\" attribute from images with less priority.`);\n      }\n    }\n    if (this.preloadedImages.has(src)) {\n      return;\n    }\n    this.preloadedImages.add(src);\n    const preload = renderer.createElement(\"link\");\n    renderer.setAttribute(preload, \"as\", \"image\");\n    renderer.setAttribute(preload, \"href\", src);\n    renderer.setAttribute(preload, \"rel\", \"preload\");\n    renderer.setAttribute(preload, \"fetchpriority\", \"high\");\n    if (sizes) {\n      renderer.setAttribute(preload, \"imageSizes\", sizes);\n    }\n    if (srcset) {\n      renderer.setAttribute(preload, \"imageSrcset\", srcset);\n    }\n    renderer.appendChild(this.document.head, preload);\n  }\n  static \\u0275fac = function PreloadLinkCreator_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _PreloadLinkCreator)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _PreloadLinkCreator,\n    factory: _PreloadLinkCreator.\\u0275fac,\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(PreloadLinkCreator, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], null, null);\n})();\nvar BASE64_IMG_MAX_LENGTH_IN_ERROR = 50;\nvar VALID_WIDTH_DESCRIPTOR_SRCSET = /^((\\s*\\d+w\\s*(,|$)){1,})$/;\nvar VALID_DENSITY_DESCRIPTOR_SRCSET = /^((\\s*\\d+(\\.\\d+)?x\\s*(,|$)){1,})$/;\nvar ABSOLUTE_SRCSET_DENSITY_CAP = 3;\nvar RECOMMENDED_SRCSET_DENSITY_CAP = 2;\nvar DENSITY_SRCSET_MULTIPLIERS = [1, 2];\nvar VIEWPORT_BREAKPOINT_CUTOFF = 640;\nvar ASPECT_RATIO_TOLERANCE = 0.1;\nvar OVERSIZED_IMAGE_TOLERANCE2 = 1e3;\nvar FIXED_SRCSET_WIDTH_LIMIT = 1920;\nvar FIXED_SRCSET_HEIGHT_LIMIT = 1080;\nvar PLACEHOLDER_BLUR_AMOUNT = 15;\nvar PLACEHOLDER_DIMENSION_LIMIT = 1e3;\nvar DATA_URL_WARN_LIMIT = 4e3;\nvar DATA_URL_ERROR_LIMIT = 1e4;\nvar BUILT_IN_LOADERS = [imgixLoaderInfo, imageKitLoaderInfo, cloudinaryLoaderInfo, netlifyLoaderInfo];\nvar PRIORITY_COUNT_THRESHOLD = 10;\nvar IMGS_WITH_PRIORITY_ATTR_COUNT = 0;\nvar NgOptimizedImage = class _NgOptimizedImage {\n  imageLoader = inject(IMAGE_LOADER);\n  config = processConfig(inject(IMAGE_CONFIG));\n  renderer = inject(Renderer2);\n  imgElement = inject(ElementRef).nativeElement;\n  injector = inject(Injector);\n  // An LCP image observer should be injected only in development mode.\n  // Do not assign it to `null` to avoid having a redundant property in the production bundle.\n  lcpObserver;\n  /**\n   * Calculate the rewritten `src` once and store it.\n   * This is needed to avoid repetitive calculations and make sure the directive cleanup in the\n   * `ngOnDestroy` does not rely on the `IMAGE_LOADER` logic (which in turn can rely on some other\n   * instance that might be already destroyed).\n   */\n  _renderedSrc = null;\n  /**\n   * Name of the source image.\n   * Image name will be processed by the image loader and the final URL will be applied as the `src`\n   * property of the image.\n   */\n  ngSrc;\n  /**\n   * A comma separated list of width or density descriptors.\n   * The image name will be taken from `ngSrc` and combined with the list of width or density\n   * descriptors to generate the final `srcset` property of the image.\n   *\n   * Example:\n   * ```html\n   * <img ngSrc=\"hello.jpg\" ngSrcset=\"100w, 200w\" />  =>\n   * <img src=\"path/hello.jpg\" srcset=\"path/hello.jpg?w=100 100w, path/hello.jpg?w=200 200w\" />\n   * ```\n   */\n  ngSrcset;\n  /**\n   * The base `sizes` attribute passed through to the `<img>` element.\n   * Providing sizes causes the image to create an automatic responsive srcset.\n   */\n  sizes;\n  /**\n   * For responsive images: the intrinsic width of the image in pixels.\n   * For fixed size images: the desired rendered width of the image in pixels.\n   */\n  width;\n  /**\n   * For responsive images: the intrinsic height of the image in pixels.\n   * For fixed size images: the desired rendered height of the image in pixels.\n   */\n  height;\n  /**\n   * The desired loading behavior (lazy, eager, or auto). Defaults to `lazy`,\n   * which is recommended for most images.\n   *\n   * Warning: Setting images as loading=\"eager\" or loading=\"auto\" marks them\n   * as non-priority images and can hurt loading performance. For images which\n   * may be the LCP element, use the `priority` attribute instead of `loading`.\n   */\n  loading;\n  /**\n   * Indicates whether this image should have a high priority.\n   */\n  priority = false;\n  /**\n   * Data to pass through to custom loaders.\n   */\n  loaderParams;\n  /**\n   * Disables automatic srcset generation for this image.\n   */\n  disableOptimizedSrcset = false;\n  /**\n   * Sets the image to \"fill mode\", which eliminates the height/width requirement and adds\n   * styles such that the image fills its containing element.\n   */\n  fill = false;\n  /**\n   * A URL or data URL for an image to be used as a placeholder while this image loads.\n   */\n  placeholder;\n  /**\n   * Configuration object for placeholder settings. Options:\n   *   * blur: Setting this to false disables the automatic CSS blur.\n   */\n  placeholderConfig;\n  /**\n   * Value of the `src` attribute if set on the host `<img>` element.\n   * This input is exclusively read to assert that `src` is not set in conflict\n   * with `ngSrc` and that images don't start to load until a lazy loading strategy is set.\n   * @internal\n   */\n  src;\n  /**\n   * Value of the `srcset` attribute if set on the host `<img>` element.\n   * This input is exclusively read to assert that `srcset` is not set in conflict\n   * with `ngSrcset` and that images don't start to load until a lazy loading strategy is set.\n   * @internal\n   */\n  srcset;\n  constructor() {\n    if (ngDevMode) {\n      this.lcpObserver = this.injector.get(LCPImageObserver);\n      const destroyRef = inject(DestroyRef);\n      destroyRef.onDestroy(() => {\n        if (!this.priority && this._renderedSrc !== null) {\n          this.lcpObserver.unregisterImage(this._renderedSrc);\n        }\n      });\n    }\n  }\n  /** @nodoc */\n  ngOnInit() {\n    performanceMarkFeature(\"NgOptimizedImage\");\n    if (ngDevMode) {\n      const ngZone = this.injector.get(NgZone);\n      assertNonEmptyInput(this, \"ngSrc\", this.ngSrc);\n      assertValidNgSrcset(this, this.ngSrcset);\n      assertNoConflictingSrc(this);\n      if (this.ngSrcset) {\n        assertNoConflictingSrcset(this);\n      }\n      assertNotBase64Image(this);\n      assertNotBlobUrl(this);\n      if (this.fill) {\n        assertEmptyWidthAndHeight(this);\n        ngZone.runOutsideAngular(() => assertNonZeroRenderedHeight(this, this.imgElement, this.renderer));\n      } else {\n        assertNonEmptyWidthAndHeight(this);\n        if (this.height !== void 0) {\n          assertGreaterThanZero(this, this.height, \"height\");\n        }\n        if (this.width !== void 0) {\n          assertGreaterThanZero(this, this.width, \"width\");\n        }\n        ngZone.runOutsideAngular(() => assertNoImageDistortion(this, this.imgElement, this.renderer));\n      }\n      assertValidLoadingInput(this);\n      if (!this.ngSrcset) {\n        assertNoComplexSizes(this);\n      }\n      assertValidPlaceholder(this, this.imageLoader);\n      assertNotMissingBuiltInLoader(this.ngSrc, this.imageLoader);\n      assertNoNgSrcsetWithoutLoader(this, this.imageLoader);\n      assertNoLoaderParamsWithoutLoader(this, this.imageLoader);\n      ngZone.runOutsideAngular(() => {\n        this.lcpObserver.registerImage(this.getRewrittenSrc(), this.ngSrc, this.priority);\n      });\n      if (this.priority) {\n        const checker = this.injector.get(PreconnectLinkChecker);\n        checker.assertPreconnect(this.getRewrittenSrc(), this.ngSrc);\n        if (true) {\n          const applicationRef = this.injector.get(ApplicationRef);\n          assetPriorityCountBelowThreshold(applicationRef);\n        }\n      }\n    }\n    if (this.placeholder) {\n      this.removePlaceholderOnLoad(this.imgElement);\n    }\n    this.setHostAttributes();\n  }\n  setHostAttributes() {\n    if (this.fill) {\n      this.sizes ||= \"100vw\";\n    } else {\n      this.setHostAttribute(\"width\", this.width.toString());\n      this.setHostAttribute(\"height\", this.height.toString());\n    }\n    this.setHostAttribute(\"loading\", this.getLoadingBehavior());\n    this.setHostAttribute(\"fetchpriority\", this.getFetchPriority());\n    this.setHostAttribute(\"ng-img\", \"true\");\n    const rewrittenSrcset = this.updateSrcAndSrcset();\n    if (this.sizes) {\n      if (this.getLoadingBehavior() === \"lazy\") {\n        this.setHostAttribute(\"sizes\", \"auto, \" + this.sizes);\n      } else {\n        this.setHostAttribute(\"sizes\", this.sizes);\n      }\n    } else {\n      if (this.ngSrcset && VALID_WIDTH_DESCRIPTOR_SRCSET.test(this.ngSrcset) && this.getLoadingBehavior() === \"lazy\") {\n        this.setHostAttribute(\"sizes\", \"auto, 100vw\");\n      }\n    }\n    if (false) {\n      const preloadLinkCreator = this.injector.get(PreloadLinkCreator);\n      preloadLinkCreator.createPreloadLinkTag(this.renderer, this.getRewrittenSrc(), rewrittenSrcset, this.sizes);\n    }\n  }\n  /** @nodoc */\n  ngOnChanges(changes) {\n    if (ngDevMode) {\n      assertNoPostInitInputChange(this, changes, [\"ngSrcset\", \"width\", \"height\", \"priority\", \"fill\", \"loading\", \"sizes\", \"loaderParams\", \"disableOptimizedSrcset\"]);\n    }\n    if (changes[\"ngSrc\"] && !changes[\"ngSrc\"].isFirstChange()) {\n      const oldSrc = this._renderedSrc;\n      this.updateSrcAndSrcset(true);\n      if (ngDevMode) {\n        const newSrc = this._renderedSrc;\n        if (oldSrc && newSrc && oldSrc !== newSrc) {\n          const ngZone = this.injector.get(NgZone);\n          ngZone.runOutsideAngular(() => {\n            this.lcpObserver.updateImage(oldSrc, newSrc);\n          });\n        }\n      }\n    }\n    if (ngDevMode && changes[\"placeholder\"]?.currentValue && true && true) {\n      assertPlaceholderDimensions(this, this.imgElement);\n    }\n  }\n  callImageLoader(configWithoutCustomParams) {\n    let augmentedConfig = configWithoutCustomParams;\n    if (this.loaderParams) {\n      augmentedConfig.loaderParams = this.loaderParams;\n    }\n    return this.imageLoader(augmentedConfig);\n  }\n  getLoadingBehavior() {\n    if (!this.priority && this.loading !== void 0) {\n      return this.loading;\n    }\n    return this.priority ? \"eager\" : \"lazy\";\n  }\n  getFetchPriority() {\n    return this.priority ? \"high\" : \"auto\";\n  }\n  getRewrittenSrc() {\n    if (!this._renderedSrc) {\n      const imgConfig = {\n        src: this.ngSrc\n      };\n      this._renderedSrc = this.callImageLoader(imgConfig);\n    }\n    return this._renderedSrc;\n  }\n  getRewrittenSrcset() {\n    const widthSrcSet = VALID_WIDTH_DESCRIPTOR_SRCSET.test(this.ngSrcset);\n    const finalSrcs = this.ngSrcset.split(\",\").filter((src) => src !== \"\").map((srcStr) => {\n      srcStr = srcStr.trim();\n      const width = widthSrcSet ? parseFloat(srcStr) : parseFloat(srcStr) * this.width;\n      return `${this.callImageLoader({\n        src: this.ngSrc,\n        width\n      })} ${srcStr}`;\n    });\n    return finalSrcs.join(\", \");\n  }\n  getAutomaticSrcset() {\n    if (this.sizes) {\n      return this.getResponsiveSrcset();\n    } else {\n      return this.getFixedSrcset();\n    }\n  }\n  getResponsiveSrcset() {\n    const {\n      breakpoints\n    } = this.config;\n    let filteredBreakpoints = breakpoints;\n    if (this.sizes?.trim() === \"100vw\") {\n      filteredBreakpoints = breakpoints.filter((bp) => bp >= VIEWPORT_BREAKPOINT_CUTOFF);\n    }\n    const finalSrcs = filteredBreakpoints.map((bp) => `${this.callImageLoader({\n      src: this.ngSrc,\n      width: bp\n    })} ${bp}w`);\n    return finalSrcs.join(\", \");\n  }\n  updateSrcAndSrcset(forceSrcRecalc = false) {\n    if (forceSrcRecalc) {\n      this._renderedSrc = null;\n    }\n    const rewrittenSrc = this.getRewrittenSrc();\n    this.setHostAttribute(\"src\", rewrittenSrc);\n    let rewrittenSrcset = void 0;\n    if (this.ngSrcset) {\n      rewrittenSrcset = this.getRewrittenSrcset();\n    } else if (this.shouldGenerateAutomaticSrcset()) {\n      rewrittenSrcset = this.getAutomaticSrcset();\n    }\n    if (rewrittenSrcset) {\n      this.setHostAttribute(\"srcset\", rewrittenSrcset);\n    }\n    return rewrittenSrcset;\n  }\n  getFixedSrcset() {\n    const finalSrcs = DENSITY_SRCSET_MULTIPLIERS.map((multiplier) => `${this.callImageLoader({\n      src: this.ngSrc,\n      width: this.width * multiplier\n    })} ${multiplier}x`);\n    return finalSrcs.join(\", \");\n  }\n  shouldGenerateAutomaticSrcset() {\n    let oversizedImage = false;\n    if (!this.sizes) {\n      oversizedImage = this.width > FIXED_SRCSET_WIDTH_LIMIT || this.height > FIXED_SRCSET_HEIGHT_LIMIT;\n    }\n    return !this.disableOptimizedSrcset && !this.srcset && this.imageLoader !== noopImageLoader && !oversizedImage;\n  }\n  /**\n   * Returns an image url formatted for use with the CSS background-image property. Expects one of:\n   * * A base64 encoded image, which is wrapped and passed through.\n   * * A boolean. If true, calls the image loader to generate a small placeholder url.\n   */\n  generatePlaceholder(placeholderInput) {\n    const {\n      placeholderResolution\n    } = this.config;\n    if (placeholderInput === true) {\n      return `url(${this.callImageLoader({\n        src: this.ngSrc,\n        width: placeholderResolution,\n        isPlaceholder: true\n      })})`;\n    } else if (typeof placeholderInput === \"string\") {\n      return `url(${placeholderInput})`;\n    }\n    return null;\n  }\n  /**\n   * Determines if blur should be applied, based on an optional boolean\n   * property `blur` within the optional configuration object `placeholderConfig`.\n   */\n  shouldBlurPlaceholder(placeholderConfig) {\n    if (!placeholderConfig || !placeholderConfig.hasOwnProperty(\"blur\")) {\n      return true;\n    }\n    return Boolean(placeholderConfig.blur);\n  }\n  removePlaceholderOnLoad(img) {\n    const callback = () => {\n      const changeDetectorRef = this.injector.get(ChangeDetectorRef);\n      removeLoadListenerFn();\n      removeErrorListenerFn();\n      this.placeholder = false;\n      changeDetectorRef.markForCheck();\n    };\n    const removeLoadListenerFn = this.renderer.listen(img, \"load\", callback);\n    const removeErrorListenerFn = this.renderer.listen(img, \"error\", callback);\n    callOnLoadIfImageIsLoaded(img, callback);\n  }\n  setHostAttribute(name, value) {\n    this.renderer.setAttribute(this.imgElement, name, value);\n  }\n  static \\u0275fac = function NgOptimizedImage_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _NgOptimizedImage)();\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _NgOptimizedImage,\n    selectors: [[\"img\", \"ngSrc\", \"\"]],\n    hostVars: 18,\n    hostBindings: function NgOptimizedImage_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        \\u0275\\u0275styleProp(\"position\", ctx.fill ? \"absolute\" : null)(\"width\", ctx.fill ? \"100%\" : null)(\"height\", ctx.fill ? \"100%\" : null)(\"inset\", ctx.fill ? \"0\" : null)(\"background-size\", ctx.placeholder ? \"cover\" : null)(\"background-position\", ctx.placeholder ? \"50% 50%\" : null)(\"background-repeat\", ctx.placeholder ? \"no-repeat\" : null)(\"background-image\", ctx.placeholder ? ctx.generatePlaceholder(ctx.placeholder) : null)(\"filter\", ctx.placeholder && ctx.shouldBlurPlaceholder(ctx.placeholderConfig) ? \"blur(15px)\" : null);\n      }\n    },\n    inputs: {\n      ngSrc: [2, \"ngSrc\", \"ngSrc\", unwrapSafeUrl],\n      ngSrcset: \"ngSrcset\",\n      sizes: \"sizes\",\n      width: [2, \"width\", \"width\", numberAttribute],\n      height: [2, \"height\", \"height\", numberAttribute],\n      loading: \"loading\",\n      priority: [2, \"priority\", \"priority\", booleanAttribute],\n      loaderParams: \"loaderParams\",\n      disableOptimizedSrcset: [2, \"disableOptimizedSrcset\", \"disableOptimizedSrcset\", booleanAttribute],\n      fill: [2, \"fill\", \"fill\", booleanAttribute],\n      placeholder: [2, \"placeholder\", \"placeholder\", booleanOrUrlAttribute],\n      placeholderConfig: \"placeholderConfig\",\n      src: \"src\",\n      srcset: \"srcset\"\n    },\n    features: [\\u0275\\u0275NgOnChangesFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(NgOptimizedImage, [{\n    type: Directive,\n    args: [{\n      selector: \"img[ngSrc]\",\n      host: {\n        \"[style.position]\": 'fill ? \"absolute\" : null',\n        \"[style.width]\": 'fill ? \"100%\" : null',\n        \"[style.height]\": 'fill ? \"100%\" : null',\n        \"[style.inset]\": 'fill ? \"0\" : null',\n        \"[style.background-size]\": 'placeholder ? \"cover\" : null',\n        \"[style.background-position]\": 'placeholder ? \"50% 50%\" : null',\n        \"[style.background-repeat]\": 'placeholder ? \"no-repeat\" : null',\n        \"[style.background-image]\": \"placeholder ? generatePlaceholder(placeholder) : null\",\n        \"[style.filter]\": `placeholder && shouldBlurPlaceholder(placeholderConfig) ? \"blur(${PLACEHOLDER_BLUR_AMOUNT}px)\" : null`\n      }\n    }]\n  }], () => [], {\n    ngSrc: [{\n      type: Input,\n      args: [{\n        required: true,\n        transform: unwrapSafeUrl\n      }]\n    }],\n    ngSrcset: [{\n      type: Input\n    }],\n    sizes: [{\n      type: Input\n    }],\n    width: [{\n      type: Input,\n      args: [{\n        transform: numberAttribute\n      }]\n    }],\n    height: [{\n      type: Input,\n      args: [{\n        transform: numberAttribute\n      }]\n    }],\n    loading: [{\n      type: Input\n    }],\n    priority: [{\n      type: Input,\n      args: [{\n        transform: booleanAttribute\n      }]\n    }],\n    loaderParams: [{\n      type: Input\n    }],\n    disableOptimizedSrcset: [{\n      type: Input,\n      args: [{\n        transform: booleanAttribute\n      }]\n    }],\n    fill: [{\n      type: Input,\n      args: [{\n        transform: booleanAttribute\n      }]\n    }],\n    placeholder: [{\n      type: Input,\n      args: [{\n        transform: booleanOrUrlAttribute\n      }]\n    }],\n    placeholderConfig: [{\n      type: Input\n    }],\n    src: [{\n      type: Input\n    }],\n    srcset: [{\n      type: Input\n    }]\n  });\n})();\nfunction processConfig(config2) {\n  let sortedBreakpoints = {};\n  if (config2.breakpoints) {\n    sortedBreakpoints.breakpoints = config2.breakpoints.sort((a, b) => a - b);\n  }\n  return Object.assign({}, IMAGE_CONFIG_DEFAULTS, config2, sortedBreakpoints);\n}\nfunction assertNoConflictingSrc(dir) {\n  if (dir.src) {\n    throw new RuntimeError(2950, `${imgDirectiveDetails(dir.ngSrc)} both \\`src\\` and \\`ngSrc\\` have been set. Supplying both of these attributes breaks lazy loading. The NgOptimizedImage directive sets \\`src\\` itself based on the value of \\`ngSrc\\`. To fix this, please remove the \\`src\\` attribute.`);\n  }\n}\nfunction assertNoConflictingSrcset(dir) {\n  if (dir.srcset) {\n    throw new RuntimeError(2951, `${imgDirectiveDetails(dir.ngSrc)} both \\`srcset\\` and \\`ngSrcset\\` have been set. Supplying both of these attributes breaks lazy loading. The NgOptimizedImage directive sets \\`srcset\\` itself based on the value of \\`ngSrcset\\`. To fix this, please remove the \\`srcset\\` attribute.`);\n  }\n}\nfunction assertNotBase64Image(dir) {\n  let ngSrc = dir.ngSrc.trim();\n  if (ngSrc.startsWith(\"data:\")) {\n    if (ngSrc.length > BASE64_IMG_MAX_LENGTH_IN_ERROR) {\n      ngSrc = ngSrc.substring(0, BASE64_IMG_MAX_LENGTH_IN_ERROR) + \"...\";\n    }\n    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \\`ngSrc\\` is a Base64-encoded string (${ngSrc}). NgOptimizedImage does not support Base64-encoded strings. To fix this, disable the NgOptimizedImage directive for this element by removing \\`ngSrc\\` and using a standard \\`src\\` attribute instead.`);\n  }\n}\nfunction assertNoComplexSizes(dir) {\n  let sizes = dir.sizes;\n  if (sizes?.match(/((\\)|,)\\s|^)\\d+px/)) {\n    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \\`sizes\\` was set to a string including pixel values. For automatic \\`srcset\\` generation, \\`sizes\\` must only include responsive values, such as \\`sizes=\"50vw\"\\` or \\`sizes=\"(min-width: 768px) 50vw, 100vw\"\\`. To fix this, modify the \\`sizes\\` attribute, or provide your own \\`ngSrcset\\` value directly.`);\n  }\n}\nfunction assertValidPlaceholder(dir, imageLoader) {\n  assertNoPlaceholderConfigWithoutPlaceholder(dir);\n  assertNoRelativePlaceholderWithoutLoader(dir, imageLoader);\n  assertNoOversizedDataUrl(dir);\n}\nfunction assertNoPlaceholderConfigWithoutPlaceholder(dir) {\n  if (dir.placeholderConfig && !dir.placeholder) {\n    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc, false)} \\`placeholderConfig\\` options were provided for an image that does not use the \\`placeholder\\` attribute, and will have no effect.`);\n  }\n}\nfunction assertNoRelativePlaceholderWithoutLoader(dir, imageLoader) {\n  if (dir.placeholder === true && imageLoader === noopImageLoader) {\n    throw new RuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \\`placeholder\\` attribute is set to true but no image loader is configured (i.e. the default one is being used), which would result in the same image being used for the primary image and its placeholder. To fix this, provide a loader or remove the \\`placeholder\\` attribute from the image.`);\n  }\n}\nfunction assertNoOversizedDataUrl(dir) {\n  if (dir.placeholder && typeof dir.placeholder === \"string\" && dir.placeholder.startsWith(\"data:\")) {\n    if (dir.placeholder.length > DATA_URL_ERROR_LIMIT) {\n      throw new RuntimeError(2965, `${imgDirectiveDetails(dir.ngSrc)} the \\`placeholder\\` attribute is set to a data URL which is longer than ${DATA_URL_ERROR_LIMIT} characters. This is strongly discouraged, as large inline placeholders directly increase the bundle size of Angular and hurt page load performance. To fix this, generate a smaller data URL placeholder.`);\n    }\n    if (dir.placeholder.length > DATA_URL_WARN_LIMIT) {\n      console.warn(formatRuntimeError(2965, `${imgDirectiveDetails(dir.ngSrc)} the \\`placeholder\\` attribute is set to a data URL which is longer than ${DATA_URL_WARN_LIMIT} characters. This is discouraged, as large inline placeholders directly increase the bundle size of Angular and hurt page load performance. For better loading performance, generate a smaller data URL placeholder.`));\n    }\n  }\n}\nfunction assertNotBlobUrl(dir) {\n  const ngSrc = dir.ngSrc.trim();\n  if (ngSrc.startsWith(\"blob:\")) {\n    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \\`ngSrc\\` was set to a blob URL (${ngSrc}). Blob URLs are not supported by the NgOptimizedImage directive. To fix this, disable the NgOptimizedImage directive for this element by removing \\`ngSrc\\` and using a regular \\`src\\` attribute instead.`);\n  }\n}\nfunction assertNonEmptyInput(dir, name, value) {\n  const isString2 = typeof value === \"string\";\n  const isEmptyString = isString2 && value.trim() === \"\";\n  if (!isString2 || isEmptyString) {\n    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \\`${name}\\` has an invalid value (\\`${value}\\`). To fix this, change the value to a non-empty string.`);\n  }\n}\nfunction assertValidNgSrcset(dir, value) {\n  if (value == null) return;\n  assertNonEmptyInput(dir, \"ngSrcset\", value);\n  const stringVal = value;\n  const isValidWidthDescriptor = VALID_WIDTH_DESCRIPTOR_SRCSET.test(stringVal);\n  const isValidDensityDescriptor = VALID_DENSITY_DESCRIPTOR_SRCSET.test(stringVal);\n  if (isValidDensityDescriptor) {\n    assertUnderDensityCap(dir, stringVal);\n  }\n  const isValidSrcset = isValidWidthDescriptor || isValidDensityDescriptor;\n  if (!isValidSrcset) {\n    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \\`ngSrcset\\` has an invalid value (\\`${value}\\`). To fix this, supply \\`ngSrcset\\` using a comma-separated list of one or more width descriptors (e.g. \"100w, 200w\") or density descriptors (e.g. \"1x, 2x\").`);\n  }\n}\nfunction assertUnderDensityCap(dir, value) {\n  const underDensityCap = value.split(\",\").every((num) => num === \"\" || parseFloat(num) <= ABSOLUTE_SRCSET_DENSITY_CAP);\n  if (!underDensityCap) {\n    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \\`ngSrcset\\` contains an unsupported image density:\\`${value}\\`. NgOptimizedImage generally recommends a max image density of ${RECOMMENDED_SRCSET_DENSITY_CAP}x but supports image densities up to ${ABSOLUTE_SRCSET_DENSITY_CAP}x. The human eye cannot distinguish between image densities greater than ${RECOMMENDED_SRCSET_DENSITY_CAP}x - which makes them unnecessary for most use cases. Images that will be pinch-zoomed are typically the primary use case for ${ABSOLUTE_SRCSET_DENSITY_CAP}x images. Please remove the high density descriptor and try again.`);\n  }\n}\nfunction postInitInputChangeError(dir, inputName) {\n  let reason;\n  if (inputName === \"width\" || inputName === \"height\") {\n    reason = `Changing \\`${inputName}\\` may result in different attribute value applied to the underlying image element and cause layout shifts on a page.`;\n  } else {\n    reason = `Changing the \\`${inputName}\\` would have no effect on the underlying image element, because the resource loading has already occurred.`;\n  }\n  return new RuntimeError(2953, `${imgDirectiveDetails(dir.ngSrc)} \\`${inputName}\\` was updated after initialization. The NgOptimizedImage directive will not react to this input change. ${reason} To fix this, either switch \\`${inputName}\\` to a static value or wrap the image element in an @if that is gated on the necessary value.`);\n}\nfunction assertNoPostInitInputChange(dir, changes, inputs) {\n  inputs.forEach((input2) => {\n    const isUpdated = changes.hasOwnProperty(input2);\n    if (isUpdated && !changes[input2].isFirstChange()) {\n      if (input2 === \"ngSrc\") {\n        dir = {\n          ngSrc: changes[input2].previousValue\n        };\n      }\n      throw postInitInputChangeError(dir, input2);\n    }\n  });\n}\nfunction assertGreaterThanZero(dir, inputValue, inputName) {\n  const validNumber = typeof inputValue === \"number\" && inputValue > 0;\n  const validString = typeof inputValue === \"string\" && /^\\d+$/.test(inputValue.trim()) && parseInt(inputValue) > 0;\n  if (!validNumber && !validString) {\n    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} \\`${inputName}\\` has an invalid value. To fix this, provide \\`${inputName}\\` as a number greater than 0.`);\n  }\n}\nfunction assertNoImageDistortion(dir, img, renderer) {\n  const callback = () => {\n    removeLoadListenerFn();\n    removeErrorListenerFn();\n    const computedStyle = window.getComputedStyle(img);\n    let renderedWidth = parseFloat(computedStyle.getPropertyValue(\"width\"));\n    let renderedHeight = parseFloat(computedStyle.getPropertyValue(\"height\"));\n    const boxSizing = computedStyle.getPropertyValue(\"box-sizing\");\n    if (boxSizing === \"border-box\") {\n      const paddingTop = computedStyle.getPropertyValue(\"padding-top\");\n      const paddingRight = computedStyle.getPropertyValue(\"padding-right\");\n      const paddingBottom = computedStyle.getPropertyValue(\"padding-bottom\");\n      const paddingLeft = computedStyle.getPropertyValue(\"padding-left\");\n      renderedWidth -= parseFloat(paddingRight) + parseFloat(paddingLeft);\n      renderedHeight -= parseFloat(paddingTop) + parseFloat(paddingBottom);\n    }\n    const renderedAspectRatio = renderedWidth / renderedHeight;\n    const nonZeroRenderedDimensions = renderedWidth !== 0 && renderedHeight !== 0;\n    const intrinsicWidth = img.naturalWidth;\n    const intrinsicHeight = img.naturalHeight;\n    const intrinsicAspectRatio = intrinsicWidth / intrinsicHeight;\n    const suppliedWidth = dir.width;\n    const suppliedHeight = dir.height;\n    const suppliedAspectRatio = suppliedWidth / suppliedHeight;\n    const inaccurateDimensions = Math.abs(suppliedAspectRatio - intrinsicAspectRatio) > ASPECT_RATIO_TOLERANCE;\n    const stylingDistortion = nonZeroRenderedDimensions && Math.abs(intrinsicAspectRatio - renderedAspectRatio) > ASPECT_RATIO_TOLERANCE;\n    if (inaccurateDimensions) {\n      console.warn(formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the aspect ratio of the image does not match the aspect ratio indicated by the width and height attributes. \nIntrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h (aspect-ratio: ${round(intrinsicAspectRatio)}). \nSupplied width and height attributes: ${suppliedWidth}w x ${suppliedHeight}h (aspect-ratio: ${round(suppliedAspectRatio)}). \nTo fix this, update the width and height attributes.`));\n    } else if (stylingDistortion) {\n      console.warn(formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the aspect ratio of the rendered image does not match the image's intrinsic aspect ratio. \nIntrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h (aspect-ratio: ${round(intrinsicAspectRatio)}). \nRendered image size: ${renderedWidth}w x ${renderedHeight}h (aspect-ratio: ${round(renderedAspectRatio)}). \nThis issue can occur if \"width\" and \"height\" attributes are added to an image without updating the corresponding image styling. To fix this, adjust image styling. In most cases, adding \"height: auto\" or \"width: auto\" to the image styling will fix this issue.`));\n    } else if (!dir.ngSrcset && nonZeroRenderedDimensions) {\n      const recommendedWidth = RECOMMENDED_SRCSET_DENSITY_CAP * renderedWidth;\n      const recommendedHeight = RECOMMENDED_SRCSET_DENSITY_CAP * renderedHeight;\n      const oversizedWidth = intrinsicWidth - recommendedWidth >= OVERSIZED_IMAGE_TOLERANCE2;\n      const oversizedHeight = intrinsicHeight - recommendedHeight >= OVERSIZED_IMAGE_TOLERANCE2;\n      if (oversizedWidth || oversizedHeight) {\n        console.warn(formatRuntimeError(2960, `${imgDirectiveDetails(dir.ngSrc)} the intrinsic image is significantly larger than necessary. \nRendered image size: ${renderedWidth}w x ${renderedHeight}h. \nIntrinsic image size: ${intrinsicWidth}w x ${intrinsicHeight}h. \nRecommended intrinsic image size: ${recommendedWidth}w x ${recommendedHeight}h. \nNote: Recommended intrinsic image size is calculated assuming a maximum DPR of ${RECOMMENDED_SRCSET_DENSITY_CAP}. To improve loading time, resize the image or consider using the \"ngSrcset\" and \"sizes\" attributes.`));\n      }\n    }\n  };\n  const removeLoadListenerFn = renderer.listen(img, \"load\", callback);\n  const removeErrorListenerFn = renderer.listen(img, \"error\", () => {\n    removeLoadListenerFn();\n    removeErrorListenerFn();\n  });\n  callOnLoadIfImageIsLoaded(img, callback);\n}\nfunction assertNonEmptyWidthAndHeight(dir) {\n  let missingAttributes = [];\n  if (dir.width === void 0) missingAttributes.push(\"width\");\n  if (dir.height === void 0) missingAttributes.push(\"height\");\n  if (missingAttributes.length > 0) {\n    throw new RuntimeError(2954, `${imgDirectiveDetails(dir.ngSrc)} these required attributes are missing: ${missingAttributes.map((attr) => `\"${attr}\"`).join(\", \")}. Including \"width\" and \"height\" attributes will prevent image-related layout shifts. To fix this, include \"width\" and \"height\" attributes on the image tag or turn on \"fill\" mode with the \\`fill\\` attribute.`);\n  }\n}\nfunction assertEmptyWidthAndHeight(dir) {\n  if (dir.width || dir.height) {\n    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the attributes \\`height\\` and/or \\`width\\` are present along with the \\`fill\\` attribute. Because \\`fill\\` mode causes an image to fill its containing element, the size attributes have no effect and should be removed.`);\n  }\n}\nfunction assertNonZeroRenderedHeight(dir, img, renderer) {\n  const callback = () => {\n    removeLoadListenerFn();\n    removeErrorListenerFn();\n    const renderedHeight = img.clientHeight;\n    if (dir.fill && renderedHeight === 0) {\n      console.warn(formatRuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the height of the fill-mode image is zero. This is likely because the containing element does not have the CSS 'position' property set to one of the following: \"relative\", \"fixed\", or \"absolute\". To fix this problem, make sure the container element has the CSS 'position' property defined and the height of the element is not zero.`));\n    }\n  };\n  const removeLoadListenerFn = renderer.listen(img, \"load\", callback);\n  const removeErrorListenerFn = renderer.listen(img, \"error\", () => {\n    removeLoadListenerFn();\n    removeErrorListenerFn();\n  });\n  callOnLoadIfImageIsLoaded(img, callback);\n}\nfunction assertValidLoadingInput(dir) {\n  if (dir.loading && dir.priority) {\n    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \\`loading\\` attribute was used on an image that was marked \"priority\". Setting \\`loading\\` on priority images is not allowed because these images will always be eagerly loaded. To fix this, remove the \\u201Cloading\\u201D attribute from the priority image.`);\n  }\n  const validInputs = [\"auto\", \"eager\", \"lazy\"];\n  if (typeof dir.loading === \"string\" && !validInputs.includes(dir.loading)) {\n    throw new RuntimeError(2952, `${imgDirectiveDetails(dir.ngSrc)} the \\`loading\\` attribute has an invalid value (\\`${dir.loading}\\`). To fix this, provide a valid value (\"lazy\", \"eager\", or \"auto\").`);\n  }\n}\nfunction assertNotMissingBuiltInLoader(ngSrc, imageLoader) {\n  if (imageLoader === noopImageLoader) {\n    let builtInLoaderName = \"\";\n    for (const loader of BUILT_IN_LOADERS) {\n      if (loader.testUrl(ngSrc)) {\n        builtInLoaderName = loader.name;\n        break;\n      }\n    }\n    if (builtInLoaderName) {\n      console.warn(formatRuntimeError(2962, `NgOptimizedImage: It looks like your images may be hosted on the ${builtInLoaderName} CDN, but your app is not using Angular's built-in loader for that CDN. We recommend switching to use the built-in by calling \\`provide${builtInLoaderName}Loader()\\` in your \\`providers\\` and passing it your instance's base URL. If you don't want to use the built-in loader, define a custom loader function using IMAGE_LOADER to silence this warning.`));\n    }\n  }\n}\nfunction assertNoNgSrcsetWithoutLoader(dir, imageLoader) {\n  if (dir.ngSrcset && imageLoader === noopImageLoader) {\n    console.warn(formatRuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \\`ngSrcset\\` attribute is present but no image loader is configured (i.e. the default one is being used), which would result in the same image being used for all configured sizes. To fix this, provide a loader or remove the \\`ngSrcset\\` attribute from the image.`));\n  }\n}\nfunction assertNoLoaderParamsWithoutLoader(dir, imageLoader) {\n  if (dir.loaderParams && imageLoader === noopImageLoader) {\n    console.warn(formatRuntimeError(2963, `${imgDirectiveDetails(dir.ngSrc)} the \\`loaderParams\\` attribute is present but no image loader is configured (i.e. the default one is being used), which means that the loaderParams data will not be consumed and will not affect the URL. To fix this, provide a custom loader or remove the \\`loaderParams\\` attribute from the image.`));\n  }\n}\nfunction assetPriorityCountBelowThreshold(appRef) {\n  return __async(this, null, function* () {\n    if (IMGS_WITH_PRIORITY_ATTR_COUNT === 0) {\n      IMGS_WITH_PRIORITY_ATTR_COUNT++;\n      yield appRef.whenStable();\n      if (IMGS_WITH_PRIORITY_ATTR_COUNT > PRIORITY_COUNT_THRESHOLD) {\n        console.warn(formatRuntimeError(2966, `NgOptimizedImage: The \"priority\" attribute is set to true more than ${PRIORITY_COUNT_THRESHOLD} times (${IMGS_WITH_PRIORITY_ATTR_COUNT} times). Marking too many images as \"high\" priority can hurt your application's LCP (https://web.dev/lcp). \"Priority\" should only be set on the image expected to be the page's LCP element.`));\n      }\n    } else {\n      IMGS_WITH_PRIORITY_ATTR_COUNT++;\n    }\n  });\n}\nfunction assertPlaceholderDimensions(dir, imgElement) {\n  const computedStyle = window.getComputedStyle(imgElement);\n  let renderedWidth = parseFloat(computedStyle.getPropertyValue(\"width\"));\n  let renderedHeight = parseFloat(computedStyle.getPropertyValue(\"height\"));\n  if (renderedWidth > PLACEHOLDER_DIMENSION_LIMIT || renderedHeight > PLACEHOLDER_DIMENSION_LIMIT) {\n    console.warn(formatRuntimeError(2967, `${imgDirectiveDetails(dir.ngSrc)} it uses a placeholder image, but at least one of the dimensions attribute (height or width) exceeds the limit of ${PLACEHOLDER_DIMENSION_LIMIT}px. To fix this, use a smaller image as a placeholder.`));\n  }\n}\nfunction callOnLoadIfImageIsLoaded(img, callback) {\n  if (img.complete && img.naturalWidth) {\n    callback();\n  }\n}\nfunction round(input2) {\n  return Number.isInteger(input2) ? input2 : input2.toFixed(2);\n}\nfunction unwrapSafeUrl(value) {\n  if (typeof value === \"string\") {\n    return value;\n  }\n  return unwrapSafeValue(value);\n}\nfunction booleanOrUrlAttribute(value) {\n  if (typeof value === \"string\" && value !== \"true\" && value !== \"false\" && value !== \"\") {\n    return value;\n  }\n  return booleanAttribute(value);\n}\n\n// node_modules/@angular/common/fesm2022/http.mjs\nvar HttpHandler = class {\n};\nvar HttpBackend = class {\n};\nvar HttpHeaders = class _HttpHeaders {\n  /**\n   * Internal map of lowercase header names to values.\n   */\n  // TODO(issue/24571): remove '!'.\n  headers;\n  /**\n   * Internal map of lowercased header names to the normalized\n   * form of the name (the form seen first).\n   */\n  normalizedNames = /* @__PURE__ */ new Map();\n  /**\n   * Complete the lazy initialization of this object (needed before reading).\n   */\n  lazyInit;\n  /**\n   * Queued updates to be materialized the next initialization.\n   */\n  lazyUpdate = null;\n  /**  Constructs a new HTTP header object with the given values.*/\n  constructor(headers) {\n    if (!headers) {\n      this.headers = /* @__PURE__ */ new Map();\n    } else if (typeof headers === \"string\") {\n      this.lazyInit = () => {\n        this.headers = /* @__PURE__ */ new Map();\n        headers.split(\"\\n\").forEach((line) => {\n          const index = line.indexOf(\":\");\n          if (index > 0) {\n            const name = line.slice(0, index);\n            const value = line.slice(index + 1).trim();\n            this.addHeaderEntry(name, value);\n          }\n        });\n      };\n    } else if (typeof Headers !== \"undefined\" && headers instanceof Headers) {\n      this.headers = /* @__PURE__ */ new Map();\n      headers.forEach((value, name) => {\n        this.addHeaderEntry(name, value);\n      });\n    } else {\n      this.lazyInit = () => {\n        if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n          assertValidHeaders(headers);\n        }\n        this.headers = /* @__PURE__ */ new Map();\n        Object.entries(headers).forEach(([name, values]) => {\n          this.setHeaderEntries(name, values);\n        });\n      };\n    }\n  }\n  /**\n   * Checks for existence of a given header.\n   *\n   * @param name The header name to check for existence.\n   *\n   * @returns True if the header exists, false otherwise.\n   */\n  has(name) {\n    this.init();\n    return this.headers.has(name.toLowerCase());\n  }\n  /**\n   * Retrieves the first value of a given header.\n   *\n   * @param name The header name.\n   *\n   * @returns The value string if the header exists, null otherwise\n   */\n  get(name) {\n    this.init();\n    const values = this.headers.get(name.toLowerCase());\n    return values && values.length > 0 ? values[0] : null;\n  }\n  /**\n   * Retrieves the names of the headers.\n   *\n   * @returns A list of header names.\n   */\n  keys() {\n    this.init();\n    return Array.from(this.normalizedNames.values());\n  }\n  /**\n   * Retrieves a list of values for a given header.\n   *\n   * @param name The header name from which to retrieve values.\n   *\n   * @returns A string of values if the header exists, null otherwise.\n   */\n  getAll(name) {\n    this.init();\n    return this.headers.get(name.toLowerCase()) || null;\n  }\n  /**\n   * Appends a new value to the existing set of values for a header\n   * and returns them in a clone of the original instance.\n   *\n   * @param name The header name for which to append the values.\n   * @param value The value to append.\n   *\n   * @returns A clone of the HTTP headers object with the value appended to the given header.\n   */\n  append(name, value) {\n    return this.clone({\n      name,\n      value,\n      op: \"a\"\n    });\n  }\n  /**\n   * Sets or modifies a value for a given header in a clone of the original instance.\n   * If the header already exists, its value is replaced with the given value\n   * in the returned object.\n   *\n   * @param name The header name.\n   * @param value The value or values to set or override for the given header.\n   *\n   * @returns A clone of the HTTP headers object with the newly set header value.\n   */\n  set(name, value) {\n    return this.clone({\n      name,\n      value,\n      op: \"s\"\n    });\n  }\n  /**\n   * Deletes values for a given header in a clone of the original instance.\n   *\n   * @param name The header name.\n   * @param value The value or values to delete for the given header.\n   *\n   * @returns A clone of the HTTP headers object with the given value deleted.\n   */\n  delete(name, value) {\n    return this.clone({\n      name,\n      value,\n      op: \"d\"\n    });\n  }\n  maybeSetNormalizedName(name, lcName) {\n    if (!this.normalizedNames.has(lcName)) {\n      this.normalizedNames.set(lcName, name);\n    }\n  }\n  init() {\n    if (!!this.lazyInit) {\n      if (this.lazyInit instanceof _HttpHeaders) {\n        this.copyFrom(this.lazyInit);\n      } else {\n        this.lazyInit();\n      }\n      this.lazyInit = null;\n      if (!!this.lazyUpdate) {\n        this.lazyUpdate.forEach((update) => this.applyUpdate(update));\n        this.lazyUpdate = null;\n      }\n    }\n  }\n  copyFrom(other) {\n    other.init();\n    Array.from(other.headers.keys()).forEach((key) => {\n      this.headers.set(key, other.headers.get(key));\n      this.normalizedNames.set(key, other.normalizedNames.get(key));\n    });\n  }\n  clone(update) {\n    const clone = new _HttpHeaders();\n    clone.lazyInit = !!this.lazyInit && this.lazyInit instanceof _HttpHeaders ? this.lazyInit : this;\n    clone.lazyUpdate = (this.lazyUpdate || []).concat([update]);\n    return clone;\n  }\n  applyUpdate(update) {\n    const key = update.name.toLowerCase();\n    switch (update.op) {\n      case \"a\":\n      case \"s\":\n        let value = update.value;\n        if (typeof value === \"string\") {\n          value = [value];\n        }\n        if (value.length === 0) {\n          return;\n        }\n        this.maybeSetNormalizedName(update.name, key);\n        const base = (update.op === \"a\" ? this.headers.get(key) : void 0) || [];\n        base.push(...value);\n        this.headers.set(key, base);\n        break;\n      case \"d\":\n        const toDelete = update.value;\n        if (!toDelete) {\n          this.headers.delete(key);\n          this.normalizedNames.delete(key);\n        } else {\n          let existing = this.headers.get(key);\n          if (!existing) {\n            return;\n          }\n          existing = existing.filter((value2) => toDelete.indexOf(value2) === -1);\n          if (existing.length === 0) {\n            this.headers.delete(key);\n            this.normalizedNames.delete(key);\n          } else {\n            this.headers.set(key, existing);\n          }\n        }\n        break;\n    }\n  }\n  addHeaderEntry(name, value) {\n    const key = name.toLowerCase();\n    this.maybeSetNormalizedName(name, key);\n    if (this.headers.has(key)) {\n      this.headers.get(key).push(value);\n    } else {\n      this.headers.set(key, [value]);\n    }\n  }\n  setHeaderEntries(name, values) {\n    const headerValues = (Array.isArray(values) ? values : [values]).map((value) => value.toString());\n    const key = name.toLowerCase();\n    this.headers.set(key, headerValues);\n    this.maybeSetNormalizedName(name, key);\n  }\n  /**\n   * @internal\n   */\n  forEach(fn) {\n    this.init();\n    Array.from(this.normalizedNames.keys()).forEach((key) => fn(this.normalizedNames.get(key), this.headers.get(key)));\n  }\n};\nfunction assertValidHeaders(headers) {\n  for (const [key, value] of Object.entries(headers)) {\n    if (!(typeof value === \"string\" || typeof value === \"number\") && !Array.isArray(value)) {\n      throw new Error(`Unexpected value of the \\`${key}\\` header provided. Expecting either a string, a number or an array, but got: \\`${value}\\`.`);\n    }\n  }\n}\nvar HttpUrlEncodingCodec = class {\n  /**\n   * Encodes a key name for a URL parameter or query-string.\n   * @param key The key name.\n   * @returns The encoded key name.\n   */\n  encodeKey(key) {\n    return standardEncoding(key);\n  }\n  /**\n   * Encodes the value of a URL parameter or query-string.\n   * @param value The value.\n   * @returns The encoded value.\n   */\n  encodeValue(value) {\n    return standardEncoding(value);\n  }\n  /**\n   * Decodes an encoded URL parameter or query-string key.\n   * @param key The encoded key name.\n   * @returns The decoded key name.\n   */\n  decodeKey(key) {\n    return decodeURIComponent(key);\n  }\n  /**\n   * Decodes an encoded URL parameter or query-string value.\n   * @param value The encoded value.\n   * @returns The decoded value.\n   */\n  decodeValue(value) {\n    return decodeURIComponent(value);\n  }\n};\nfunction paramParser(rawParams, codec) {\n  const map2 = /* @__PURE__ */ new Map();\n  if (rawParams.length > 0) {\n    const params = rawParams.replace(/^\\?/, \"\").split(\"&\");\n    params.forEach((param) => {\n      const eqIdx = param.indexOf(\"=\");\n      const [key, val] = eqIdx == -1 ? [codec.decodeKey(param), \"\"] : [codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1))];\n      const list = map2.get(key) || [];\n      list.push(val);\n      map2.set(key, list);\n    });\n  }\n  return map2;\n}\nvar STANDARD_ENCODING_REGEX = /%(\\d[a-f0-9])/gi;\nvar STANDARD_ENCODING_REPLACEMENTS = {\n  \"40\": \"@\",\n  \"3A\": \":\",\n  \"24\": \"$\",\n  \"2C\": \",\",\n  \"3B\": \";\",\n  \"3D\": \"=\",\n  \"3F\": \"?\",\n  \"2F\": \"/\"\n};\nfunction standardEncoding(v) {\n  return encodeURIComponent(v).replace(STANDARD_ENCODING_REGEX, (s, t) => STANDARD_ENCODING_REPLACEMENTS[t] ?? s);\n}\nfunction valueToString(value) {\n  return `${value}`;\n}\nvar HttpParams = class _HttpParams {\n  map;\n  encoder;\n  updates = null;\n  cloneFrom = null;\n  constructor(options = {}) {\n    this.encoder = options.encoder || new HttpUrlEncodingCodec();\n    if (options.fromString) {\n      if (options.fromObject) {\n        throw new RuntimeError(2805, ngDevMode && \"Cannot specify both fromString and fromObject.\");\n      }\n      this.map = paramParser(options.fromString, this.encoder);\n    } else if (!!options.fromObject) {\n      this.map = /* @__PURE__ */ new Map();\n      Object.keys(options.fromObject).forEach((key) => {\n        const value = options.fromObject[key];\n        const values = Array.isArray(value) ? value.map(valueToString) : [valueToString(value)];\n        this.map.set(key, values);\n      });\n    } else {\n      this.map = null;\n    }\n  }\n  /**\n   * Reports whether the body includes one or more values for a given parameter.\n   * @param param The parameter name.\n   * @returns True if the parameter has one or more values,\n   * false if it has no value or is not present.\n   */\n  has(param) {\n    this.init();\n    return this.map.has(param);\n  }\n  /**\n   * Retrieves the first value for a parameter.\n   * @param param The parameter name.\n   * @returns The first value of the given parameter,\n   * or `null` if the parameter is not present.\n   */\n  get(param) {\n    this.init();\n    const res = this.map.get(param);\n    return !!res ? res[0] : null;\n  }\n  /**\n   * Retrieves all values for a  parameter.\n   * @param param The parameter name.\n   * @returns All values in a string array,\n   * or `null` if the parameter not present.\n   */\n  getAll(param) {\n    this.init();\n    return this.map.get(param) || null;\n  }\n  /**\n   * Retrieves all the parameters for this body.\n   * @returns The parameter names in a string array.\n   */\n  keys() {\n    this.init();\n    return Array.from(this.map.keys());\n  }\n  /**\n   * Appends a new value to existing values for a parameter.\n   * @param param The parameter name.\n   * @param value The new value to add.\n   * @return A new body with the appended value.\n   */\n  append(param, value) {\n    return this.clone({\n      param,\n      value,\n      op: \"a\"\n    });\n  }\n  /**\n   * Constructs a new body with appended values for the given parameter name.\n   * @param params parameters and values\n   * @return A new body with the new value.\n   */\n  appendAll(params) {\n    const updates = [];\n    Object.keys(params).forEach((param) => {\n      const value = params[param];\n      if (Array.isArray(value)) {\n        value.forEach((_value) => {\n          updates.push({\n            param,\n            value: _value,\n            op: \"a\"\n          });\n        });\n      } else {\n        updates.push({\n          param,\n          value,\n          op: \"a\"\n        });\n      }\n    });\n    return this.clone(updates);\n  }\n  /**\n   * Replaces the value for a parameter.\n   * @param param The parameter name.\n   * @param value The new value.\n   * @return A new body with the new value.\n   */\n  set(param, value) {\n    return this.clone({\n      param,\n      value,\n      op: \"s\"\n    });\n  }\n  /**\n   * Removes a given value or all values from a parameter.\n   * @param param The parameter name.\n   * @param value The value to remove, if provided.\n   * @return A new body with the given value removed, or with all values\n   * removed if no value is specified.\n   */\n  delete(param, value) {\n    return this.clone({\n      param,\n      value,\n      op: \"d\"\n    });\n  }\n  /**\n   * Serializes the body to an encoded string, where key-value pairs (separated by `=`) are\n   * separated by `&`s.\n   */\n  toString() {\n    this.init();\n    return this.keys().map((key) => {\n      const eKey = this.encoder.encodeKey(key);\n      return this.map.get(key).map((value) => eKey + \"=\" + this.encoder.encodeValue(value)).join(\"&\");\n    }).filter((param) => param !== \"\").join(\"&\");\n  }\n  clone(update) {\n    const clone = new _HttpParams({\n      encoder: this.encoder\n    });\n    clone.cloneFrom = this.cloneFrom || this;\n    clone.updates = (this.updates || []).concat(update);\n    return clone;\n  }\n  init() {\n    if (this.map === null) {\n      this.map = /* @__PURE__ */ new Map();\n    }\n    if (this.cloneFrom !== null) {\n      this.cloneFrom.init();\n      this.cloneFrom.keys().forEach((key) => this.map.set(key, this.cloneFrom.map.get(key)));\n      this.updates.forEach((update) => {\n        switch (update.op) {\n          case \"a\":\n          case \"s\":\n            const base = (update.op === \"a\" ? this.map.get(update.param) : void 0) || [];\n            base.push(valueToString(update.value));\n            this.map.set(update.param, base);\n            break;\n          case \"d\":\n            if (update.value !== void 0) {\n              let base2 = this.map.get(update.param) || [];\n              const idx = base2.indexOf(valueToString(update.value));\n              if (idx !== -1) {\n                base2.splice(idx, 1);\n              }\n              if (base2.length > 0) {\n                this.map.set(update.param, base2);\n              } else {\n                this.map.delete(update.param);\n              }\n            } else {\n              this.map.delete(update.param);\n              break;\n            }\n        }\n      });\n      this.cloneFrom = this.updates = null;\n    }\n  }\n};\nvar HttpContext = class {\n  map = /* @__PURE__ */ new Map();\n  /**\n   * Store a value in the context. If a value is already present it will be overwritten.\n   *\n   * @param token The reference to an instance of `HttpContextToken`.\n   * @param value The value to store.\n   *\n   * @returns A reference to itself for easy chaining.\n   */\n  set(token, value) {\n    this.map.set(token, value);\n    return this;\n  }\n  /**\n   * Retrieve the value associated with the given token.\n   *\n   * @param token The reference to an instance of `HttpContextToken`.\n   *\n   * @returns The stored value or default if one is defined.\n   */\n  get(token) {\n    if (!this.map.has(token)) {\n      this.map.set(token, token.defaultValue());\n    }\n    return this.map.get(token);\n  }\n  /**\n   * Delete the value associated with the given token.\n   *\n   * @param token The reference to an instance of `HttpContextToken`.\n   *\n   * @returns A reference to itself for easy chaining.\n   */\n  delete(token) {\n    this.map.delete(token);\n    return this;\n  }\n  /**\n   * Checks for existence of a given token.\n   *\n   * @param token The reference to an instance of `HttpContextToken`.\n   *\n   * @returns True if the token exists, false otherwise.\n   */\n  has(token) {\n    return this.map.has(token);\n  }\n  /**\n   * @returns a list of tokens currently stored in the context.\n   */\n  keys() {\n    return this.map.keys();\n  }\n};\nfunction mightHaveBody(method) {\n  switch (method) {\n    case \"DELETE\":\n    case \"GET\":\n    case \"HEAD\":\n    case \"OPTIONS\":\n    case \"JSONP\":\n      return false;\n    default:\n      return true;\n  }\n}\nfunction isArrayBuffer(value) {\n  return typeof ArrayBuffer !== \"undefined\" && value instanceof ArrayBuffer;\n}\nfunction isBlob(value) {\n  return typeof Blob !== \"undefined\" && value instanceof Blob;\n}\nfunction isFormData(value) {\n  return typeof FormData !== \"undefined\" && value instanceof FormData;\n}\nfunction isUrlSearchParams(value) {\n  return typeof URLSearchParams !== \"undefined\" && value instanceof URLSearchParams;\n}\nvar CONTENT_TYPE_HEADER = \"Content-Type\";\nvar ACCEPT_HEADER = \"Accept\";\nvar X_REQUEST_URL_HEADER = \"X-Request-URL\";\nvar TEXT_CONTENT_TYPE = \"text/plain\";\nvar JSON_CONTENT_TYPE = \"application/json\";\nvar ACCEPT_HEADER_VALUE = `${JSON_CONTENT_TYPE}, ${TEXT_CONTENT_TYPE}, */*`;\nvar HttpRequest = class _HttpRequest {\n  url;\n  /**\n   * The request body, or `null` if one isn't set.\n   *\n   * Bodies are not enforced to be immutable, as they can include a reference to any\n   * user-defined data type. However, interceptors should take care to preserve\n   * idempotence by treating them as such.\n   */\n  body = null;\n  /**\n   * Outgoing headers for this request.\n   */\n  // TODO(issue/24571): remove '!'.\n  headers;\n  /**\n   * Shared and mutable context that can be used by interceptors\n   */\n  context;\n  /**\n   * Whether this request should be made in a way that exposes progress events.\n   *\n   * Progress events are expensive (change detection runs on each event) and so\n   * they should only be requested if the consumer intends to monitor them.\n   *\n   * Note: The `FetchBackend` doesn't support progress report on uploads.\n   */\n  reportProgress = false;\n  /**\n   * Whether this request should be sent with outgoing credentials (cookies).\n   */\n  withCredentials = false;\n  /**\n   * The expected response type of the server.\n   *\n   * This is used to parse the response appropriately before returning it to\n   * the requestee.\n   */\n  responseType = \"json\";\n  /**\n   * The outgoing HTTP request method.\n   */\n  method;\n  /**\n   * Outgoing URL parameters.\n   *\n   * To pass a string representation of HTTP parameters in the URL-query-string format,\n   * the `HttpParamsOptions`' `fromString` may be used. For example:\n   *\n   * ```ts\n   * new HttpParams({fromString: 'angular=awesome'})\n   * ```\n   */\n  // TODO(issue/24571): remove '!'.\n  params;\n  /**\n   * The outgoing URL with all URL parameters set.\n   */\n  urlWithParams;\n  /**\n   * The HttpTransferCache option for the request\n   */\n  transferCache;\n  constructor(method, url, third, fourth) {\n    this.url = url;\n    this.method = method.toUpperCase();\n    let options;\n    if (mightHaveBody(this.method) || !!fourth) {\n      this.body = third !== void 0 ? third : null;\n      options = fourth;\n    } else {\n      options = third;\n    }\n    if (options) {\n      this.reportProgress = !!options.reportProgress;\n      this.withCredentials = !!options.withCredentials;\n      if (!!options.responseType) {\n        this.responseType = options.responseType;\n      }\n      if (!!options.headers) {\n        this.headers = options.headers;\n      }\n      if (!!options.context) {\n        this.context = options.context;\n      }\n      if (!!options.params) {\n        this.params = options.params;\n      }\n      this.transferCache = options.transferCache;\n    }\n    this.headers ??= new HttpHeaders();\n    this.context ??= new HttpContext();\n    if (!this.params) {\n      this.params = new HttpParams();\n      this.urlWithParams = url;\n    } else {\n      const params = this.params.toString();\n      if (params.length === 0) {\n        this.urlWithParams = url;\n      } else {\n        const qIdx = url.indexOf(\"?\");\n        const sep = qIdx === -1 ? \"?\" : qIdx < url.length - 1 ? \"&\" : \"\";\n        this.urlWithParams = url + sep + params;\n      }\n    }\n  }\n  /**\n   * Transform the free-form body into a serialized format suitable for\n   * transmission to the server.\n   */\n  serializeBody() {\n    if (this.body === null) {\n      return null;\n    }\n    if (typeof this.body === \"string\" || isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) || isUrlSearchParams(this.body)) {\n      return this.body;\n    }\n    if (this.body instanceof HttpParams) {\n      return this.body.toString();\n    }\n    if (typeof this.body === \"object\" || typeof this.body === \"boolean\" || Array.isArray(this.body)) {\n      return JSON.stringify(this.body);\n    }\n    return this.body.toString();\n  }\n  /**\n   * Examine the body and attempt to infer an appropriate MIME type\n   * for it.\n   *\n   * If no such type can be inferred, this method will return `null`.\n   */\n  detectContentTypeHeader() {\n    if (this.body === null) {\n      return null;\n    }\n    if (isFormData(this.body)) {\n      return null;\n    }\n    if (isBlob(this.body)) {\n      return this.body.type || null;\n    }\n    if (isArrayBuffer(this.body)) {\n      return null;\n    }\n    if (typeof this.body === \"string\") {\n      return TEXT_CONTENT_TYPE;\n    }\n    if (this.body instanceof HttpParams) {\n      return \"application/x-www-form-urlencoded;charset=UTF-8\";\n    }\n    if (typeof this.body === \"object\" || typeof this.body === \"number\" || typeof this.body === \"boolean\") {\n      return JSON_CONTENT_TYPE;\n    }\n    return null;\n  }\n  clone(update = {}) {\n    const method = update.method || this.method;\n    const url = update.url || this.url;\n    const responseType = update.responseType || this.responseType;\n    const transferCache = update.transferCache ?? this.transferCache;\n    const body = update.body !== void 0 ? update.body : this.body;\n    const withCredentials = update.withCredentials ?? this.withCredentials;\n    const reportProgress = update.reportProgress ?? this.reportProgress;\n    let headers = update.headers || this.headers;\n    let params = update.params || this.params;\n    const context2 = update.context ?? this.context;\n    if (update.setHeaders !== void 0) {\n      headers = Object.keys(update.setHeaders).reduce((headers2, name) => headers2.set(name, update.setHeaders[name]), headers);\n    }\n    if (update.setParams) {\n      params = Object.keys(update.setParams).reduce((params2, param) => params2.set(param, update.setParams[param]), params);\n    }\n    return new _HttpRequest(method, url, body, {\n      params,\n      headers,\n      context: context2,\n      reportProgress,\n      responseType,\n      withCredentials,\n      transferCache\n    });\n  }\n};\nvar HttpEventType;\n(function(HttpEventType2) {\n  HttpEventType2[HttpEventType2[\"Sent\"] = 0] = \"Sent\";\n  HttpEventType2[HttpEventType2[\"UploadProgress\"] = 1] = \"UploadProgress\";\n  HttpEventType2[HttpEventType2[\"ResponseHeader\"] = 2] = \"ResponseHeader\";\n  HttpEventType2[HttpEventType2[\"DownloadProgress\"] = 3] = \"DownloadProgress\";\n  HttpEventType2[HttpEventType2[\"Response\"] = 4] = \"Response\";\n  HttpEventType2[HttpEventType2[\"User\"] = 5] = \"User\";\n})(HttpEventType || (HttpEventType = {}));\nvar HttpResponseBase = class {\n  /**\n   * All response headers.\n   */\n  headers;\n  /**\n   * Response status code.\n   */\n  status;\n  /**\n   * Textual description of response status code, defaults to OK.\n   *\n   * Do not depend on this.\n   */\n  statusText;\n  /**\n   * URL of the resource retrieved, or null if not available.\n   */\n  url;\n  /**\n   * Whether the status code falls in the 2xx range.\n   */\n  ok;\n  /**\n   * Type of the response, narrowed to either the full response or the header.\n   */\n  // TODO(issue/24571): remove '!'.\n  type;\n  /**\n   * Super-constructor for all responses.\n   *\n   * The single parameter accepted is an initialization hash. Any properties\n   * of the response passed there will override the default values.\n   */\n  constructor(init, defaultStatus = 200, defaultStatusText = \"OK\") {\n    this.headers = init.headers || new HttpHeaders();\n    this.status = init.status !== void 0 ? init.status : defaultStatus;\n    this.statusText = init.statusText || defaultStatusText;\n    this.url = init.url || null;\n    this.ok = this.status >= 200 && this.status < 300;\n  }\n};\nvar HttpHeaderResponse = class _HttpHeaderResponse extends HttpResponseBase {\n  /**\n   * Create a new `HttpHeaderResponse` with the given parameters.\n   */\n  constructor(init = {}) {\n    super(init);\n  }\n  type = HttpEventType.ResponseHeader;\n  /**\n   * Copy this `HttpHeaderResponse`, overriding its contents with the\n   * given parameter hash.\n   */\n  clone(update = {}) {\n    return new _HttpHeaderResponse({\n      headers: update.headers || this.headers,\n      status: update.status !== void 0 ? update.status : this.status,\n      statusText: update.statusText || this.statusText,\n      url: update.url || this.url || void 0\n    });\n  }\n};\nvar HttpResponse = class _HttpResponse extends HttpResponseBase {\n  /**\n   * The response body, or `null` if one was not returned.\n   */\n  body;\n  /**\n   * Construct a new `HttpResponse`.\n   */\n  constructor(init = {}) {\n    super(init);\n    this.body = init.body !== void 0 ? init.body : null;\n  }\n  type = HttpEventType.Response;\n  clone(update = {}) {\n    return new _HttpResponse({\n      body: update.body !== void 0 ? update.body : this.body,\n      headers: update.headers || this.headers,\n      status: update.status !== void 0 ? update.status : this.status,\n      statusText: update.statusText || this.statusText,\n      url: update.url || this.url || void 0\n    });\n  }\n};\nvar HttpErrorResponse = class extends HttpResponseBase {\n  name = \"HttpErrorResponse\";\n  message;\n  error;\n  /**\n   * Errors are never okay, even when the status code is in the 2xx success range.\n   */\n  ok = false;\n  constructor(init) {\n    super(init, 0, \"Unknown Error\");\n    if (this.status >= 200 && this.status < 300) {\n      this.message = `Http failure during parsing for ${init.url || \"(unknown url)\"}`;\n    } else {\n      this.message = `Http failure response for ${init.url || \"(unknown url)\"}: ${init.status} ${init.statusText}`;\n    }\n    this.error = init.error || null;\n  }\n};\nvar HTTP_STATUS_CODE_OK = 200;\nvar HTTP_STATUS_CODE_NO_CONTENT = 204;\nvar HttpStatusCode;\n(function(HttpStatusCode2) {\n  HttpStatusCode2[HttpStatusCode2[\"Continue\"] = 100] = \"Continue\";\n  HttpStatusCode2[HttpStatusCode2[\"SwitchingProtocols\"] = 101] = \"SwitchingProtocols\";\n  HttpStatusCode2[HttpStatusCode2[\"Processing\"] = 102] = \"Processing\";\n  HttpStatusCode2[HttpStatusCode2[\"EarlyHints\"] = 103] = \"EarlyHints\";\n  HttpStatusCode2[HttpStatusCode2[\"Ok\"] = 200] = \"Ok\";\n  HttpStatusCode2[HttpStatusCode2[\"Created\"] = 201] = \"Created\";\n  HttpStatusCode2[HttpStatusCode2[\"Accepted\"] = 202] = \"Accepted\";\n  HttpStatusCode2[HttpStatusCode2[\"NonAuthoritativeInformation\"] = 203] = \"NonAuthoritativeInformation\";\n  HttpStatusCode2[HttpStatusCode2[\"NoContent\"] = 204] = \"NoContent\";\n  HttpStatusCode2[HttpStatusCode2[\"ResetContent\"] = 205] = \"ResetContent\";\n  HttpStatusCode2[HttpStatusCode2[\"PartialContent\"] = 206] = \"PartialContent\";\n  HttpStatusCode2[HttpStatusCode2[\"MultiStatus\"] = 207] = \"MultiStatus\";\n  HttpStatusCode2[HttpStatusCode2[\"AlreadyReported\"] = 208] = \"AlreadyReported\";\n  HttpStatusCode2[HttpStatusCode2[\"ImUsed\"] = 226] = \"ImUsed\";\n  HttpStatusCode2[HttpStatusCode2[\"MultipleChoices\"] = 300] = \"MultipleChoices\";\n  HttpStatusCode2[HttpStatusCode2[\"MovedPermanently\"] = 301] = \"MovedPermanently\";\n  HttpStatusCode2[HttpStatusCode2[\"Found\"] = 302] = \"Found\";\n  HttpStatusCode2[HttpStatusCode2[\"SeeOther\"] = 303] = \"SeeOther\";\n  HttpStatusCode2[HttpStatusCode2[\"NotModified\"] = 304] = \"NotModified\";\n  HttpStatusCode2[HttpStatusCode2[\"UseProxy\"] = 305] = \"UseProxy\";\n  HttpStatusCode2[HttpStatusCode2[\"Unused\"] = 306] = \"Unused\";\n  HttpStatusCode2[HttpStatusCode2[\"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\n  HttpStatusCode2[HttpStatusCode2[\"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\n  HttpStatusCode2[HttpStatusCode2[\"BadRequest\"] = 400] = \"BadRequest\";\n  HttpStatusCode2[HttpStatusCode2[\"Unauthorized\"] = 401] = \"Unauthorized\";\n  HttpStatusCode2[HttpStatusCode2[\"PaymentRequired\"] = 402] = \"PaymentRequired\";\n  HttpStatusCode2[HttpStatusCode2[\"Forbidden\"] = 403] = \"Forbidden\";\n  HttpStatusCode2[HttpStatusCode2[\"NotFound\"] = 404] = \"NotFound\";\n  HttpStatusCode2[HttpStatusCode2[\"MethodNotAllowed\"] = 405] = \"MethodNotAllowed\";\n  HttpStatusCode2[HttpStatusCode2[\"NotAcceptable\"] = 406] = \"NotAcceptable\";\n  HttpStatusCode2[HttpStatusCode2[\"ProxyAuthenticationRequired\"] = 407] = \"ProxyAuthenticationRequired\";\n  HttpStatusCode2[HttpStatusCode2[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n  HttpStatusCode2[HttpStatusCode2[\"Conflict\"] = 409] = \"Conflict\";\n  HttpStatusCode2[HttpStatusCode2[\"Gone\"] = 410] = \"Gone\";\n  HttpStatusCode2[HttpStatusCode2[\"LengthRequired\"] = 411] = \"LengthRequired\";\n  HttpStatusCode2[HttpStatusCode2[\"PreconditionFailed\"] = 412] = \"PreconditionFailed\";\n  HttpStatusCode2[HttpStatusCode2[\"PayloadTooLarge\"] = 413] = \"PayloadTooLarge\";\n  HttpStatusCode2[HttpStatusCode2[\"UriTooLong\"] = 414] = \"UriTooLong\";\n  HttpStatusCode2[HttpStatusCode2[\"UnsupportedMediaType\"] = 415] = \"UnsupportedMediaType\";\n  HttpStatusCode2[HttpStatusCode2[\"RangeNotSatisfiable\"] = 416] = \"RangeNotSatisfiable\";\n  HttpStatusCode2[HttpStatusCode2[\"ExpectationFailed\"] = 417] = \"ExpectationFailed\";\n  HttpStatusCode2[HttpStatusCode2[\"ImATeapot\"] = 418] = \"ImATeapot\";\n  HttpStatusCode2[HttpStatusCode2[\"MisdirectedRequest\"] = 421] = \"MisdirectedRequest\";\n  HttpStatusCode2[HttpStatusCode2[\"UnprocessableEntity\"] = 422] = \"UnprocessableEntity\";\n  HttpStatusCode2[HttpStatusCode2[\"Locked\"] = 423] = \"Locked\";\n  HttpStatusCode2[HttpStatusCode2[\"FailedDependency\"] = 424] = \"FailedDependency\";\n  HttpStatusCode2[HttpStatusCode2[\"TooEarly\"] = 425] = \"TooEarly\";\n  HttpStatusCode2[HttpStatusCode2[\"UpgradeRequired\"] = 426] = \"UpgradeRequired\";\n  HttpStatusCode2[HttpStatusCode2[\"PreconditionRequired\"] = 428] = \"PreconditionRequired\";\n  HttpStatusCode2[HttpStatusCode2[\"TooManyRequests\"] = 429] = \"TooManyRequests\";\n  HttpStatusCode2[HttpStatusCode2[\"RequestHeaderFieldsTooLarge\"] = 431] = \"RequestHeaderFieldsTooLarge\";\n  HttpStatusCode2[HttpStatusCode2[\"UnavailableForLegalReasons\"] = 451] = \"UnavailableForLegalReasons\";\n  HttpStatusCode2[HttpStatusCode2[\"InternalServerError\"] = 500] = \"InternalServerError\";\n  HttpStatusCode2[HttpStatusCode2[\"NotImplemented\"] = 501] = \"NotImplemented\";\n  HttpStatusCode2[HttpStatusCode2[\"BadGateway\"] = 502] = \"BadGateway\";\n  HttpStatusCode2[HttpStatusCode2[\"ServiceUnavailable\"] = 503] = \"ServiceUnavailable\";\n  HttpStatusCode2[HttpStatusCode2[\"GatewayTimeout\"] = 504] = \"GatewayTimeout\";\n  HttpStatusCode2[HttpStatusCode2[\"HttpVersionNotSupported\"] = 505] = \"HttpVersionNotSupported\";\n  HttpStatusCode2[HttpStatusCode2[\"VariantAlsoNegotiates\"] = 506] = \"VariantAlsoNegotiates\";\n  HttpStatusCode2[HttpStatusCode2[\"InsufficientStorage\"] = 507] = \"InsufficientStorage\";\n  HttpStatusCode2[HttpStatusCode2[\"LoopDetected\"] = 508] = \"LoopDetected\";\n  HttpStatusCode2[HttpStatusCode2[\"NotExtended\"] = 510] = \"NotExtended\";\n  HttpStatusCode2[HttpStatusCode2[\"NetworkAuthenticationRequired\"] = 511] = \"NetworkAuthenticationRequired\";\n})(HttpStatusCode || (HttpStatusCode = {}));\nfunction addBody(options, body) {\n  return {\n    body,\n    headers: options.headers,\n    context: options.context,\n    observe: options.observe,\n    params: options.params,\n    reportProgress: options.reportProgress,\n    responseType: options.responseType,\n    withCredentials: options.withCredentials,\n    transferCache: options.transferCache\n  };\n}\nvar HttpClient = class _HttpClient {\n  handler;\n  constructor(handler) {\n    this.handler = handler;\n  }\n  /**\n   * Constructs an observable for a generic HTTP request that, when subscribed,\n   * fires the request through the chain of registered interceptors and on to the\n   * server.\n   *\n   * You can pass an `HttpRequest` directly as the only parameter. In this case,\n   * the call returns an observable of the raw `HttpEvent` stream.\n   *\n   * Alternatively you can pass an HTTP method as the first parameter,\n   * a URL string as the second, and an options hash containing the request body as the third.\n   * See `addBody()`. In this case, the specified `responseType` and `observe` options determine the\n   * type of returned observable.\n   *   * The `responseType` value determines how a successful response body is parsed.\n   *   * If `responseType` is the default `json`, you can pass a type interface for the resulting\n   * object as a type parameter to the call.\n   *\n   * The `observe` value determines the return type, according to what you are interested in\n   * observing.\n   *   * An `observe` value of events returns an observable of the raw `HttpEvent` stream, including\n   * progress events by default.\n   *   * An `observe` value of response returns an observable of `HttpResponse<T>`,\n   * where the `T` parameter depends on the `responseType` and any optionally provided type\n   * parameter.\n   *   * An `observe` value of body returns an observable of `<T>` with the same `T` body type.\n   *\n   */\n  request(first2, url, options = {}) {\n    let req;\n    if (first2 instanceof HttpRequest) {\n      req = first2;\n    } else {\n      let headers = void 0;\n      if (options.headers instanceof HttpHeaders) {\n        headers = options.headers;\n      } else {\n        headers = new HttpHeaders(options.headers);\n      }\n      let params = void 0;\n      if (!!options.params) {\n        if (options.params instanceof HttpParams) {\n          params = options.params;\n        } else {\n          params = new HttpParams({\n            fromObject: options.params\n          });\n        }\n      }\n      req = new HttpRequest(first2, url, options.body !== void 0 ? options.body : null, {\n        headers,\n        context: options.context,\n        params,\n        reportProgress: options.reportProgress,\n        // By default, JSON is assumed to be returned for all calls.\n        responseType: options.responseType || \"json\",\n        withCredentials: options.withCredentials,\n        transferCache: options.transferCache\n      });\n    }\n    const events$ = of(req).pipe(concatMap((req2) => this.handler.handle(req2)));\n    if (first2 instanceof HttpRequest || options.observe === \"events\") {\n      return events$;\n    }\n    const res$ = events$.pipe(filter((event) => event instanceof HttpResponse));\n    switch (options.observe || \"body\") {\n      case \"body\":\n        switch (req.responseType) {\n          case \"arraybuffer\":\n            return res$.pipe(map((res) => {\n              if (res.body !== null && !(res.body instanceof ArrayBuffer)) {\n                throw new RuntimeError(2806, ngDevMode && \"Response is not an ArrayBuffer.\");\n              }\n              return res.body;\n            }));\n          case \"blob\":\n            return res$.pipe(map((res) => {\n              if (res.body !== null && !(res.body instanceof Blob)) {\n                throw new RuntimeError(2807, ngDevMode && \"Response is not a Blob.\");\n              }\n              return res.body;\n            }));\n          case \"text\":\n            return res$.pipe(map((res) => {\n              if (res.body !== null && typeof res.body !== \"string\") {\n                throw new RuntimeError(2808, ngDevMode && \"Response is not a string.\");\n              }\n              return res.body;\n            }));\n          case \"json\":\n          default:\n            return res$.pipe(map((res) => res.body));\n        }\n      case \"response\":\n        return res$;\n      default:\n        throw new RuntimeError(2809, ngDevMode && `Unreachable: unhandled observe type ${options.observe}}`);\n    }\n  }\n  /**\n   * Constructs an observable that, when subscribed, causes the configured\n   * `DELETE` request to execute on the server. See the individual overloads for\n   * details on the return type.\n   *\n   * @param url     The endpoint URL.\n   * @param options The HTTP options to send with the request.\n   *\n   */\n  delete(url, options = {}) {\n    return this.request(\"DELETE\", url, options);\n  }\n  /**\n   * Constructs an observable that, when subscribed, causes the configured\n   * `GET` request to execute on the server. See the individual overloads for\n   * details on the return type.\n   */\n  get(url, options = {}) {\n    return this.request(\"GET\", url, options);\n  }\n  /**\n   * Constructs an observable that, when subscribed, causes the configured\n   * `HEAD` request to execute on the server. The `HEAD` method returns\n   * meta information about the resource without transferring the\n   * resource itself. See the individual overloads for\n   * details on the return type.\n   */\n  head(url, options = {}) {\n    return this.request(\"HEAD\", url, options);\n  }\n  /**\n   * Constructs an `Observable` that, when subscribed, causes a request with the special method\n   * `JSONP` to be dispatched via the interceptor pipeline.\n   * The [JSONP pattern](https://en.wikipedia.org/wiki/JSONP) works around limitations of certain\n   * API endpoints that don't support newer,\n   * and preferable [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) protocol.\n   * JSONP treats the endpoint API as a JavaScript file and tricks the browser to process the\n   * requests even if the API endpoint is not located on the same domain (origin) as the client-side\n   * application making the request.\n   * The endpoint API must support JSONP callback for JSONP requests to work.\n   * The resource API returns the JSON response wrapped in a callback function.\n   * You can pass the callback function name as one of the query parameters.\n   * Note that JSONP requests can only be used with `GET` requests.\n   *\n   * @param url The resource URL.\n   * @param callbackParam The callback function name.\n   *\n   */\n  jsonp(url, callbackParam) {\n    return this.request(\"JSONP\", url, {\n      params: new HttpParams().append(callbackParam, \"JSONP_CALLBACK\"),\n      observe: \"body\",\n      responseType: \"json\"\n    });\n  }\n  /**\n   * Constructs an `Observable` that, when subscribed, causes the configured\n   * `OPTIONS` request to execute on the server. This method allows the client\n   * to determine the supported HTTP methods and other capabilities of an endpoint,\n   * without implying a resource action. See the individual overloads for\n   * details on the return type.\n   */\n  options(url, options = {}) {\n    return this.request(\"OPTIONS\", url, options);\n  }\n  /**\n   * Constructs an observable that, when subscribed, causes the configured\n   * `PATCH` request to execute on the server. See the individual overloads for\n   * details on the return type.\n   */\n  patch(url, body, options = {}) {\n    return this.request(\"PATCH\", url, addBody(options, body));\n  }\n  /**\n   * Constructs an observable that, when subscribed, causes the configured\n   * `POST` request to execute on the server. The server responds with the location of\n   * the replaced resource. See the individual overloads for\n   * details on the return type.\n   */\n  post(url, body, options = {}) {\n    return this.request(\"POST\", url, addBody(options, body));\n  }\n  /**\n   * Constructs an observable that, when subscribed, causes the configured\n   * `PUT` request to execute on the server. The `PUT` method replaces an existing resource\n   * with a new set of values.\n   * See the individual overloads for details on the return type.\n   */\n  put(url, body, options = {}) {\n    return this.request(\"PUT\", url, addBody(options, body));\n  }\n  static \\u0275fac = function HttpClient_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _HttpClient)(\\u0275\\u0275inject(HttpHandler));\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _HttpClient,\n    factory: _HttpClient.\\u0275fac\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(HttpClient, [{\n    type: Injectable\n  }], () => [{\n    type: HttpHandler\n  }], null);\n})();\nvar XSSI_PREFIX$1 = /^\\)\\]\\}',?\\n/;\nfunction getResponseUrl$1(response) {\n  if (response.url) {\n    return response.url;\n  }\n  const xRequestUrl = X_REQUEST_URL_HEADER.toLocaleLowerCase();\n  return response.headers.get(xRequestUrl);\n}\nvar FETCH_BACKEND = new InjectionToken(typeof ngDevMode === \"undefined\" || ngDevMode ? \"FETCH_BACKEND\" : \"\");\nvar FetchBackend = class _FetchBackend {\n  // We use an arrow function to always reference the current global implementation of `fetch`.\n  // This is helpful for cases when the global `fetch` implementation is modified by external code,\n  // see https://github.com/angular/angular/issues/57527.\n  fetchImpl = inject(FetchFactory, {\n    optional: true\n  })?.fetch ?? ((...args) => globalThis.fetch(...args));\n  ngZone = inject(NgZone);\n  handle(request) {\n    return new Observable((observer) => {\n      const aborter = new AbortController();\n      this.doRequest(request, aborter.signal, observer).then(noop3, (error) => observer.error(new HttpErrorResponse({\n        error\n      })));\n      return () => aborter.abort();\n    });\n  }\n  doRequest(request, signal2, observer) {\n    return __async(this, null, function* () {\n      const init = this.createRequestInit(request);\n      let response;\n      try {\n        const fetchPromise = this.ngZone.runOutsideAngular(() => this.fetchImpl(request.urlWithParams, __spreadValues({\n          signal: signal2\n        }, init)));\n        silenceSuperfluousUnhandledPromiseRejection(fetchPromise);\n        observer.next({\n          type: HttpEventType.Sent\n        });\n        response = yield fetchPromise;\n      } catch (error) {\n        observer.error(new HttpErrorResponse({\n          error,\n          status: error.status ?? 0,\n          statusText: error.statusText,\n          url: request.urlWithParams,\n          headers: error.headers\n        }));\n        return;\n      }\n      const headers = new HttpHeaders(response.headers);\n      const statusText = response.statusText;\n      const url = getResponseUrl$1(response) ?? request.urlWithParams;\n      let status = response.status;\n      let body = null;\n      if (request.reportProgress) {\n        observer.next(new HttpHeaderResponse({\n          headers,\n          status,\n          statusText,\n          url\n        }));\n      }\n      if (response.body) {\n        const contentLength = response.headers.get(\"content-length\");\n        const chunks = [];\n        const reader = response.body.getReader();\n        let receivedLength = 0;\n        let decoder;\n        let partialText;\n        const reqZone = typeof Zone !== \"undefined\" && Zone.current;\n        yield this.ngZone.runOutsideAngular(() => __async(this, null, function* () {\n          while (true) {\n            const {\n              done,\n              value\n            } = yield reader.read();\n            if (done) {\n              break;\n            }\n            chunks.push(value);\n            receivedLength += value.length;\n            if (request.reportProgress) {\n              partialText = request.responseType === \"text\" ? (partialText ?? \"\") + (decoder ??= new TextDecoder()).decode(value, {\n                stream: true\n              }) : void 0;\n              const reportProgress = () => observer.next({\n                type: HttpEventType.DownloadProgress,\n                total: contentLength ? +contentLength : void 0,\n                loaded: receivedLength,\n                partialText\n              });\n              reqZone ? reqZone.run(reportProgress) : reportProgress();\n            }\n          }\n        }));\n        const chunksAll = this.concatChunks(chunks, receivedLength);\n        try {\n          const contentType = response.headers.get(CONTENT_TYPE_HEADER) ?? \"\";\n          body = this.parseBody(request, chunksAll, contentType);\n        } catch (error) {\n          observer.error(new HttpErrorResponse({\n            error,\n            headers: new HttpHeaders(response.headers),\n            status: response.status,\n            statusText: response.statusText,\n            url: getResponseUrl$1(response) ?? request.urlWithParams\n          }));\n          return;\n        }\n      }\n      if (status === 0) {\n        status = body ? HTTP_STATUS_CODE_OK : 0;\n      }\n      const ok = status >= 200 && status < 300;\n      if (ok) {\n        observer.next(new HttpResponse({\n          body,\n          headers,\n          status,\n          statusText,\n          url\n        }));\n        observer.complete();\n      } else {\n        observer.error(new HttpErrorResponse({\n          error: body,\n          headers,\n          status,\n          statusText,\n          url\n        }));\n      }\n    });\n  }\n  parseBody(request, binContent, contentType) {\n    switch (request.responseType) {\n      case \"json\":\n        const text = new TextDecoder().decode(binContent).replace(XSSI_PREFIX$1, \"\");\n        return text === \"\" ? null : JSON.parse(text);\n      case \"text\":\n        return new TextDecoder().decode(binContent);\n      case \"blob\":\n        return new Blob([binContent], {\n          type: contentType\n        });\n      case \"arraybuffer\":\n        return binContent.buffer;\n    }\n  }\n  createRequestInit(req) {\n    const headers = {};\n    const credentials = req.withCredentials ? \"include\" : void 0;\n    req.headers.forEach((name, values) => headers[name] = values.join(\",\"));\n    if (!req.headers.has(ACCEPT_HEADER)) {\n      headers[ACCEPT_HEADER] = ACCEPT_HEADER_VALUE;\n    }\n    if (!req.headers.has(CONTENT_TYPE_HEADER)) {\n      const detectedType = req.detectContentTypeHeader();\n      if (detectedType !== null) {\n        headers[CONTENT_TYPE_HEADER] = detectedType;\n      }\n    }\n    return {\n      body: req.serializeBody(),\n      method: req.method,\n      headers,\n      credentials\n    };\n  }\n  concatChunks(chunks, totalLength) {\n    const chunksAll = new Uint8Array(totalLength);\n    let position = 0;\n    for (const chunk of chunks) {\n      chunksAll.set(chunk, position);\n      position += chunk.length;\n    }\n    return chunksAll;\n  }\n  static \\u0275fac = function FetchBackend_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _FetchBackend)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _FetchBackend,\n    factory: _FetchBackend.\\u0275fac\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(FetchBackend, [{\n    type: Injectable\n  }], null, null);\n})();\nvar FetchFactory = class {\n};\nfunction noop3() {\n}\nfunction silenceSuperfluousUnhandledPromiseRejection(promise) {\n  promise.then(noop3, noop3);\n}\nfunction interceptorChainEndFn(req, finalHandlerFn) {\n  return finalHandlerFn(req);\n}\nfunction adaptLegacyInterceptorToChain(chainTailFn, interceptor) {\n  return (initialRequest, finalHandlerFn) => interceptor.intercept(initialRequest, {\n    handle: (downstreamRequest) => chainTailFn(downstreamRequest, finalHandlerFn)\n  });\n}\nfunction chainedInterceptorFn(chainTailFn, interceptorFn, injector) {\n  return (initialRequest, finalHandlerFn) => runInInjectionContext(injector, () => interceptorFn(initialRequest, (downstreamRequest) => chainTailFn(downstreamRequest, finalHandlerFn)));\n}\nvar HTTP_INTERCEPTORS = new InjectionToken(ngDevMode ? \"HTTP_INTERCEPTORS\" : \"\");\nvar HTTP_INTERCEPTOR_FNS = new InjectionToken(ngDevMode ? \"HTTP_INTERCEPTOR_FNS\" : \"\");\nvar HTTP_ROOT_INTERCEPTOR_FNS = new InjectionToken(ngDevMode ? \"HTTP_ROOT_INTERCEPTOR_FNS\" : \"\");\nvar REQUESTS_CONTRIBUTE_TO_STABILITY = new InjectionToken(ngDevMode ? \"REQUESTS_CONTRIBUTE_TO_STABILITY\" : \"\", {\n  providedIn: \"root\",\n  factory: () => true\n});\nfunction legacyInterceptorFnFactory() {\n  let chain = null;\n  return (req, handler) => {\n    if (chain === null) {\n      const interceptors = inject(HTTP_INTERCEPTORS, {\n        optional: true\n      }) ?? [];\n      chain = interceptors.reduceRight(adaptLegacyInterceptorToChain, interceptorChainEndFn);\n    }\n    const pendingTasks = inject(PendingTasksInternal);\n    const contributeToStability = inject(REQUESTS_CONTRIBUTE_TO_STABILITY);\n    if (contributeToStability) {\n      const taskId = pendingTasks.add();\n      return chain(req, handler).pipe(finalize(() => pendingTasks.remove(taskId)));\n    } else {\n      return chain(req, handler);\n    }\n  };\n}\nvar fetchBackendWarningDisplayed = false;\nvar HttpInterceptorHandler = class _HttpInterceptorHandler extends HttpHandler {\n  backend;\n  injector;\n  chain = null;\n  pendingTasks = inject(PendingTasksInternal);\n  contributeToStability = inject(REQUESTS_CONTRIBUTE_TO_STABILITY);\n  constructor(backend, injector) {\n    super();\n    this.backend = backend;\n    this.injector = injector;\n    if ((typeof ngDevMode === \"undefined\" || ngDevMode) && !fetchBackendWarningDisplayed) {\n      const isServer = isPlatformServer(injector.get(PLATFORM_ID));\n      const isTestingBackend = this.backend.isTestingBackend;\n      if (isServer && !(this.backend instanceof FetchBackend) && !isTestingBackend) {\n        fetchBackendWarningDisplayed = true;\n        injector.get(Console).warn(formatRuntimeError(2801, \"Angular detected that `HttpClient` is not configured to use `fetch` APIs. It's strongly recommended to enable `fetch` for applications that use Server-Side Rendering for better performance and compatibility. To enable `fetch`, add the `withFetch()` to the `provideHttpClient()` call at the root of the application.\"));\n      }\n    }\n  }\n  handle(initialRequest) {\n    if (this.chain === null) {\n      const dedupedInterceptorFns = Array.from(/* @__PURE__ */ new Set([...this.injector.get(HTTP_INTERCEPTOR_FNS), ...this.injector.get(HTTP_ROOT_INTERCEPTOR_FNS, [])]));\n      this.chain = dedupedInterceptorFns.reduceRight((nextSequencedFn, interceptorFn) => chainedInterceptorFn(nextSequencedFn, interceptorFn, this.injector), interceptorChainEndFn);\n    }\n    if (this.contributeToStability) {\n      const taskId = this.pendingTasks.add();\n      return this.chain(initialRequest, (downstreamRequest) => this.backend.handle(downstreamRequest)).pipe(finalize(() => this.pendingTasks.remove(taskId)));\n    } else {\n      return this.chain(initialRequest, (downstreamRequest) => this.backend.handle(downstreamRequest));\n    }\n  }\n  static \\u0275fac = function HttpInterceptorHandler_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _HttpInterceptorHandler)(\\u0275\\u0275inject(HttpBackend), \\u0275\\u0275inject(EnvironmentInjector));\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _HttpInterceptorHandler,\n    factory: _HttpInterceptorHandler.\\u0275fac\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(HttpInterceptorHandler, [{\n    type: Injectable\n  }], () => [{\n    type: HttpBackend\n  }, {\n    type: EnvironmentInjector\n  }], null);\n})();\nvar nextRequestId = 0;\nvar foreignDocument;\nvar JSONP_ERR_NO_CALLBACK = \"JSONP injected script did not invoke callback.\";\nvar JSONP_ERR_WRONG_METHOD = \"JSONP requests must use JSONP request method.\";\nvar JSONP_ERR_WRONG_RESPONSE_TYPE = \"JSONP requests must use Json response type.\";\nvar JSONP_ERR_HEADERS_NOT_SUPPORTED = \"JSONP requests do not support headers.\";\nvar JsonpCallbackContext = class {\n};\nfunction jsonpCallbackContext() {\n  if (typeof window === \"object\") {\n    return window;\n  }\n  return {};\n}\nvar JsonpClientBackend = class _JsonpClientBackend {\n  callbackMap;\n  document;\n  /**\n   * A resolved promise that can be used to schedule microtasks in the event handlers.\n   */\n  resolvedPromise = Promise.resolve();\n  constructor(callbackMap, document2) {\n    this.callbackMap = callbackMap;\n    this.document = document2;\n  }\n  /**\n   * Get the name of the next callback method, by incrementing the global `nextRequestId`.\n   */\n  nextCallback() {\n    return `ng_jsonp_callback_${nextRequestId++}`;\n  }\n  /**\n   * Processes a JSONP request and returns an event stream of the results.\n   * @param req The request object.\n   * @returns An observable of the response events.\n   *\n   */\n  handle(req) {\n    if (req.method !== \"JSONP\") {\n      throw new Error(JSONP_ERR_WRONG_METHOD);\n    } else if (req.responseType !== \"json\") {\n      throw new Error(JSONP_ERR_WRONG_RESPONSE_TYPE);\n    }\n    if (req.headers.keys().length > 0) {\n      throw new Error(JSONP_ERR_HEADERS_NOT_SUPPORTED);\n    }\n    return new Observable((observer) => {\n      const callback = this.nextCallback();\n      const url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, `=${callback}$1`);\n      const node = this.document.createElement(\"script\");\n      node.src = url;\n      let body = null;\n      let finished = false;\n      this.callbackMap[callback] = (data) => {\n        delete this.callbackMap[callback];\n        body = data;\n        finished = true;\n      };\n      const cleanup = () => {\n        node.removeEventListener(\"load\", onLoad);\n        node.removeEventListener(\"error\", onError);\n        node.remove();\n        delete this.callbackMap[callback];\n      };\n      const onLoad = (event) => {\n        this.resolvedPromise.then(() => {\n          cleanup();\n          if (!finished) {\n            observer.error(new HttpErrorResponse({\n              url,\n              status: 0,\n              statusText: \"JSONP Error\",\n              error: new Error(JSONP_ERR_NO_CALLBACK)\n            }));\n            return;\n          }\n          observer.next(new HttpResponse({\n            body,\n            status: HTTP_STATUS_CODE_OK,\n            statusText: \"OK\",\n            url\n          }));\n          observer.complete();\n        });\n      };\n      const onError = (error) => {\n        cleanup();\n        observer.error(new HttpErrorResponse({\n          error,\n          status: 0,\n          statusText: \"JSONP Error\",\n          url\n        }));\n      };\n      node.addEventListener(\"load\", onLoad);\n      node.addEventListener(\"error\", onError);\n      this.document.body.appendChild(node);\n      observer.next({\n        type: HttpEventType.Sent\n      });\n      return () => {\n        if (!finished) {\n          this.removeListeners(node);\n        }\n        cleanup();\n      };\n    });\n  }\n  removeListeners(script) {\n    foreignDocument ??= this.document.implementation.createHTMLDocument();\n    foreignDocument.adoptNode(script);\n  }\n  static \\u0275fac = function JsonpClientBackend_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _JsonpClientBackend)(\\u0275\\u0275inject(JsonpCallbackContext), \\u0275\\u0275inject(DOCUMENT2));\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _JsonpClientBackend,\n    factory: _JsonpClientBackend.\\u0275fac\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(JsonpClientBackend, [{\n    type: Injectable\n  }], () => [{\n    type: JsonpCallbackContext\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT2]\n    }]\n  }], null);\n})();\nfunction jsonpInterceptorFn(req, next) {\n  if (req.method === \"JSONP\") {\n    return inject(JsonpClientBackend).handle(req);\n  }\n  return next(req);\n}\nvar JsonpInterceptor = class _JsonpInterceptor {\n  injector;\n  constructor(injector) {\n    this.injector = injector;\n  }\n  /**\n   * Identifies and handles a given JSONP request.\n   * @param initialRequest The outgoing request object to handle.\n   * @param next The next interceptor in the chain, or the backend\n   * if no interceptors remain in the chain.\n   * @returns An observable of the event stream.\n   */\n  intercept(initialRequest, next) {\n    return runInInjectionContext(this.injector, () => jsonpInterceptorFn(initialRequest, (downstreamRequest) => next.handle(downstreamRequest)));\n  }\n  static \\u0275fac = function JsonpInterceptor_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _JsonpInterceptor)(\\u0275\\u0275inject(EnvironmentInjector));\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _JsonpInterceptor,\n    factory: _JsonpInterceptor.\\u0275fac\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(JsonpInterceptor, [{\n    type: Injectable\n  }], () => [{\n    type: EnvironmentInjector\n  }], null);\n})();\nvar XSSI_PREFIX = /^\\)\\]\\}',?\\n/;\nvar X_REQUEST_URL_REGEXP = RegExp(`^${X_REQUEST_URL_HEADER}:`, \"m\");\nfunction getResponseUrl(xhr) {\n  if (\"responseURL\" in xhr && xhr.responseURL) {\n    return xhr.responseURL;\n  }\n  if (X_REQUEST_URL_REGEXP.test(xhr.getAllResponseHeaders())) {\n    return xhr.getResponseHeader(X_REQUEST_URL_HEADER);\n  }\n  return null;\n}\nvar HttpXhrBackend = class _HttpXhrBackend {\n  xhrFactory;\n  constructor(xhrFactory) {\n    this.xhrFactory = xhrFactory;\n  }\n  /**\n   * Processes a request and returns a stream of response events.\n   * @param req The request object.\n   * @returns An observable of the response events.\n   */\n  handle(req) {\n    if (req.method === \"JSONP\") {\n      throw new RuntimeError(-2800, (typeof ngDevMode === \"undefined\" || ngDevMode) && `Cannot make a JSONP request without JSONP support. To fix the problem, either add the \\`withJsonpSupport()\\` call (if \\`provideHttpClient()\\` is used) or import the \\`HttpClientJsonpModule\\` in the root NgModule.`);\n    }\n    const xhrFactory = this.xhrFactory;\n    const source = xhrFactory.\\u0275loadImpl ? from(xhrFactory.\\u0275loadImpl()) : of(null);\n    return source.pipe(switchMap(() => {\n      return new Observable((observer) => {\n        const xhr = xhrFactory.build();\n        xhr.open(req.method, req.urlWithParams);\n        if (req.withCredentials) {\n          xhr.withCredentials = true;\n        }\n        req.headers.forEach((name, values) => xhr.setRequestHeader(name, values.join(\",\")));\n        if (!req.headers.has(ACCEPT_HEADER)) {\n          xhr.setRequestHeader(ACCEPT_HEADER, ACCEPT_HEADER_VALUE);\n        }\n        if (!req.headers.has(CONTENT_TYPE_HEADER)) {\n          const detectedType = req.detectContentTypeHeader();\n          if (detectedType !== null) {\n            xhr.setRequestHeader(CONTENT_TYPE_HEADER, detectedType);\n          }\n        }\n        if (req.responseType) {\n          const responseType = req.responseType.toLowerCase();\n          xhr.responseType = responseType !== \"json\" ? responseType : \"text\";\n        }\n        const reqBody = req.serializeBody();\n        let headerResponse = null;\n        const partialFromXhr = () => {\n          if (headerResponse !== null) {\n            return headerResponse;\n          }\n          const statusText = xhr.statusText || \"OK\";\n          const headers = new HttpHeaders(xhr.getAllResponseHeaders());\n          const url = getResponseUrl(xhr) || req.url;\n          headerResponse = new HttpHeaderResponse({\n            headers,\n            status: xhr.status,\n            statusText,\n            url\n          });\n          return headerResponse;\n        };\n        const onLoad = () => {\n          let {\n            headers,\n            status,\n            statusText,\n            url\n          } = partialFromXhr();\n          let body = null;\n          if (status !== HTTP_STATUS_CODE_NO_CONTENT) {\n            body = typeof xhr.response === \"undefined\" ? xhr.responseText : xhr.response;\n          }\n          if (status === 0) {\n            status = !!body ? HTTP_STATUS_CODE_OK : 0;\n          }\n          let ok = status >= 200 && status < 300;\n          if (req.responseType === \"json\" && typeof body === \"string\") {\n            const originalBody = body;\n            body = body.replace(XSSI_PREFIX, \"\");\n            try {\n              body = body !== \"\" ? JSON.parse(body) : null;\n            } catch (error) {\n              body = originalBody;\n              if (ok) {\n                ok = false;\n                body = {\n                  error,\n                  text: body\n                };\n              }\n            }\n          }\n          if (ok) {\n            observer.next(new HttpResponse({\n              body,\n              headers,\n              status,\n              statusText,\n              url: url || void 0\n            }));\n            observer.complete();\n          } else {\n            observer.error(new HttpErrorResponse({\n              // The error in this case is the response body (error from the server).\n              error: body,\n              headers,\n              status,\n              statusText,\n              url: url || void 0\n            }));\n          }\n        };\n        const onError = (error) => {\n          const {\n            url\n          } = partialFromXhr();\n          const res = new HttpErrorResponse({\n            error,\n            status: xhr.status || 0,\n            statusText: xhr.statusText || \"Unknown Error\",\n            url: url || void 0\n          });\n          observer.error(res);\n        };\n        let sentHeaders = false;\n        const onDownProgress = (event) => {\n          if (!sentHeaders) {\n            observer.next(partialFromXhr());\n            sentHeaders = true;\n          }\n          let progressEvent = {\n            type: HttpEventType.DownloadProgress,\n            loaded: event.loaded\n          };\n          if (event.lengthComputable) {\n            progressEvent.total = event.total;\n          }\n          if (req.responseType === \"text\" && !!xhr.responseText) {\n            progressEvent.partialText = xhr.responseText;\n          }\n          observer.next(progressEvent);\n        };\n        const onUpProgress = (event) => {\n          let progress = {\n            type: HttpEventType.UploadProgress,\n            loaded: event.loaded\n          };\n          if (event.lengthComputable) {\n            progress.total = event.total;\n          }\n          observer.next(progress);\n        };\n        xhr.addEventListener(\"load\", onLoad);\n        xhr.addEventListener(\"error\", onError);\n        xhr.addEventListener(\"timeout\", onError);\n        xhr.addEventListener(\"abort\", onError);\n        if (req.reportProgress) {\n          xhr.addEventListener(\"progress\", onDownProgress);\n          if (reqBody !== null && xhr.upload) {\n            xhr.upload.addEventListener(\"progress\", onUpProgress);\n          }\n        }\n        xhr.send(reqBody);\n        observer.next({\n          type: HttpEventType.Sent\n        });\n        return () => {\n          xhr.removeEventListener(\"error\", onError);\n          xhr.removeEventListener(\"abort\", onError);\n          xhr.removeEventListener(\"load\", onLoad);\n          xhr.removeEventListener(\"timeout\", onError);\n          if (req.reportProgress) {\n            xhr.removeEventListener(\"progress\", onDownProgress);\n            if (reqBody !== null && xhr.upload) {\n              xhr.upload.removeEventListener(\"progress\", onUpProgress);\n            }\n          }\n          if (xhr.readyState !== xhr.DONE) {\n            xhr.abort();\n          }\n        };\n      });\n    }));\n  }\n  static \\u0275fac = function HttpXhrBackend_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _HttpXhrBackend)(\\u0275\\u0275inject(XhrFactory));\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _HttpXhrBackend,\n    factory: _HttpXhrBackend.\\u0275fac\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(HttpXhrBackend, [{\n    type: Injectable\n  }], () => [{\n    type: XhrFactory\n  }], null);\n})();\nvar XSRF_ENABLED = new InjectionToken(ngDevMode ? \"XSRF_ENABLED\" : \"\");\nvar XSRF_DEFAULT_COOKIE_NAME = \"XSRF-TOKEN\";\nvar XSRF_COOKIE_NAME = new InjectionToken(ngDevMode ? \"XSRF_COOKIE_NAME\" : \"\", {\n  providedIn: \"root\",\n  factory: () => XSRF_DEFAULT_COOKIE_NAME\n});\nvar XSRF_DEFAULT_HEADER_NAME = \"X-XSRF-TOKEN\";\nvar XSRF_HEADER_NAME = new InjectionToken(ngDevMode ? \"XSRF_HEADER_NAME\" : \"\", {\n  providedIn: \"root\",\n  factory: () => XSRF_DEFAULT_HEADER_NAME\n});\nvar HttpXsrfTokenExtractor = class {\n};\nvar HttpXsrfCookieExtractor = class _HttpXsrfCookieExtractor {\n  doc;\n  platform;\n  cookieName;\n  lastCookieString = \"\";\n  lastToken = null;\n  /**\n   * @internal for testing\n   */\n  parseCount = 0;\n  constructor(doc, platform, cookieName) {\n    this.doc = doc;\n    this.platform = platform;\n    this.cookieName = cookieName;\n  }\n  getToken() {\n    if (this.platform === \"server\") {\n      return null;\n    }\n    const cookieString = this.doc.cookie || \"\";\n    if (cookieString !== this.lastCookieString) {\n      this.parseCount++;\n      this.lastToken = parseCookieValue(cookieString, this.cookieName);\n      this.lastCookieString = cookieString;\n    }\n    return this.lastToken;\n  }\n  static \\u0275fac = function HttpXsrfCookieExtractor_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _HttpXsrfCookieExtractor)(\\u0275\\u0275inject(DOCUMENT2), \\u0275\\u0275inject(PLATFORM_ID), \\u0275\\u0275inject(XSRF_COOKIE_NAME));\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _HttpXsrfCookieExtractor,\n    factory: _HttpXsrfCookieExtractor.\\u0275fac\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(HttpXsrfCookieExtractor, [{\n    type: Injectable\n  }], () => [{\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT2]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [PLATFORM_ID]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [XSRF_COOKIE_NAME]\n    }]\n  }], null);\n})();\nfunction xsrfInterceptorFn(req, next) {\n  const lcUrl = req.url.toLowerCase();\n  if (!inject(XSRF_ENABLED) || req.method === \"GET\" || req.method === \"HEAD\" || lcUrl.startsWith(\"http://\") || lcUrl.startsWith(\"https://\")) {\n    return next(req);\n  }\n  const token = inject(HttpXsrfTokenExtractor).getToken();\n  const headerName = inject(XSRF_HEADER_NAME);\n  if (token != null && !req.headers.has(headerName)) {\n    req = req.clone({\n      headers: req.headers.set(headerName, token)\n    });\n  }\n  return next(req);\n}\nvar HttpXsrfInterceptor = class _HttpXsrfInterceptor {\n  injector;\n  constructor(injector) {\n    this.injector = injector;\n  }\n  intercept(initialRequest, next) {\n    return runInInjectionContext(this.injector, () => xsrfInterceptorFn(initialRequest, (downstreamRequest) => next.handle(downstreamRequest)));\n  }\n  static \\u0275fac = function HttpXsrfInterceptor_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _HttpXsrfInterceptor)(\\u0275\\u0275inject(EnvironmentInjector));\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _HttpXsrfInterceptor,\n    factory: _HttpXsrfInterceptor.\\u0275fac\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(HttpXsrfInterceptor, [{\n    type: Injectable\n  }], () => [{\n    type: EnvironmentInjector\n  }], null);\n})();\nvar HttpFeatureKind;\n(function(HttpFeatureKind2) {\n  HttpFeatureKind2[HttpFeatureKind2[\"Interceptors\"] = 0] = \"Interceptors\";\n  HttpFeatureKind2[HttpFeatureKind2[\"LegacyInterceptors\"] = 1] = \"LegacyInterceptors\";\n  HttpFeatureKind2[HttpFeatureKind2[\"CustomXsrfConfiguration\"] = 2] = \"CustomXsrfConfiguration\";\n  HttpFeatureKind2[HttpFeatureKind2[\"NoXsrfProtection\"] = 3] = \"NoXsrfProtection\";\n  HttpFeatureKind2[HttpFeatureKind2[\"JsonpSupport\"] = 4] = \"JsonpSupport\";\n  HttpFeatureKind2[HttpFeatureKind2[\"RequestsMadeViaParent\"] = 5] = \"RequestsMadeViaParent\";\n  HttpFeatureKind2[HttpFeatureKind2[\"Fetch\"] = 6] = \"Fetch\";\n})(HttpFeatureKind || (HttpFeatureKind = {}));\nfunction makeHttpFeature(kind, providers) {\n  return {\n    \\u0275kind: kind,\n    \\u0275providers: providers\n  };\n}\nfunction provideHttpClient(...features) {\n  if (ngDevMode) {\n    const featureKinds = new Set(features.map((f) => f.\\u0275kind));\n    if (featureKinds.has(HttpFeatureKind.NoXsrfProtection) && featureKinds.has(HttpFeatureKind.CustomXsrfConfiguration)) {\n      throw new Error(ngDevMode ? `Configuration error: found both withXsrfConfiguration() and withNoXsrfProtection() in the same call to provideHttpClient(), which is a contradiction.` : \"\");\n    }\n  }\n  const providers = [HttpClient, HttpXhrBackend, HttpInterceptorHandler, {\n    provide: HttpHandler,\n    useExisting: HttpInterceptorHandler\n  }, {\n    provide: HttpBackend,\n    useFactory: () => {\n      return inject(FETCH_BACKEND, {\n        optional: true\n      }) ?? inject(HttpXhrBackend);\n    }\n  }, {\n    provide: HTTP_INTERCEPTOR_FNS,\n    useValue: xsrfInterceptorFn,\n    multi: true\n  }, {\n    provide: XSRF_ENABLED,\n    useValue: true\n  }, {\n    provide: HttpXsrfTokenExtractor,\n    useClass: HttpXsrfCookieExtractor\n  }];\n  for (const feature of features) {\n    providers.push(...feature.\\u0275providers);\n  }\n  return makeEnvironmentProviders(providers);\n}\nvar LEGACY_INTERCEPTOR_FN = new InjectionToken(ngDevMode ? \"LEGACY_INTERCEPTOR_FN\" : \"\");\nfunction withInterceptorsFromDi() {\n  return makeHttpFeature(HttpFeatureKind.LegacyInterceptors, [{\n    provide: LEGACY_INTERCEPTOR_FN,\n    useFactory: legacyInterceptorFnFactory\n  }, {\n    provide: HTTP_INTERCEPTOR_FNS,\n    useExisting: LEGACY_INTERCEPTOR_FN,\n    multi: true\n  }]);\n}\nfunction withXsrfConfiguration({\n  cookieName,\n  headerName\n}) {\n  const providers = [];\n  if (cookieName !== void 0) {\n    providers.push({\n      provide: XSRF_COOKIE_NAME,\n      useValue: cookieName\n    });\n  }\n  if (headerName !== void 0) {\n    providers.push({\n      provide: XSRF_HEADER_NAME,\n      useValue: headerName\n    });\n  }\n  return makeHttpFeature(HttpFeatureKind.CustomXsrfConfiguration, providers);\n}\nfunction withNoXsrfProtection() {\n  return makeHttpFeature(HttpFeatureKind.NoXsrfProtection, [{\n    provide: XSRF_ENABLED,\n    useValue: false\n  }]);\n}\nfunction withJsonpSupport() {\n  return makeHttpFeature(HttpFeatureKind.JsonpSupport, [JsonpClientBackend, {\n    provide: JsonpCallbackContext,\n    useFactory: jsonpCallbackContext\n  }, {\n    provide: HTTP_INTERCEPTOR_FNS,\n    useValue: jsonpInterceptorFn,\n    multi: true\n  }]);\n}\nvar HttpClientXsrfModule = class _HttpClientXsrfModule {\n  /**\n   * Disable the default XSRF protection.\n   */\n  static disable() {\n    return {\n      ngModule: _HttpClientXsrfModule,\n      providers: [withNoXsrfProtection().\\u0275providers]\n    };\n  }\n  /**\n   * Configure XSRF protection.\n   * @param options An object that can specify either or both\n   * cookie name or header name.\n   * - Cookie name default is `XSRF-TOKEN`.\n   * - Header name default is `X-XSRF-TOKEN`.\n   *\n   */\n  static withOptions(options = {}) {\n    return {\n      ngModule: _HttpClientXsrfModule,\n      providers: withXsrfConfiguration(options).\\u0275providers\n    };\n  }\n  static \\u0275fac = function HttpClientXsrfModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _HttpClientXsrfModule)();\n  };\n  static \\u0275mod = /* @__PURE__ */ \\u0275\\u0275defineNgModule({\n    type: _HttpClientXsrfModule\n  });\n  static \\u0275inj = /* @__PURE__ */ \\u0275\\u0275defineInjector({\n    providers: [HttpXsrfInterceptor, {\n      provide: HTTP_INTERCEPTORS,\n      useExisting: HttpXsrfInterceptor,\n      multi: true\n    }, {\n      provide: HttpXsrfTokenExtractor,\n      useClass: HttpXsrfCookieExtractor\n    }, withXsrfConfiguration({\n      cookieName: XSRF_DEFAULT_COOKIE_NAME,\n      headerName: XSRF_DEFAULT_HEADER_NAME\n    }).\\u0275providers, {\n      provide: XSRF_ENABLED,\n      useValue: true\n    }]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(HttpClientXsrfModule, [{\n    type: NgModule,\n    args: [{\n      providers: [HttpXsrfInterceptor, {\n        provide: HTTP_INTERCEPTORS,\n        useExisting: HttpXsrfInterceptor,\n        multi: true\n      }, {\n        provide: HttpXsrfTokenExtractor,\n        useClass: HttpXsrfCookieExtractor\n      }, withXsrfConfiguration({\n        cookieName: XSRF_DEFAULT_COOKIE_NAME,\n        headerName: XSRF_DEFAULT_HEADER_NAME\n      }).\\u0275providers, {\n        provide: XSRF_ENABLED,\n        useValue: true\n      }]\n    }]\n  }], null, null);\n})();\nvar HttpClientModule = class _HttpClientModule {\n  static \\u0275fac = function HttpClientModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _HttpClientModule)();\n  };\n  static \\u0275mod = /* @__PURE__ */ \\u0275\\u0275defineNgModule({\n    type: _HttpClientModule\n  });\n  static \\u0275inj = /* @__PURE__ */ \\u0275\\u0275defineInjector({\n    providers: [provideHttpClient(withInterceptorsFromDi())]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(HttpClientModule, [{\n    type: NgModule,\n    args: [{\n      /**\n       * Configures the dependency injector where it is imported\n       * with supporting services for HTTP communications.\n       */\n      providers: [provideHttpClient(withInterceptorsFromDi())]\n    }]\n  }], null, null);\n})();\nvar HttpClientJsonpModule = class _HttpClientJsonpModule {\n  static \\u0275fac = function HttpClientJsonpModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _HttpClientJsonpModule)();\n  };\n  static \\u0275mod = /* @__PURE__ */ \\u0275\\u0275defineNgModule({\n    type: _HttpClientJsonpModule\n  });\n  static \\u0275inj = /* @__PURE__ */ \\u0275\\u0275defineInjector({\n    providers: [withJsonpSupport().\\u0275providers]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(HttpClientJsonpModule, [{\n    type: NgModule,\n    args: [{\n      providers: [withJsonpSupport().\\u0275providers]\n    }]\n  }], null, null);\n})();\nvar httpResource = (() => {\n  const jsonFn = makeHttpResourceFn(\"json\");\n  jsonFn.arrayBuffer = makeHttpResourceFn(\"arraybuffer\");\n  jsonFn.blob = makeHttpResourceFn(\"blob\");\n  jsonFn.text = makeHttpResourceFn(\"text\");\n  return jsonFn;\n})();\nfunction makeHttpResourceFn(responseType) {\n  return function httpResourceRef(request, options) {\n    options?.injector || assertInInjectionContext(httpResource);\n    const injector = options?.injector ?? inject(Injector);\n    return new HttpResourceImpl(injector, () => normalizeRequest(request, responseType), options?.defaultValue, options?.parse, options?.equal);\n  };\n}\nfunction normalizeRequest(request, responseType) {\n  let unwrappedRequest = typeof request === \"function\" ? request() : request;\n  if (unwrappedRequest === void 0) {\n    return void 0;\n  } else if (typeof unwrappedRequest === \"string\") {\n    unwrappedRequest = {\n      url: unwrappedRequest\n    };\n  }\n  const headers = unwrappedRequest.headers instanceof HttpHeaders ? unwrappedRequest.headers : new HttpHeaders(unwrappedRequest.headers);\n  const params = unwrappedRequest.params instanceof HttpParams ? unwrappedRequest.params : new HttpParams({\n    fromObject: unwrappedRequest.params\n  });\n  return new HttpRequest(unwrappedRequest.method ?? \"GET\", unwrappedRequest.url, unwrappedRequest.body ?? null, {\n    headers,\n    params,\n    reportProgress: unwrappedRequest.reportProgress,\n    withCredentials: unwrappedRequest.withCredentials,\n    responseType,\n    context: unwrappedRequest.context,\n    transferCache: unwrappedRequest.transferCache\n  });\n}\nvar HttpResourceImpl = class extends ResourceImpl {\n  client;\n  _headers = linkedSignal({\n    source: this.extRequest,\n    computation: () => void 0\n  });\n  _progress = linkedSignal({\n    source: this.extRequest,\n    computation: () => void 0\n  });\n  _statusCode = linkedSignal({\n    source: this.extRequest,\n    computation: () => void 0\n  });\n  headers = computed(() => this.status() === ResourceStatus.Resolved || this.status() === ResourceStatus.Error ? this._headers() : void 0);\n  progress = this._progress.asReadonly();\n  statusCode = this._statusCode.asReadonly();\n  constructor(injector, request, defaultValue, parse, equal) {\n    super(request, ({\n      request: request2,\n      abortSignal\n    }) => {\n      let sub;\n      const onAbort = () => sub.unsubscribe();\n      abortSignal.addEventListener(\"abort\", onAbort);\n      const stream = signal({\n        value: void 0\n      });\n      let resolve;\n      const promise = new Promise((r) => resolve = r);\n      const send = (value) => {\n        stream.set(value);\n        resolve?.(stream);\n        resolve = void 0;\n      };\n      sub = this.client.request(request2).subscribe({\n        next: (event) => {\n          switch (event.type) {\n            case HttpEventType.Response:\n              this._headers.set(event.headers);\n              this._statusCode.set(event.status);\n              try {\n                send({\n                  value: parse ? parse(event.body) : event.body\n                });\n              } catch (error) {\n                send({\n                  error\n                });\n              }\n              break;\n            case HttpEventType.DownloadProgress:\n              this._progress.set(event);\n              break;\n          }\n        },\n        error: (error) => send({\n          error\n        }),\n        complete: () => {\n          if (resolve) {\n            send({\n              error: new Error(\"Resource completed before producing a value\")\n            });\n          }\n          abortSignal.removeEventListener(\"abort\", onAbort);\n        }\n      });\n      return promise;\n    }, defaultValue, equal, injector);\n    this.client = injector.get(HttpClient);\n  }\n};\nvar HTTP_TRANSFER_CACHE_ORIGIN_MAP = new InjectionToken(ngDevMode ? \"HTTP_TRANSFER_CACHE_ORIGIN_MAP\" : \"\");\nvar CACHE_OPTIONS = new InjectionToken(ngDevMode ? \"HTTP_TRANSFER_STATE_CACHE_OPTIONS\" : \"\");\n\n// node_modules/@angular/platform-browser/fesm2022/platform-browser.mjs\nvar GenericBrowserDomAdapter = class extends DomAdapter {\n  supportsDOMEvents = true;\n};\nvar BrowserDomAdapter = class _BrowserDomAdapter extends GenericBrowserDomAdapter {\n  static makeCurrent() {\n    setRootDomAdapter(new _BrowserDomAdapter());\n  }\n  onAndCancel(el, evt, listener, options) {\n    el.addEventListener(evt, listener, options);\n    return () => {\n      el.removeEventListener(evt, listener, options);\n    };\n  }\n  dispatchEvent(el, evt) {\n    el.dispatchEvent(evt);\n  }\n  remove(node) {\n    node.remove();\n  }\n  createElement(tagName, doc) {\n    doc = doc || this.getDefaultDocument();\n    return doc.createElement(tagName);\n  }\n  createHtmlDocument() {\n    return document.implementation.createHTMLDocument(\"fakeTitle\");\n  }\n  getDefaultDocument() {\n    return document;\n  }\n  isElementNode(node) {\n    return node.nodeType === Node.ELEMENT_NODE;\n  }\n  isShadowRoot(node) {\n    return node instanceof DocumentFragment;\n  }\n  /** @deprecated No longer being used in Ivy code. To be removed in version 14. */\n  getGlobalEventTarget(doc, target) {\n    if (target === \"window\") {\n      return window;\n    }\n    if (target === \"document\") {\n      return doc;\n    }\n    if (target === \"body\") {\n      return doc.body;\n    }\n    return null;\n  }\n  getBaseHref(doc) {\n    const href = getBaseElementHref();\n    return href == null ? null : relativePath(href);\n  }\n  resetBaseElement() {\n    baseElement = null;\n  }\n  getUserAgent() {\n    return window.navigator.userAgent;\n  }\n  getCookie(name) {\n    return parseCookieValue(document.cookie, name);\n  }\n};\nvar baseElement = null;\nfunction getBaseElementHref() {\n  baseElement = baseElement || document.querySelector(\"base\");\n  return baseElement ? baseElement.getAttribute(\"href\") : null;\n}\nfunction relativePath(url) {\n  return new URL(url, document.baseURI).pathname;\n}\nvar BrowserGetTestability = class {\n  addToWindow(registry) {\n    _global[\"getAngularTestability\"] = (elem, findInAncestors = true) => {\n      const testability = registry.findTestabilityInTree(elem, findInAncestors);\n      if (testability == null) {\n        throw new RuntimeError(5103, (typeof ngDevMode === \"undefined\" || ngDevMode) && \"Could not find testability for element.\");\n      }\n      return testability;\n    };\n    _global[\"getAllAngularTestabilities\"] = () => registry.getAllTestabilities();\n    _global[\"getAllAngularRootElements\"] = () => registry.getAllRootElements();\n    const whenAllStable = (callback) => {\n      const testabilities = _global[\"getAllAngularTestabilities\"]();\n      let count = testabilities.length;\n      const decrement = function() {\n        count--;\n        if (count == 0) {\n          callback();\n        }\n      };\n      testabilities.forEach((testability) => {\n        testability.whenStable(decrement);\n      });\n    };\n    if (!_global[\"frameworkStabilizers\"]) {\n      _global[\"frameworkStabilizers\"] = [];\n    }\n    _global[\"frameworkStabilizers\"].push(whenAllStable);\n  }\n  findTestabilityInTree(registry, elem, findInAncestors) {\n    if (elem == null) {\n      return null;\n    }\n    const t = registry.getTestability(elem);\n    if (t != null) {\n      return t;\n    } else if (!findInAncestors) {\n      return null;\n    }\n    if (getDOM().isShadowRoot(elem)) {\n      return this.findTestabilityInTree(registry, elem.host, true);\n    }\n    return this.findTestabilityInTree(registry, elem.parentElement, true);\n  }\n};\nvar BrowserXhr = class _BrowserXhr {\n  build() {\n    return new XMLHttpRequest();\n  }\n  static \\u0275fac = function BrowserXhr_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _BrowserXhr)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _BrowserXhr,\n    factory: _BrowserXhr.\\u0275fac\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(BrowserXhr, [{\n    type: Injectable\n  }], null, null);\n})();\nvar EVENT_MANAGER_PLUGINS = new InjectionToken(ngDevMode ? \"EventManagerPlugins\" : \"\");\nvar EventManager = class _EventManager {\n  _zone;\n  _plugins;\n  _eventNameToPlugin = /* @__PURE__ */ new Map();\n  /**\n   * Initializes an instance of the event-manager service.\n   */\n  constructor(plugins, _zone) {\n    this._zone = _zone;\n    plugins.forEach((plugin) => {\n      plugin.manager = this;\n    });\n    this._plugins = plugins.slice().reverse();\n  }\n  /**\n   * Registers a handler for a specific element and event.\n   *\n   * @param element The HTML element to receive event notifications.\n   * @param eventName The name of the event to listen for.\n   * @param handler A function to call when the notification occurs. Receives the\n   * event object as an argument.\n   * @param options Options that configure how the event listener is bound.\n   * @returns  A callback function that can be used to remove the handler.\n   */\n  addEventListener(element, eventName, handler, options) {\n    const plugin = this._findPluginFor(eventName);\n    return plugin.addEventListener(element, eventName, handler, options);\n  }\n  /**\n   * Retrieves the compilation zone in which event listeners are registered.\n   */\n  getZone() {\n    return this._zone;\n  }\n  /** @internal */\n  _findPluginFor(eventName) {\n    let plugin = this._eventNameToPlugin.get(eventName);\n    if (plugin) {\n      return plugin;\n    }\n    const plugins = this._plugins;\n    plugin = plugins.find((plugin2) => plugin2.supports(eventName));\n    if (!plugin) {\n      throw new RuntimeError(5101, (typeof ngDevMode === \"undefined\" || ngDevMode) && `No event manager plugin found for event ${eventName}`);\n    }\n    this._eventNameToPlugin.set(eventName, plugin);\n    return plugin;\n  }\n  static \\u0275fac = function EventManager_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _EventManager)(\\u0275\\u0275inject(EVENT_MANAGER_PLUGINS), \\u0275\\u0275inject(NgZone));\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _EventManager,\n    factory: _EventManager.\\u0275fac\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(EventManager, [{\n    type: Injectable\n  }], () => [{\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [EVENT_MANAGER_PLUGINS]\n    }]\n  }, {\n    type: NgZone\n  }], null);\n})();\nvar EventManagerPlugin = class {\n  _doc;\n  // TODO: remove (has some usage in G3)\n  constructor(_doc) {\n    this._doc = _doc;\n  }\n  // Using non-null assertion because it's set by EventManager's constructor\n  manager;\n};\nvar APP_ID_ATTRIBUTE_NAME = \"ng-app-id\";\nfunction removeElements(elements) {\n  for (const element of elements) {\n    element.remove();\n  }\n}\nfunction createStyleElement(style, doc) {\n  const styleElement = doc.createElement(\"style\");\n  styleElement.textContent = style;\n  return styleElement;\n}\nfunction addServerStyles(doc, appId, inline, external) {\n  const elements = doc.head?.querySelectorAll(`style[${APP_ID_ATTRIBUTE_NAME}=\"${appId}\"],link[${APP_ID_ATTRIBUTE_NAME}=\"${appId}\"]`);\n  if (elements) {\n    for (const styleElement of elements) {\n      styleElement.removeAttribute(APP_ID_ATTRIBUTE_NAME);\n      if (styleElement instanceof HTMLLinkElement) {\n        external.set(styleElement.href.slice(styleElement.href.lastIndexOf(\"/\") + 1), {\n          usage: 0,\n          elements: [styleElement]\n        });\n      } else if (styleElement.textContent) {\n        inline.set(styleElement.textContent, {\n          usage: 0,\n          elements: [styleElement]\n        });\n      }\n    }\n  }\n}\nfunction createLinkElement(url, doc) {\n  const linkElement = doc.createElement(\"link\");\n  linkElement.setAttribute(\"rel\", \"stylesheet\");\n  linkElement.setAttribute(\"href\", url);\n  return linkElement;\n}\nvar SharedStylesHost = class _SharedStylesHost {\n  doc;\n  appId;\n  nonce;\n  /**\n   * Provides usage information for active inline style content and associated HTML <style> elements.\n   * Embedded styles typically originate from the `styles` metadata of a rendered component.\n   */\n  inline = /* @__PURE__ */ new Map();\n  /**\n   * Provides usage information for active external style URLs and the associated HTML <link> elements.\n   * External styles typically originate from the `ɵɵExternalStylesFeature` of a rendered component.\n   */\n  external = /* @__PURE__ */ new Map();\n  /**\n   * Set of host DOM nodes that will have styles attached.\n   */\n  hosts = /* @__PURE__ */ new Set();\n  /**\n   * Whether the application code is currently executing on a server.\n   */\n  isServer;\n  constructor(doc, appId, nonce, platformId = {}) {\n    this.doc = doc;\n    this.appId = appId;\n    this.nonce = nonce;\n    this.isServer = isPlatformServer(platformId);\n    addServerStyles(doc, appId, this.inline, this.external);\n    this.hosts.add(doc.head);\n  }\n  /**\n   * Adds embedded styles to the DOM via HTML `style` elements.\n   * @param styles An array of style content strings.\n   */\n  addStyles(styles, urls) {\n    for (const value of styles) {\n      this.addUsage(value, this.inline, createStyleElement);\n    }\n    urls?.forEach((value) => this.addUsage(value, this.external, createLinkElement));\n  }\n  /**\n   * Removes embedded styles from the DOM that were added as HTML `style` elements.\n   * @param styles An array of style content strings.\n   */\n  removeStyles(styles, urls) {\n    for (const value of styles) {\n      this.removeUsage(value, this.inline);\n    }\n    urls?.forEach((value) => this.removeUsage(value, this.external));\n  }\n  addUsage(value, usages, creator) {\n    const record = usages.get(value);\n    if (record) {\n      if ((typeof ngDevMode === \"undefined\" || ngDevMode) && record.usage === 0) {\n        record.elements.forEach((element) => element.setAttribute(\"ng-style-reused\", \"\"));\n      }\n      record.usage++;\n    } else {\n      usages.set(value, {\n        usage: 1,\n        elements: [...this.hosts].map((host) => this.addElement(host, creator(value, this.doc)))\n      });\n    }\n  }\n  removeUsage(value, usages) {\n    const record = usages.get(value);\n    if (record) {\n      record.usage--;\n      if (record.usage <= 0) {\n        removeElements(record.elements);\n        usages.delete(value);\n      }\n    }\n  }\n  ngOnDestroy() {\n    for (const [, {\n      elements\n    }] of [...this.inline, ...this.external]) {\n      removeElements(elements);\n    }\n    this.hosts.clear();\n  }\n  /**\n   * Adds a host node to the set of style hosts and adds all existing style usage to\n   * the newly added host node.\n   *\n   * This is currently only used for Shadow DOM encapsulation mode.\n   */\n  addHost(hostNode) {\n    this.hosts.add(hostNode);\n    for (const [style, {\n      elements\n    }] of this.inline) {\n      elements.push(this.addElement(hostNode, createStyleElement(style, this.doc)));\n    }\n    for (const [url, {\n      elements\n    }] of this.external) {\n      elements.push(this.addElement(hostNode, createLinkElement(url, this.doc)));\n    }\n  }\n  removeHost(hostNode) {\n    this.hosts.delete(hostNode);\n  }\n  addElement(host, element) {\n    if (this.nonce) {\n      element.setAttribute(\"nonce\", this.nonce);\n    }\n    if (this.isServer) {\n      element.setAttribute(APP_ID_ATTRIBUTE_NAME, this.appId);\n    }\n    return host.appendChild(element);\n  }\n  static \\u0275fac = function SharedStylesHost_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _SharedStylesHost)(\\u0275\\u0275inject(DOCUMENT2), \\u0275\\u0275inject(APP_ID), \\u0275\\u0275inject(CSP_NONCE, 8), \\u0275\\u0275inject(PLATFORM_ID));\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _SharedStylesHost,\n    factory: _SharedStylesHost.\\u0275fac\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(SharedStylesHost, [{\n    type: Injectable\n  }], () => [{\n    type: Document,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT2]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [APP_ID]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [CSP_NONCE]\n    }, {\n      type: Optional\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [PLATFORM_ID]\n    }]\n  }], null);\n})();\nvar NAMESPACE_URIS = {\n  \"svg\": \"http://www.w3.org/2000/svg\",\n  \"xhtml\": \"http://www.w3.org/1999/xhtml\",\n  \"xlink\": \"http://www.w3.org/1999/xlink\",\n  \"xml\": \"http://www.w3.org/XML/1998/namespace\",\n  \"xmlns\": \"http://www.w3.org/2000/xmlns/\",\n  \"math\": \"http://www.w3.org/1998/Math/MathML\"\n};\nvar COMPONENT_REGEX = /%COMP%/g;\nvar SOURCEMAP_URL_REGEXP = /\\/\\*#\\s*sourceMappingURL=(.+?)\\s*\\*\\//;\nvar PROTOCOL_REGEXP = /^https?:/;\nvar COMPONENT_VARIABLE = \"%COMP%\";\nvar HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;\nvar CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;\nvar REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT = true;\nvar REMOVE_STYLES_ON_COMPONENT_DESTROY = new InjectionToken(ngDevMode ? \"RemoveStylesOnCompDestroy\" : \"\", {\n  providedIn: \"root\",\n  factory: () => REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT\n});\nfunction shimContentAttribute(componentShortId) {\n  return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);\n}\nfunction shimHostAttribute(componentShortId) {\n  return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);\n}\nfunction shimStylesContent(compId, styles) {\n  return styles.map((s) => s.replace(COMPONENT_REGEX, compId));\n}\nfunction addBaseHrefToCssSourceMap(baseHref, styles) {\n  if (!baseHref) {\n    return styles;\n  }\n  const absoluteBaseHrefUrl = new URL(baseHref, \"http://localhost\");\n  return styles.map((cssContent) => {\n    if (!cssContent.includes(\"sourceMappingURL=\")) {\n      return cssContent;\n    }\n    return cssContent.replace(SOURCEMAP_URL_REGEXP, (_, sourceMapUrl) => {\n      if (sourceMapUrl[0] === \"/\" || sourceMapUrl.startsWith(\"data:\") || PROTOCOL_REGEXP.test(sourceMapUrl)) {\n        return `/*# sourceMappingURL=${sourceMapUrl} */`;\n      }\n      const {\n        pathname: resolvedSourceMapUrl\n      } = new URL(sourceMapUrl, absoluteBaseHrefUrl);\n      return `/*# sourceMappingURL=${resolvedSourceMapUrl} */`;\n    });\n  });\n}\nvar DomRendererFactory2 = class _DomRendererFactory2 {\n  eventManager;\n  sharedStylesHost;\n  appId;\n  removeStylesOnCompDestroy;\n  doc;\n  platformId;\n  ngZone;\n  nonce;\n  tracingService;\n  rendererByCompId = /* @__PURE__ */ new Map();\n  defaultRenderer;\n  platformIsServer;\n  constructor(eventManager, sharedStylesHost, appId, removeStylesOnCompDestroy, doc, platformId, ngZone, nonce = null, tracingService = null) {\n    this.eventManager = eventManager;\n    this.sharedStylesHost = sharedStylesHost;\n    this.appId = appId;\n    this.removeStylesOnCompDestroy = removeStylesOnCompDestroy;\n    this.doc = doc;\n    this.platformId = platformId;\n    this.ngZone = ngZone;\n    this.nonce = nonce;\n    this.tracingService = tracingService;\n    this.platformIsServer = isPlatformServer(platformId);\n    this.defaultRenderer = new DefaultDomRenderer2(eventManager, doc, ngZone, this.platformIsServer, this.tracingService);\n  }\n  createRenderer(element, type) {\n    if (!element || !type) {\n      return this.defaultRenderer;\n    }\n    if (this.platformIsServer && type.encapsulation === ViewEncapsulation.ShadowDom) {\n      type = __spreadProps(__spreadValues({}, type), {\n        encapsulation: ViewEncapsulation.Emulated\n      });\n    }\n    const renderer = this.getOrCreateRenderer(element, type);\n    if (renderer instanceof EmulatedEncapsulationDomRenderer2) {\n      renderer.applyToHost(element);\n    } else if (renderer instanceof NoneEncapsulationDomRenderer) {\n      renderer.applyStyles();\n    }\n    return renderer;\n  }\n  getOrCreateRenderer(element, type) {\n    const rendererByCompId = this.rendererByCompId;\n    let renderer = rendererByCompId.get(type.id);\n    if (!renderer) {\n      const doc = this.doc;\n      const ngZone = this.ngZone;\n      const eventManager = this.eventManager;\n      const sharedStylesHost = this.sharedStylesHost;\n      const removeStylesOnCompDestroy = this.removeStylesOnCompDestroy;\n      const platformIsServer = this.platformIsServer;\n      const tracingService = this.tracingService;\n      switch (type.encapsulation) {\n        case ViewEncapsulation.Emulated:\n          renderer = new EmulatedEncapsulationDomRenderer2(eventManager, sharedStylesHost, type, this.appId, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, tracingService);\n          break;\n        case ViewEncapsulation.ShadowDom:\n          return new ShadowDomRenderer(eventManager, sharedStylesHost, element, type, doc, ngZone, this.nonce, platformIsServer, tracingService);\n        default:\n          renderer = new NoneEncapsulationDomRenderer(eventManager, sharedStylesHost, type, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, tracingService);\n          break;\n      }\n      rendererByCompId.set(type.id, renderer);\n    }\n    return renderer;\n  }\n  ngOnDestroy() {\n    this.rendererByCompId.clear();\n  }\n  /**\n   * Used during HMR to clear any cached data about a component.\n   * @param componentId ID of the component that is being replaced.\n   */\n  componentReplaced(componentId) {\n    this.rendererByCompId.delete(componentId);\n  }\n  static \\u0275fac = function DomRendererFactory2_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _DomRendererFactory2)(\\u0275\\u0275inject(EventManager), \\u0275\\u0275inject(SharedStylesHost), \\u0275\\u0275inject(APP_ID), \\u0275\\u0275inject(REMOVE_STYLES_ON_COMPONENT_DESTROY), \\u0275\\u0275inject(DOCUMENT2), \\u0275\\u0275inject(PLATFORM_ID), \\u0275\\u0275inject(NgZone), \\u0275\\u0275inject(CSP_NONCE), \\u0275\\u0275inject(TracingService, 8));\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _DomRendererFactory2,\n    factory: _DomRendererFactory2.\\u0275fac\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(DomRendererFactory2, [{\n    type: Injectable\n  }], () => [{\n    type: EventManager\n  }, {\n    type: SharedStylesHost\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [APP_ID]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [REMOVE_STYLES_ON_COMPONENT_DESTROY]\n    }]\n  }, {\n    type: Document,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT2]\n    }]\n  }, {\n    type: Object,\n    decorators: [{\n      type: Inject,\n      args: [PLATFORM_ID]\n    }]\n  }, {\n    type: NgZone\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [CSP_NONCE]\n    }]\n  }, {\n    type: TracingService,\n    decorators: [{\n      type: Inject,\n      args: [TracingService]\n    }, {\n      type: Optional\n    }]\n  }], null);\n})();\nvar DefaultDomRenderer2 = class {\n  eventManager;\n  doc;\n  ngZone;\n  platformIsServer;\n  tracingService;\n  data = /* @__PURE__ */ Object.create(null);\n  /**\n   * By default this renderer throws when encountering synthetic properties\n   * This can be disabled for example by the AsyncAnimationRendererFactory\n   */\n  throwOnSyntheticProps = true;\n  constructor(eventManager, doc, ngZone, platformIsServer, tracingService) {\n    this.eventManager = eventManager;\n    this.doc = doc;\n    this.ngZone = ngZone;\n    this.platformIsServer = platformIsServer;\n    this.tracingService = tracingService;\n  }\n  destroy() {\n  }\n  destroyNode = null;\n  createElement(name, namespace) {\n    if (namespace) {\n      return this.doc.createElementNS(NAMESPACE_URIS[namespace] || namespace, name);\n    }\n    return this.doc.createElement(name);\n  }\n  createComment(value) {\n    return this.doc.createComment(value);\n  }\n  createText(value) {\n    return this.doc.createTextNode(value);\n  }\n  appendChild(parent, newChild) {\n    const targetParent = isTemplateNode(parent) ? parent.content : parent;\n    targetParent.appendChild(newChild);\n  }\n  insertBefore(parent, newChild, refChild) {\n    if (parent) {\n      const targetParent = isTemplateNode(parent) ? parent.content : parent;\n      targetParent.insertBefore(newChild, refChild);\n    }\n  }\n  removeChild(_parent, oldChild) {\n    oldChild.remove();\n  }\n  selectRootElement(selectorOrNode, preserveContent) {\n    let el = typeof selectorOrNode === \"string\" ? this.doc.querySelector(selectorOrNode) : selectorOrNode;\n    if (!el) {\n      throw new RuntimeError(-5104, (typeof ngDevMode === \"undefined\" || ngDevMode) && `The selector \"${selectorOrNode}\" did not match any elements`);\n    }\n    if (!preserveContent) {\n      el.textContent = \"\";\n    }\n    return el;\n  }\n  parentNode(node) {\n    return node.parentNode;\n  }\n  nextSibling(node) {\n    return node.nextSibling;\n  }\n  setAttribute(el, name, value, namespace) {\n    if (namespace) {\n      name = namespace + \":\" + name;\n      const namespaceUri = NAMESPACE_URIS[namespace];\n      if (namespaceUri) {\n        el.setAttributeNS(namespaceUri, name, value);\n      } else {\n        el.setAttribute(name, value);\n      }\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n  removeAttribute(el, name, namespace) {\n    if (namespace) {\n      const namespaceUri = NAMESPACE_URIS[namespace];\n      if (namespaceUri) {\n        el.removeAttributeNS(namespaceUri, name);\n      } else {\n        el.removeAttribute(`${namespace}:${name}`);\n      }\n    } else {\n      el.removeAttribute(name);\n    }\n  }\n  addClass(el, name) {\n    el.classList.add(name);\n  }\n  removeClass(el, name) {\n    el.classList.remove(name);\n  }\n  setStyle(el, style, value, flags) {\n    if (flags & (RendererStyleFlags2.DashCase | RendererStyleFlags2.Important)) {\n      el.style.setProperty(style, value, flags & RendererStyleFlags2.Important ? \"important\" : \"\");\n    } else {\n      el.style[style] = value;\n    }\n  }\n  removeStyle(el, style, flags) {\n    if (flags & RendererStyleFlags2.DashCase) {\n      el.style.removeProperty(style);\n    } else {\n      el.style[style] = \"\";\n    }\n  }\n  setProperty(el, name, value) {\n    if (el == null) {\n      return;\n    }\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && this.throwOnSyntheticProps && checkNoSyntheticProp(name, \"property\");\n    el[name] = value;\n  }\n  setValue(node, value) {\n    node.nodeValue = value;\n  }\n  listen(target, event, callback, options) {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && this.throwOnSyntheticProps && checkNoSyntheticProp(event, \"listener\");\n    if (typeof target === \"string\") {\n      target = getDOM().getGlobalEventTarget(this.doc, target);\n      if (!target) {\n        throw new RuntimeError(5102, (typeof ngDevMode === \"undefined\" || ngDevMode) && `Unsupported event target ${target} for event ${event}`);\n      }\n    }\n    let wrappedCallback = this.decoratePreventDefault(callback);\n    if (this.tracingService?.wrapEventListener) {\n      wrappedCallback = this.tracingService.wrapEventListener(target, event, wrappedCallback);\n    }\n    return this.eventManager.addEventListener(target, event, wrappedCallback, options);\n  }\n  decoratePreventDefault(eventHandler) {\n    return (event) => {\n      if (event === \"__ngUnwrap__\") {\n        return eventHandler;\n      }\n      const allowDefaultBehavior = this.platformIsServer ? this.ngZone.runGuarded(() => eventHandler(event)) : eventHandler(event);\n      if (allowDefaultBehavior === false) {\n        event.preventDefault();\n      }\n      return void 0;\n    };\n  }\n};\nvar AT_CHARCODE = (() => \"@\".charCodeAt(0))();\nfunction checkNoSyntheticProp(name, nameKind) {\n  if (name.charCodeAt(0) === AT_CHARCODE) {\n    throw new RuntimeError(5105, `Unexpected synthetic ${nameKind} ${name} found. Please make sure that:\n  - Make sure \\`provideAnimationsAsync()\\`, \\`provideAnimations()\\` or \\`provideNoopAnimations()\\` call was added to a list of providers used to bootstrap an application.\n  - There is a corresponding animation configuration named \\`${name}\\` defined in the \\`animations\\` field of the \\`@Component\\` decorator (see https://angular.dev/api/core/Component#animations).`);\n  }\n}\nfunction isTemplateNode(node) {\n  return node.tagName === \"TEMPLATE\" && node.content !== void 0;\n}\nvar ShadowDomRenderer = class extends DefaultDomRenderer2 {\n  sharedStylesHost;\n  hostEl;\n  shadowRoot;\n  constructor(eventManager, sharedStylesHost, hostEl, component, doc, ngZone, nonce, platformIsServer, tracingService) {\n    super(eventManager, doc, ngZone, platformIsServer, tracingService);\n    this.sharedStylesHost = sharedStylesHost;\n    this.hostEl = hostEl;\n    this.shadowRoot = hostEl.attachShadow({\n      mode: \"open\"\n    });\n    this.sharedStylesHost.addHost(this.shadowRoot);\n    let styles = component.styles;\n    if (ngDevMode) {\n      const baseHref = getDOM().getBaseHref(doc) ?? \"\";\n      styles = addBaseHrefToCssSourceMap(baseHref, styles);\n    }\n    styles = shimStylesContent(component.id, styles);\n    for (const style of styles) {\n      const styleEl = document.createElement(\"style\");\n      if (nonce) {\n        styleEl.setAttribute(\"nonce\", nonce);\n      }\n      styleEl.textContent = style;\n      this.shadowRoot.appendChild(styleEl);\n    }\n    const styleUrls = component.getExternalStyles?.();\n    if (styleUrls) {\n      for (const styleUrl of styleUrls) {\n        const linkEl = createLinkElement(styleUrl, doc);\n        if (nonce) {\n          linkEl.setAttribute(\"nonce\", nonce);\n        }\n        this.shadowRoot.appendChild(linkEl);\n      }\n    }\n  }\n  nodeOrShadowRoot(node) {\n    return node === this.hostEl ? this.shadowRoot : node;\n  }\n  appendChild(parent, newChild) {\n    return super.appendChild(this.nodeOrShadowRoot(parent), newChild);\n  }\n  insertBefore(parent, newChild, refChild) {\n    return super.insertBefore(this.nodeOrShadowRoot(parent), newChild, refChild);\n  }\n  removeChild(_parent, oldChild) {\n    return super.removeChild(null, oldChild);\n  }\n  parentNode(node) {\n    return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)));\n  }\n  destroy() {\n    this.sharedStylesHost.removeHost(this.shadowRoot);\n  }\n};\nvar NoneEncapsulationDomRenderer = class extends DefaultDomRenderer2 {\n  sharedStylesHost;\n  removeStylesOnCompDestroy;\n  styles;\n  styleUrls;\n  constructor(eventManager, sharedStylesHost, component, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, tracingService, compId) {\n    super(eventManager, doc, ngZone, platformIsServer, tracingService);\n    this.sharedStylesHost = sharedStylesHost;\n    this.removeStylesOnCompDestroy = removeStylesOnCompDestroy;\n    let styles = component.styles;\n    if (ngDevMode) {\n      const baseHref = getDOM().getBaseHref(doc) ?? \"\";\n      styles = addBaseHrefToCssSourceMap(baseHref, styles);\n    }\n    this.styles = compId ? shimStylesContent(compId, styles) : styles;\n    this.styleUrls = component.getExternalStyles?.(compId);\n  }\n  applyStyles() {\n    this.sharedStylesHost.addStyles(this.styles, this.styleUrls);\n  }\n  destroy() {\n    if (!this.removeStylesOnCompDestroy) {\n      return;\n    }\n    this.sharedStylesHost.removeStyles(this.styles, this.styleUrls);\n  }\n};\nvar EmulatedEncapsulationDomRenderer2 = class extends NoneEncapsulationDomRenderer {\n  contentAttr;\n  hostAttr;\n  constructor(eventManager, sharedStylesHost, component, appId, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, tracingService) {\n    const compId = appId + \"-\" + component.id;\n    super(eventManager, sharedStylesHost, component, removeStylesOnCompDestroy, doc, ngZone, platformIsServer, tracingService, compId);\n    this.contentAttr = shimContentAttribute(compId);\n    this.hostAttr = shimHostAttribute(compId);\n  }\n  applyToHost(element) {\n    this.applyStyles();\n    this.setAttribute(element, this.hostAttr, \"\");\n  }\n  createElement(parent, name) {\n    const el = super.createElement(parent, name);\n    super.setAttribute(el, this.contentAttr, \"\");\n    return el;\n  }\n};\nvar DomEventsPlugin = class _DomEventsPlugin extends EventManagerPlugin {\n  constructor(doc) {\n    super(doc);\n  }\n  // This plugin should come last in the list of plugins, because it accepts all\n  // events.\n  supports(eventName) {\n    return true;\n  }\n  addEventListener(element, eventName, handler, options) {\n    element.addEventListener(eventName, handler, options);\n    return () => this.removeEventListener(element, eventName, handler, options);\n  }\n  removeEventListener(target, eventName, callback, options) {\n    return target.removeEventListener(eventName, callback, options);\n  }\n  static \\u0275fac = function DomEventsPlugin_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _DomEventsPlugin)(\\u0275\\u0275inject(DOCUMENT2));\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _DomEventsPlugin,\n    factory: _DomEventsPlugin.\\u0275fac\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(DomEventsPlugin, [{\n    type: Injectable\n  }], () => [{\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT2]\n    }]\n  }], null);\n})();\nvar MODIFIER_KEYS = [\"alt\", \"control\", \"meta\", \"shift\"];\nvar _keyMap = {\n  \"\\b\": \"Backspace\",\n  \"\t\": \"Tab\",\n  \"\\x7F\": \"Delete\",\n  \"\\x1B\": \"Escape\",\n  \"Del\": \"Delete\",\n  \"Esc\": \"Escape\",\n  \"Left\": \"ArrowLeft\",\n  \"Right\": \"ArrowRight\",\n  \"Up\": \"ArrowUp\",\n  \"Down\": \"ArrowDown\",\n  \"Menu\": \"ContextMenu\",\n  \"Scroll\": \"ScrollLock\",\n  \"Win\": \"OS\"\n};\nvar MODIFIER_KEY_GETTERS = {\n  \"alt\": (event) => event.altKey,\n  \"control\": (event) => event.ctrlKey,\n  \"meta\": (event) => event.metaKey,\n  \"shift\": (event) => event.shiftKey\n};\nvar KeyEventsPlugin = class _KeyEventsPlugin extends EventManagerPlugin {\n  /**\n   * Initializes an instance of the browser plug-in.\n   * @param doc The document in which key events will be detected.\n   */\n  constructor(doc) {\n    super(doc);\n  }\n  /**\n   * Reports whether a named key event is supported.\n   * @param eventName The event name to query.\n   * @return True if the named key event is supported.\n   */\n  supports(eventName) {\n    return _KeyEventsPlugin.parseEventName(eventName) != null;\n  }\n  /**\n   * Registers a handler for a specific element and key event.\n   * @param element The HTML element to receive event notifications.\n   * @param eventName The name of the key event to listen for.\n   * @param handler A function to call when the notification occurs. Receives the\n   * event object as an argument.\n   * @returns The key event that was registered.\n   */\n  addEventListener(element, eventName, handler, options) {\n    const parsedEvent = _KeyEventsPlugin.parseEventName(eventName);\n    const outsideHandler = _KeyEventsPlugin.eventCallback(parsedEvent[\"fullKey\"], handler, this.manager.getZone());\n    return this.manager.getZone().runOutsideAngular(() => {\n      return getDOM().onAndCancel(element, parsedEvent[\"domEventName\"], outsideHandler, options);\n    });\n  }\n  /**\n   * Parses the user provided full keyboard event definition and normalizes it for\n   * later internal use. It ensures the string is all lowercase, converts special\n   * characters to a standard spelling, and orders all the values consistently.\n   *\n   * @param eventName The name of the key event to listen for.\n   * @returns an object with the full, normalized string, and the dom event name\n   * or null in the case when the event doesn't match a keyboard event.\n   */\n  static parseEventName(eventName) {\n    const parts = eventName.toLowerCase().split(\".\");\n    const domEventName = parts.shift();\n    if (parts.length === 0 || !(domEventName === \"keydown\" || domEventName === \"keyup\")) {\n      return null;\n    }\n    const key = _KeyEventsPlugin._normalizeKey(parts.pop());\n    let fullKey = \"\";\n    let codeIX = parts.indexOf(\"code\");\n    if (codeIX > -1) {\n      parts.splice(codeIX, 1);\n      fullKey = \"code.\";\n    }\n    MODIFIER_KEYS.forEach((modifierName) => {\n      const index = parts.indexOf(modifierName);\n      if (index > -1) {\n        parts.splice(index, 1);\n        fullKey += modifierName + \".\";\n      }\n    });\n    fullKey += key;\n    if (parts.length != 0 || key.length === 0) {\n      return null;\n    }\n    const result = {};\n    result[\"domEventName\"] = domEventName;\n    result[\"fullKey\"] = fullKey;\n    return result;\n  }\n  /**\n   * Determines whether the actual keys pressed match the configured key code string.\n   * The `fullKeyCode` event is normalized in the `parseEventName` method when the\n   * event is attached to the DOM during the `addEventListener` call. This is unseen\n   * by the end user and is normalized for internal consistency and parsing.\n   *\n   * @param event The keyboard event.\n   * @param fullKeyCode The normalized user defined expected key event string\n   * @returns boolean.\n   */\n  static matchEventFullKeyCode(event, fullKeyCode) {\n    let keycode = _keyMap[event.key] || event.key;\n    let key = \"\";\n    if (fullKeyCode.indexOf(\"code.\") > -1) {\n      keycode = event.code;\n      key = \"code.\";\n    }\n    if (keycode == null || !keycode) return false;\n    keycode = keycode.toLowerCase();\n    if (keycode === \" \") {\n      keycode = \"space\";\n    } else if (keycode === \".\") {\n      keycode = \"dot\";\n    }\n    MODIFIER_KEYS.forEach((modifierName) => {\n      if (modifierName !== keycode) {\n        const modifierGetter = MODIFIER_KEY_GETTERS[modifierName];\n        if (modifierGetter(event)) {\n          key += modifierName + \".\";\n        }\n      }\n    });\n    key += keycode;\n    return key === fullKeyCode;\n  }\n  /**\n   * Configures a handler callback for a key event.\n   * @param fullKey The event name that combines all simultaneous keystrokes.\n   * @param handler The function that responds to the key event.\n   * @param zone The zone in which the event occurred.\n   * @returns A callback function.\n   */\n  static eventCallback(fullKey, handler, zone) {\n    return (event) => {\n      if (_KeyEventsPlugin.matchEventFullKeyCode(event, fullKey)) {\n        zone.runGuarded(() => handler(event));\n      }\n    };\n  }\n  /** @internal */\n  static _normalizeKey(keyName) {\n    return keyName === \"esc\" ? \"escape\" : keyName;\n  }\n  static \\u0275fac = function KeyEventsPlugin_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _KeyEventsPlugin)(\\u0275\\u0275inject(DOCUMENT2));\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _KeyEventsPlugin,\n    factory: _KeyEventsPlugin.\\u0275fac\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(KeyEventsPlugin, [{\n    type: Injectable\n  }], () => [{\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT2]\n    }]\n  }], null);\n})();\nfunction bootstrapApplication(rootComponent, options) {\n  return internalCreateApplication(__spreadValues({\n    rootComponent\n  }, createProvidersConfig(options)));\n}\nfunction createProvidersConfig(options) {\n  return {\n    appProviders: [...BROWSER_MODULE_PROVIDERS, ...options?.providers ?? []],\n    platformProviders: INTERNAL_BROWSER_PLATFORM_PROVIDERS\n  };\n}\nfunction initDomAdapter() {\n  BrowserDomAdapter.makeCurrent();\n}\nfunction errorHandler() {\n  return new ErrorHandler();\n}\nfunction _document() {\n  setDocument(document);\n  return document;\n}\nvar INTERNAL_BROWSER_PLATFORM_PROVIDERS = [{\n  provide: PLATFORM_ID,\n  useValue: PLATFORM_BROWSER_ID\n}, {\n  provide: PLATFORM_INITIALIZER,\n  useValue: initDomAdapter,\n  multi: true\n}, {\n  provide: DOCUMENT2,\n  useFactory: _document,\n  deps: []\n}];\nvar platformBrowser = createPlatformFactory(platformCore, \"browser\", INTERNAL_BROWSER_PLATFORM_PROVIDERS);\nvar BROWSER_MODULE_PROVIDERS_MARKER = new InjectionToken(typeof ngDevMode === \"undefined\" || ngDevMode ? \"BrowserModule Providers Marker\" : \"\");\nvar TESTABILITY_PROVIDERS = [{\n  provide: TESTABILITY_GETTER,\n  useClass: BrowserGetTestability,\n  deps: []\n}, {\n  provide: TESTABILITY,\n  useClass: Testability,\n  deps: [NgZone, TestabilityRegistry, TESTABILITY_GETTER]\n}, {\n  provide: Testability,\n  // Also provide as `Testability` for backwards-compatibility.\n  useClass: Testability,\n  deps: [NgZone, TestabilityRegistry, TESTABILITY_GETTER]\n}];\nvar BROWSER_MODULE_PROVIDERS = [{\n  provide: INJECTOR_SCOPE,\n  useValue: \"root\"\n}, {\n  provide: ErrorHandler,\n  useFactory: errorHandler,\n  deps: []\n}, {\n  provide: EVENT_MANAGER_PLUGINS,\n  useClass: DomEventsPlugin,\n  multi: true,\n  deps: [DOCUMENT2]\n}, {\n  provide: EVENT_MANAGER_PLUGINS,\n  useClass: KeyEventsPlugin,\n  multi: true,\n  deps: [DOCUMENT2]\n}, DomRendererFactory2, SharedStylesHost, EventManager, {\n  provide: RendererFactory2,\n  useExisting: DomRendererFactory2\n}, {\n  provide: XhrFactory,\n  useClass: BrowserXhr,\n  deps: []\n}, typeof ngDevMode === \"undefined\" || ngDevMode ? {\n  provide: BROWSER_MODULE_PROVIDERS_MARKER,\n  useValue: true\n} : []];\nvar BrowserModule = class _BrowserModule {\n  constructor() {\n    if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n      const providersAlreadyPresent = inject(BROWSER_MODULE_PROVIDERS_MARKER, {\n        optional: true,\n        skipSelf: true\n      });\n      if (providersAlreadyPresent) {\n        throw new RuntimeError(5100, `Providers from the \\`BrowserModule\\` have already been loaded. If you need access to common directives such as NgIf and NgFor, import the \\`CommonModule\\` instead.`);\n      }\n    }\n  }\n  static \\u0275fac = function BrowserModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _BrowserModule)();\n  };\n  static \\u0275mod = /* @__PURE__ */ \\u0275\\u0275defineNgModule({\n    type: _BrowserModule\n  });\n  static \\u0275inj = /* @__PURE__ */ \\u0275\\u0275defineInjector({\n    providers: [...BROWSER_MODULE_PROVIDERS, ...TESTABILITY_PROVIDERS],\n    imports: [CommonModule, ApplicationModule]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(BrowserModule, [{\n    type: NgModule,\n    args: [{\n      providers: [...BROWSER_MODULE_PROVIDERS, ...TESTABILITY_PROVIDERS],\n      exports: [CommonModule, ApplicationModule]\n    }]\n  }], () => [], null);\n})();\nvar Meta = class _Meta {\n  _doc;\n  _dom;\n  constructor(_doc) {\n    this._doc = _doc;\n    this._dom = getDOM();\n  }\n  /**\n   * Retrieves or creates a specific `<meta>` tag element in the current HTML document.\n   * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute\n   * values in the provided tag definition, and verifies that all other attribute values are equal.\n   * If an existing element is found, it is returned and is not modified in any way.\n   * @param tag The definition of a `<meta>` element to match or create.\n   * @param forceCreation True to create a new element without checking whether one already exists.\n   * @returns The existing element with the same attributes and values if found,\n   * the new element if no match is found, or `null` if the tag parameter is not defined.\n   */\n  addTag(tag, forceCreation = false) {\n    if (!tag) return null;\n    return this._getOrCreateElement(tag, forceCreation);\n  }\n  /**\n   * Retrieves or creates a set of `<meta>` tag elements in the current HTML document.\n   * In searching for an existing tag, Angular attempts to match the `name` or `property` attribute\n   * values in the provided tag definition, and verifies that all other attribute values are equal.\n   * @param tags An array of tag definitions to match or create.\n   * @param forceCreation True to create new elements without checking whether they already exist.\n   * @returns The matching elements if found, or the new elements.\n   */\n  addTags(tags, forceCreation = false) {\n    if (!tags) return [];\n    return tags.reduce((result, tag) => {\n      if (tag) {\n        result.push(this._getOrCreateElement(tag, forceCreation));\n      }\n      return result;\n    }, []);\n  }\n  /**\n   * Retrieves a `<meta>` tag element in the current HTML document.\n   * @param attrSelector The tag attribute and value to match against, in the format\n   * `\"tag_attribute='value string'\"`.\n   * @returns The matching element, if any.\n   */\n  getTag(attrSelector) {\n    if (!attrSelector) return null;\n    return this._doc.querySelector(`meta[${attrSelector}]`) || null;\n  }\n  /**\n   * Retrieves a set of `<meta>` tag elements in the current HTML document.\n   * @param attrSelector The tag attribute and value to match against, in the format\n   * `\"tag_attribute='value string'\"`.\n   * @returns The matching elements, if any.\n   */\n  getTags(attrSelector) {\n    if (!attrSelector) return [];\n    const list = this._doc.querySelectorAll(`meta[${attrSelector}]`);\n    return list ? [].slice.call(list) : [];\n  }\n  /**\n   * Modifies an existing `<meta>` tag element in the current HTML document.\n   * @param tag The tag description with which to replace the existing tag content.\n   * @param selector A tag attribute and value to match against, to identify\n   * an existing tag. A string in the format `\"tag_attribute=`value string`\"`.\n   * If not supplied, matches a tag with the same `name` or `property` attribute value as the\n   * replacement tag.\n   * @return The modified element.\n   */\n  updateTag(tag, selector) {\n    if (!tag) return null;\n    selector = selector || this._parseSelector(tag);\n    const meta = this.getTag(selector);\n    if (meta) {\n      return this._setMetaElementAttributes(tag, meta);\n    }\n    return this._getOrCreateElement(tag, true);\n  }\n  /**\n   * Removes an existing `<meta>` tag element from the current HTML document.\n   * @param attrSelector A tag attribute and value to match against, to identify\n   * an existing tag. A string in the format `\"tag_attribute=`value string`\"`.\n   */\n  removeTag(attrSelector) {\n    this.removeTagElement(this.getTag(attrSelector));\n  }\n  /**\n   * Removes an existing `<meta>` tag element from the current HTML document.\n   * @param meta The tag definition to match against to identify an existing tag.\n   */\n  removeTagElement(meta) {\n    if (meta) {\n      this._dom.remove(meta);\n    }\n  }\n  _getOrCreateElement(meta, forceCreation = false) {\n    if (!forceCreation) {\n      const selector = this._parseSelector(meta);\n      const elem = this.getTags(selector).filter((elem2) => this._containsAttributes(meta, elem2))[0];\n      if (elem !== void 0) return elem;\n    }\n    const element = this._dom.createElement(\"meta\");\n    this._setMetaElementAttributes(meta, element);\n    const head = this._doc.getElementsByTagName(\"head\")[0];\n    head.appendChild(element);\n    return element;\n  }\n  _setMetaElementAttributes(tag, el) {\n    Object.keys(tag).forEach((prop) => el.setAttribute(this._getMetaKeyMap(prop), tag[prop]));\n    return el;\n  }\n  _parseSelector(tag) {\n    const attr = tag.name ? \"name\" : \"property\";\n    return `${attr}=\"${tag[attr]}\"`;\n  }\n  _containsAttributes(tag, elem) {\n    return Object.keys(tag).every((key) => elem.getAttribute(this._getMetaKeyMap(key)) === tag[key]);\n  }\n  _getMetaKeyMap(prop) {\n    return META_KEYS_MAP[prop] || prop;\n  }\n  static \\u0275fac = function Meta_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _Meta)(\\u0275\\u0275inject(DOCUMENT2));\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _Meta,\n    factory: _Meta.\\u0275fac,\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(Meta, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], () => [{\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT2]\n    }]\n  }], null);\n})();\nvar META_KEYS_MAP = {\n  httpEquiv: \"http-equiv\"\n};\nvar Title = class _Title {\n  _doc;\n  constructor(_doc) {\n    this._doc = _doc;\n  }\n  /**\n   * Get the title of the current HTML document.\n   */\n  getTitle() {\n    return this._doc.title;\n  }\n  /**\n   * Set the title of the current HTML document.\n   * @param newTitle\n   */\n  setTitle(newTitle) {\n    this._doc.title = newTitle || \"\";\n  }\n  static \\u0275fac = function Title_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _Title)(\\u0275\\u0275inject(DOCUMENT2));\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _Title,\n    factory: _Title.\\u0275fac,\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(Title, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], () => [{\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT2]\n    }]\n  }], null);\n})();\nvar EVENT_NAMES = {\n  // pan\n  \"pan\": true,\n  \"panstart\": true,\n  \"panmove\": true,\n  \"panend\": true,\n  \"pancancel\": true,\n  \"panleft\": true,\n  \"panright\": true,\n  \"panup\": true,\n  \"pandown\": true,\n  // pinch\n  \"pinch\": true,\n  \"pinchstart\": true,\n  \"pinchmove\": true,\n  \"pinchend\": true,\n  \"pinchcancel\": true,\n  \"pinchin\": true,\n  \"pinchout\": true,\n  // press\n  \"press\": true,\n  \"pressup\": true,\n  // rotate\n  \"rotate\": true,\n  \"rotatestart\": true,\n  \"rotatemove\": true,\n  \"rotateend\": true,\n  \"rotatecancel\": true,\n  // swipe\n  \"swipe\": true,\n  \"swipeleft\": true,\n  \"swiperight\": true,\n  \"swipeup\": true,\n  \"swipedown\": true,\n  // tap\n  \"tap\": true,\n  \"doubletap\": true\n};\nvar HAMMER_GESTURE_CONFIG = new InjectionToken(typeof ngDevMode === \"undefined\" || ngDevMode ? \"HammerGestureConfig\" : \"\");\nvar HAMMER_LOADER = new InjectionToken(typeof ngDevMode === \"undefined\" || ngDevMode ? \"HammerLoader\" : \"\");\nvar HammerGestureConfig = class _HammerGestureConfig {\n  /**\n   * A set of supported event names for gestures to be used in Angular.\n   * Angular supports all built-in recognizers, as listed in\n   * [HammerJS documentation](https://hammerjs.github.io/).\n   */\n  events = [];\n  /**\n   * Maps gesture event names to a set of configuration options\n   * that specify overrides to the default values for specific properties.\n   *\n   * The key is a supported event name to be configured,\n   * and the options object contains a set of properties, with override values\n   * to be applied to the named recognizer event.\n   * For example, to disable recognition of the rotate event, specify\n   *  `{\"rotate\": {\"enable\": false}}`.\n   *\n   * Properties that are not present take the HammerJS default values.\n   * For information about which properties are supported for which events,\n   * and their allowed and default values, see\n   * [HammerJS documentation](https://hammerjs.github.io/).\n   *\n   */\n  overrides = {};\n  /**\n   * Properties whose default values can be overridden for a given event.\n   * Different sets of properties apply to different events.\n   * For information about which properties are supported for which events,\n   * and their allowed and default values, see\n   * [HammerJS documentation](https://hammerjs.github.io/).\n   */\n  options;\n  /**\n   * Creates a [HammerJS Manager](https://hammerjs.github.io/api/#hammermanager)\n   * and attaches it to a given HTML element.\n   * @param element The element that will recognize gestures.\n   * @returns A HammerJS event-manager object.\n   */\n  buildHammer(element) {\n    const mc = new Hammer(element, this.options);\n    mc.get(\"pinch\").set({\n      enable: true\n    });\n    mc.get(\"rotate\").set({\n      enable: true\n    });\n    for (const eventName in this.overrides) {\n      mc.get(eventName).set(this.overrides[eventName]);\n    }\n    return mc;\n  }\n  static \\u0275fac = function HammerGestureConfig_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _HammerGestureConfig)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _HammerGestureConfig,\n    factory: _HammerGestureConfig.\\u0275fac\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(HammerGestureConfig, [{\n    type: Injectable\n  }], null, null);\n})();\nvar HammerGesturesPlugin = class _HammerGesturesPlugin extends EventManagerPlugin {\n  _config;\n  _injector;\n  loader;\n  _loaderPromise = null;\n  constructor(doc, _config, _injector, loader) {\n    super(doc);\n    this._config = _config;\n    this._injector = _injector;\n    this.loader = loader;\n  }\n  supports(eventName) {\n    if (!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) {\n      return false;\n    }\n    if (!window.Hammer && !this.loader) {\n      if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n        const _console = this._injector.get(Console);\n        _console.warn(`The \"${eventName}\" event cannot be bound because Hammer.JS is not loaded and no custom loader has been specified.`);\n      }\n      return false;\n    }\n    return true;\n  }\n  addEventListener(element, eventName, handler) {\n    const zone = this.manager.getZone();\n    eventName = eventName.toLowerCase();\n    if (!window.Hammer && this.loader) {\n      this._loaderPromise = this._loaderPromise || zone.runOutsideAngular(() => this.loader());\n      let cancelRegistration = false;\n      let deregister = () => {\n        cancelRegistration = true;\n      };\n      zone.runOutsideAngular(() => this._loaderPromise.then(() => {\n        if (!window.Hammer) {\n          if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n            const _console = this._injector.get(Console);\n            _console.warn(`The custom HAMMER_LOADER completed, but Hammer.JS is not present.`);\n          }\n          deregister = () => {\n          };\n          return;\n        }\n        if (!cancelRegistration) {\n          deregister = this.addEventListener(element, eventName, handler);\n        }\n      }).catch(() => {\n        if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n          const _console = this._injector.get(Console);\n          _console.warn(`The \"${eventName}\" event cannot be bound because the custom Hammer.JS loader failed.`);\n        }\n        deregister = () => {\n        };\n      }));\n      return () => {\n        deregister();\n      };\n    }\n    return zone.runOutsideAngular(() => {\n      const mc = this._config.buildHammer(element);\n      const callback = function(eventObj) {\n        zone.runGuarded(function() {\n          handler(eventObj);\n        });\n      };\n      mc.on(eventName, callback);\n      return () => {\n        mc.off(eventName, callback);\n        if (typeof mc.destroy === \"function\") {\n          mc.destroy();\n        }\n      };\n    });\n  }\n  isCustomEvent(eventName) {\n    return this._config.events.indexOf(eventName) > -1;\n  }\n  static \\u0275fac = function HammerGesturesPlugin_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _HammerGesturesPlugin)(\\u0275\\u0275inject(DOCUMENT2), \\u0275\\u0275inject(HAMMER_GESTURE_CONFIG), \\u0275\\u0275inject(Injector), \\u0275\\u0275inject(HAMMER_LOADER, 8));\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _HammerGesturesPlugin,\n    factory: _HammerGesturesPlugin.\\u0275fac\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(HammerGesturesPlugin, [{\n    type: Injectable\n  }], () => [{\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT2]\n    }]\n  }, {\n    type: HammerGestureConfig,\n    decorators: [{\n      type: Inject,\n      args: [HAMMER_GESTURE_CONFIG]\n    }]\n  }, {\n    type: Injector\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [HAMMER_LOADER]\n    }]\n  }], null);\n})();\nvar HammerModule = class _HammerModule {\n  static \\u0275fac = function HammerModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _HammerModule)();\n  };\n  static \\u0275mod = /* @__PURE__ */ \\u0275\\u0275defineNgModule({\n    type: _HammerModule\n  });\n  static \\u0275inj = /* @__PURE__ */ \\u0275\\u0275defineInjector({\n    providers: [{\n      provide: EVENT_MANAGER_PLUGINS,\n      useClass: HammerGesturesPlugin,\n      multi: true,\n      deps: [DOCUMENT2, HAMMER_GESTURE_CONFIG, Injector, [new Optional(), HAMMER_LOADER]]\n    }, {\n      provide: HAMMER_GESTURE_CONFIG,\n      useClass: HammerGestureConfig,\n      deps: []\n    }]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(HammerModule, [{\n    type: NgModule,\n    args: [{\n      providers: [{\n        provide: EVENT_MANAGER_PLUGINS,\n        useClass: HammerGesturesPlugin,\n        multi: true,\n        deps: [DOCUMENT2, HAMMER_GESTURE_CONFIG, Injector, [new Optional(), HAMMER_LOADER]]\n      }, {\n        provide: HAMMER_GESTURE_CONFIG,\n        useClass: HammerGestureConfig,\n        deps: []\n      }]\n    }]\n  }], null, null);\n})();\nvar DomSanitizer = class _DomSanitizer {\n  static \\u0275fac = function DomSanitizer_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _DomSanitizer)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _DomSanitizer,\n    factory: function DomSanitizer_Factory(__ngFactoryType__) {\n      let __ngConditionalFactory__ = null;\n      if (__ngFactoryType__) {\n        __ngConditionalFactory__ = new (__ngFactoryType__ || _DomSanitizer)();\n      } else {\n        __ngConditionalFactory__ = \\u0275\\u0275inject(DomSanitizerImpl);\n      }\n      return __ngConditionalFactory__;\n    },\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(DomSanitizer, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\",\n      useExisting: forwardRef(() => DomSanitizerImpl)\n    }]\n  }], null, null);\n})();\nvar DomSanitizerImpl = class _DomSanitizerImpl extends DomSanitizer {\n  _doc;\n  constructor(_doc) {\n    super();\n    this._doc = _doc;\n  }\n  sanitize(ctx, value) {\n    if (value == null) return null;\n    switch (ctx) {\n      case SecurityContext.NONE:\n        return value;\n      case SecurityContext.HTML:\n        if (allowSanitizationBypassAndThrow(\n          value,\n          \"HTML\"\n          /* BypassType.Html */\n        )) {\n          return unwrapSafeValue(value);\n        }\n        return _sanitizeHtml(this._doc, String(value)).toString();\n      case SecurityContext.STYLE:\n        if (allowSanitizationBypassAndThrow(\n          value,\n          \"Style\"\n          /* BypassType.Style */\n        )) {\n          return unwrapSafeValue(value);\n        }\n        return value;\n      case SecurityContext.SCRIPT:\n        if (allowSanitizationBypassAndThrow(\n          value,\n          \"Script\"\n          /* BypassType.Script */\n        )) {\n          return unwrapSafeValue(value);\n        }\n        throw new RuntimeError(5200, (typeof ngDevMode === \"undefined\" || ngDevMode) && \"unsafe value used in a script context\");\n      case SecurityContext.URL:\n        if (allowSanitizationBypassAndThrow(\n          value,\n          \"URL\"\n          /* BypassType.Url */\n        )) {\n          return unwrapSafeValue(value);\n        }\n        return _sanitizeUrl(String(value));\n      case SecurityContext.RESOURCE_URL:\n        if (allowSanitizationBypassAndThrow(\n          value,\n          \"ResourceURL\"\n          /* BypassType.ResourceUrl */\n        )) {\n          return unwrapSafeValue(value);\n        }\n        throw new RuntimeError(5201, (typeof ngDevMode === \"undefined\" || ngDevMode) && `unsafe value used in a resource URL context (see ${XSS_SECURITY_URL})`);\n      default:\n        throw new RuntimeError(5202, (typeof ngDevMode === \"undefined\" || ngDevMode) && `Unexpected SecurityContext ${ctx} (see ${XSS_SECURITY_URL})`);\n    }\n  }\n  bypassSecurityTrustHtml(value) {\n    return bypassSanitizationTrustHtml(value);\n  }\n  bypassSecurityTrustStyle(value) {\n    return bypassSanitizationTrustStyle(value);\n  }\n  bypassSecurityTrustScript(value) {\n    return bypassSanitizationTrustScript(value);\n  }\n  bypassSecurityTrustUrl(value) {\n    return bypassSanitizationTrustUrl(value);\n  }\n  bypassSecurityTrustResourceUrl(value) {\n    return bypassSanitizationTrustResourceUrl(value);\n  }\n  static \\u0275fac = function DomSanitizerImpl_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _DomSanitizerImpl)(\\u0275\\u0275inject(DOCUMENT2));\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _DomSanitizerImpl,\n    factory: _DomSanitizerImpl.\\u0275fac,\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(DomSanitizerImpl, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], () => [{\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [DOCUMENT2]\n    }]\n  }], null);\n})();\nvar HydrationFeatureKind;\n(function(HydrationFeatureKind2) {\n  HydrationFeatureKind2[HydrationFeatureKind2[\"NoHttpTransferCache\"] = 0] = \"NoHttpTransferCache\";\n  HydrationFeatureKind2[HydrationFeatureKind2[\"HttpTransferCacheOptions\"] = 1] = \"HttpTransferCacheOptions\";\n  HydrationFeatureKind2[HydrationFeatureKind2[\"I18nSupport\"] = 2] = \"I18nSupport\";\n  HydrationFeatureKind2[HydrationFeatureKind2[\"EventReplay\"] = 3] = \"EventReplay\";\n  HydrationFeatureKind2[HydrationFeatureKind2[\"IncrementalHydration\"] = 4] = \"IncrementalHydration\";\n})(HydrationFeatureKind || (HydrationFeatureKind = {}));\nvar VERSION3 = new Version(\"19.2.3\");\n\n// node_modules/@angular/router/fesm2022/router.mjs\nvar PRIMARY_OUTLET = \"primary\";\nvar RouteTitleKey = /* @__PURE__ */ Symbol(\"RouteTitle\");\nvar ParamsAsMap = class {\n  params;\n  constructor(params) {\n    this.params = params || {};\n  }\n  has(name) {\n    return Object.prototype.hasOwnProperty.call(this.params, name);\n  }\n  get(name) {\n    if (this.has(name)) {\n      const v = this.params[name];\n      return Array.isArray(v) ? v[0] : v;\n    }\n    return null;\n  }\n  getAll(name) {\n    if (this.has(name)) {\n      const v = this.params[name];\n      return Array.isArray(v) ? v : [v];\n    }\n    return [];\n  }\n  get keys() {\n    return Object.keys(this.params);\n  }\n};\nfunction convertToParamMap(params) {\n  return new ParamsAsMap(params);\n}\nfunction defaultUrlMatcher(segments, segmentGroup, route) {\n  const parts = route.path.split(\"/\");\n  if (parts.length > segments.length) {\n    return null;\n  }\n  if (route.pathMatch === \"full\" && (segmentGroup.hasChildren() || parts.length < segments.length)) {\n    return null;\n  }\n  const posParams = {};\n  for (let index = 0; index < parts.length; index++) {\n    const part = parts[index];\n    const segment = segments[index];\n    const isParameter = part[0] === \":\";\n    if (isParameter) {\n      posParams[part.substring(1)] = segment;\n    } else if (part !== segment.path) {\n      return null;\n    }\n  }\n  return {\n    consumed: segments.slice(0, parts.length),\n    posParams\n  };\n}\nfunction shallowEqualArrays(a, b) {\n  if (a.length !== b.length) return false;\n  for (let i = 0; i < a.length; ++i) {\n    if (!shallowEqual(a[i], b[i])) return false;\n  }\n  return true;\n}\nfunction shallowEqual(a, b) {\n  const k1 = a ? getDataKeys(a) : void 0;\n  const k2 = b ? getDataKeys(b) : void 0;\n  if (!k1 || !k2 || k1.length != k2.length) {\n    return false;\n  }\n  let key;\n  for (let i = 0; i < k1.length; i++) {\n    key = k1[i];\n    if (!equalArraysOrString(a[key], b[key])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getDataKeys(obj) {\n  return [...Object.keys(obj), ...Object.getOwnPropertySymbols(obj)];\n}\nfunction equalArraysOrString(a, b) {\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) return false;\n    const aSorted = [...a].sort();\n    const bSorted = [...b].sort();\n    return aSorted.every((val, index) => bSorted[index] === val);\n  } else {\n    return a === b;\n  }\n}\nfunction last3(a) {\n  return a.length > 0 ? a[a.length - 1] : null;\n}\nfunction wrapIntoObservable(value) {\n  if (isObservable(value)) {\n    return value;\n  }\n  if (isPromise2(value)) {\n    return from(Promise.resolve(value));\n  }\n  return of(value);\n}\nvar pathCompareMap = {\n  \"exact\": equalSegmentGroups,\n  \"subset\": containsSegmentGroup\n};\nvar paramCompareMap = {\n  \"exact\": equalParams,\n  \"subset\": containsParams,\n  \"ignored\": () => true\n};\nfunction containsTree(container, containee, options) {\n  return pathCompareMap[options.paths](container.root, containee.root, options.matrixParams) && paramCompareMap[options.queryParams](container.queryParams, containee.queryParams) && !(options.fragment === \"exact\" && container.fragment !== containee.fragment);\n}\nfunction equalParams(container, containee) {\n  return shallowEqual(container, containee);\n}\nfunction equalSegmentGroups(container, containee, matrixParams) {\n  if (!equalPath(container.segments, containee.segments)) return false;\n  if (!matrixParamsMatch(container.segments, containee.segments, matrixParams)) {\n    return false;\n  }\n  if (container.numberOfChildren !== containee.numberOfChildren) return false;\n  for (const c in containee.children) {\n    if (!container.children[c]) return false;\n    if (!equalSegmentGroups(container.children[c], containee.children[c], matrixParams)) return false;\n  }\n  return true;\n}\nfunction containsParams(container, containee) {\n  return Object.keys(containee).length <= Object.keys(container).length && Object.keys(containee).every((key) => equalArraysOrString(container[key], containee[key]));\n}\nfunction containsSegmentGroup(container, containee, matrixParams) {\n  return containsSegmentGroupHelper(container, containee, containee.segments, matrixParams);\n}\nfunction containsSegmentGroupHelper(container, containee, containeePaths, matrixParams) {\n  if (container.segments.length > containeePaths.length) {\n    const current = container.segments.slice(0, containeePaths.length);\n    if (!equalPath(current, containeePaths)) return false;\n    if (containee.hasChildren()) return false;\n    if (!matrixParamsMatch(current, containeePaths, matrixParams)) return false;\n    return true;\n  } else if (container.segments.length === containeePaths.length) {\n    if (!equalPath(container.segments, containeePaths)) return false;\n    if (!matrixParamsMatch(container.segments, containeePaths, matrixParams)) return false;\n    for (const c in containee.children) {\n      if (!container.children[c]) return false;\n      if (!containsSegmentGroup(container.children[c], containee.children[c], matrixParams)) {\n        return false;\n      }\n    }\n    return true;\n  } else {\n    const current = containeePaths.slice(0, container.segments.length);\n    const next = containeePaths.slice(container.segments.length);\n    if (!equalPath(container.segments, current)) return false;\n    if (!matrixParamsMatch(container.segments, current, matrixParams)) return false;\n    if (!container.children[PRIMARY_OUTLET]) return false;\n    return containsSegmentGroupHelper(container.children[PRIMARY_OUTLET], containee, next, matrixParams);\n  }\n}\nfunction matrixParamsMatch(containerPaths, containeePaths, options) {\n  return containeePaths.every((containeeSegment, i) => {\n    return paramCompareMap[options](containerPaths[i].parameters, containeeSegment.parameters);\n  });\n}\nvar UrlTree = class {\n  root;\n  queryParams;\n  fragment;\n  /** @internal */\n  _queryParamMap;\n  constructor(root = new UrlSegmentGroup([], {}), queryParams = {}, fragment = null) {\n    this.root = root;\n    this.queryParams = queryParams;\n    this.fragment = fragment;\n    if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n      if (root.segments.length > 0) {\n        throw new RuntimeError(4015, \"The root `UrlSegmentGroup` should not contain `segments`. Instead, these segments belong in the `children` so they can be associated with a named outlet.\");\n      }\n    }\n  }\n  get queryParamMap() {\n    this._queryParamMap ??= convertToParamMap(this.queryParams);\n    return this._queryParamMap;\n  }\n  /** @docsNotRequired */\n  toString() {\n    return DEFAULT_SERIALIZER.serialize(this);\n  }\n};\nvar UrlSegmentGroup = class {\n  segments;\n  children;\n  /** The parent node in the url tree */\n  parent = null;\n  constructor(segments, children) {\n    this.segments = segments;\n    this.children = children;\n    Object.values(children).forEach((v) => v.parent = this);\n  }\n  /** Whether the segment has child segments */\n  hasChildren() {\n    return this.numberOfChildren > 0;\n  }\n  /** Number of child segments */\n  get numberOfChildren() {\n    return Object.keys(this.children).length;\n  }\n  /** @docsNotRequired */\n  toString() {\n    return serializePaths(this);\n  }\n};\nvar UrlSegment = class {\n  path;\n  parameters;\n  /** @internal */\n  _parameterMap;\n  constructor(path, parameters) {\n    this.path = path;\n    this.parameters = parameters;\n  }\n  get parameterMap() {\n    this._parameterMap ??= convertToParamMap(this.parameters);\n    return this._parameterMap;\n  }\n  /** @docsNotRequired */\n  toString() {\n    return serializePath(this);\n  }\n};\nfunction equalSegments(as, bs) {\n  return equalPath(as, bs) && as.every((a, i) => shallowEqual(a.parameters, bs[i].parameters));\n}\nfunction equalPath(as, bs) {\n  if (as.length !== bs.length) return false;\n  return as.every((a, i) => a.path === bs[i].path);\n}\nfunction mapChildrenIntoArray(segment, fn) {\n  let res = [];\n  Object.entries(segment.children).forEach(([childOutlet, child]) => {\n    if (childOutlet === PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  Object.entries(segment.children).forEach(([childOutlet, child]) => {\n    if (childOutlet !== PRIMARY_OUTLET) {\n      res = res.concat(fn(child, childOutlet));\n    }\n  });\n  return res;\n}\nvar UrlSerializer = class _UrlSerializer {\n  static \\u0275fac = function UrlSerializer_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _UrlSerializer)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _UrlSerializer,\n    factory: () => (() => new DefaultUrlSerializer())(),\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(UrlSerializer, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\",\n      useFactory: () => new DefaultUrlSerializer()\n    }]\n  }], null, null);\n})();\nvar DefaultUrlSerializer = class {\n  /** Parses a url into a `UrlTree` */\n  parse(url) {\n    const p = new UrlParser(url);\n    return new UrlTree(p.parseRootSegment(), p.parseQueryParams(), p.parseFragment());\n  }\n  /** Converts a `UrlTree` into a url */\n  serialize(tree2) {\n    const segment = `/${serializeSegment(tree2.root, true)}`;\n    const query = serializeQueryParams(tree2.queryParams);\n    const fragment = typeof tree2.fragment === `string` ? `#${encodeUriFragment(tree2.fragment)}` : \"\";\n    return `${segment}${query}${fragment}`;\n  }\n};\nvar DEFAULT_SERIALIZER = new DefaultUrlSerializer();\nfunction serializePaths(segment) {\n  return segment.segments.map((p) => serializePath(p)).join(\"/\");\n}\nfunction serializeSegment(segment, root) {\n  if (!segment.hasChildren()) {\n    return serializePaths(segment);\n  }\n  if (root) {\n    const primary = segment.children[PRIMARY_OUTLET] ? serializeSegment(segment.children[PRIMARY_OUTLET], false) : \"\";\n    const children = [];\n    Object.entries(segment.children).forEach(([k, v]) => {\n      if (k !== PRIMARY_OUTLET) {\n        children.push(`${k}:${serializeSegment(v, false)}`);\n      }\n    });\n    return children.length > 0 ? `${primary}(${children.join(\"//\")})` : primary;\n  } else {\n    const children = mapChildrenIntoArray(segment, (v, k) => {\n      if (k === PRIMARY_OUTLET) {\n        return [serializeSegment(segment.children[PRIMARY_OUTLET], false)];\n      }\n      return [`${k}:${serializeSegment(v, false)}`];\n    });\n    if (Object.keys(segment.children).length === 1 && segment.children[PRIMARY_OUTLET] != null) {\n      return `${serializePaths(segment)}/${children[0]}`;\n    }\n    return `${serializePaths(segment)}/(${children.join(\"//\")})`;\n  }\n}\nfunction encodeUriString(s) {\n  return encodeURIComponent(s).replace(/%40/g, \"@\").replace(/%3A/gi, \":\").replace(/%24/g, \"$\").replace(/%2C/gi, \",\");\n}\nfunction encodeUriQuery(s) {\n  return encodeUriString(s).replace(/%3B/gi, \";\");\n}\nfunction encodeUriFragment(s) {\n  return encodeURI(s);\n}\nfunction encodeUriSegment(s) {\n  return encodeUriString(s).replace(/\\(/g, \"%28\").replace(/\\)/g, \"%29\").replace(/%26/gi, \"&\");\n}\nfunction decode(s) {\n  return decodeURIComponent(s);\n}\nfunction decodeQuery(s) {\n  return decode(s.replace(/\\+/g, \"%20\"));\n}\nfunction serializePath(path) {\n  return `${encodeUriSegment(path.path)}${serializeMatrixParams(path.parameters)}`;\n}\nfunction serializeMatrixParams(params) {\n  return Object.entries(params).map(([key, value]) => `;${encodeUriSegment(key)}=${encodeUriSegment(value)}`).join(\"\");\n}\nfunction serializeQueryParams(params) {\n  const strParams = Object.entries(params).map(([name, value]) => {\n    return Array.isArray(value) ? value.map((v) => `${encodeUriQuery(name)}=${encodeUriQuery(v)}`).join(\"&\") : `${encodeUriQuery(name)}=${encodeUriQuery(value)}`;\n  }).filter((s) => s);\n  return strParams.length ? `?${strParams.join(\"&\")}` : \"\";\n}\nvar SEGMENT_RE = /^[^\\/()?;#]+/;\nfunction matchSegments(str) {\n  const match2 = str.match(SEGMENT_RE);\n  return match2 ? match2[0] : \"\";\n}\nvar MATRIX_PARAM_SEGMENT_RE = /^[^\\/()?;=#]+/;\nfunction matchMatrixKeySegments(str) {\n  const match2 = str.match(MATRIX_PARAM_SEGMENT_RE);\n  return match2 ? match2[0] : \"\";\n}\nvar QUERY_PARAM_RE = /^[^=?&#]+/;\nfunction matchQueryParams(str) {\n  const match2 = str.match(QUERY_PARAM_RE);\n  return match2 ? match2[0] : \"\";\n}\nvar QUERY_PARAM_VALUE_RE = /^[^&#]+/;\nfunction matchUrlQueryParamValue(str) {\n  const match2 = str.match(QUERY_PARAM_VALUE_RE);\n  return match2 ? match2[0] : \"\";\n}\nvar UrlParser = class {\n  url;\n  remaining;\n  constructor(url) {\n    this.url = url;\n    this.remaining = url;\n  }\n  parseRootSegment() {\n    this.consumeOptional(\"/\");\n    if (this.remaining === \"\" || this.peekStartsWith(\"?\") || this.peekStartsWith(\"#\")) {\n      return new UrlSegmentGroup([], {});\n    }\n    return new UrlSegmentGroup([], this.parseChildren());\n  }\n  parseQueryParams() {\n    const params = {};\n    if (this.consumeOptional(\"?\")) {\n      do {\n        this.parseQueryParam(params);\n      } while (this.consumeOptional(\"&\"));\n    }\n    return params;\n  }\n  parseFragment() {\n    return this.consumeOptional(\"#\") ? decodeURIComponent(this.remaining) : null;\n  }\n  parseChildren() {\n    if (this.remaining === \"\") {\n      return {};\n    }\n    this.consumeOptional(\"/\");\n    const segments = [];\n    if (!this.peekStartsWith(\"(\")) {\n      segments.push(this.parseSegment());\n    }\n    while (this.peekStartsWith(\"/\") && !this.peekStartsWith(\"//\") && !this.peekStartsWith(\"/(\")) {\n      this.capture(\"/\");\n      segments.push(this.parseSegment());\n    }\n    let children = {};\n    if (this.peekStartsWith(\"/(\")) {\n      this.capture(\"/\");\n      children = this.parseParens(true);\n    }\n    let res = {};\n    if (this.peekStartsWith(\"(\")) {\n      res = this.parseParens(false);\n    }\n    if (segments.length > 0 || Object.keys(children).length > 0) {\n      res[PRIMARY_OUTLET] = new UrlSegmentGroup(segments, children);\n    }\n    return res;\n  }\n  // parse a segment with its matrix parameters\n  // ie `name;k1=v1;k2`\n  parseSegment() {\n    const path = matchSegments(this.remaining);\n    if (path === \"\" && this.peekStartsWith(\";\")) {\n      throw new RuntimeError(4009, (typeof ngDevMode === \"undefined\" || ngDevMode) && `Empty path url segment cannot have parameters: '${this.remaining}'.`);\n    }\n    this.capture(path);\n    return new UrlSegment(decode(path), this.parseMatrixParams());\n  }\n  parseMatrixParams() {\n    const params = {};\n    while (this.consumeOptional(\";\")) {\n      this.parseParam(params);\n    }\n    return params;\n  }\n  parseParam(params) {\n    const key = matchMatrixKeySegments(this.remaining);\n    if (!key) {\n      return;\n    }\n    this.capture(key);\n    let value = \"\";\n    if (this.consumeOptional(\"=\")) {\n      const valueMatch = matchSegments(this.remaining);\n      if (valueMatch) {\n        value = valueMatch;\n        this.capture(value);\n      }\n    }\n    params[decode(key)] = decode(value);\n  }\n  // Parse a single query parameter `name[=value]`\n  parseQueryParam(params) {\n    const key = matchQueryParams(this.remaining);\n    if (!key) {\n      return;\n    }\n    this.capture(key);\n    let value = \"\";\n    if (this.consumeOptional(\"=\")) {\n      const valueMatch = matchUrlQueryParamValue(this.remaining);\n      if (valueMatch) {\n        value = valueMatch;\n        this.capture(value);\n      }\n    }\n    const decodedKey = decodeQuery(key);\n    const decodedVal = decodeQuery(value);\n    if (params.hasOwnProperty(decodedKey)) {\n      let currentVal = params[decodedKey];\n      if (!Array.isArray(currentVal)) {\n        currentVal = [currentVal];\n        params[decodedKey] = currentVal;\n      }\n      currentVal.push(decodedVal);\n    } else {\n      params[decodedKey] = decodedVal;\n    }\n  }\n  // parse `(a/b//outlet_name:c/d)`\n  parseParens(allowPrimary) {\n    const segments = {};\n    this.capture(\"(\");\n    while (!this.consumeOptional(\")\") && this.remaining.length > 0) {\n      const path = matchSegments(this.remaining);\n      const next = this.remaining[path.length];\n      if (next !== \"/\" && next !== \")\" && next !== \";\") {\n        throw new RuntimeError(4010, (typeof ngDevMode === \"undefined\" || ngDevMode) && `Cannot parse url '${this.url}'`);\n      }\n      let outletName = void 0;\n      if (path.indexOf(\":\") > -1) {\n        outletName = path.slice(0, path.indexOf(\":\"));\n        this.capture(outletName);\n        this.capture(\":\");\n      } else if (allowPrimary) {\n        outletName = PRIMARY_OUTLET;\n      }\n      const children = this.parseChildren();\n      segments[outletName] = Object.keys(children).length === 1 ? children[PRIMARY_OUTLET] : new UrlSegmentGroup([], children);\n      this.consumeOptional(\"//\");\n    }\n    return segments;\n  }\n  peekStartsWith(str) {\n    return this.remaining.startsWith(str);\n  }\n  // Consumes the prefix when it is present and returns whether it has been consumed\n  consumeOptional(str) {\n    if (this.peekStartsWith(str)) {\n      this.remaining = this.remaining.substring(str.length);\n      return true;\n    }\n    return false;\n  }\n  capture(str) {\n    if (!this.consumeOptional(str)) {\n      throw new RuntimeError(4011, (typeof ngDevMode === \"undefined\" || ngDevMode) && `Expected \"${str}\".`);\n    }\n  }\n};\nfunction createRoot(rootCandidate) {\n  return rootCandidate.segments.length > 0 ? new UrlSegmentGroup([], {\n    [PRIMARY_OUTLET]: rootCandidate\n  }) : rootCandidate;\n}\nfunction squashSegmentGroup(segmentGroup) {\n  const newChildren = {};\n  for (const [childOutlet, child] of Object.entries(segmentGroup.children)) {\n    const childCandidate = squashSegmentGroup(child);\n    if (childOutlet === PRIMARY_OUTLET && childCandidate.segments.length === 0 && childCandidate.hasChildren()) {\n      for (const [grandChildOutlet, grandChild] of Object.entries(childCandidate.children)) {\n        newChildren[grandChildOutlet] = grandChild;\n      }\n    } else if (childCandidate.segments.length > 0 || childCandidate.hasChildren()) {\n      newChildren[childOutlet] = childCandidate;\n    }\n  }\n  const s = new UrlSegmentGroup(segmentGroup.segments, newChildren);\n  return mergeTrivialChildren(s);\n}\nfunction mergeTrivialChildren(s) {\n  if (s.numberOfChildren === 1 && s.children[PRIMARY_OUTLET]) {\n    const c = s.children[PRIMARY_OUTLET];\n    return new UrlSegmentGroup(s.segments.concat(c.segments), c.children);\n  }\n  return s;\n}\nfunction isUrlTree(v) {\n  return v instanceof UrlTree;\n}\nfunction createUrlTreeFromSnapshot(relativeTo, commands, queryParams = null, fragment = null) {\n  const relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeTo);\n  return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, queryParams, fragment);\n}\nfunction createSegmentGroupFromRoute(route) {\n  let targetGroup;\n  function createSegmentGroupFromRouteRecursive(currentRoute) {\n    const childOutlets = {};\n    for (const childSnapshot of currentRoute.children) {\n      const root = createSegmentGroupFromRouteRecursive(childSnapshot);\n      childOutlets[childSnapshot.outlet] = root;\n    }\n    const segmentGroup = new UrlSegmentGroup(currentRoute.url, childOutlets);\n    if (currentRoute === route) {\n      targetGroup = segmentGroup;\n    }\n    return segmentGroup;\n  }\n  const rootCandidate = createSegmentGroupFromRouteRecursive(route.root);\n  const rootSegmentGroup = createRoot(rootCandidate);\n  return targetGroup ?? rootSegmentGroup;\n}\nfunction createUrlTreeFromSegmentGroup(relativeTo, commands, queryParams, fragment) {\n  let root = relativeTo;\n  while (root.parent) {\n    root = root.parent;\n  }\n  if (commands.length === 0) {\n    return tree(root, root, root, queryParams, fragment);\n  }\n  const nav = computeNavigation(commands);\n  if (nav.toRoot()) {\n    return tree(root, root, new UrlSegmentGroup([], {}), queryParams, fragment);\n  }\n  const position = findStartingPositionForTargetGroup(nav, root, relativeTo);\n  const newSegmentGroup = position.processChildren ? updateSegmentGroupChildren(position.segmentGroup, position.index, nav.commands) : updateSegmentGroup(position.segmentGroup, position.index, nav.commands);\n  return tree(root, position.segmentGroup, newSegmentGroup, queryParams, fragment);\n}\nfunction isMatrixParams(command) {\n  return typeof command === \"object\" && command != null && !command.outlets && !command.segmentPath;\n}\nfunction isCommandWithOutlets(command) {\n  return typeof command === \"object\" && command != null && command.outlets;\n}\nfunction tree(oldRoot, oldSegmentGroup, newSegmentGroup, queryParams, fragment) {\n  let qp = {};\n  if (queryParams) {\n    Object.entries(queryParams).forEach(([name, value]) => {\n      qp[name] = Array.isArray(value) ? value.map((v) => `${v}`) : `${value}`;\n    });\n  }\n  let rootCandidate;\n  if (oldRoot === oldSegmentGroup) {\n    rootCandidate = newSegmentGroup;\n  } else {\n    rootCandidate = replaceSegment(oldRoot, oldSegmentGroup, newSegmentGroup);\n  }\n  const newRoot = createRoot(squashSegmentGroup(rootCandidate));\n  return new UrlTree(newRoot, qp, fragment);\n}\nfunction replaceSegment(current, oldSegment, newSegment) {\n  const children = {};\n  Object.entries(current.children).forEach(([outletName, c]) => {\n    if (c === oldSegment) {\n      children[outletName] = newSegment;\n    } else {\n      children[outletName] = replaceSegment(c, oldSegment, newSegment);\n    }\n  });\n  return new UrlSegmentGroup(current.segments, children);\n}\nvar Navigation = class {\n  isAbsolute;\n  numberOfDoubleDots;\n  commands;\n  constructor(isAbsolute, numberOfDoubleDots, commands) {\n    this.isAbsolute = isAbsolute;\n    this.numberOfDoubleDots = numberOfDoubleDots;\n    this.commands = commands;\n    if (isAbsolute && commands.length > 0 && isMatrixParams(commands[0])) {\n      throw new RuntimeError(4003, (typeof ngDevMode === \"undefined\" || ngDevMode) && \"Root segment cannot have matrix parameters\");\n    }\n    const cmdWithOutlet = commands.find(isCommandWithOutlets);\n    if (cmdWithOutlet && cmdWithOutlet !== last3(commands)) {\n      throw new RuntimeError(4004, (typeof ngDevMode === \"undefined\" || ngDevMode) && \"{outlets:{}} has to be the last command\");\n    }\n  }\n  toRoot() {\n    return this.isAbsolute && this.commands.length === 1 && this.commands[0] == \"/\";\n  }\n};\nfunction computeNavigation(commands) {\n  if (typeof commands[0] === \"string\" && commands.length === 1 && commands[0] === \"/\") {\n    return new Navigation(true, 0, commands);\n  }\n  let numberOfDoubleDots = 0;\n  let isAbsolute = false;\n  const res = commands.reduce((res2, cmd, cmdIdx) => {\n    if (typeof cmd === \"object\" && cmd != null) {\n      if (cmd.outlets) {\n        const outlets = {};\n        Object.entries(cmd.outlets).forEach(([name, commands2]) => {\n          outlets[name] = typeof commands2 === \"string\" ? commands2.split(\"/\") : commands2;\n        });\n        return [...res2, {\n          outlets\n        }];\n      }\n      if (cmd.segmentPath) {\n        return [...res2, cmd.segmentPath];\n      }\n    }\n    if (!(typeof cmd === \"string\")) {\n      return [...res2, cmd];\n    }\n    if (cmdIdx === 0) {\n      cmd.split(\"/\").forEach((urlPart, partIndex) => {\n        if (partIndex == 0 && urlPart === \".\") ;\n        else if (partIndex == 0 && urlPart === \"\") {\n          isAbsolute = true;\n        } else if (urlPart === \"..\") {\n          numberOfDoubleDots++;\n        } else if (urlPart != \"\") {\n          res2.push(urlPart);\n        }\n      });\n      return res2;\n    }\n    return [...res2, cmd];\n  }, []);\n  return new Navigation(isAbsolute, numberOfDoubleDots, res);\n}\nvar Position = class {\n  segmentGroup;\n  processChildren;\n  index;\n  constructor(segmentGroup, processChildren, index) {\n    this.segmentGroup = segmentGroup;\n    this.processChildren = processChildren;\n    this.index = index;\n  }\n};\nfunction findStartingPositionForTargetGroup(nav, root, target) {\n  if (nav.isAbsolute) {\n    return new Position(root, true, 0);\n  }\n  if (!target) {\n    return new Position(root, false, NaN);\n  }\n  if (target.parent === null) {\n    return new Position(target, true, 0);\n  }\n  const modifier = isMatrixParams(nav.commands[0]) ? 0 : 1;\n  const index = target.segments.length - 1 + modifier;\n  return createPositionApplyingDoubleDots(target, index, nav.numberOfDoubleDots);\n}\nfunction createPositionApplyingDoubleDots(group, index, numberOfDoubleDots) {\n  let g = group;\n  let ci = index;\n  let dd = numberOfDoubleDots;\n  while (dd > ci) {\n    dd -= ci;\n    g = g.parent;\n    if (!g) {\n      throw new RuntimeError(4005, (typeof ngDevMode === \"undefined\" || ngDevMode) && \"Invalid number of '../'\");\n    }\n    ci = g.segments.length;\n  }\n  return new Position(g, false, ci - dd);\n}\nfunction getOutlets(commands) {\n  if (isCommandWithOutlets(commands[0])) {\n    return commands[0].outlets;\n  }\n  return {\n    [PRIMARY_OUTLET]: commands\n  };\n}\nfunction updateSegmentGroup(segmentGroup, startIndex, commands) {\n  segmentGroup ??= new UrlSegmentGroup([], {});\n  if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n    return updateSegmentGroupChildren(segmentGroup, startIndex, commands);\n  }\n  const m = prefixedWith(segmentGroup, startIndex, commands);\n  const slicedCommands = commands.slice(m.commandIndex);\n  if (m.match && m.pathIndex < segmentGroup.segments.length) {\n    const g = new UrlSegmentGroup(segmentGroup.segments.slice(0, m.pathIndex), {});\n    g.children[PRIMARY_OUTLET] = new UrlSegmentGroup(segmentGroup.segments.slice(m.pathIndex), segmentGroup.children);\n    return updateSegmentGroupChildren(g, 0, slicedCommands);\n  } else if (m.match && slicedCommands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else if (m.match && !segmentGroup.hasChildren()) {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  } else if (m.match) {\n    return updateSegmentGroupChildren(segmentGroup, 0, slicedCommands);\n  } else {\n    return createNewSegmentGroup(segmentGroup, startIndex, commands);\n  }\n}\nfunction updateSegmentGroupChildren(segmentGroup, startIndex, commands) {\n  if (commands.length === 0) {\n    return new UrlSegmentGroup(segmentGroup.segments, {});\n  } else {\n    const outlets = getOutlets(commands);\n    const children = {};\n    if (Object.keys(outlets).some((o) => o !== PRIMARY_OUTLET) && segmentGroup.children[PRIMARY_OUTLET] && segmentGroup.numberOfChildren === 1 && segmentGroup.children[PRIMARY_OUTLET].segments.length === 0) {\n      const childrenOfEmptyChild = updateSegmentGroupChildren(segmentGroup.children[PRIMARY_OUTLET], startIndex, commands);\n      return new UrlSegmentGroup(segmentGroup.segments, childrenOfEmptyChild.children);\n    }\n    Object.entries(outlets).forEach(([outlet, commands2]) => {\n      if (typeof commands2 === \"string\") {\n        commands2 = [commands2];\n      }\n      if (commands2 !== null) {\n        children[outlet] = updateSegmentGroup(segmentGroup.children[outlet], startIndex, commands2);\n      }\n    });\n    Object.entries(segmentGroup.children).forEach(([childOutlet, child]) => {\n      if (outlets[childOutlet] === void 0) {\n        children[childOutlet] = child;\n      }\n    });\n    return new UrlSegmentGroup(segmentGroup.segments, children);\n  }\n}\nfunction prefixedWith(segmentGroup, startIndex, commands) {\n  let currentCommandIndex = 0;\n  let currentPathIndex = startIndex;\n  const noMatch2 = {\n    match: false,\n    pathIndex: 0,\n    commandIndex: 0\n  };\n  while (currentPathIndex < segmentGroup.segments.length) {\n    if (currentCommandIndex >= commands.length) return noMatch2;\n    const path = segmentGroup.segments[currentPathIndex];\n    const command = commands[currentCommandIndex];\n    if (isCommandWithOutlets(command)) {\n      break;\n    }\n    const curr = `${command}`;\n    const next = currentCommandIndex < commands.length - 1 ? commands[currentCommandIndex + 1] : null;\n    if (currentPathIndex > 0 && curr === void 0) break;\n    if (curr && next && typeof next === \"object\" && next.outlets === void 0) {\n      if (!compare(curr, next, path)) return noMatch2;\n      currentCommandIndex += 2;\n    } else {\n      if (!compare(curr, {}, path)) return noMatch2;\n      currentCommandIndex++;\n    }\n    currentPathIndex++;\n  }\n  return {\n    match: true,\n    pathIndex: currentPathIndex,\n    commandIndex: currentCommandIndex\n  };\n}\nfunction createNewSegmentGroup(segmentGroup, startIndex, commands) {\n  const paths = segmentGroup.segments.slice(0, startIndex);\n  let i = 0;\n  while (i < commands.length) {\n    const command = commands[i];\n    if (isCommandWithOutlets(command)) {\n      const children = createNewSegmentChildren(command.outlets);\n      return new UrlSegmentGroup(paths, children);\n    }\n    if (i === 0 && isMatrixParams(commands[0])) {\n      const p = segmentGroup.segments[startIndex];\n      paths.push(new UrlSegment(p.path, stringify2(commands[0])));\n      i++;\n      continue;\n    }\n    const curr = isCommandWithOutlets(command) ? command.outlets[PRIMARY_OUTLET] : `${command}`;\n    const next = i < commands.length - 1 ? commands[i + 1] : null;\n    if (curr && next && isMatrixParams(next)) {\n      paths.push(new UrlSegment(curr, stringify2(next)));\n      i += 2;\n    } else {\n      paths.push(new UrlSegment(curr, {}));\n      i++;\n    }\n  }\n  return new UrlSegmentGroup(paths, {});\n}\nfunction createNewSegmentChildren(outlets) {\n  const children = {};\n  Object.entries(outlets).forEach(([outlet, commands]) => {\n    if (typeof commands === \"string\") {\n      commands = [commands];\n    }\n    if (commands !== null) {\n      children[outlet] = createNewSegmentGroup(new UrlSegmentGroup([], {}), 0, commands);\n    }\n  });\n  return children;\n}\nfunction stringify2(params) {\n  const res = {};\n  Object.entries(params).forEach(([k, v]) => res[k] = `${v}`);\n  return res;\n}\nfunction compare(path, params, segment) {\n  return path == segment.path && shallowEqual(params, segment.parameters);\n}\nvar IMPERATIVE_NAVIGATION = \"imperative\";\nvar EventType;\n(function(EventType2) {\n  EventType2[EventType2[\"NavigationStart\"] = 0] = \"NavigationStart\";\n  EventType2[EventType2[\"NavigationEnd\"] = 1] = \"NavigationEnd\";\n  EventType2[EventType2[\"NavigationCancel\"] = 2] = \"NavigationCancel\";\n  EventType2[EventType2[\"NavigationError\"] = 3] = \"NavigationError\";\n  EventType2[EventType2[\"RoutesRecognized\"] = 4] = \"RoutesRecognized\";\n  EventType2[EventType2[\"ResolveStart\"] = 5] = \"ResolveStart\";\n  EventType2[EventType2[\"ResolveEnd\"] = 6] = \"ResolveEnd\";\n  EventType2[EventType2[\"GuardsCheckStart\"] = 7] = \"GuardsCheckStart\";\n  EventType2[EventType2[\"GuardsCheckEnd\"] = 8] = \"GuardsCheckEnd\";\n  EventType2[EventType2[\"RouteConfigLoadStart\"] = 9] = \"RouteConfigLoadStart\";\n  EventType2[EventType2[\"RouteConfigLoadEnd\"] = 10] = \"RouteConfigLoadEnd\";\n  EventType2[EventType2[\"ChildActivationStart\"] = 11] = \"ChildActivationStart\";\n  EventType2[EventType2[\"ChildActivationEnd\"] = 12] = \"ChildActivationEnd\";\n  EventType2[EventType2[\"ActivationStart\"] = 13] = \"ActivationStart\";\n  EventType2[EventType2[\"ActivationEnd\"] = 14] = \"ActivationEnd\";\n  EventType2[EventType2[\"Scroll\"] = 15] = \"Scroll\";\n  EventType2[EventType2[\"NavigationSkipped\"] = 16] = \"NavigationSkipped\";\n})(EventType || (EventType = {}));\nvar RouterEvent = class {\n  id;\n  url;\n  constructor(id, url) {\n    this.id = id;\n    this.url = url;\n  }\n};\nvar NavigationStart = class extends RouterEvent {\n  type = EventType.NavigationStart;\n  /**\n   * Identifies the call or event that triggered the navigation.\n   * An `imperative` trigger is a call to `router.navigateByUrl()` or `router.navigate()`.\n   *\n   * @see {@link NavigationEnd}\n   * @see {@link NavigationCancel}\n   * @see {@link NavigationError}\n   */\n  navigationTrigger;\n  /**\n   * The navigation state that was previously supplied to the `pushState` call,\n   * when the navigation is triggered by a `popstate` event. Otherwise null.\n   *\n   * The state object is defined by `NavigationExtras`, and contains any\n   * developer-defined state value, as well as a unique ID that\n   * the router assigns to every router transition/navigation.\n   *\n   * From the perspective of the router, the router never \"goes back\".\n   * When the user clicks on the back button in the browser,\n   * a new navigation ID is created.\n   *\n   * Use the ID in this previous-state object to differentiate between a newly created\n   * state and one returned to by a `popstate` event, so that you can restore some\n   * remembered state, such as scroll position.\n   *\n   */\n  restoredState;\n  constructor(id, url, navigationTrigger = \"imperative\", restoredState = null) {\n    super(id, url);\n    this.navigationTrigger = navigationTrigger;\n    this.restoredState = restoredState;\n  }\n  /** @docsNotRequired */\n  toString() {\n    return `NavigationStart(id: ${this.id}, url: '${this.url}')`;\n  }\n};\nvar NavigationEnd = class extends RouterEvent {\n  urlAfterRedirects;\n  type = EventType.NavigationEnd;\n  constructor(id, url, urlAfterRedirects) {\n    super(id, url);\n    this.urlAfterRedirects = urlAfterRedirects;\n  }\n  /** @docsNotRequired */\n  toString() {\n    return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`;\n  }\n};\nvar NavigationCancellationCode;\n(function(NavigationCancellationCode2) {\n  NavigationCancellationCode2[NavigationCancellationCode2[\"Redirect\"] = 0] = \"Redirect\";\n  NavigationCancellationCode2[NavigationCancellationCode2[\"SupersededByNewNavigation\"] = 1] = \"SupersededByNewNavigation\";\n  NavigationCancellationCode2[NavigationCancellationCode2[\"NoDataFromResolver\"] = 2] = \"NoDataFromResolver\";\n  NavigationCancellationCode2[NavigationCancellationCode2[\"GuardRejected\"] = 3] = \"GuardRejected\";\n})(NavigationCancellationCode || (NavigationCancellationCode = {}));\nvar NavigationSkippedCode;\n(function(NavigationSkippedCode2) {\n  NavigationSkippedCode2[NavigationSkippedCode2[\"IgnoredSameUrlNavigation\"] = 0] = \"IgnoredSameUrlNavigation\";\n  NavigationSkippedCode2[NavigationSkippedCode2[\"IgnoredByUrlHandlingStrategy\"] = 1] = \"IgnoredByUrlHandlingStrategy\";\n})(NavigationSkippedCode || (NavigationSkippedCode = {}));\nvar NavigationCancel = class extends RouterEvent {\n  reason;\n  code;\n  type = EventType.NavigationCancel;\n  constructor(id, url, reason, code) {\n    super(id, url);\n    this.reason = reason;\n    this.code = code;\n  }\n  /** @docsNotRequired */\n  toString() {\n    return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;\n  }\n};\nvar NavigationSkipped = class extends RouterEvent {\n  reason;\n  code;\n  type = EventType.NavigationSkipped;\n  constructor(id, url, reason, code) {\n    super(id, url);\n    this.reason = reason;\n    this.code = code;\n  }\n};\nvar NavigationError = class extends RouterEvent {\n  error;\n  target;\n  type = EventType.NavigationError;\n  constructor(id, url, error, target) {\n    super(id, url);\n    this.error = error;\n    this.target = target;\n  }\n  /** @docsNotRequired */\n  toString() {\n    return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;\n  }\n};\nvar RoutesRecognized = class extends RouterEvent {\n  urlAfterRedirects;\n  state;\n  type = EventType.RoutesRecognized;\n  constructor(id, url, urlAfterRedirects, state) {\n    super(id, url);\n    this.urlAfterRedirects = urlAfterRedirects;\n    this.state = state;\n  }\n  /** @docsNotRequired */\n  toString() {\n    return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n};\nvar GuardsCheckStart = class extends RouterEvent {\n  urlAfterRedirects;\n  state;\n  type = EventType.GuardsCheckStart;\n  constructor(id, url, urlAfterRedirects, state) {\n    super(id, url);\n    this.urlAfterRedirects = urlAfterRedirects;\n    this.state = state;\n  }\n  toString() {\n    return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n};\nvar GuardsCheckEnd = class extends RouterEvent {\n  urlAfterRedirects;\n  state;\n  shouldActivate;\n  type = EventType.GuardsCheckEnd;\n  constructor(id, url, urlAfterRedirects, state, shouldActivate) {\n    super(id, url);\n    this.urlAfterRedirects = urlAfterRedirects;\n    this.state = state;\n    this.shouldActivate = shouldActivate;\n  }\n  toString() {\n    return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;\n  }\n};\nvar ResolveStart = class extends RouterEvent {\n  urlAfterRedirects;\n  state;\n  type = EventType.ResolveStart;\n  constructor(id, url, urlAfterRedirects, state) {\n    super(id, url);\n    this.urlAfterRedirects = urlAfterRedirects;\n    this.state = state;\n  }\n  toString() {\n    return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n};\nvar ResolveEnd = class extends RouterEvent {\n  urlAfterRedirects;\n  state;\n  type = EventType.ResolveEnd;\n  constructor(id, url, urlAfterRedirects, state) {\n    super(id, url);\n    this.urlAfterRedirects = urlAfterRedirects;\n    this.state = state;\n  }\n  toString() {\n    return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;\n  }\n};\nvar RouteConfigLoadStart = class {\n  route;\n  type = EventType.RouteConfigLoadStart;\n  constructor(route) {\n    this.route = route;\n  }\n  toString() {\n    return `RouteConfigLoadStart(path: ${this.route.path})`;\n  }\n};\nvar RouteConfigLoadEnd = class {\n  route;\n  type = EventType.RouteConfigLoadEnd;\n  constructor(route) {\n    this.route = route;\n  }\n  toString() {\n    return `RouteConfigLoadEnd(path: ${this.route.path})`;\n  }\n};\nvar ChildActivationStart = class {\n  snapshot;\n  type = EventType.ChildActivationStart;\n  constructor(snapshot) {\n    this.snapshot = snapshot;\n  }\n  toString() {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || \"\";\n    return `ChildActivationStart(path: '${path}')`;\n  }\n};\nvar ChildActivationEnd = class {\n  snapshot;\n  type = EventType.ChildActivationEnd;\n  constructor(snapshot) {\n    this.snapshot = snapshot;\n  }\n  toString() {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || \"\";\n    return `ChildActivationEnd(path: '${path}')`;\n  }\n};\nvar ActivationStart = class {\n  snapshot;\n  type = EventType.ActivationStart;\n  constructor(snapshot) {\n    this.snapshot = snapshot;\n  }\n  toString() {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || \"\";\n    return `ActivationStart(path: '${path}')`;\n  }\n};\nvar ActivationEnd = class {\n  snapshot;\n  type = EventType.ActivationEnd;\n  constructor(snapshot) {\n    this.snapshot = snapshot;\n  }\n  toString() {\n    const path = this.snapshot.routeConfig && this.snapshot.routeConfig.path || \"\";\n    return `ActivationEnd(path: '${path}')`;\n  }\n};\nvar Scroll = class {\n  routerEvent;\n  position;\n  anchor;\n  type = EventType.Scroll;\n  constructor(routerEvent, position, anchor) {\n    this.routerEvent = routerEvent;\n    this.position = position;\n    this.anchor = anchor;\n  }\n  toString() {\n    const pos = this.position ? `${this.position[0]}, ${this.position[1]}` : null;\n    return `Scroll(anchor: '${this.anchor}', position: '${pos}')`;\n  }\n};\nvar BeforeActivateRoutes = class {\n};\nvar RedirectRequest = class {\n  url;\n  navigationBehaviorOptions;\n  constructor(url, navigationBehaviorOptions) {\n    this.url = url;\n    this.navigationBehaviorOptions = navigationBehaviorOptions;\n  }\n};\nfunction stringifyEvent(routerEvent) {\n  switch (routerEvent.type) {\n    case EventType.ActivationEnd:\n      return `ActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || \"\"}')`;\n    case EventType.ActivationStart:\n      return `ActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || \"\"}')`;\n    case EventType.ChildActivationEnd:\n      return `ChildActivationEnd(path: '${routerEvent.snapshot.routeConfig?.path || \"\"}')`;\n    case EventType.ChildActivationStart:\n      return `ChildActivationStart(path: '${routerEvent.snapshot.routeConfig?.path || \"\"}')`;\n    case EventType.GuardsCheckEnd:\n      return `GuardsCheckEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state}, shouldActivate: ${routerEvent.shouldActivate})`;\n    case EventType.GuardsCheckStart:\n      return `GuardsCheckStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.NavigationCancel:\n      return `NavigationCancel(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n    case EventType.NavigationSkipped:\n      return `NavigationSkipped(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n    case EventType.NavigationEnd:\n      return `NavigationEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}')`;\n    case EventType.NavigationError:\n      return `NavigationError(id: ${routerEvent.id}, url: '${routerEvent.url}', error: ${routerEvent.error})`;\n    case EventType.NavigationStart:\n      return `NavigationStart(id: ${routerEvent.id}, url: '${routerEvent.url}')`;\n    case EventType.ResolveEnd:\n      return `ResolveEnd(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.ResolveStart:\n      return `ResolveStart(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.RouteConfigLoadEnd:\n      return `RouteConfigLoadEnd(path: ${routerEvent.route.path})`;\n    case EventType.RouteConfigLoadStart:\n      return `RouteConfigLoadStart(path: ${routerEvent.route.path})`;\n    case EventType.RoutesRecognized:\n      return `RoutesRecognized(id: ${routerEvent.id}, url: '${routerEvent.url}', urlAfterRedirects: '${routerEvent.urlAfterRedirects}', state: ${routerEvent.state})`;\n    case EventType.Scroll:\n      const pos = routerEvent.position ? `${routerEvent.position[0]}, ${routerEvent.position[1]}` : null;\n      return `Scroll(anchor: '${routerEvent.anchor}', position: '${pos}')`;\n  }\n}\nfunction getOrCreateRouteInjectorIfNeeded(route, currentInjector) {\n  if (route.providers && !route._injector) {\n    route._injector = createEnvironmentInjector(route.providers, currentInjector, `Route: ${route.path}`);\n  }\n  return route._injector ?? currentInjector;\n}\nfunction validateConfig(config2, parentPath = \"\", requireStandaloneComponents = false) {\n  for (let i = 0; i < config2.length; i++) {\n    const route = config2[i];\n    const fullPath = getFullPath(parentPath, route);\n    validateNode(route, fullPath, requireStandaloneComponents);\n  }\n}\nfunction assertStandalone(fullPath, component) {\n  if (component && isNgModule(component)) {\n    throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}'. You are using 'loadComponent' with a module, but it must be used with standalone components. Use 'loadChildren' instead.`);\n  } else if (component && !isStandalone(component)) {\n    throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}'. The component must be standalone.`);\n  }\n}\nfunction validateNode(route, fullPath, requireStandaloneComponents) {\n  if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n    if (!route) {\n      throw new RuntimeError(4014, `\n      Invalid configuration of route '${fullPath}': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    `);\n    }\n    if (Array.isArray(route)) {\n      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': Array cannot be specified`);\n    }\n    if (!route.redirectTo && !route.component && !route.loadComponent && !route.children && !route.loadChildren && route.outlet && route.outlet !== PRIMARY_OUTLET) {\n      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': a componentless route without children or loadChildren cannot have a named outlet set`);\n    }\n    if (route.redirectTo && route.children) {\n      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and children cannot be used together`);\n    }\n    if (route.redirectTo && route.loadChildren) {\n      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and loadChildren cannot be used together`);\n    }\n    if (route.children && route.loadChildren) {\n      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': children and loadChildren cannot be used together`);\n    }\n    if (route.redirectTo && (route.component || route.loadComponent)) {\n      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and component/loadComponent cannot be used together`);\n    }\n    if (route.component && route.loadComponent) {\n      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': component and loadComponent cannot be used together`);\n    }\n    if (route.redirectTo && route.canActivate) {\n      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': redirectTo and canActivate cannot be used together. Redirects happen before activation so canActivate will never be executed.`);\n    }\n    if (route.path && route.matcher) {\n      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': path and matcher cannot be used together`);\n    }\n    if (route.redirectTo === void 0 && !route.component && !route.loadComponent && !route.children && !route.loadChildren) {\n      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}'. One of the following must be provided: component, loadComponent, redirectTo, children or loadChildren`);\n    }\n    if (route.path === void 0 && route.matcher === void 0) {\n      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': routes must have either a path or a matcher specified`);\n    }\n    if (typeof route.path === \"string\" && route.path.charAt(0) === \"/\") {\n      throw new RuntimeError(4014, `Invalid configuration of route '${fullPath}': path cannot start with a slash`);\n    }\n    if (route.path === \"\" && route.redirectTo !== void 0 && route.pathMatch === void 0) {\n      const exp = `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;\n      throw new RuntimeError(4014, `Invalid configuration of route '{path: \"${fullPath}\", redirectTo: \"${route.redirectTo}\"}': please provide 'pathMatch'. ${exp}`);\n    }\n    if (requireStandaloneComponents) {\n      assertStandalone(fullPath, route.component);\n    }\n  }\n  if (route.children) {\n    validateConfig(route.children, fullPath, requireStandaloneComponents);\n  }\n}\nfunction getFullPath(parentPath, currentRoute) {\n  if (!currentRoute) {\n    return parentPath;\n  }\n  if (!parentPath && !currentRoute.path) {\n    return \"\";\n  } else if (parentPath && !currentRoute.path) {\n    return `${parentPath}/`;\n  } else if (!parentPath && currentRoute.path) {\n    return currentRoute.path;\n  } else {\n    return `${parentPath}/${currentRoute.path}`;\n  }\n}\nfunction getOutlet(route) {\n  return route.outlet || PRIMARY_OUTLET;\n}\nfunction sortByMatchingOutlets(routes2, outletName) {\n  const sortedConfig = routes2.filter((r) => getOutlet(r) === outletName);\n  sortedConfig.push(...routes2.filter((r) => getOutlet(r) !== outletName));\n  return sortedConfig;\n}\nfunction getClosestRouteInjector(snapshot) {\n  if (!snapshot) return null;\n  if (snapshot.routeConfig?._injector) {\n    return snapshot.routeConfig._injector;\n  }\n  for (let s = snapshot.parent; s; s = s.parent) {\n    const route = s.routeConfig;\n    if (route?._loadedInjector) return route._loadedInjector;\n    if (route?._injector) return route._injector;\n  }\n  return null;\n}\nvar OutletContext = class {\n  rootInjector;\n  outlet = null;\n  route = null;\n  children;\n  attachRef = null;\n  get injector() {\n    return getClosestRouteInjector(this.route?.snapshot) ?? this.rootInjector;\n  }\n  constructor(rootInjector) {\n    this.rootInjector = rootInjector;\n    this.children = new ChildrenOutletContexts(this.rootInjector);\n  }\n};\nvar ChildrenOutletContexts = class _ChildrenOutletContexts {\n  rootInjector;\n  // contexts for child outlets, by name.\n  contexts = /* @__PURE__ */ new Map();\n  /** @nodoc */\n  constructor(rootInjector) {\n    this.rootInjector = rootInjector;\n  }\n  /** Called when a `RouterOutlet` directive is instantiated */\n  onChildOutletCreated(childName, outlet) {\n    const context2 = this.getOrCreateContext(childName);\n    context2.outlet = outlet;\n    this.contexts.set(childName, context2);\n  }\n  /**\n   * Called when a `RouterOutlet` directive is destroyed.\n   * We need to keep the context as the outlet could be destroyed inside a NgIf and might be\n   * re-created later.\n   */\n  onChildOutletDestroyed(childName) {\n    const context2 = this.getContext(childName);\n    if (context2) {\n      context2.outlet = null;\n      context2.attachRef = null;\n    }\n  }\n  /**\n   * Called when the corresponding route is deactivated during navigation.\n   * Because the component get destroyed, all children outlet are destroyed.\n   */\n  onOutletDeactivated() {\n    const contexts = this.contexts;\n    this.contexts = /* @__PURE__ */ new Map();\n    return contexts;\n  }\n  onOutletReAttached(contexts) {\n    this.contexts = contexts;\n  }\n  getOrCreateContext(childName) {\n    let context2 = this.getContext(childName);\n    if (!context2) {\n      context2 = new OutletContext(this.rootInjector);\n      this.contexts.set(childName, context2);\n    }\n    return context2;\n  }\n  getContext(childName) {\n    return this.contexts.get(childName) || null;\n  }\n  static \\u0275fac = function ChildrenOutletContexts_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _ChildrenOutletContexts)(\\u0275\\u0275inject(EnvironmentInjector));\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _ChildrenOutletContexts,\n    factory: _ChildrenOutletContexts.\\u0275fac,\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(ChildrenOutletContexts, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], () => [{\n    type: EnvironmentInjector\n  }], null);\n})();\nvar Tree = class {\n  /** @internal */\n  _root;\n  constructor(root) {\n    this._root = root;\n  }\n  get root() {\n    return this._root.value;\n  }\n  /**\n   * @internal\n   */\n  parent(t) {\n    const p = this.pathFromRoot(t);\n    return p.length > 1 ? p[p.length - 2] : null;\n  }\n  /**\n   * @internal\n   */\n  children(t) {\n    const n = findNode(t, this._root);\n    return n ? n.children.map((t2) => t2.value) : [];\n  }\n  /**\n   * @internal\n   */\n  firstChild(t) {\n    const n = findNode(t, this._root);\n    return n && n.children.length > 0 ? n.children[0].value : null;\n  }\n  /**\n   * @internal\n   */\n  siblings(t) {\n    const p = findPath(t, this._root);\n    if (p.length < 2) return [];\n    const c = p[p.length - 2].children.map((c2) => c2.value);\n    return c.filter((cc) => cc !== t);\n  }\n  /**\n   * @internal\n   */\n  pathFromRoot(t) {\n    return findPath(t, this._root).map((s) => s.value);\n  }\n};\nfunction findNode(value, node) {\n  if (value === node.value) return node;\n  for (const child of node.children) {\n    const node2 = findNode(value, child);\n    if (node2) return node2;\n  }\n  return null;\n}\nfunction findPath(value, node) {\n  if (value === node.value) return [node];\n  for (const child of node.children) {\n    const path = findPath(value, child);\n    if (path.length) {\n      path.unshift(node);\n      return path;\n    }\n  }\n  return [];\n}\nvar TreeNode = class {\n  value;\n  children;\n  constructor(value, children) {\n    this.value = value;\n    this.children = children;\n  }\n  toString() {\n    return `TreeNode(${this.value})`;\n  }\n};\nfunction nodeChildrenAsMap(node) {\n  const map2 = {};\n  if (node) {\n    node.children.forEach((child) => map2[child.value.outlet] = child);\n  }\n  return map2;\n}\nvar RouterState = class extends Tree {\n  snapshot;\n  /** @internal */\n  constructor(root, snapshot) {\n    super(root);\n    this.snapshot = snapshot;\n    setRouterState(this, root);\n  }\n  toString() {\n    return this.snapshot.toString();\n  }\n};\nfunction createEmptyState(rootComponent) {\n  const snapshot = createEmptyStateSnapshot(rootComponent);\n  const emptyUrl = new BehaviorSubject([new UrlSegment(\"\", {})]);\n  const emptyParams = new BehaviorSubject({});\n  const emptyData = new BehaviorSubject({});\n  const emptyQueryParams = new BehaviorSubject({});\n  const fragment = new BehaviorSubject(\"\");\n  const activated = new ActivatedRoute(emptyUrl, emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, snapshot.root);\n  activated.snapshot = snapshot.root;\n  return new RouterState(new TreeNode(activated, []), snapshot);\n}\nfunction createEmptyStateSnapshot(rootComponent) {\n  const emptyParams = {};\n  const emptyData = {};\n  const emptyQueryParams = {};\n  const fragment = \"\";\n  const activated = new ActivatedRouteSnapshot([], emptyParams, emptyQueryParams, fragment, emptyData, PRIMARY_OUTLET, rootComponent, null, {});\n  return new RouterStateSnapshot(\"\", new TreeNode(activated, []));\n}\nvar ActivatedRoute = class {\n  urlSubject;\n  paramsSubject;\n  queryParamsSubject;\n  fragmentSubject;\n  dataSubject;\n  outlet;\n  component;\n  /** The current snapshot of this route */\n  snapshot;\n  /** @internal */\n  _futureSnapshot;\n  /** @internal */\n  _routerState;\n  /** @internal */\n  _paramMap;\n  /** @internal */\n  _queryParamMap;\n  /** An Observable of the resolved route title */\n  title;\n  /** An observable of the URL segments matched by this route. */\n  url;\n  /** An observable of the matrix parameters scoped to this route. */\n  params;\n  /** An observable of the query parameters shared by all the routes. */\n  queryParams;\n  /** An observable of the URL fragment shared by all the routes. */\n  fragment;\n  /** An observable of the static and resolved data of this route. */\n  data;\n  /** @internal */\n  constructor(urlSubject, paramsSubject, queryParamsSubject, fragmentSubject, dataSubject, outlet, component, futureSnapshot) {\n    this.urlSubject = urlSubject;\n    this.paramsSubject = paramsSubject;\n    this.queryParamsSubject = queryParamsSubject;\n    this.fragmentSubject = fragmentSubject;\n    this.dataSubject = dataSubject;\n    this.outlet = outlet;\n    this.component = component;\n    this._futureSnapshot = futureSnapshot;\n    this.title = this.dataSubject?.pipe(map((d) => d[RouteTitleKey])) ?? of(void 0);\n    this.url = urlSubject;\n    this.params = paramsSubject;\n    this.queryParams = queryParamsSubject;\n    this.fragment = fragmentSubject;\n    this.data = dataSubject;\n  }\n  /** The configuration used to match this route. */\n  get routeConfig() {\n    return this._futureSnapshot.routeConfig;\n  }\n  /** The root of the router state. */\n  get root() {\n    return this._routerState.root;\n  }\n  /** The parent of this route in the router state tree. */\n  get parent() {\n    return this._routerState.parent(this);\n  }\n  /** The first child of this route in the router state tree. */\n  get firstChild() {\n    return this._routerState.firstChild(this);\n  }\n  /** The children of this route in the router state tree. */\n  get children() {\n    return this._routerState.children(this);\n  }\n  /** The path from the root of the router state tree to this route. */\n  get pathFromRoot() {\n    return this._routerState.pathFromRoot(this);\n  }\n  /**\n   * An Observable that contains a map of the required and optional parameters\n   * specific to the route.\n   * The map supports retrieving single and multiple values from the same parameter.\n   */\n  get paramMap() {\n    this._paramMap ??= this.params.pipe(map((p) => convertToParamMap(p)));\n    return this._paramMap;\n  }\n  /**\n   * An Observable that contains a map of the query parameters available to all routes.\n   * The map supports retrieving single and multiple values from the query parameter.\n   */\n  get queryParamMap() {\n    this._queryParamMap ??= this.queryParams.pipe(map((p) => convertToParamMap(p)));\n    return this._queryParamMap;\n  }\n  toString() {\n    return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})`;\n  }\n};\nfunction getInherited(route, parent, paramsInheritanceStrategy = \"emptyOnly\") {\n  let inherited;\n  const {\n    routeConfig\n  } = route;\n  if (parent !== null && (paramsInheritanceStrategy === \"always\" || // inherit parent data if route is empty path\n  routeConfig?.path === \"\" || // inherit parent data if parent was componentless\n  !parent.component && !parent.routeConfig?.loadComponent)) {\n    inherited = {\n      params: __spreadValues(__spreadValues({}, parent.params), route.params),\n      data: __spreadValues(__spreadValues({}, parent.data), route.data),\n      resolve: __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, route.data), parent.data), routeConfig?.data), route._resolvedData)\n    };\n  } else {\n    inherited = {\n      params: __spreadValues({}, route.params),\n      data: __spreadValues({}, route.data),\n      resolve: __spreadValues(__spreadValues({}, route.data), route._resolvedData ?? {})\n    };\n  }\n  if (routeConfig && hasStaticTitle(routeConfig)) {\n    inherited.resolve[RouteTitleKey] = routeConfig.title;\n  }\n  return inherited;\n}\nvar ActivatedRouteSnapshot = class {\n  url;\n  params;\n  queryParams;\n  fragment;\n  data;\n  outlet;\n  component;\n  /** The configuration used to match this route **/\n  routeConfig;\n  /** @internal */\n  _resolve;\n  /** @internal */\n  _resolvedData;\n  /** @internal */\n  _routerState;\n  /** @internal */\n  _paramMap;\n  /** @internal */\n  _queryParamMap;\n  /** The resolved route title */\n  get title() {\n    return this.data?.[RouteTitleKey];\n  }\n  /** @internal */\n  constructor(url, params, queryParams, fragment, data, outlet, component, routeConfig, resolve) {\n    this.url = url;\n    this.params = params;\n    this.queryParams = queryParams;\n    this.fragment = fragment;\n    this.data = data;\n    this.outlet = outlet;\n    this.component = component;\n    this.routeConfig = routeConfig;\n    this._resolve = resolve;\n  }\n  /** The root of the router state */\n  get root() {\n    return this._routerState.root;\n  }\n  /** The parent of this route in the router state tree */\n  get parent() {\n    return this._routerState.parent(this);\n  }\n  /** The first child of this route in the router state tree */\n  get firstChild() {\n    return this._routerState.firstChild(this);\n  }\n  /** The children of this route in the router state tree */\n  get children() {\n    return this._routerState.children(this);\n  }\n  /** The path from the root of the router state tree to this route */\n  get pathFromRoot() {\n    return this._routerState.pathFromRoot(this);\n  }\n  get paramMap() {\n    this._paramMap ??= convertToParamMap(this.params);\n    return this._paramMap;\n  }\n  get queryParamMap() {\n    this._queryParamMap ??= convertToParamMap(this.queryParams);\n    return this._queryParamMap;\n  }\n  toString() {\n    const url = this.url.map((segment) => segment.toString()).join(\"/\");\n    const matched = this.routeConfig ? this.routeConfig.path : \"\";\n    return `Route(url:'${url}', path:'${matched}')`;\n  }\n};\nvar RouterStateSnapshot = class extends Tree {\n  url;\n  /** @internal */\n  constructor(url, root) {\n    super(root);\n    this.url = url;\n    setRouterState(this, root);\n  }\n  toString() {\n    return serializeNode(this._root);\n  }\n};\nfunction setRouterState(state, node) {\n  node.value._routerState = state;\n  node.children.forEach((c) => setRouterState(state, c));\n}\nfunction serializeNode(node) {\n  const c = node.children.length > 0 ? ` { ${node.children.map(serializeNode).join(\", \")} } ` : \"\";\n  return `${node.value}${c}`;\n}\nfunction advanceActivatedRoute(route) {\n  if (route.snapshot) {\n    const currentSnapshot = route.snapshot;\n    const nextSnapshot = route._futureSnapshot;\n    route.snapshot = nextSnapshot;\n    if (!shallowEqual(currentSnapshot.queryParams, nextSnapshot.queryParams)) {\n      route.queryParamsSubject.next(nextSnapshot.queryParams);\n    }\n    if (currentSnapshot.fragment !== nextSnapshot.fragment) {\n      route.fragmentSubject.next(nextSnapshot.fragment);\n    }\n    if (!shallowEqual(currentSnapshot.params, nextSnapshot.params)) {\n      route.paramsSubject.next(nextSnapshot.params);\n    }\n    if (!shallowEqualArrays(currentSnapshot.url, nextSnapshot.url)) {\n      route.urlSubject.next(nextSnapshot.url);\n    }\n    if (!shallowEqual(currentSnapshot.data, nextSnapshot.data)) {\n      route.dataSubject.next(nextSnapshot.data);\n    }\n  } else {\n    route.snapshot = route._futureSnapshot;\n    route.dataSubject.next(route._futureSnapshot.data);\n  }\n}\nfunction equalParamsAndUrlSegments(a, b) {\n  const equalUrlParams = shallowEqual(a.params, b.params) && equalSegments(a.url, b.url);\n  const parentsMismatch = !a.parent !== !b.parent;\n  return equalUrlParams && !parentsMismatch && (!a.parent || equalParamsAndUrlSegments(a.parent, b.parent));\n}\nfunction hasStaticTitle(config2) {\n  return typeof config2.title === \"string\" || config2.title === null;\n}\nvar ROUTER_OUTLET_DATA = new InjectionToken(ngDevMode ? \"RouterOutlet data\" : \"\");\nvar RouterOutlet = class _RouterOutlet {\n  activated = null;\n  /** @internal */\n  get activatedComponentRef() {\n    return this.activated;\n  }\n  _activatedRoute = null;\n  /**\n   * The name of the outlet\n   *\n   */\n  name = PRIMARY_OUTLET;\n  activateEvents = new EventEmitter();\n  deactivateEvents = new EventEmitter();\n  /**\n   * Emits an attached component instance when the `RouteReuseStrategy` instructs to re-attach a\n   * previously detached subtree.\n   **/\n  attachEvents = new EventEmitter();\n  /**\n   * Emits a detached component instance when the `RouteReuseStrategy` instructs to detach the\n   * subtree.\n   */\n  detachEvents = new EventEmitter();\n  /**\n   * Data that will be provided to the child injector through the `ROUTER_OUTLET_DATA` token.\n   *\n   * When unset, the value of the token is `undefined` by default.\n   */\n  routerOutletData = input(void 0);\n  parentContexts = inject(ChildrenOutletContexts);\n  location = inject(ViewContainerRef);\n  changeDetector = inject(ChangeDetectorRef);\n  inputBinder = inject(INPUT_BINDER, {\n    optional: true\n  });\n  /** @nodoc */\n  supportsBindingToComponentInputs = true;\n  /** @nodoc */\n  ngOnChanges(changes) {\n    if (changes[\"name\"]) {\n      const {\n        firstChange,\n        previousValue\n      } = changes[\"name\"];\n      if (firstChange) {\n        return;\n      }\n      if (this.isTrackedInParentContexts(previousValue)) {\n        this.deactivate();\n        this.parentContexts.onChildOutletDestroyed(previousValue);\n      }\n      this.initializeOutletWithName();\n    }\n  }\n  /** @nodoc */\n  ngOnDestroy() {\n    if (this.isTrackedInParentContexts(this.name)) {\n      this.parentContexts.onChildOutletDestroyed(this.name);\n    }\n    this.inputBinder?.unsubscribeFromRouteData(this);\n  }\n  isTrackedInParentContexts(outletName) {\n    return this.parentContexts.getContext(outletName)?.outlet === this;\n  }\n  /** @nodoc */\n  ngOnInit() {\n    this.initializeOutletWithName();\n  }\n  initializeOutletWithName() {\n    this.parentContexts.onChildOutletCreated(this.name, this);\n    if (this.activated) {\n      return;\n    }\n    const context2 = this.parentContexts.getContext(this.name);\n    if (context2?.route) {\n      if (context2.attachRef) {\n        this.attach(context2.attachRef, context2.route);\n      } else {\n        this.activateWith(context2.route, context2.injector);\n      }\n    }\n  }\n  get isActivated() {\n    return !!this.activated;\n  }\n  /**\n   * @returns The currently activated component instance.\n   * @throws An error if the outlet is not activated.\n   */\n  get component() {\n    if (!this.activated) throw new RuntimeError(4012, (typeof ngDevMode === \"undefined\" || ngDevMode) && \"Outlet is not activated\");\n    return this.activated.instance;\n  }\n  get activatedRoute() {\n    if (!this.activated) throw new RuntimeError(4012, (typeof ngDevMode === \"undefined\" || ngDevMode) && \"Outlet is not activated\");\n    return this._activatedRoute;\n  }\n  get activatedRouteData() {\n    if (this._activatedRoute) {\n      return this._activatedRoute.snapshot.data;\n    }\n    return {};\n  }\n  /**\n   * Called when the `RouteReuseStrategy` instructs to detach the subtree\n   */\n  detach() {\n    if (!this.activated) throw new RuntimeError(4012, (typeof ngDevMode === \"undefined\" || ngDevMode) && \"Outlet is not activated\");\n    this.location.detach();\n    const cmp = this.activated;\n    this.activated = null;\n    this._activatedRoute = null;\n    this.detachEvents.emit(cmp.instance);\n    return cmp;\n  }\n  /**\n   * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n   */\n  attach(ref, activatedRoute) {\n    this.activated = ref;\n    this._activatedRoute = activatedRoute;\n    this.location.insert(ref.hostView);\n    this.inputBinder?.bindActivatedRouteToOutletComponent(this);\n    this.attachEvents.emit(ref.instance);\n  }\n  deactivate() {\n    if (this.activated) {\n      const c = this.component;\n      this.activated.destroy();\n      this.activated = null;\n      this._activatedRoute = null;\n      this.deactivateEvents.emit(c);\n    }\n  }\n  activateWith(activatedRoute, environmentInjector) {\n    if (this.isActivated) {\n      throw new RuntimeError(4013, (typeof ngDevMode === \"undefined\" || ngDevMode) && \"Cannot activate an already activated outlet\");\n    }\n    this._activatedRoute = activatedRoute;\n    const location2 = this.location;\n    const snapshot = activatedRoute.snapshot;\n    const component = snapshot.component;\n    const childContexts = this.parentContexts.getOrCreateContext(this.name).children;\n    const injector = new OutletInjector(activatedRoute, childContexts, location2.injector, this.routerOutletData);\n    this.activated = location2.createComponent(component, {\n      index: location2.length,\n      injector,\n      environmentInjector\n    });\n    this.changeDetector.markForCheck();\n    this.inputBinder?.bindActivatedRouteToOutletComponent(this);\n    this.activateEvents.emit(this.activated.instance);\n  }\n  static \\u0275fac = function RouterOutlet_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _RouterOutlet)();\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _RouterOutlet,\n    selectors: [[\"router-outlet\"]],\n    inputs: {\n      name: \"name\",\n      routerOutletData: [1, \"routerOutletData\"]\n    },\n    outputs: {\n      activateEvents: \"activate\",\n      deactivateEvents: \"deactivate\",\n      attachEvents: \"attach\",\n      detachEvents: \"detach\"\n    },\n    exportAs: [\"outlet\"],\n    features: [\\u0275\\u0275NgOnChangesFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(RouterOutlet, [{\n    type: Directive,\n    args: [{\n      selector: \"router-outlet\",\n      exportAs: \"outlet\"\n    }]\n  }], null, {\n    name: [{\n      type: Input\n    }],\n    activateEvents: [{\n      type: Output,\n      args: [\"activate\"]\n    }],\n    deactivateEvents: [{\n      type: Output,\n      args: [\"deactivate\"]\n    }],\n    attachEvents: [{\n      type: Output,\n      args: [\"attach\"]\n    }],\n    detachEvents: [{\n      type: Output,\n      args: [\"detach\"]\n    }]\n  });\n})();\nvar OutletInjector = class _OutletInjector {\n  route;\n  childContexts;\n  parent;\n  outletData;\n  /**\n   * This injector has a special handing for the `ActivatedRoute` and\n   * `ChildrenOutletContexts` tokens: it returns corresponding values for those\n   * tokens dynamically. This behavior is different from the regular injector logic,\n   * when we initialize and store a value, which is later returned for all inject\n   * requests.\n   *\n   * In some cases (e.g. when using `@defer`), this dynamic behavior requires special\n   * handling. This function allows to identify an instance of the `OutletInjector` and\n   * create an instance of it without referring to the class itself (so this logic can\n   * be invoked from the `core` package). This helps to retain dynamic behavior for the\n   * mentioned tokens.\n   *\n   * Note: it's a temporary solution and we should explore how to support this case better.\n   */\n  __ngOutletInjector(parentInjector) {\n    return new _OutletInjector(this.route, this.childContexts, parentInjector, this.outletData);\n  }\n  constructor(route, childContexts, parent, outletData) {\n    this.route = route;\n    this.childContexts = childContexts;\n    this.parent = parent;\n    this.outletData = outletData;\n  }\n  get(token, notFoundValue) {\n    if (token === ActivatedRoute) {\n      return this.route;\n    }\n    if (token === ChildrenOutletContexts) {\n      return this.childContexts;\n    }\n    if (token === ROUTER_OUTLET_DATA) {\n      return this.outletData;\n    }\n    return this.parent.get(token, notFoundValue);\n  }\n};\nvar INPUT_BINDER = new InjectionToken(\"\");\nvar RoutedComponentInputBinder = class _RoutedComponentInputBinder {\n  outletDataSubscriptions = /* @__PURE__ */ new Map();\n  bindActivatedRouteToOutletComponent(outlet) {\n    this.unsubscribeFromRouteData(outlet);\n    this.subscribeToRouteData(outlet);\n  }\n  unsubscribeFromRouteData(outlet) {\n    this.outletDataSubscriptions.get(outlet)?.unsubscribe();\n    this.outletDataSubscriptions.delete(outlet);\n  }\n  subscribeToRouteData(outlet) {\n    const {\n      activatedRoute\n    } = outlet;\n    const dataSubscription = combineLatest([activatedRoute.queryParams, activatedRoute.params, activatedRoute.data]).pipe(switchMap(([queryParams, params, data], index) => {\n      data = __spreadValues(__spreadValues(__spreadValues({}, queryParams), params), data);\n      if (index === 0) {\n        return of(data);\n      }\n      return Promise.resolve(data);\n    })).subscribe((data) => {\n      if (!outlet.isActivated || !outlet.activatedComponentRef || outlet.activatedRoute !== activatedRoute || activatedRoute.component === null) {\n        this.unsubscribeFromRouteData(outlet);\n        return;\n      }\n      const mirror = reflectComponentType(activatedRoute.component);\n      if (!mirror) {\n        this.unsubscribeFromRouteData(outlet);\n        return;\n      }\n      for (const {\n        templateName\n      } of mirror.inputs) {\n        outlet.activatedComponentRef.setInput(templateName, data[templateName]);\n      }\n    });\n    this.outletDataSubscriptions.set(outlet, dataSubscription);\n  }\n  static \\u0275fac = function RoutedComponentInputBinder_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _RoutedComponentInputBinder)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _RoutedComponentInputBinder,\n    factory: _RoutedComponentInputBinder.\\u0275fac\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(RoutedComponentInputBinder, [{\n    type: Injectable\n  }], null, null);\n})();\nfunction createRouterState(routeReuseStrategy, curr, prevState) {\n  const root = createNode(routeReuseStrategy, curr._root, prevState ? prevState._root : void 0);\n  return new RouterState(root, curr);\n}\nfunction createNode(routeReuseStrategy, curr, prevState) {\n  if (prevState && routeReuseStrategy.shouldReuseRoute(curr.value, prevState.value.snapshot)) {\n    const value = prevState.value;\n    value._futureSnapshot = curr.value;\n    const children = createOrReuseChildren(routeReuseStrategy, curr, prevState);\n    return new TreeNode(value, children);\n  } else {\n    if (routeReuseStrategy.shouldAttach(curr.value)) {\n      const detachedRouteHandle = routeReuseStrategy.retrieve(curr.value);\n      if (detachedRouteHandle !== null) {\n        const tree2 = detachedRouteHandle.route;\n        tree2.value._futureSnapshot = curr.value;\n        tree2.children = curr.children.map((c) => createNode(routeReuseStrategy, c));\n        return tree2;\n      }\n    }\n    const value = createActivatedRoute(curr.value);\n    const children = curr.children.map((c) => createNode(routeReuseStrategy, c));\n    return new TreeNode(value, children);\n  }\n}\nfunction createOrReuseChildren(routeReuseStrategy, curr, prevState) {\n  return curr.children.map((child) => {\n    for (const p of prevState.children) {\n      if (routeReuseStrategy.shouldReuseRoute(child.value, p.value.snapshot)) {\n        return createNode(routeReuseStrategy, child, p);\n      }\n    }\n    return createNode(routeReuseStrategy, child);\n  });\n}\nfunction createActivatedRoute(c) {\n  return new ActivatedRoute(new BehaviorSubject(c.url), new BehaviorSubject(c.params), new BehaviorSubject(c.queryParams), new BehaviorSubject(c.fragment), new BehaviorSubject(c.data), c.outlet, c.component, c);\n}\nvar RedirectCommand = class {\n  redirectTo;\n  navigationBehaviorOptions;\n  constructor(redirectTo, navigationBehaviorOptions) {\n    this.redirectTo = redirectTo;\n    this.navigationBehaviorOptions = navigationBehaviorOptions;\n  }\n};\nvar NAVIGATION_CANCELING_ERROR = \"ngNavigationCancelingError\";\nfunction redirectingNavigationError(urlSerializer, redirect) {\n  const {\n    redirectTo,\n    navigationBehaviorOptions\n  } = isUrlTree(redirect) ? {\n    redirectTo: redirect,\n    navigationBehaviorOptions: void 0\n  } : redirect;\n  const error = navigationCancelingError(ngDevMode && `Redirecting to \"${urlSerializer.serialize(redirectTo)}\"`, NavigationCancellationCode.Redirect);\n  error.url = redirectTo;\n  error.navigationBehaviorOptions = navigationBehaviorOptions;\n  return error;\n}\nfunction navigationCancelingError(message, code) {\n  const error = new Error(`NavigationCancelingError: ${message || \"\"}`);\n  error[NAVIGATION_CANCELING_ERROR] = true;\n  error.cancellationCode = code;\n  return error;\n}\nfunction isRedirectingNavigationCancelingError(error) {\n  return isNavigationCancelingError(error) && isUrlTree(error.url);\n}\nfunction isNavigationCancelingError(error) {\n  return !!error && error[NAVIGATION_CANCELING_ERROR];\n}\nvar warnedAboutUnsupportedInputBinding = false;\nvar activateRoutes = (rootContexts, routeReuseStrategy, forwardEvent, inputBindingEnabled) => map((t) => {\n  new ActivateRoutes(routeReuseStrategy, t.targetRouterState, t.currentRouterState, forwardEvent, inputBindingEnabled).activate(rootContexts);\n  return t;\n});\nvar ActivateRoutes = class {\n  routeReuseStrategy;\n  futureState;\n  currState;\n  forwardEvent;\n  inputBindingEnabled;\n  constructor(routeReuseStrategy, futureState, currState, forwardEvent, inputBindingEnabled) {\n    this.routeReuseStrategy = routeReuseStrategy;\n    this.futureState = futureState;\n    this.currState = currState;\n    this.forwardEvent = forwardEvent;\n    this.inputBindingEnabled = inputBindingEnabled;\n  }\n  activate(parentContexts) {\n    const futureRoot = this.futureState._root;\n    const currRoot = this.currState ? this.currState._root : null;\n    this.deactivateChildRoutes(futureRoot, currRoot, parentContexts);\n    advanceActivatedRoute(this.futureState.root);\n    this.activateChildRoutes(futureRoot, currRoot, parentContexts);\n  }\n  // De-activate the child route that are not re-used for the future state\n  deactivateChildRoutes(futureNode, currNode, contexts) {\n    const children = nodeChildrenAsMap(currNode);\n    futureNode.children.forEach((futureChild) => {\n      const childOutletName = futureChild.value.outlet;\n      this.deactivateRoutes(futureChild, children[childOutletName], contexts);\n      delete children[childOutletName];\n    });\n    Object.values(children).forEach((v) => {\n      this.deactivateRouteAndItsChildren(v, contexts);\n    });\n  }\n  deactivateRoutes(futureNode, currNode, parentContext) {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n    if (future === curr) {\n      if (future.component) {\n        const context2 = parentContext.getContext(future.outlet);\n        if (context2) {\n          this.deactivateChildRoutes(futureNode, currNode, context2.children);\n        }\n      } else {\n        this.deactivateChildRoutes(futureNode, currNode, parentContext);\n      }\n    } else {\n      if (curr) {\n        this.deactivateRouteAndItsChildren(currNode, parentContext);\n      }\n    }\n  }\n  deactivateRouteAndItsChildren(route, parentContexts) {\n    if (route.value.component && this.routeReuseStrategy.shouldDetach(route.value.snapshot)) {\n      this.detachAndStoreRouteSubtree(route, parentContexts);\n    } else {\n      this.deactivateRouteAndOutlet(route, parentContexts);\n    }\n  }\n  detachAndStoreRouteSubtree(route, parentContexts) {\n    const context2 = parentContexts.getContext(route.value.outlet);\n    const contexts = context2 && route.value.component ? context2.children : parentContexts;\n    const children = nodeChildrenAsMap(route);\n    for (const treeNode of Object.values(children)) {\n      this.deactivateRouteAndItsChildren(treeNode, contexts);\n    }\n    if (context2 && context2.outlet) {\n      const componentRef = context2.outlet.detach();\n      const contexts2 = context2.children.onOutletDeactivated();\n      this.routeReuseStrategy.store(route.value.snapshot, {\n        componentRef,\n        route,\n        contexts: contexts2\n      });\n    }\n  }\n  deactivateRouteAndOutlet(route, parentContexts) {\n    const context2 = parentContexts.getContext(route.value.outlet);\n    const contexts = context2 && route.value.component ? context2.children : parentContexts;\n    const children = nodeChildrenAsMap(route);\n    for (const treeNode of Object.values(children)) {\n      this.deactivateRouteAndItsChildren(treeNode, contexts);\n    }\n    if (context2) {\n      if (context2.outlet) {\n        context2.outlet.deactivate();\n        context2.children.onOutletDeactivated();\n      }\n      context2.attachRef = null;\n      context2.route = null;\n    }\n  }\n  activateChildRoutes(futureNode, currNode, contexts) {\n    const children = nodeChildrenAsMap(currNode);\n    futureNode.children.forEach((c) => {\n      this.activateRoutes(c, children[c.value.outlet], contexts);\n      this.forwardEvent(new ActivationEnd(c.value.snapshot));\n    });\n    if (futureNode.children.length) {\n      this.forwardEvent(new ChildActivationEnd(futureNode.value.snapshot));\n    }\n  }\n  activateRoutes(futureNode, currNode, parentContexts) {\n    const future = futureNode.value;\n    const curr = currNode ? currNode.value : null;\n    advanceActivatedRoute(future);\n    if (future === curr) {\n      if (future.component) {\n        const context2 = parentContexts.getOrCreateContext(future.outlet);\n        this.activateChildRoutes(futureNode, currNode, context2.children);\n      } else {\n        this.activateChildRoutes(futureNode, currNode, parentContexts);\n      }\n    } else {\n      if (future.component) {\n        const context2 = parentContexts.getOrCreateContext(future.outlet);\n        if (this.routeReuseStrategy.shouldAttach(future.snapshot)) {\n          const stored = this.routeReuseStrategy.retrieve(future.snapshot);\n          this.routeReuseStrategy.store(future.snapshot, null);\n          context2.children.onOutletReAttached(stored.contexts);\n          context2.attachRef = stored.componentRef;\n          context2.route = stored.route.value;\n          if (context2.outlet) {\n            context2.outlet.attach(stored.componentRef, stored.route.value);\n          }\n          advanceActivatedRoute(stored.route.value);\n          this.activateChildRoutes(futureNode, null, context2.children);\n        } else {\n          context2.attachRef = null;\n          context2.route = future;\n          if (context2.outlet) {\n            context2.outlet.activateWith(future, context2.injector);\n          }\n          this.activateChildRoutes(futureNode, null, context2.children);\n        }\n      } else {\n        this.activateChildRoutes(futureNode, null, parentContexts);\n      }\n    }\n    if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n      const context2 = parentContexts.getOrCreateContext(future.outlet);\n      const outlet = context2.outlet;\n      if (outlet && this.inputBindingEnabled && !outlet.supportsBindingToComponentInputs && !warnedAboutUnsupportedInputBinding) {\n        console.warn(`'withComponentInputBinding' feature is enabled but this application is using an outlet that may not support binding to component inputs.`);\n        warnedAboutUnsupportedInputBinding = true;\n      }\n    }\n  }\n};\nvar CanActivate = class {\n  path;\n  route;\n  constructor(path) {\n    this.path = path;\n    this.route = this.path[this.path.length - 1];\n  }\n};\nvar CanDeactivate = class {\n  component;\n  route;\n  constructor(component, route) {\n    this.component = component;\n    this.route = route;\n  }\n};\nfunction getAllRouteGuards(future, curr, parentContexts) {\n  const futureRoot = future._root;\n  const currRoot = curr ? curr._root : null;\n  return getChildRouteGuards(futureRoot, currRoot, parentContexts, [futureRoot.value]);\n}\nfunction getCanActivateChild(p) {\n  const canActivateChild = p.routeConfig ? p.routeConfig.canActivateChild : null;\n  if (!canActivateChild || canActivateChild.length === 0) return null;\n  return {\n    node: p,\n    guards: canActivateChild\n  };\n}\nfunction getTokenOrFunctionIdentity(tokenOrFunction, injector) {\n  const NOT_FOUND3 = Symbol();\n  const result = injector.get(tokenOrFunction, NOT_FOUND3);\n  if (result === NOT_FOUND3) {\n    if (typeof tokenOrFunction === \"function\" && !isInjectable(tokenOrFunction)) {\n      return tokenOrFunction;\n    } else {\n      return injector.get(tokenOrFunction);\n    }\n  }\n  return result;\n}\nfunction getChildRouteGuards(futureNode, currNode, contexts, futurePath, checks = {\n  canDeactivateChecks: [],\n  canActivateChecks: []\n}) {\n  const prevChildren = nodeChildrenAsMap(currNode);\n  futureNode.children.forEach((c) => {\n    getRouteGuards(c, prevChildren[c.value.outlet], contexts, futurePath.concat([c.value]), checks);\n    delete prevChildren[c.value.outlet];\n  });\n  Object.entries(prevChildren).forEach(([k, v]) => deactivateRouteAndItsChildren(v, contexts.getContext(k), checks));\n  return checks;\n}\nfunction getRouteGuards(futureNode, currNode, parentContexts, futurePath, checks = {\n  canDeactivateChecks: [],\n  canActivateChecks: []\n}) {\n  const future = futureNode.value;\n  const curr = currNode ? currNode.value : null;\n  const context2 = parentContexts ? parentContexts.getContext(futureNode.value.outlet) : null;\n  if (curr && future.routeConfig === curr.routeConfig) {\n    const shouldRun = shouldRunGuardsAndResolvers(curr, future, future.routeConfig.runGuardsAndResolvers);\n    if (shouldRun) {\n      checks.canActivateChecks.push(new CanActivate(futurePath));\n    } else {\n      future.data = curr.data;\n      future._resolvedData = curr._resolvedData;\n    }\n    if (future.component) {\n      getChildRouteGuards(futureNode, currNode, context2 ? context2.children : null, futurePath, checks);\n    } else {\n      getChildRouteGuards(futureNode, currNode, parentContexts, futurePath, checks);\n    }\n    if (shouldRun && context2 && context2.outlet && context2.outlet.isActivated) {\n      checks.canDeactivateChecks.push(new CanDeactivate(context2.outlet.component, curr));\n    }\n  } else {\n    if (curr) {\n      deactivateRouteAndItsChildren(currNode, context2, checks);\n    }\n    checks.canActivateChecks.push(new CanActivate(futurePath));\n    if (future.component) {\n      getChildRouteGuards(futureNode, null, context2 ? context2.children : null, futurePath, checks);\n    } else {\n      getChildRouteGuards(futureNode, null, parentContexts, futurePath, checks);\n    }\n  }\n  return checks;\n}\nfunction shouldRunGuardsAndResolvers(curr, future, mode) {\n  if (typeof mode === \"function\") {\n    return mode(curr, future);\n  }\n  switch (mode) {\n    case \"pathParamsChange\":\n      return !equalPath(curr.url, future.url);\n    case \"pathParamsOrQueryParamsChange\":\n      return !equalPath(curr.url, future.url) || !shallowEqual(curr.queryParams, future.queryParams);\n    case \"always\":\n      return true;\n    case \"paramsOrQueryParamsChange\":\n      return !equalParamsAndUrlSegments(curr, future) || !shallowEqual(curr.queryParams, future.queryParams);\n    case \"paramsChange\":\n    default:\n      return !equalParamsAndUrlSegments(curr, future);\n  }\n}\nfunction deactivateRouteAndItsChildren(route, context2, checks) {\n  const children = nodeChildrenAsMap(route);\n  const r = route.value;\n  Object.entries(children).forEach(([childName, node]) => {\n    if (!r.component) {\n      deactivateRouteAndItsChildren(node, context2, checks);\n    } else if (context2) {\n      deactivateRouteAndItsChildren(node, context2.children.getContext(childName), checks);\n    } else {\n      deactivateRouteAndItsChildren(node, null, checks);\n    }\n  });\n  if (!r.component) {\n    checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n  } else if (context2 && context2.outlet && context2.outlet.isActivated) {\n    checks.canDeactivateChecks.push(new CanDeactivate(context2.outlet.component, r));\n  } else {\n    checks.canDeactivateChecks.push(new CanDeactivate(null, r));\n  }\n}\nfunction isFunction2(v) {\n  return typeof v === \"function\";\n}\nfunction isBoolean(v) {\n  return typeof v === \"boolean\";\n}\nfunction isCanLoad(guard) {\n  return guard && isFunction2(guard.canLoad);\n}\nfunction isCanActivate(guard) {\n  return guard && isFunction2(guard.canActivate);\n}\nfunction isCanActivateChild(guard) {\n  return guard && isFunction2(guard.canActivateChild);\n}\nfunction isCanDeactivate(guard) {\n  return guard && isFunction2(guard.canDeactivate);\n}\nfunction isCanMatch(guard) {\n  return guard && isFunction2(guard.canMatch);\n}\nfunction isEmptyError(e) {\n  return e instanceof EmptyError || e?.name === \"EmptyError\";\n}\nvar INITIAL_VALUE = /* @__PURE__ */ Symbol(\"INITIAL_VALUE\");\nfunction prioritizedGuardValue() {\n  return switchMap((obs) => {\n    return combineLatest(obs.map((o) => o.pipe(take(1), startWith(INITIAL_VALUE)))).pipe(map((results) => {\n      for (const result of results) {\n        if (result === true) {\n          continue;\n        } else if (result === INITIAL_VALUE) {\n          return INITIAL_VALUE;\n        } else if (result === false || isRedirect(result)) {\n          return result;\n        }\n      }\n      return true;\n    }), filter((item) => item !== INITIAL_VALUE), take(1));\n  });\n}\nfunction isRedirect(val) {\n  return isUrlTree(val) || val instanceof RedirectCommand;\n}\nfunction checkGuards(injector, forwardEvent) {\n  return mergeMap((t) => {\n    const {\n      targetSnapshot,\n      currentSnapshot,\n      guards: {\n        canActivateChecks,\n        canDeactivateChecks\n      }\n    } = t;\n    if (canDeactivateChecks.length === 0 && canActivateChecks.length === 0) {\n      return of(__spreadProps(__spreadValues({}, t), {\n        guardsResult: true\n      }));\n    }\n    return runCanDeactivateChecks(canDeactivateChecks, targetSnapshot, currentSnapshot, injector).pipe(mergeMap((canDeactivate) => {\n      return canDeactivate && isBoolean(canDeactivate) ? runCanActivateChecks(targetSnapshot, canActivateChecks, injector, forwardEvent) : of(canDeactivate);\n    }), map((guardsResult) => __spreadProps(__spreadValues({}, t), {\n      guardsResult\n    })));\n  });\n}\nfunction runCanDeactivateChecks(checks, futureRSS, currRSS, injector) {\n  return from(checks).pipe(mergeMap((check) => runCanDeactivate(check.component, check.route, currRSS, futureRSS, injector)), first((result) => {\n    return result !== true;\n  }, true));\n}\nfunction runCanActivateChecks(futureSnapshot, checks, injector, forwardEvent) {\n  return from(checks).pipe(concatMap((check) => {\n    return concat(fireChildActivationStart(check.route.parent, forwardEvent), fireActivationStart(check.route, forwardEvent), runCanActivateChild(futureSnapshot, check.path, injector), runCanActivate(futureSnapshot, check.route, injector));\n  }), first((result) => {\n    return result !== true;\n  }, true));\n}\nfunction fireActivationStart(snapshot, forwardEvent) {\n  if (snapshot !== null && forwardEvent) {\n    forwardEvent(new ActivationStart(snapshot));\n  }\n  return of(true);\n}\nfunction fireChildActivationStart(snapshot, forwardEvent) {\n  if (snapshot !== null && forwardEvent) {\n    forwardEvent(new ChildActivationStart(snapshot));\n  }\n  return of(true);\n}\nfunction runCanActivate(futureRSS, futureARS, injector) {\n  const canActivate = futureARS.routeConfig ? futureARS.routeConfig.canActivate : null;\n  if (!canActivate || canActivate.length === 0) return of(true);\n  const canActivateObservables = canActivate.map((canActivate2) => {\n    return defer(() => {\n      const closestInjector = getClosestRouteInjector(futureARS) ?? injector;\n      const guard = getTokenOrFunctionIdentity(canActivate2, closestInjector);\n      const guardVal = isCanActivate(guard) ? guard.canActivate(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => guard(futureARS, futureRSS));\n      return wrapIntoObservable(guardVal).pipe(first());\n    });\n  });\n  return of(canActivateObservables).pipe(prioritizedGuardValue());\n}\nfunction runCanActivateChild(futureRSS, path, injector) {\n  const futureARS = path[path.length - 1];\n  const canActivateChildGuards = path.slice(0, path.length - 1).reverse().map((p) => getCanActivateChild(p)).filter((_) => _ !== null);\n  const canActivateChildGuardsMapped = canActivateChildGuards.map((d) => {\n    return defer(() => {\n      const guardsMapped = d.guards.map((canActivateChild) => {\n        const closestInjector = getClosestRouteInjector(d.node) ?? injector;\n        const guard = getTokenOrFunctionIdentity(canActivateChild, closestInjector);\n        const guardVal = isCanActivateChild(guard) ? guard.canActivateChild(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => guard(futureARS, futureRSS));\n        return wrapIntoObservable(guardVal).pipe(first());\n      });\n      return of(guardsMapped).pipe(prioritizedGuardValue());\n    });\n  });\n  return of(canActivateChildGuardsMapped).pipe(prioritizedGuardValue());\n}\nfunction runCanDeactivate(component, currARS, currRSS, futureRSS, injector) {\n  const canDeactivate = currARS && currARS.routeConfig ? currARS.routeConfig.canDeactivate : null;\n  if (!canDeactivate || canDeactivate.length === 0) return of(true);\n  const canDeactivateObservables = canDeactivate.map((c) => {\n    const closestInjector = getClosestRouteInjector(currARS) ?? injector;\n    const guard = getTokenOrFunctionIdentity(c, closestInjector);\n    const guardVal = isCanDeactivate(guard) ? guard.canDeactivate(component, currARS, currRSS, futureRSS) : runInInjectionContext(closestInjector, () => guard(component, currARS, currRSS, futureRSS));\n    return wrapIntoObservable(guardVal).pipe(first());\n  });\n  return of(canDeactivateObservables).pipe(prioritizedGuardValue());\n}\nfunction runCanLoadGuards(injector, route, segments, urlSerializer) {\n  const canLoad = route.canLoad;\n  if (canLoad === void 0 || canLoad.length === 0) {\n    return of(true);\n  }\n  const canLoadObservables = canLoad.map((injectionToken) => {\n    const guard = getTokenOrFunctionIdentity(injectionToken, injector);\n    const guardVal = isCanLoad(guard) ? guard.canLoad(route, segments) : runInInjectionContext(injector, () => guard(route, segments));\n    return wrapIntoObservable(guardVal);\n  });\n  return of(canLoadObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));\n}\nfunction redirectIfUrlTree(urlSerializer) {\n  return pipe(tap((result) => {\n    if (typeof result === \"boolean\") return;\n    throw redirectingNavigationError(urlSerializer, result);\n  }), map((result) => result === true));\n}\nfunction runCanMatchGuards(injector, route, segments, urlSerializer) {\n  const canMatch = route.canMatch;\n  if (!canMatch || canMatch.length === 0) return of(true);\n  const canMatchObservables = canMatch.map((injectionToken) => {\n    const guard = getTokenOrFunctionIdentity(injectionToken, injector);\n    const guardVal = isCanMatch(guard) ? guard.canMatch(route, segments) : runInInjectionContext(injector, () => guard(route, segments));\n    return wrapIntoObservable(guardVal);\n  });\n  return of(canMatchObservables).pipe(prioritizedGuardValue(), redirectIfUrlTree(urlSerializer));\n}\nvar NoMatch = class {\n  segmentGroup;\n  constructor(segmentGroup) {\n    this.segmentGroup = segmentGroup || null;\n  }\n};\nvar AbsoluteRedirect = class extends Error {\n  urlTree;\n  constructor(urlTree) {\n    super();\n    this.urlTree = urlTree;\n  }\n};\nfunction noMatch$1(segmentGroup) {\n  return throwError(new NoMatch(segmentGroup));\n}\nfunction namedOutletsRedirect(redirectTo) {\n  return throwError(new RuntimeError(4e3, (typeof ngDevMode === \"undefined\" || ngDevMode) && `Only absolute redirects can have named outlets. redirectTo: '${redirectTo}'`));\n}\nfunction canLoadFails(route) {\n  return throwError(navigationCancelingError((typeof ngDevMode === \"undefined\" || ngDevMode) && `Cannot load children because the guard of the route \"path: '${route.path}'\" returned false`, NavigationCancellationCode.GuardRejected));\n}\nvar ApplyRedirects = class {\n  urlSerializer;\n  urlTree;\n  constructor(urlSerializer, urlTree) {\n    this.urlSerializer = urlSerializer;\n    this.urlTree = urlTree;\n  }\n  lineralizeSegments(route, urlTree) {\n    let res = [];\n    let c = urlTree.root;\n    while (true) {\n      res = res.concat(c.segments);\n      if (c.numberOfChildren === 0) {\n        return of(res);\n      }\n      if (c.numberOfChildren > 1 || !c.children[PRIMARY_OUTLET]) {\n        return namedOutletsRedirect(`${route.redirectTo}`);\n      }\n      c = c.children[PRIMARY_OUTLET];\n    }\n  }\n  applyRedirectCommands(segments, redirectTo, posParams, currentSnapshot, injector) {\n    if (typeof redirectTo !== \"string\") {\n      const redirectToFn = redirectTo;\n      const {\n        queryParams,\n        fragment,\n        routeConfig,\n        url,\n        outlet,\n        params,\n        data,\n        title\n      } = currentSnapshot;\n      const newRedirect = runInInjectionContext(injector, () => redirectToFn({\n        params,\n        data,\n        queryParams,\n        fragment,\n        routeConfig,\n        url,\n        outlet,\n        title\n      }));\n      if (newRedirect instanceof UrlTree) {\n        throw new AbsoluteRedirect(newRedirect);\n      }\n      redirectTo = newRedirect;\n    }\n    const newTree = this.applyRedirectCreateUrlTree(redirectTo, this.urlSerializer.parse(redirectTo), segments, posParams);\n    if (redirectTo[0] === \"/\") {\n      throw new AbsoluteRedirect(newTree);\n    }\n    return newTree;\n  }\n  applyRedirectCreateUrlTree(redirectTo, urlTree, segments, posParams) {\n    const newRoot = this.createSegmentGroup(redirectTo, urlTree.root, segments, posParams);\n    return new UrlTree(newRoot, this.createQueryParams(urlTree.queryParams, this.urlTree.queryParams), urlTree.fragment);\n  }\n  createQueryParams(redirectToParams, actualParams) {\n    const res = {};\n    Object.entries(redirectToParams).forEach(([k, v]) => {\n      const copySourceValue = typeof v === \"string\" && v[0] === \":\";\n      if (copySourceValue) {\n        const sourceName = v.substring(1);\n        res[k] = actualParams[sourceName];\n      } else {\n        res[k] = v;\n      }\n    });\n    return res;\n  }\n  createSegmentGroup(redirectTo, group, segments, posParams) {\n    const updatedSegments = this.createSegments(redirectTo, group.segments, segments, posParams);\n    let children = {};\n    Object.entries(group.children).forEach(([name, child]) => {\n      children[name] = this.createSegmentGroup(redirectTo, child, segments, posParams);\n    });\n    return new UrlSegmentGroup(updatedSegments, children);\n  }\n  createSegments(redirectTo, redirectToSegments, actualSegments, posParams) {\n    return redirectToSegments.map((s) => s.path[0] === \":\" ? this.findPosParam(redirectTo, s, posParams) : this.findOrReturn(s, actualSegments));\n  }\n  findPosParam(redirectTo, redirectToUrlSegment, posParams) {\n    const pos = posParams[redirectToUrlSegment.path.substring(1)];\n    if (!pos) throw new RuntimeError(4001, (typeof ngDevMode === \"undefined\" || ngDevMode) && `Cannot redirect to '${redirectTo}'. Cannot find '${redirectToUrlSegment.path}'.`);\n    return pos;\n  }\n  findOrReturn(redirectToUrlSegment, actualSegments) {\n    let idx = 0;\n    for (const s of actualSegments) {\n      if (s.path === redirectToUrlSegment.path) {\n        actualSegments.splice(idx);\n        return s;\n      }\n      idx++;\n    }\n    return redirectToUrlSegment;\n  }\n};\nvar noMatch = {\n  matched: false,\n  consumedSegments: [],\n  remainingSegments: [],\n  parameters: {},\n  positionalParamSegments: {}\n};\nfunction matchWithChecks(segmentGroup, route, segments, injector, urlSerializer) {\n  const result = match(segmentGroup, route, segments);\n  if (!result.matched) {\n    return of(result);\n  }\n  injector = getOrCreateRouteInjectorIfNeeded(route, injector);\n  return runCanMatchGuards(injector, route, segments, urlSerializer).pipe(map((v) => v === true ? result : __spreadValues({}, noMatch)));\n}\nfunction match(segmentGroup, route, segments) {\n  if (route.path === \"**\") {\n    return createWildcardMatchResult(segments);\n  }\n  if (route.path === \"\") {\n    if (route.pathMatch === \"full\" && (segmentGroup.hasChildren() || segments.length > 0)) {\n      return __spreadValues({}, noMatch);\n    }\n    return {\n      matched: true,\n      consumedSegments: [],\n      remainingSegments: segments,\n      parameters: {},\n      positionalParamSegments: {}\n    };\n  }\n  const matcher = route.matcher || defaultUrlMatcher;\n  const res = matcher(segments, segmentGroup, route);\n  if (!res) return __spreadValues({}, noMatch);\n  const posParams = {};\n  Object.entries(res.posParams ?? {}).forEach(([k, v]) => {\n    posParams[k] = v.path;\n  });\n  const parameters = res.consumed.length > 0 ? __spreadValues(__spreadValues({}, posParams), res.consumed[res.consumed.length - 1].parameters) : posParams;\n  return {\n    matched: true,\n    consumedSegments: res.consumed,\n    remainingSegments: segments.slice(res.consumed.length),\n    // TODO(atscott): investigate combining parameters and positionalParamSegments\n    parameters,\n    positionalParamSegments: res.posParams ?? {}\n  };\n}\nfunction createWildcardMatchResult(segments) {\n  return {\n    matched: true,\n    parameters: segments.length > 0 ? last3(segments).parameters : {},\n    consumedSegments: segments,\n    remainingSegments: [],\n    positionalParamSegments: {}\n  };\n}\nfunction split(segmentGroup, consumedSegments, slicedSegments, config2) {\n  if (slicedSegments.length > 0 && containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, config2)) {\n    const s2 = new UrlSegmentGroup(consumedSegments, createChildrenForEmptyPaths(config2, new UrlSegmentGroup(slicedSegments, segmentGroup.children)));\n    return {\n      segmentGroup: s2,\n      slicedSegments: []\n    };\n  }\n  if (slicedSegments.length === 0 && containsEmptyPathMatches(segmentGroup, slicedSegments, config2)) {\n    const s2 = new UrlSegmentGroup(segmentGroup.segments, addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, config2, segmentGroup.children));\n    return {\n      segmentGroup: s2,\n      slicedSegments\n    };\n  }\n  const s = new UrlSegmentGroup(segmentGroup.segments, segmentGroup.children);\n  return {\n    segmentGroup: s,\n    slicedSegments\n  };\n}\nfunction addEmptyPathsToChildrenIfNeeded(segmentGroup, slicedSegments, routes2, children) {\n  const res = {};\n  for (const r of routes2) {\n    if (emptyPathMatch(segmentGroup, slicedSegments, r) && !children[getOutlet(r)]) {\n      const s = new UrlSegmentGroup([], {});\n      res[getOutlet(r)] = s;\n    }\n  }\n  return __spreadValues(__spreadValues({}, children), res);\n}\nfunction createChildrenForEmptyPaths(routes2, primarySegment) {\n  const res = {};\n  res[PRIMARY_OUTLET] = primarySegment;\n  for (const r of routes2) {\n    if (r.path === \"\" && getOutlet(r) !== PRIMARY_OUTLET) {\n      const s = new UrlSegmentGroup([], {});\n      res[getOutlet(r)] = s;\n    }\n  }\n  return res;\n}\nfunction containsEmptyPathMatchesWithNamedOutlets(segmentGroup, slicedSegments, routes2) {\n  return routes2.some((r) => emptyPathMatch(segmentGroup, slicedSegments, r) && getOutlet(r) !== PRIMARY_OUTLET);\n}\nfunction containsEmptyPathMatches(segmentGroup, slicedSegments, routes2) {\n  return routes2.some((r) => emptyPathMatch(segmentGroup, slicedSegments, r));\n}\nfunction emptyPathMatch(segmentGroup, slicedSegments, r) {\n  if ((segmentGroup.hasChildren() || slicedSegments.length > 0) && r.pathMatch === \"full\") {\n    return false;\n  }\n  return r.path === \"\";\n}\nfunction noLeftoversInUrl(segmentGroup, segments, outlet) {\n  return segments.length === 0 && !segmentGroup.children[outlet];\n}\nvar NoLeftoversInUrl = class {\n};\nfunction recognize$1(injector, configLoader, rootComponentType, config2, urlTree, urlSerializer, paramsInheritanceStrategy = \"emptyOnly\") {\n  return new Recognizer(injector, configLoader, rootComponentType, config2, urlTree, paramsInheritanceStrategy, urlSerializer).recognize();\n}\nvar MAX_ALLOWED_REDIRECTS = 31;\nvar Recognizer = class {\n  injector;\n  configLoader;\n  rootComponentType;\n  config;\n  urlTree;\n  paramsInheritanceStrategy;\n  urlSerializer;\n  applyRedirects;\n  absoluteRedirectCount = 0;\n  allowRedirects = true;\n  constructor(injector, configLoader, rootComponentType, config2, urlTree, paramsInheritanceStrategy, urlSerializer) {\n    this.injector = injector;\n    this.configLoader = configLoader;\n    this.rootComponentType = rootComponentType;\n    this.config = config2;\n    this.urlTree = urlTree;\n    this.paramsInheritanceStrategy = paramsInheritanceStrategy;\n    this.urlSerializer = urlSerializer;\n    this.applyRedirects = new ApplyRedirects(this.urlSerializer, this.urlTree);\n  }\n  noMatchError(e) {\n    return new RuntimeError(4002, typeof ngDevMode === \"undefined\" || ngDevMode ? `Cannot match any routes. URL Segment: '${e.segmentGroup}'` : `'${e.segmentGroup}'`);\n  }\n  recognize() {\n    const rootSegmentGroup = split(this.urlTree.root, [], [], this.config).segmentGroup;\n    return this.match(rootSegmentGroup).pipe(map(({\n      children,\n      rootSnapshot\n    }) => {\n      const rootNode = new TreeNode(rootSnapshot, children);\n      const routeState = new RouterStateSnapshot(\"\", rootNode);\n      const tree2 = createUrlTreeFromSnapshot(rootSnapshot, [], this.urlTree.queryParams, this.urlTree.fragment);\n      tree2.queryParams = this.urlTree.queryParams;\n      routeState.url = this.urlSerializer.serialize(tree2);\n      return {\n        state: routeState,\n        tree: tree2\n      };\n    }));\n  }\n  match(rootSegmentGroup) {\n    const rootSnapshot = new ActivatedRouteSnapshot([], Object.freeze({}), Object.freeze(__spreadValues({}, this.urlTree.queryParams)), this.urlTree.fragment, Object.freeze({}), PRIMARY_OUTLET, this.rootComponentType, null, {});\n    return this.processSegmentGroup(this.injector, this.config, rootSegmentGroup, PRIMARY_OUTLET, rootSnapshot).pipe(map((children) => {\n      return {\n        children,\n        rootSnapshot\n      };\n    }), catchError((e) => {\n      if (e instanceof AbsoluteRedirect) {\n        this.urlTree = e.urlTree;\n        return this.match(e.urlTree.root);\n      }\n      if (e instanceof NoMatch) {\n        throw this.noMatchError(e);\n      }\n      throw e;\n    }));\n  }\n  processSegmentGroup(injector, config2, segmentGroup, outlet, parentRoute) {\n    if (segmentGroup.segments.length === 0 && segmentGroup.hasChildren()) {\n      return this.processChildren(injector, config2, segmentGroup, parentRoute);\n    }\n    return this.processSegment(injector, config2, segmentGroup, segmentGroup.segments, outlet, true, parentRoute).pipe(map((child) => child instanceof TreeNode ? [child] : []));\n  }\n  /**\n   * Matches every child outlet in the `segmentGroup` to a `Route` in the config. Returns `null` if\n   * we cannot find a match for _any_ of the children.\n   *\n   * @param config - The `Routes` to match against\n   * @param segmentGroup - The `UrlSegmentGroup` whose children need to be matched against the\n   *     config.\n   */\n  processChildren(injector, config2, segmentGroup, parentRoute) {\n    const childOutlets = [];\n    for (const child of Object.keys(segmentGroup.children)) {\n      if (child === \"primary\") {\n        childOutlets.unshift(child);\n      } else {\n        childOutlets.push(child);\n      }\n    }\n    return from(childOutlets).pipe(concatMap((childOutlet) => {\n      const child = segmentGroup.children[childOutlet];\n      const sortedConfig = sortByMatchingOutlets(config2, childOutlet);\n      return this.processSegmentGroup(injector, sortedConfig, child, childOutlet, parentRoute);\n    }), scan((children, outletChildren) => {\n      children.push(...outletChildren);\n      return children;\n    }), defaultIfEmpty(null), last2(), mergeMap((children) => {\n      if (children === null) return noMatch$1(segmentGroup);\n      const mergedChildren = mergeEmptyPathMatches(children);\n      if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n        checkOutletNameUniqueness(mergedChildren);\n      }\n      sortActivatedRouteSnapshots(mergedChildren);\n      return of(mergedChildren);\n    }));\n  }\n  processSegment(injector, routes2, segmentGroup, segments, outlet, allowRedirects, parentRoute) {\n    return from(routes2).pipe(concatMap((r) => {\n      return this.processSegmentAgainstRoute(r._injector ?? injector, routes2, r, segmentGroup, segments, outlet, allowRedirects, parentRoute).pipe(catchError((e) => {\n        if (e instanceof NoMatch) {\n          return of(null);\n        }\n        throw e;\n      }));\n    }), first((x) => !!x), catchError((e) => {\n      if (isEmptyError(e)) {\n        if (noLeftoversInUrl(segmentGroup, segments, outlet)) {\n          return of(new NoLeftoversInUrl());\n        }\n        return noMatch$1(segmentGroup);\n      }\n      throw e;\n    }));\n  }\n  processSegmentAgainstRoute(injector, routes2, route, rawSegment, segments, outlet, allowRedirects, parentRoute) {\n    if (getOutlet(route) !== outlet && (outlet === PRIMARY_OUTLET || !emptyPathMatch(rawSegment, segments, route))) {\n      return noMatch$1(rawSegment);\n    }\n    if (route.redirectTo === void 0) {\n      return this.matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute);\n    }\n    if (this.allowRedirects && allowRedirects) {\n      return this.expandSegmentAgainstRouteUsingRedirect(injector, rawSegment, routes2, route, segments, outlet, parentRoute);\n    }\n    return noMatch$1(rawSegment);\n  }\n  expandSegmentAgainstRouteUsingRedirect(injector, segmentGroup, routes2, route, segments, outlet, parentRoute) {\n    const {\n      matched,\n      parameters,\n      consumedSegments,\n      positionalParamSegments,\n      remainingSegments\n    } = match(segmentGroup, route, segments);\n    if (!matched) return noMatch$1(segmentGroup);\n    if (typeof route.redirectTo === \"string\" && route.redirectTo[0] === \"/\") {\n      this.absoluteRedirectCount++;\n      if (this.absoluteRedirectCount > MAX_ALLOWED_REDIRECTS) {\n        if (ngDevMode) {\n          throw new RuntimeError(4016, `Detected possible infinite redirect when redirecting from '${this.urlTree}' to '${route.redirectTo}'.\nThis is currently a dev mode only error but will become a call stack size exceeded error in production in a future major version.`);\n        }\n        this.allowRedirects = false;\n      }\n    }\n    const currentSnapshot = new ActivatedRouteSnapshot(segments, parameters, Object.freeze(__spreadValues({}, this.urlTree.queryParams)), this.urlTree.fragment, getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve(route));\n    const inherited = getInherited(currentSnapshot, parentRoute, this.paramsInheritanceStrategy);\n    currentSnapshot.params = Object.freeze(inherited.params);\n    currentSnapshot.data = Object.freeze(inherited.data);\n    const newTree = this.applyRedirects.applyRedirectCommands(consumedSegments, route.redirectTo, positionalParamSegments, currentSnapshot, injector);\n    return this.applyRedirects.lineralizeSegments(route, newTree).pipe(mergeMap((newSegments) => {\n      return this.processSegment(injector, routes2, segmentGroup, newSegments.concat(remainingSegments), outlet, false, parentRoute);\n    }));\n  }\n  matchSegmentAgainstRoute(injector, rawSegment, route, segments, outlet, parentRoute) {\n    const matchResult = matchWithChecks(rawSegment, route, segments, injector, this.urlSerializer);\n    if (route.path === \"**\") {\n      rawSegment.children = {};\n    }\n    return matchResult.pipe(switchMap((result) => {\n      if (!result.matched) {\n        return noMatch$1(rawSegment);\n      }\n      injector = route._injector ?? injector;\n      return this.getChildConfig(injector, route, segments).pipe(switchMap(({\n        routes: childConfig\n      }) => {\n        const childInjector = route._loadedInjector ?? injector;\n        const {\n          parameters,\n          consumedSegments,\n          remainingSegments\n        } = result;\n        const snapshot = new ActivatedRouteSnapshot(consumedSegments, parameters, Object.freeze(__spreadValues({}, this.urlTree.queryParams)), this.urlTree.fragment, getData(route), getOutlet(route), route.component ?? route._loadedComponent ?? null, route, getResolve(route));\n        const inherited = getInherited(snapshot, parentRoute, this.paramsInheritanceStrategy);\n        snapshot.params = Object.freeze(inherited.params);\n        snapshot.data = Object.freeze(inherited.data);\n        const {\n          segmentGroup,\n          slicedSegments\n        } = split(rawSegment, consumedSegments, remainingSegments, childConfig);\n        if (slicedSegments.length === 0 && segmentGroup.hasChildren()) {\n          return this.processChildren(childInjector, childConfig, segmentGroup, snapshot).pipe(map((children) => {\n            return new TreeNode(snapshot, children);\n          }));\n        }\n        if (childConfig.length === 0 && slicedSegments.length === 0) {\n          return of(new TreeNode(snapshot, []));\n        }\n        const matchedOnOutlet = getOutlet(route) === outlet;\n        return this.processSegment(childInjector, childConfig, segmentGroup, slicedSegments, matchedOnOutlet ? PRIMARY_OUTLET : outlet, true, snapshot).pipe(map((child) => {\n          return new TreeNode(snapshot, child instanceof TreeNode ? [child] : []);\n        }));\n      }));\n    }));\n  }\n  getChildConfig(injector, route, segments) {\n    if (route.children) {\n      return of({\n        routes: route.children,\n        injector\n      });\n    }\n    if (route.loadChildren) {\n      if (route._loadedRoutes !== void 0) {\n        return of({\n          routes: route._loadedRoutes,\n          injector: route._loadedInjector\n        });\n      }\n      return runCanLoadGuards(injector, route, segments, this.urlSerializer).pipe(mergeMap((shouldLoadResult) => {\n        if (shouldLoadResult) {\n          return this.configLoader.loadChildren(injector, route).pipe(tap((cfg) => {\n            route._loadedRoutes = cfg.routes;\n            route._loadedInjector = cfg.injector;\n          }));\n        }\n        return canLoadFails(route);\n      }));\n    }\n    return of({\n      routes: [],\n      injector\n    });\n  }\n};\nfunction sortActivatedRouteSnapshots(nodes) {\n  nodes.sort((a, b) => {\n    if (a.value.outlet === PRIMARY_OUTLET) return -1;\n    if (b.value.outlet === PRIMARY_OUTLET) return 1;\n    return a.value.outlet.localeCompare(b.value.outlet);\n  });\n}\nfunction hasEmptyPathConfig(node) {\n  const config2 = node.value.routeConfig;\n  return config2 && config2.path === \"\";\n}\nfunction mergeEmptyPathMatches(nodes) {\n  const result = [];\n  const mergedNodes = /* @__PURE__ */ new Set();\n  for (const node of nodes) {\n    if (!hasEmptyPathConfig(node)) {\n      result.push(node);\n      continue;\n    }\n    const duplicateEmptyPathNode = result.find((resultNode) => node.value.routeConfig === resultNode.value.routeConfig);\n    if (duplicateEmptyPathNode !== void 0) {\n      duplicateEmptyPathNode.children.push(...node.children);\n      mergedNodes.add(duplicateEmptyPathNode);\n    } else {\n      result.push(node);\n    }\n  }\n  for (const mergedNode of mergedNodes) {\n    const mergedChildren = mergeEmptyPathMatches(mergedNode.children);\n    result.push(new TreeNode(mergedNode.value, mergedChildren));\n  }\n  return result.filter((n) => !mergedNodes.has(n));\n}\nfunction checkOutletNameUniqueness(nodes) {\n  const names = {};\n  nodes.forEach((n) => {\n    const routeWithSameOutletName = names[n.value.outlet];\n    if (routeWithSameOutletName) {\n      const p = routeWithSameOutletName.url.map((s) => s.toString()).join(\"/\");\n      const c = n.value.url.map((s) => s.toString()).join(\"/\");\n      throw new RuntimeError(4006, (typeof ngDevMode === \"undefined\" || ngDevMode) && `Two segments cannot have the same outlet name: '${p}' and '${c}'.`);\n    }\n    names[n.value.outlet] = n.value;\n  });\n}\nfunction getData(route) {\n  return route.data || {};\n}\nfunction getResolve(route) {\n  return route.resolve || {};\n}\nfunction recognize(injector, configLoader, rootComponentType, config2, serializer, paramsInheritanceStrategy) {\n  return mergeMap((t) => recognize$1(injector, configLoader, rootComponentType, config2, t.extractedUrl, serializer, paramsInheritanceStrategy).pipe(map(({\n    state: targetSnapshot,\n    tree: urlAfterRedirects\n  }) => {\n    return __spreadProps(__spreadValues({}, t), {\n      targetSnapshot,\n      urlAfterRedirects\n    });\n  })));\n}\nfunction resolveData(paramsInheritanceStrategy, injector) {\n  return mergeMap((t) => {\n    const {\n      targetSnapshot,\n      guards: {\n        canActivateChecks\n      }\n    } = t;\n    if (!canActivateChecks.length) {\n      return of(t);\n    }\n    const routesWithResolversToRun = new Set(canActivateChecks.map((check) => check.route));\n    const routesNeedingDataUpdates = /* @__PURE__ */ new Set();\n    for (const route of routesWithResolversToRun) {\n      if (routesNeedingDataUpdates.has(route)) {\n        continue;\n      }\n      for (const newRoute of flattenRouteTree(route)) {\n        routesNeedingDataUpdates.add(newRoute);\n      }\n    }\n    let routesProcessed = 0;\n    return from(routesNeedingDataUpdates).pipe(concatMap((route) => {\n      if (routesWithResolversToRun.has(route)) {\n        return runResolve(route, targetSnapshot, paramsInheritanceStrategy, injector);\n      } else {\n        route.data = getInherited(route, route.parent, paramsInheritanceStrategy).resolve;\n        return of(void 0);\n      }\n    }), tap(() => routesProcessed++), takeLast(1), mergeMap((_) => routesProcessed === routesNeedingDataUpdates.size ? of(t) : EMPTY));\n  });\n}\nfunction flattenRouteTree(route) {\n  const descendants = route.children.map((child) => flattenRouteTree(child)).flat();\n  return [route, ...descendants];\n}\nfunction runResolve(futureARS, futureRSS, paramsInheritanceStrategy, injector) {\n  const config2 = futureARS.routeConfig;\n  const resolve = futureARS._resolve;\n  if (config2?.title !== void 0 && !hasStaticTitle(config2)) {\n    resolve[RouteTitleKey] = config2.title;\n  }\n  return resolveNode(resolve, futureARS, futureRSS, injector).pipe(map((resolvedData) => {\n    futureARS._resolvedData = resolvedData;\n    futureARS.data = getInherited(futureARS, futureARS.parent, paramsInheritanceStrategy).resolve;\n    return null;\n  }));\n}\nfunction resolveNode(resolve, futureARS, futureRSS, injector) {\n  const keys = getDataKeys(resolve);\n  if (keys.length === 0) {\n    return of({});\n  }\n  const data = {};\n  return from(keys).pipe(mergeMap((key) => getResolver(resolve[key], futureARS, futureRSS, injector).pipe(first(), tap((value) => {\n    if (value instanceof RedirectCommand) {\n      throw redirectingNavigationError(new DefaultUrlSerializer(), value);\n    }\n    data[key] = value;\n  }))), takeLast(1), map(() => data), catchError((e) => isEmptyError(e) ? EMPTY : throwError(e)));\n}\nfunction getResolver(injectionToken, futureARS, futureRSS, injector) {\n  const closestInjector = getClosestRouteInjector(futureARS) ?? injector;\n  const resolver = getTokenOrFunctionIdentity(injectionToken, closestInjector);\n  const resolverValue = resolver.resolve ? resolver.resolve(futureARS, futureRSS) : runInInjectionContext(closestInjector, () => resolver(futureARS, futureRSS));\n  return wrapIntoObservable(resolverValue);\n}\nfunction switchTap(next) {\n  return switchMap((v) => {\n    const nextResult = next(v);\n    if (nextResult) {\n      return from(nextResult).pipe(map(() => v));\n    }\n    return of(v);\n  });\n}\nvar TitleStrategy = class _TitleStrategy {\n  /**\n   * @returns The `title` of the deepest primary route.\n   */\n  buildTitle(snapshot) {\n    let pageTitle;\n    let route = snapshot.root;\n    while (route !== void 0) {\n      pageTitle = this.getResolvedTitleForRoute(route) ?? pageTitle;\n      route = route.children.find((child) => child.outlet === PRIMARY_OUTLET);\n    }\n    return pageTitle;\n  }\n  /**\n   * Given an `ActivatedRouteSnapshot`, returns the final value of the\n   * `Route.title` property, which can either be a static string or a resolved value.\n   */\n  getResolvedTitleForRoute(snapshot) {\n    return snapshot.data[RouteTitleKey];\n  }\n  static \\u0275fac = function TitleStrategy_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _TitleStrategy)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _TitleStrategy,\n    factory: () => (() => inject(DefaultTitleStrategy))(),\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(TitleStrategy, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\",\n      useFactory: () => inject(DefaultTitleStrategy)\n    }]\n  }], null, null);\n})();\nvar DefaultTitleStrategy = class _DefaultTitleStrategy extends TitleStrategy {\n  title;\n  constructor(title) {\n    super();\n    this.title = title;\n  }\n  /**\n   * Sets the title of the browser to the given value.\n   *\n   * @param title The `pageTitle` from the deepest primary route.\n   */\n  updateTitle(snapshot) {\n    const title = this.buildTitle(snapshot);\n    if (title !== void 0) {\n      this.title.setTitle(title);\n    }\n  }\n  static \\u0275fac = function DefaultTitleStrategy_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _DefaultTitleStrategy)(\\u0275\\u0275inject(Title));\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _DefaultTitleStrategy,\n    factory: _DefaultTitleStrategy.\\u0275fac,\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(DefaultTitleStrategy, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], () => [{\n    type: Title\n  }], null);\n})();\nvar ROUTER_CONFIGURATION = new InjectionToken(typeof ngDevMode === \"undefined\" || ngDevMode ? \"router config\" : \"\", {\n  providedIn: \"root\",\n  factory: () => ({})\n});\nvar \\u0275EmptyOutletComponent = class _\\u0275EmptyOutletComponent {\n  static \\u0275fac = function \\u0275EmptyOutletComponent_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _\\u0275EmptyOutletComponent)();\n  };\n  static \\u0275cmp = /* @__PURE__ */ \\u0275\\u0275defineComponent({\n    type: _\\u0275EmptyOutletComponent,\n    selectors: [[\"ng-component\"]],\n    exportAs: [\"emptyRouterOutlet\"],\n    decls: 1,\n    vars: 0,\n    template: function _EmptyOutletComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        \\u0275\\u0275element(0, \"router-outlet\");\n      }\n    },\n    dependencies: [RouterOutlet],\n    encapsulation: 2\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(\\u0275EmptyOutletComponent, [{\n    type: Component,\n    args: [{\n      template: `<router-outlet/>`,\n      imports: [RouterOutlet],\n      // Used to avoid component ID collisions with user code.\n      exportAs: \"emptyRouterOutlet\"\n    }]\n  }], null, null);\n})();\nfunction standardizeConfig(r) {\n  const children = r.children && r.children.map(standardizeConfig);\n  const c = children ? __spreadProps(__spreadValues({}, r), {\n    children\n  }) : __spreadValues({}, r);\n  if (!c.component && !c.loadComponent && (children || c.loadChildren) && c.outlet && c.outlet !== PRIMARY_OUTLET) {\n    c.component = \\u0275EmptyOutletComponent;\n  }\n  return c;\n}\nvar ROUTES = new InjectionToken(ngDevMode ? \"ROUTES\" : \"\");\nvar RouterConfigLoader = class _RouterConfigLoader {\n  componentLoaders = /* @__PURE__ */ new WeakMap();\n  childrenLoaders = /* @__PURE__ */ new WeakMap();\n  onLoadStartListener;\n  onLoadEndListener;\n  compiler = inject(Compiler);\n  loadComponent(route) {\n    if (this.componentLoaders.get(route)) {\n      return this.componentLoaders.get(route);\n    } else if (route._loadedComponent) {\n      return of(route._loadedComponent);\n    }\n    if (this.onLoadStartListener) {\n      this.onLoadStartListener(route);\n    }\n    const loadRunner = wrapIntoObservable(route.loadComponent()).pipe(map(maybeUnwrapDefaultExport), tap((component) => {\n      if (this.onLoadEndListener) {\n        this.onLoadEndListener(route);\n      }\n      (typeof ngDevMode === \"undefined\" || ngDevMode) && assertStandalone(route.path ?? \"\", component);\n      route._loadedComponent = component;\n    }), finalize(() => {\n      this.componentLoaders.delete(route);\n    }));\n    const loader = new ConnectableObservable(loadRunner, () => new Subject()).pipe(refCount());\n    this.componentLoaders.set(route, loader);\n    return loader;\n  }\n  loadChildren(parentInjector, route) {\n    if (this.childrenLoaders.get(route)) {\n      return this.childrenLoaders.get(route);\n    } else if (route._loadedRoutes) {\n      return of({\n        routes: route._loadedRoutes,\n        injector: route._loadedInjector\n      });\n    }\n    if (this.onLoadStartListener) {\n      this.onLoadStartListener(route);\n    }\n    const moduleFactoryOrRoutes$ = loadChildren(route, this.compiler, parentInjector, this.onLoadEndListener);\n    const loadRunner = moduleFactoryOrRoutes$.pipe(finalize(() => {\n      this.childrenLoaders.delete(route);\n    }));\n    const loader = new ConnectableObservable(loadRunner, () => new Subject()).pipe(refCount());\n    this.childrenLoaders.set(route, loader);\n    return loader;\n  }\n  static \\u0275fac = function RouterConfigLoader_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _RouterConfigLoader)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _RouterConfigLoader,\n    factory: _RouterConfigLoader.\\u0275fac,\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(RouterConfigLoader, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], null, null);\n})();\nfunction loadChildren(route, compiler, parentInjector, onLoadEndListener) {\n  return wrapIntoObservable(route.loadChildren()).pipe(map(maybeUnwrapDefaultExport), mergeMap((t) => {\n    if (t instanceof NgModuleFactory$1 || Array.isArray(t)) {\n      return of(t);\n    } else {\n      return from(compiler.compileModuleAsync(t));\n    }\n  }), map((factoryOrRoutes) => {\n    if (onLoadEndListener) {\n      onLoadEndListener(route);\n    }\n    let injector;\n    let rawRoutes;\n    let requireStandaloneComponents = false;\n    if (Array.isArray(factoryOrRoutes)) {\n      rawRoutes = factoryOrRoutes;\n      requireStandaloneComponents = true;\n    } else {\n      injector = factoryOrRoutes.create(parentInjector).injector;\n      rawRoutes = injector.get(ROUTES, [], {\n        optional: true,\n        self: true\n      }).flat();\n    }\n    const routes2 = rawRoutes.map(standardizeConfig);\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && validateConfig(routes2, route.path, requireStandaloneComponents);\n    return {\n      routes: routes2,\n      injector\n    };\n  }));\n}\nfunction isWrappedDefaultExport(value) {\n  return value && typeof value === \"object\" && \"default\" in value;\n}\nfunction maybeUnwrapDefaultExport(input2) {\n  return isWrappedDefaultExport(input2) ? input2[\"default\"] : input2;\n}\nvar UrlHandlingStrategy = class _UrlHandlingStrategy {\n  static \\u0275fac = function UrlHandlingStrategy_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _UrlHandlingStrategy)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _UrlHandlingStrategy,\n    factory: () => (() => inject(DefaultUrlHandlingStrategy))(),\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(UrlHandlingStrategy, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\",\n      useFactory: () => inject(DefaultUrlHandlingStrategy)\n    }]\n  }], null, null);\n})();\nvar DefaultUrlHandlingStrategy = class _DefaultUrlHandlingStrategy {\n  shouldProcessUrl(url) {\n    return true;\n  }\n  extract(url) {\n    return url;\n  }\n  merge(newUrlPart, wholeUrl) {\n    return newUrlPart;\n  }\n  static \\u0275fac = function DefaultUrlHandlingStrategy_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _DefaultUrlHandlingStrategy)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _DefaultUrlHandlingStrategy,\n    factory: _DefaultUrlHandlingStrategy.\\u0275fac,\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(DefaultUrlHandlingStrategy, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], null, null);\n})();\nvar CREATE_VIEW_TRANSITION = new InjectionToken(ngDevMode ? \"view transition helper\" : \"\");\nvar VIEW_TRANSITION_OPTIONS = new InjectionToken(ngDevMode ? \"view transition options\" : \"\");\nfunction createViewTransition(injector, from2, to) {\n  const transitionOptions = injector.get(VIEW_TRANSITION_OPTIONS);\n  const document2 = injector.get(DOCUMENT2);\n  return injector.get(NgZone).runOutsideAngular(() => {\n    if (!document2.startViewTransition || transitionOptions.skipNextTransition) {\n      transitionOptions.skipNextTransition = false;\n      return new Promise((resolve) => setTimeout(resolve));\n    }\n    let resolveViewTransitionStarted;\n    const viewTransitionStarted = new Promise((resolve) => {\n      resolveViewTransitionStarted = resolve;\n    });\n    const transition = document2.startViewTransition(() => {\n      resolveViewTransitionStarted();\n      return createRenderPromise(injector);\n    });\n    const {\n      onViewTransitionCreated\n    } = transitionOptions;\n    if (onViewTransitionCreated) {\n      runInInjectionContext(injector, () => onViewTransitionCreated({\n        transition,\n        from: from2,\n        to\n      }));\n    }\n    return viewTransitionStarted;\n  });\n}\nfunction createRenderPromise(injector) {\n  return new Promise((resolve) => {\n    afterNextRender({\n      read: () => setTimeout(resolve)\n    }, {\n      injector\n    });\n  });\n}\nvar NAVIGATION_ERROR_HANDLER = new InjectionToken(typeof ngDevMode === \"undefined\" || ngDevMode ? \"navigation error handler\" : \"\");\nvar NavigationTransitions = class _NavigationTransitions {\n  currentNavigation = null;\n  currentTransition = null;\n  lastSuccessfulNavigation = null;\n  /**\n   * These events are used to communicate back to the Router about the state of the transition. The\n   * Router wants to respond to these events in various ways. Because the `NavigationTransition`\n   * class is not public, this event subject is not publicly exposed.\n   */\n  events = new Subject();\n  /**\n   * Used to abort the current transition with an error.\n   */\n  transitionAbortSubject = new Subject();\n  configLoader = inject(RouterConfigLoader);\n  environmentInjector = inject(EnvironmentInjector);\n  destroyRef = inject(DestroyRef);\n  urlSerializer = inject(UrlSerializer);\n  rootContexts = inject(ChildrenOutletContexts);\n  location = inject(Location);\n  inputBindingEnabled = inject(INPUT_BINDER, {\n    optional: true\n  }) !== null;\n  titleStrategy = inject(TitleStrategy);\n  options = inject(ROUTER_CONFIGURATION, {\n    optional: true\n  }) || {};\n  paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || \"emptyOnly\";\n  urlHandlingStrategy = inject(UrlHandlingStrategy);\n  createViewTransition = inject(CREATE_VIEW_TRANSITION, {\n    optional: true\n  });\n  navigationErrorHandler = inject(NAVIGATION_ERROR_HANDLER, {\n    optional: true\n  });\n  navigationId = 0;\n  get hasRequestedNavigation() {\n    return this.navigationId !== 0;\n  }\n  transitions;\n  /**\n   * Hook that enables you to pause navigation after the preactivation phase.\n   * Used by `RouterModule`.\n   *\n   * @internal\n   */\n  afterPreactivation = () => of(void 0);\n  /** @internal */\n  rootComponentType = null;\n  destroyed = false;\n  constructor() {\n    const onLoadStart = (r) => this.events.next(new RouteConfigLoadStart(r));\n    const onLoadEnd = (r) => this.events.next(new RouteConfigLoadEnd(r));\n    this.configLoader.onLoadEndListener = onLoadEnd;\n    this.configLoader.onLoadStartListener = onLoadStart;\n    this.destroyRef.onDestroy(() => {\n      this.destroyed = true;\n    });\n  }\n  complete() {\n    this.transitions?.complete();\n  }\n  handleNavigationRequest(request) {\n    const id = ++this.navigationId;\n    this.transitions?.next(__spreadProps(__spreadValues({}, request), {\n      extractedUrl: this.urlHandlingStrategy.extract(request.rawUrl),\n      targetSnapshot: null,\n      targetRouterState: null,\n      guards: {\n        canActivateChecks: [],\n        canDeactivateChecks: []\n      },\n      guardsResult: null,\n      id\n    }));\n  }\n  setupNavigations(router) {\n    this.transitions = new BehaviorSubject(null);\n    return this.transitions.pipe(\n      filter((t) => t !== null),\n      // Using switchMap so we cancel executing navigations when a new one comes in\n      switchMap((overallTransitionState) => {\n        let completed = false;\n        let errored = false;\n        return of(overallTransitionState).pipe(\n          switchMap((t) => {\n            if (this.navigationId > overallTransitionState.id) {\n              const cancellationReason = typeof ngDevMode === \"undefined\" || ngDevMode ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}` : \"\";\n              this.cancelNavigationTransition(overallTransitionState, cancellationReason, NavigationCancellationCode.SupersededByNewNavigation);\n              return EMPTY;\n            }\n            this.currentTransition = overallTransitionState;\n            this.currentNavigation = {\n              id: t.id,\n              initialUrl: t.rawUrl,\n              extractedUrl: t.extractedUrl,\n              targetBrowserUrl: typeof t.extras.browserUrl === \"string\" ? this.urlSerializer.parse(t.extras.browserUrl) : t.extras.browserUrl,\n              trigger: t.source,\n              extras: t.extras,\n              previousNavigation: !this.lastSuccessfulNavigation ? null : __spreadProps(__spreadValues({}, this.lastSuccessfulNavigation), {\n                previousNavigation: null\n              })\n            };\n            const urlTransition = !router.navigated || this.isUpdatingInternalState() || this.isUpdatedBrowserUrl();\n            const onSameUrlNavigation = t.extras.onSameUrlNavigation ?? router.onSameUrlNavigation;\n            if (!urlTransition && onSameUrlNavigation !== \"reload\") {\n              const reason = typeof ngDevMode === \"undefined\" || ngDevMode ? `Navigation to ${t.rawUrl} was ignored because it is the same as the current Router URL.` : \"\";\n              this.events.next(new NavigationSkipped(t.id, this.urlSerializer.serialize(t.rawUrl), reason, NavigationSkippedCode.IgnoredSameUrlNavigation));\n              t.resolve(false);\n              return EMPTY;\n            }\n            if (this.urlHandlingStrategy.shouldProcessUrl(t.rawUrl)) {\n              return of(t).pipe(\n                // Fire NavigationStart event\n                switchMap((t2) => {\n                  this.events.next(new NavigationStart(t2.id, this.urlSerializer.serialize(t2.extractedUrl), t2.source, t2.restoredState));\n                  if (t2.id !== this.navigationId) {\n                    return EMPTY;\n                  }\n                  return Promise.resolve(t2);\n                }),\n                // Recognize\n                recognize(this.environmentInjector, this.configLoader, this.rootComponentType, router.config, this.urlSerializer, this.paramsInheritanceStrategy),\n                // Update URL if in `eager` update mode\n                tap((t2) => {\n                  overallTransitionState.targetSnapshot = t2.targetSnapshot;\n                  overallTransitionState.urlAfterRedirects = t2.urlAfterRedirects;\n                  this.currentNavigation = __spreadProps(__spreadValues({}, this.currentNavigation), {\n                    finalUrl: t2.urlAfterRedirects\n                  });\n                  const routesRecognized = new RoutesRecognized(t2.id, this.urlSerializer.serialize(t2.extractedUrl), this.urlSerializer.serialize(t2.urlAfterRedirects), t2.targetSnapshot);\n                  this.events.next(routesRecognized);\n                })\n              );\n            } else if (urlTransition && this.urlHandlingStrategy.shouldProcessUrl(t.currentRawUrl)) {\n              const {\n                id,\n                extractedUrl,\n                source,\n                restoredState,\n                extras\n              } = t;\n              const navStart = new NavigationStart(id, this.urlSerializer.serialize(extractedUrl), source, restoredState);\n              this.events.next(navStart);\n              const targetSnapshot = createEmptyState(this.rootComponentType).snapshot;\n              this.currentTransition = overallTransitionState = __spreadProps(__spreadValues({}, t), {\n                targetSnapshot,\n                urlAfterRedirects: extractedUrl,\n                extras: __spreadProps(__spreadValues({}, extras), {\n                  skipLocationChange: false,\n                  replaceUrl: false\n                })\n              });\n              this.currentNavigation.finalUrl = extractedUrl;\n              return of(overallTransitionState);\n            } else {\n              const reason = typeof ngDevMode === \"undefined\" || ngDevMode ? `Navigation was ignored because the UrlHandlingStrategy indicated neither the current URL ${t.currentRawUrl} nor target URL ${t.rawUrl} should be processed.` : \"\";\n              this.events.next(new NavigationSkipped(t.id, this.urlSerializer.serialize(t.extractedUrl), reason, NavigationSkippedCode.IgnoredByUrlHandlingStrategy));\n              t.resolve(false);\n              return EMPTY;\n            }\n          }),\n          // --- GUARDS ---\n          tap((t) => {\n            const guardsStart = new GuardsCheckStart(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot);\n            this.events.next(guardsStart);\n          }),\n          map((t) => {\n            this.currentTransition = overallTransitionState = __spreadProps(__spreadValues({}, t), {\n              guards: getAllRouteGuards(t.targetSnapshot, t.currentSnapshot, this.rootContexts)\n            });\n            return overallTransitionState;\n          }),\n          checkGuards(this.environmentInjector, (evt) => this.events.next(evt)),\n          tap((t) => {\n            overallTransitionState.guardsResult = t.guardsResult;\n            if (t.guardsResult && typeof t.guardsResult !== \"boolean\") {\n              throw redirectingNavigationError(this.urlSerializer, t.guardsResult);\n            }\n            const guardsEnd = new GuardsCheckEnd(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects), t.targetSnapshot, !!t.guardsResult);\n            this.events.next(guardsEnd);\n          }),\n          filter((t) => {\n            if (!t.guardsResult) {\n              this.cancelNavigationTransition(t, \"\", NavigationCancellationCode.GuardRejected);\n              return false;\n            }\n            return true;\n          }),\n          // --- RESOLVE ---\n          switchTap((t) => {\n            if (t.guards.canActivateChecks.length === 0) {\n              return void 0;\n            }\n            return of(t).pipe(tap((t2) => {\n              const resolveStart = new ResolveStart(t2.id, this.urlSerializer.serialize(t2.extractedUrl), this.urlSerializer.serialize(t2.urlAfterRedirects), t2.targetSnapshot);\n              this.events.next(resolveStart);\n            }), switchMap((t2) => {\n              let dataResolved = false;\n              return of(t2).pipe(resolveData(this.paramsInheritanceStrategy, this.environmentInjector), tap({\n                next: () => dataResolved = true,\n                complete: () => {\n                  if (!dataResolved) {\n                    this.cancelNavigationTransition(t2, typeof ngDevMode === \"undefined\" || ngDevMode ? `At least one route resolver didn't emit any value.` : \"\", NavigationCancellationCode.NoDataFromResolver);\n                  }\n                }\n              }));\n            }), tap((t2) => {\n              const resolveEnd = new ResolveEnd(t2.id, this.urlSerializer.serialize(t2.extractedUrl), this.urlSerializer.serialize(t2.urlAfterRedirects), t2.targetSnapshot);\n              this.events.next(resolveEnd);\n            }));\n          }),\n          // --- LOAD COMPONENTS ---\n          switchTap((t) => {\n            const loadComponents = (route) => {\n              const loaders = [];\n              if (route.routeConfig?.loadComponent && !route.routeConfig._loadedComponent) {\n                loaders.push(this.configLoader.loadComponent(route.routeConfig).pipe(tap((loadedComponent) => {\n                  route.component = loadedComponent;\n                }), map(() => void 0)));\n              }\n              for (const child of route.children) {\n                loaders.push(...loadComponents(child));\n              }\n              return loaders;\n            };\n            return combineLatest(loadComponents(t.targetSnapshot.root)).pipe(defaultIfEmpty(null), take(1));\n          }),\n          switchTap(() => this.afterPreactivation()),\n          switchMap(() => {\n            const {\n              currentSnapshot,\n              targetSnapshot\n            } = overallTransitionState;\n            const viewTransitionStarted = this.createViewTransition?.(this.environmentInjector, currentSnapshot.root, targetSnapshot.root);\n            return viewTransitionStarted ? from(viewTransitionStarted).pipe(map(() => overallTransitionState)) : of(overallTransitionState);\n          }),\n          map((t) => {\n            const targetRouterState = createRouterState(router.routeReuseStrategy, t.targetSnapshot, t.currentRouterState);\n            this.currentTransition = overallTransitionState = __spreadProps(__spreadValues({}, t), {\n              targetRouterState\n            });\n            this.currentNavigation.targetRouterState = targetRouterState;\n            return overallTransitionState;\n          }),\n          tap(() => {\n            this.events.next(new BeforeActivateRoutes());\n          }),\n          activateRoutes(this.rootContexts, router.routeReuseStrategy, (evt) => this.events.next(evt), this.inputBindingEnabled),\n          // Ensure that if some observable used to drive the transition doesn't\n          // complete, the navigation still finalizes This should never happen, but\n          // this is done as a safety measure to avoid surfacing this error (#49567).\n          take(1),\n          tap({\n            next: (t) => {\n              completed = true;\n              this.lastSuccessfulNavigation = this.currentNavigation;\n              this.events.next(new NavigationEnd(t.id, this.urlSerializer.serialize(t.extractedUrl), this.urlSerializer.serialize(t.urlAfterRedirects)));\n              this.titleStrategy?.updateTitle(t.targetRouterState.snapshot);\n              t.resolve(true);\n            },\n            complete: () => {\n              completed = true;\n            }\n          }),\n          // There used to be a lot more logic happening directly within the\n          // transition Observable. Some of this logic has been refactored out to\n          // other places but there may still be errors that happen there. This gives\n          // us a way to cancel the transition from the outside. This may also be\n          // required in the future to support something like the abort signal of the\n          // Navigation API where the navigation gets aborted from outside the\n          // transition.\n          takeUntil(this.transitionAbortSubject.pipe(tap((err) => {\n            throw err;\n          }))),\n          finalize(() => {\n            if (!completed && !errored) {\n              const cancelationReason = typeof ngDevMode === \"undefined\" || ngDevMode ? `Navigation ID ${overallTransitionState.id} is not equal to the current navigation id ${this.navigationId}` : \"\";\n              this.cancelNavigationTransition(overallTransitionState, cancelationReason, NavigationCancellationCode.SupersededByNewNavigation);\n            }\n            if (this.currentTransition?.id === overallTransitionState.id) {\n              this.currentNavigation = null;\n              this.currentTransition = null;\n            }\n          }),\n          catchError((e) => {\n            if (this.destroyed) {\n              overallTransitionState.resolve(false);\n              return EMPTY;\n            }\n            errored = true;\n            if (isNavigationCancelingError(e)) {\n              this.events.next(new NavigationCancel(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), e.message, e.cancellationCode));\n              if (!isRedirectingNavigationCancelingError(e)) {\n                overallTransitionState.resolve(false);\n              } else {\n                this.events.next(new RedirectRequest(e.url, e.navigationBehaviorOptions));\n              }\n            } else {\n              const navigationError = new NavigationError(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), e, overallTransitionState.targetSnapshot ?? void 0);\n              try {\n                const navigationErrorHandlerResult = runInInjectionContext(this.environmentInjector, () => this.navigationErrorHandler?.(navigationError));\n                if (navigationErrorHandlerResult instanceof RedirectCommand) {\n                  const {\n                    message,\n                    cancellationCode\n                  } = redirectingNavigationError(this.urlSerializer, navigationErrorHandlerResult);\n                  this.events.next(new NavigationCancel(overallTransitionState.id, this.urlSerializer.serialize(overallTransitionState.extractedUrl), message, cancellationCode));\n                  this.events.next(new RedirectRequest(navigationErrorHandlerResult.redirectTo, navigationErrorHandlerResult.navigationBehaviorOptions));\n                } else {\n                  this.events.next(navigationError);\n                  throw e;\n                }\n              } catch (ee) {\n                if (this.options.resolveNavigationPromiseOnError) {\n                  overallTransitionState.resolve(false);\n                } else {\n                  overallTransitionState.reject(ee);\n                }\n              }\n            }\n            return EMPTY;\n          })\n        );\n      })\n    );\n  }\n  cancelNavigationTransition(t, reason, code) {\n    const navCancel = new NavigationCancel(t.id, this.urlSerializer.serialize(t.extractedUrl), reason, code);\n    this.events.next(navCancel);\n    t.resolve(false);\n  }\n  /**\n   * @returns Whether we're navigating to somewhere that is not what the Router is\n   * currently set to.\n   */\n  isUpdatingInternalState() {\n    return this.currentTransition?.extractedUrl.toString() !== this.currentTransition?.currentUrlTree.toString();\n  }\n  /**\n   * @returns Whether we're updating the browser URL to something new (navigation is going\n   * to somewhere not displayed in the URL bar and we will update the URL\n   * bar if navigation succeeds).\n   */\n  isUpdatedBrowserUrl() {\n    const currentBrowserUrl = this.urlHandlingStrategy.extract(this.urlSerializer.parse(this.location.path(true)));\n    const targetBrowserUrl = this.currentNavigation?.targetBrowserUrl ?? this.currentNavigation?.extractedUrl;\n    return currentBrowserUrl.toString() !== targetBrowserUrl?.toString() && !this.currentNavigation?.extras.skipLocationChange;\n  }\n  static \\u0275fac = function NavigationTransitions_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _NavigationTransitions)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _NavigationTransitions,\n    factory: _NavigationTransitions.\\u0275fac,\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(NavigationTransitions, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], () => [], null);\n})();\nfunction isBrowserTriggeredNavigation(source) {\n  return source !== IMPERATIVE_NAVIGATION;\n}\nvar RouteReuseStrategy = class _RouteReuseStrategy {\n  static \\u0275fac = function RouteReuseStrategy_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _RouteReuseStrategy)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _RouteReuseStrategy,\n    factory: () => (() => inject(DefaultRouteReuseStrategy))(),\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(RouteReuseStrategy, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\",\n      useFactory: () => inject(DefaultRouteReuseStrategy)\n    }]\n  }], null, null);\n})();\nvar BaseRouteReuseStrategy = class {\n  /**\n   * Whether the given route should detach for later reuse.\n   * Always returns false for `BaseRouteReuseStrategy`.\n   * */\n  shouldDetach(route) {\n    return false;\n  }\n  /**\n   * A no-op; the route is never stored since this strategy never detaches routes for later re-use.\n   */\n  store(route, detachedTree) {\n  }\n  /** Returns `false`, meaning the route (and its subtree) is never reattached */\n  shouldAttach(route) {\n    return false;\n  }\n  /** Returns `null` because this strategy does not store routes for later re-use. */\n  retrieve(route) {\n    return null;\n  }\n  /**\n   * Determines if a route should be reused.\n   * This strategy returns `true` when the future route config and current route config are\n   * identical.\n   */\n  shouldReuseRoute(future, curr) {\n    return future.routeConfig === curr.routeConfig;\n  }\n};\nvar DefaultRouteReuseStrategy = class _DefaultRouteReuseStrategy extends BaseRouteReuseStrategy {\n  static \\u0275fac = /* @__PURE__ */ (() => {\n    let \\u0275DefaultRouteReuseStrategy_BaseFactory;\n    return function DefaultRouteReuseStrategy_Factory(__ngFactoryType__) {\n      return (\\u0275DefaultRouteReuseStrategy_BaseFactory || (\\u0275DefaultRouteReuseStrategy_BaseFactory = \\u0275\\u0275getInheritedFactory(_DefaultRouteReuseStrategy)))(__ngFactoryType__ || _DefaultRouteReuseStrategy);\n    };\n  })();\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _DefaultRouteReuseStrategy,\n    factory: _DefaultRouteReuseStrategy.\\u0275fac,\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(DefaultRouteReuseStrategy, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], null, null);\n})();\nvar StateManager = class _StateManager {\n  static \\u0275fac = function StateManager_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _StateManager)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _StateManager,\n    factory: () => (() => inject(HistoryStateManager))(),\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(StateManager, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\",\n      useFactory: () => inject(HistoryStateManager)\n    }]\n  }], null, null);\n})();\nvar HistoryStateManager = class _HistoryStateManager extends StateManager {\n  location = inject(Location);\n  urlSerializer = inject(UrlSerializer);\n  options = inject(ROUTER_CONFIGURATION, {\n    optional: true\n  }) || {};\n  canceledNavigationResolution = this.options.canceledNavigationResolution || \"replace\";\n  urlHandlingStrategy = inject(UrlHandlingStrategy);\n  urlUpdateStrategy = this.options.urlUpdateStrategy || \"deferred\";\n  currentUrlTree = new UrlTree();\n  getCurrentUrlTree() {\n    return this.currentUrlTree;\n  }\n  rawUrlTree = this.currentUrlTree;\n  getRawUrlTree() {\n    return this.rawUrlTree;\n  }\n  /**\n   * The id of the currently active page in the router.\n   * Updated to the transition's target id on a successful navigation.\n   *\n   * This is used to track what page the router last activated. When an attempted navigation fails,\n   * the router can then use this to compute how to restore the state back to the previously active\n   * page.\n   */\n  currentPageId = 0;\n  lastSuccessfulId = -1;\n  restoredState() {\n    return this.location.getState();\n  }\n  /**\n   * The ɵrouterPageId of whatever page is currently active in the browser history. This is\n   * important for computing the target page id for new navigations because we need to ensure each\n   * page id in the browser history is 1 more than the previous entry.\n   */\n  get browserPageId() {\n    if (this.canceledNavigationResolution !== \"computed\") {\n      return this.currentPageId;\n    }\n    return this.restoredState()?.\\u0275routerPageId ?? this.currentPageId;\n  }\n  routerState = createEmptyState(null);\n  getRouterState() {\n    return this.routerState;\n  }\n  stateMemento = this.createStateMemento();\n  createStateMemento() {\n    return {\n      rawUrlTree: this.rawUrlTree,\n      currentUrlTree: this.currentUrlTree,\n      routerState: this.routerState\n    };\n  }\n  registerNonRouterCurrentEntryChangeListener(listener) {\n    return this.location.subscribe((event) => {\n      if (event[\"type\"] === \"popstate\") {\n        listener(event[\"url\"], event.state);\n      }\n    });\n  }\n  handleRouterEvent(e, currentTransition) {\n    if (e instanceof NavigationStart) {\n      this.stateMemento = this.createStateMemento();\n    } else if (e instanceof NavigationSkipped) {\n      this.rawUrlTree = currentTransition.initialUrl;\n    } else if (e instanceof RoutesRecognized) {\n      if (this.urlUpdateStrategy === \"eager\") {\n        if (!currentTransition.extras.skipLocationChange) {\n          const rawUrl = this.urlHandlingStrategy.merge(currentTransition.finalUrl, currentTransition.initialUrl);\n          this.setBrowserUrl(currentTransition.targetBrowserUrl ?? rawUrl, currentTransition);\n        }\n      }\n    } else if (e instanceof BeforeActivateRoutes) {\n      this.currentUrlTree = currentTransition.finalUrl;\n      this.rawUrlTree = this.urlHandlingStrategy.merge(currentTransition.finalUrl, currentTransition.initialUrl);\n      this.routerState = currentTransition.targetRouterState;\n      if (this.urlUpdateStrategy === \"deferred\" && !currentTransition.extras.skipLocationChange) {\n        this.setBrowserUrl(currentTransition.targetBrowserUrl ?? this.rawUrlTree, currentTransition);\n      }\n    } else if (e instanceof NavigationCancel && (e.code === NavigationCancellationCode.GuardRejected || e.code === NavigationCancellationCode.NoDataFromResolver)) {\n      this.restoreHistory(currentTransition);\n    } else if (e instanceof NavigationError) {\n      this.restoreHistory(currentTransition, true);\n    } else if (e instanceof NavigationEnd) {\n      this.lastSuccessfulId = e.id;\n      this.currentPageId = this.browserPageId;\n    }\n  }\n  setBrowserUrl(url, transition) {\n    const path = url instanceof UrlTree ? this.urlSerializer.serialize(url) : url;\n    if (this.location.isCurrentPathEqualTo(path) || !!transition.extras.replaceUrl) {\n      const currentBrowserPageId = this.browserPageId;\n      const state = __spreadValues(__spreadValues({}, transition.extras.state), this.generateNgRouterState(transition.id, currentBrowserPageId));\n      this.location.replaceState(path, \"\", state);\n    } else {\n      const state = __spreadValues(__spreadValues({}, transition.extras.state), this.generateNgRouterState(transition.id, this.browserPageId + 1));\n      this.location.go(path, \"\", state);\n    }\n  }\n  /**\n   * Performs the necessary rollback action to restore the browser URL to the\n   * state before the transition.\n   */\n  restoreHistory(navigation, restoringFromCaughtError = false) {\n    if (this.canceledNavigationResolution === \"computed\") {\n      const currentBrowserPageId = this.browserPageId;\n      const targetPagePosition = this.currentPageId - currentBrowserPageId;\n      if (targetPagePosition !== 0) {\n        this.location.historyGo(targetPagePosition);\n      } else if (this.currentUrlTree === navigation.finalUrl && targetPagePosition === 0) {\n        this.resetState(navigation);\n        this.resetUrlToCurrentUrlTree();\n      } else ;\n    } else if (this.canceledNavigationResolution === \"replace\") {\n      if (restoringFromCaughtError) {\n        this.resetState(navigation);\n      }\n      this.resetUrlToCurrentUrlTree();\n    }\n  }\n  resetState(navigation) {\n    this.routerState = this.stateMemento.routerState;\n    this.currentUrlTree = this.stateMemento.currentUrlTree;\n    this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, navigation.finalUrl ?? this.rawUrlTree);\n  }\n  resetUrlToCurrentUrlTree() {\n    this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), \"\", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId));\n  }\n  generateNgRouterState(navigationId, routerPageId) {\n    if (this.canceledNavigationResolution === \"computed\") {\n      return {\n        navigationId,\n        \\u0275routerPageId: routerPageId\n      };\n    }\n    return {\n      navigationId\n    };\n  }\n  static \\u0275fac = /* @__PURE__ */ (() => {\n    let \\u0275HistoryStateManager_BaseFactory;\n    return function HistoryStateManager_Factory(__ngFactoryType__) {\n      return (\\u0275HistoryStateManager_BaseFactory || (\\u0275HistoryStateManager_BaseFactory = \\u0275\\u0275getInheritedFactory(_HistoryStateManager)))(__ngFactoryType__ || _HistoryStateManager);\n    };\n  })();\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _HistoryStateManager,\n    factory: _HistoryStateManager.\\u0275fac,\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(HistoryStateManager, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], null, null);\n})();\nfunction afterNextNavigation(router, action) {\n  router.events.pipe(filter((e) => e instanceof NavigationEnd || e instanceof NavigationCancel || e instanceof NavigationError || e instanceof NavigationSkipped), map((e) => {\n    if (e instanceof NavigationEnd || e instanceof NavigationSkipped) {\n      return 0;\n    }\n    const redirecting = e instanceof NavigationCancel ? e.code === NavigationCancellationCode.Redirect || e.code === NavigationCancellationCode.SupersededByNewNavigation : false;\n    return redirecting ? 2 : 1;\n  }), filter(\n    (result) => result !== 2\n    /* NavigationResult.REDIRECTING */\n  ), take(1)).subscribe(() => {\n    action();\n  });\n}\nvar exactMatchOptions = {\n  paths: \"exact\",\n  fragment: \"ignored\",\n  matrixParams: \"ignored\",\n  queryParams: \"exact\"\n};\nvar subsetMatchOptions = {\n  paths: \"subset\",\n  fragment: \"ignored\",\n  matrixParams: \"ignored\",\n  queryParams: \"subset\"\n};\nvar Router = class _Router {\n  get currentUrlTree() {\n    return this.stateManager.getCurrentUrlTree();\n  }\n  get rawUrlTree() {\n    return this.stateManager.getRawUrlTree();\n  }\n  disposed = false;\n  nonRouterCurrentEntryChangeSubscription;\n  console = inject(Console);\n  stateManager = inject(StateManager);\n  options = inject(ROUTER_CONFIGURATION, {\n    optional: true\n  }) || {};\n  pendingTasks = inject(PendingTasksInternal);\n  urlUpdateStrategy = this.options.urlUpdateStrategy || \"deferred\";\n  navigationTransitions = inject(NavigationTransitions);\n  urlSerializer = inject(UrlSerializer);\n  location = inject(Location);\n  urlHandlingStrategy = inject(UrlHandlingStrategy);\n  /**\n   * The private `Subject` type for the public events exposed in the getter. This is used internally\n   * to push events to. The separate field allows us to expose separate types in the public API\n   * (i.e., an Observable rather than the Subject).\n   */\n  _events = new Subject();\n  /**\n   * An event stream for routing events.\n   */\n  get events() {\n    return this._events;\n  }\n  /**\n   * The current state of routing in this NgModule.\n   */\n  get routerState() {\n    return this.stateManager.getRouterState();\n  }\n  /**\n   * True if at least one navigation event has occurred,\n   * false otherwise.\n   */\n  navigated = false;\n  /**\n   * A strategy for re-using routes.\n   *\n   * @deprecated Configure using `providers` instead:\n   *   `{provide: RouteReuseStrategy, useClass: MyStrategy}`.\n   */\n  routeReuseStrategy = inject(RouteReuseStrategy);\n  /**\n   * How to handle a navigation request to the current URL.\n   *\n   *\n   * @deprecated Configure this through `provideRouter` or `RouterModule.forRoot` instead.\n   * @see {@link withRouterConfig}\n   * @see {@link provideRouter}\n   * @see {@link RouterModule}\n   */\n  onSameUrlNavigation = this.options.onSameUrlNavigation || \"ignore\";\n  config = inject(ROUTES, {\n    optional: true\n  })?.flat() ?? [];\n  /**\n   * Indicates whether the application has opted in to binding Router data to component inputs.\n   *\n   * This option is enabled by the `withComponentInputBinding` feature of `provideRouter` or\n   * `bindToComponentInputs` in the `ExtraOptions` of `RouterModule.forRoot`.\n   */\n  componentInputBindingEnabled = !!inject(INPUT_BINDER, {\n    optional: true\n  });\n  constructor() {\n    this.resetConfig(this.config);\n    this.navigationTransitions.setupNavigations(this).subscribe({\n      error: (e) => {\n        this.console.warn(ngDevMode ? `Unhandled Navigation Error: ${e}` : e);\n      }\n    });\n    this.subscribeToNavigationEvents();\n  }\n  eventsSubscription = new Subscription();\n  subscribeToNavigationEvents() {\n    const subscription = this.navigationTransitions.events.subscribe((e) => {\n      try {\n        const currentTransition = this.navigationTransitions.currentTransition;\n        const currentNavigation = this.navigationTransitions.currentNavigation;\n        if (currentTransition !== null && currentNavigation !== null) {\n          this.stateManager.handleRouterEvent(e, currentNavigation);\n          if (e instanceof NavigationCancel && e.code !== NavigationCancellationCode.Redirect && e.code !== NavigationCancellationCode.SupersededByNewNavigation) {\n            this.navigated = true;\n          } else if (e instanceof NavigationEnd) {\n            this.navigated = true;\n          } else if (e instanceof RedirectRequest) {\n            const opts = e.navigationBehaviorOptions;\n            const mergedTree = this.urlHandlingStrategy.merge(e.url, currentTransition.currentRawUrl);\n            const extras = __spreadValues({\n              browserUrl: currentTransition.extras.browserUrl,\n              info: currentTransition.extras.info,\n              skipLocationChange: currentTransition.extras.skipLocationChange,\n              // The URL is already updated at this point if we have 'eager' URL\n              // updates or if the navigation was triggered by the browser (back\n              // button, URL bar, etc). We want to replace that item in history\n              // if the navigation is rejected.\n              replaceUrl: currentTransition.extras.replaceUrl || this.urlUpdateStrategy === \"eager\" || isBrowserTriggeredNavigation(currentTransition.source)\n            }, opts);\n            this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras, {\n              resolve: currentTransition.resolve,\n              reject: currentTransition.reject,\n              promise: currentTransition.promise\n            });\n          }\n        }\n        if (isPublicRouterEvent(e)) {\n          this._events.next(e);\n        }\n      } catch (e2) {\n        this.navigationTransitions.transitionAbortSubject.next(e2);\n      }\n    });\n    this.eventsSubscription.add(subscription);\n  }\n  /** @internal */\n  resetRootComponentType(rootComponentType) {\n    this.routerState.root.component = rootComponentType;\n    this.navigationTransitions.rootComponentType = rootComponentType;\n  }\n  /**\n   * Sets up the location change listener and performs the initial navigation.\n   */\n  initialNavigation() {\n    this.setUpLocationChangeListener();\n    if (!this.navigationTransitions.hasRequestedNavigation) {\n      this.navigateToSyncWithBrowser(this.location.path(true), IMPERATIVE_NAVIGATION, this.stateManager.restoredState());\n    }\n  }\n  /**\n   * Sets up the location change listener. This listener detects navigations triggered from outside\n   * the Router (the browser back/forward buttons, for example) and schedules a corresponding Router\n   * navigation so that the correct events, guards, etc. are triggered.\n   */\n  setUpLocationChangeListener() {\n    this.nonRouterCurrentEntryChangeSubscription ??= this.stateManager.registerNonRouterCurrentEntryChangeListener((url, state) => {\n      setTimeout(() => {\n        this.navigateToSyncWithBrowser(url, \"popstate\", state);\n      }, 0);\n    });\n  }\n  /**\n   * Schedules a router navigation to synchronize Router state with the browser state.\n   *\n   * This is done as a response to a popstate event and the initial navigation. These\n   * two scenarios represent times when the browser URL/state has been updated and\n   * the Router needs to respond to ensure its internal state matches.\n   */\n  navigateToSyncWithBrowser(url, source, state) {\n    const extras = {\n      replaceUrl: true\n    };\n    const restoredState = state?.navigationId ? state : null;\n    if (state) {\n      const stateCopy = __spreadValues({}, state);\n      delete stateCopy.navigationId;\n      delete stateCopy.\\u0275routerPageId;\n      if (Object.keys(stateCopy).length !== 0) {\n        extras.state = stateCopy;\n      }\n    }\n    const urlTree = this.parseUrl(url);\n    this.scheduleNavigation(urlTree, source, restoredState, extras);\n  }\n  /** The current URL. */\n  get url() {\n    return this.serializeUrl(this.currentUrlTree);\n  }\n  /**\n   * Returns the current `Navigation` object when the router is navigating,\n   * and `null` when idle.\n   */\n  getCurrentNavigation() {\n    return this.navigationTransitions.currentNavigation;\n  }\n  /**\n   * The `Navigation` object of the most recent navigation to succeed and `null` if there\n   *     has not been a successful navigation yet.\n   */\n  get lastSuccessfulNavigation() {\n    return this.navigationTransitions.lastSuccessfulNavigation;\n  }\n  /**\n   * Resets the route configuration used for navigation and generating links.\n   *\n   * @param config The route array for the new configuration.\n   *\n   * @usageNotes\n   *\n   * ```ts\n   * router.resetConfig([\n   *  { path: 'team/:id', component: TeamCmp, children: [\n   *    { path: 'simple', component: SimpleCmp },\n   *    { path: 'user/:name', component: UserCmp }\n   *  ]}\n   * ]);\n   * ```\n   */\n  resetConfig(config2) {\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && validateConfig(config2);\n    this.config = config2.map(standardizeConfig);\n    this.navigated = false;\n  }\n  /** @nodoc */\n  ngOnDestroy() {\n    this.dispose();\n  }\n  /** Disposes of the router. */\n  dispose() {\n    this._events.unsubscribe();\n    this.navigationTransitions.complete();\n    if (this.nonRouterCurrentEntryChangeSubscription) {\n      this.nonRouterCurrentEntryChangeSubscription.unsubscribe();\n      this.nonRouterCurrentEntryChangeSubscription = void 0;\n    }\n    this.disposed = true;\n    this.eventsSubscription.unsubscribe();\n  }\n  /**\n   * Appends URL segments to the current URL tree to create a new URL tree.\n   *\n   * @param commands An array of URL fragments with which to construct the new URL tree.\n   * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n   * segments, followed by the parameters for each segment.\n   * The fragments are applied to the current URL tree or the one provided  in the `relativeTo`\n   * property of the options object, if supplied.\n   * @param navigationExtras Options that control the navigation strategy.\n   * @returns The new URL tree.\n   *\n   * @usageNotes\n   *\n   * ```\n   * // create /team/33/user/11\n   * router.createUrlTree(['/team', 33, 'user', 11]);\n   *\n   * // create /team/33;expand=true/user/11\n   * router.createUrlTree(['/team', 33, {expand: true}, 'user', 11]);\n   *\n   * // you can collapse static segments like this (this works only with the first passed-in value):\n   * router.createUrlTree(['/team/33/user', userId]);\n   *\n   * // If the first segment can contain slashes, and you do not want the router to split it,\n   * // you can do the following:\n   * router.createUrlTree([{segmentPath: '/one/two'}]);\n   *\n   * // create /team/33/(user/11//right:chat)\n   * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: 'chat'}}]);\n   *\n   * // remove the right secondary node\n   * router.createUrlTree(['/team', 33, {outlets: {primary: 'user/11', right: null}}]);\n   *\n   * // assuming the current url is `/team/33/user/11` and the route points to `user/11`\n   *\n   * // navigate to /team/33/user/11/details\n   * router.createUrlTree(['details'], {relativeTo: route});\n   *\n   * // navigate to /team/33/user/22\n   * router.createUrlTree(['../22'], {relativeTo: route});\n   *\n   * // navigate to /team/44/user/22\n   * router.createUrlTree(['../../team/44/user/22'], {relativeTo: route});\n   *\n   * Note that a value of `null` or `undefined` for `relativeTo` indicates that the\n   * tree should be created relative to the root.\n   * ```\n   */\n  createUrlTree(commands, navigationExtras = {}) {\n    const {\n      relativeTo,\n      queryParams,\n      fragment,\n      queryParamsHandling,\n      preserveFragment\n    } = navigationExtras;\n    const f = preserveFragment ? this.currentUrlTree.fragment : fragment;\n    let q = null;\n    switch (queryParamsHandling ?? this.options.defaultQueryParamsHandling) {\n      case \"merge\":\n        q = __spreadValues(__spreadValues({}, this.currentUrlTree.queryParams), queryParams);\n        break;\n      case \"preserve\":\n        q = this.currentUrlTree.queryParams;\n        break;\n      default:\n        q = queryParams || null;\n    }\n    if (q !== null) {\n      q = this.removeEmptyProps(q);\n    }\n    let relativeToUrlSegmentGroup;\n    try {\n      const relativeToSnapshot = relativeTo ? relativeTo.snapshot : this.routerState.snapshot.root;\n      relativeToUrlSegmentGroup = createSegmentGroupFromRoute(relativeToSnapshot);\n    } catch (e) {\n      if (typeof commands[0] !== \"string\" || commands[0][0] !== \"/\") {\n        commands = [];\n      }\n      relativeToUrlSegmentGroup = this.currentUrlTree.root;\n    }\n    return createUrlTreeFromSegmentGroup(relativeToUrlSegmentGroup, commands, q, f ?? null);\n  }\n  /**\n   * Navigates to a view using an absolute route path.\n   *\n   * @param url An absolute path for a defined route. The function does not apply any delta to the\n   *     current URL.\n   * @param extras An object containing properties that modify the navigation strategy.\n   *\n   * @returns A Promise that resolves to 'true' when navigation succeeds,\n   * to 'false' when navigation fails, or is rejected on error.\n   *\n   * @usageNotes\n   *\n   * The following calls request navigation to an absolute path.\n   *\n   * ```ts\n   * router.navigateByUrl(\"/team/33/user/11\");\n   *\n   * // Navigate without updating the URL\n   * router.navigateByUrl(\"/team/33/user/11\", { skipLocationChange: true });\n   * ```\n   *\n   * @see [Routing and Navigation guide](guide/routing/common-router-tasks)\n   *\n   */\n  navigateByUrl(url, extras = {\n    skipLocationChange: false\n  }) {\n    const urlTree = isUrlTree(url) ? url : this.parseUrl(url);\n    const mergedTree = this.urlHandlingStrategy.merge(urlTree, this.rawUrlTree);\n    return this.scheduleNavigation(mergedTree, IMPERATIVE_NAVIGATION, null, extras);\n  }\n  /**\n   * Navigate based on the provided array of commands and a starting point.\n   * If no starting route is provided, the navigation is absolute.\n   *\n   * @param commands An array of URL fragments with which to construct the target URL.\n   * If the path is static, can be the literal URL string. For a dynamic path, pass an array of path\n   * segments, followed by the parameters for each segment.\n   * The fragments are applied to the current URL or the one provided  in the `relativeTo` property\n   * of the options object, if supplied.\n   * @param extras An options object that determines how the URL should be constructed or\n   *     interpreted.\n   *\n   * @returns A Promise that resolves to `true` when navigation succeeds, or `false` when navigation\n   *     fails. The Promise is rejected when an error occurs if `resolveNavigationPromiseOnError` is\n   * not `true`.\n   *\n   * @usageNotes\n   *\n   * The following calls request navigation to a dynamic route path relative to the current URL.\n   *\n   * ```ts\n   * router.navigate(['team', 33, 'user', 11], {relativeTo: route});\n   *\n   * // Navigate without updating the URL, overriding the default behavior\n   * router.navigate(['team', 33, 'user', 11], {relativeTo: route, skipLocationChange: true});\n   * ```\n   *\n   * @see [Routing and Navigation guide](guide/routing/common-router-tasks)\n   *\n   */\n  navigate(commands, extras = {\n    skipLocationChange: false\n  }) {\n    validateCommands(commands);\n    return this.navigateByUrl(this.createUrlTree(commands, extras), extras);\n  }\n  /** Serializes a `UrlTree` into a string */\n  serializeUrl(url) {\n    return this.urlSerializer.serialize(url);\n  }\n  /** Parses a string into a `UrlTree` */\n  parseUrl(url) {\n    try {\n      return this.urlSerializer.parse(url);\n    } catch {\n      return this.urlSerializer.parse(\"/\");\n    }\n  }\n  isActive(url, matchOptions) {\n    let options;\n    if (matchOptions === true) {\n      options = __spreadValues({}, exactMatchOptions);\n    } else if (matchOptions === false) {\n      options = __spreadValues({}, subsetMatchOptions);\n    } else {\n      options = matchOptions;\n    }\n    if (isUrlTree(url)) {\n      return containsTree(this.currentUrlTree, url, options);\n    }\n    const urlTree = this.parseUrl(url);\n    return containsTree(this.currentUrlTree, urlTree, options);\n  }\n  removeEmptyProps(params) {\n    return Object.entries(params).reduce((result, [key, value]) => {\n      if (value !== null && value !== void 0) {\n        result[key] = value;\n      }\n      return result;\n    }, {});\n  }\n  scheduleNavigation(rawUrl, source, restoredState, extras, priorPromise) {\n    if (this.disposed) {\n      return Promise.resolve(false);\n    }\n    let resolve;\n    let reject;\n    let promise;\n    if (priorPromise) {\n      resolve = priorPromise.resolve;\n      reject = priorPromise.reject;\n      promise = priorPromise.promise;\n    } else {\n      promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n      });\n    }\n    const taskId = this.pendingTasks.add();\n    afterNextNavigation(this, () => {\n      queueMicrotask(() => this.pendingTasks.remove(taskId));\n    });\n    this.navigationTransitions.handleNavigationRequest({\n      source,\n      restoredState,\n      currentUrlTree: this.currentUrlTree,\n      currentRawUrl: this.currentUrlTree,\n      rawUrl,\n      extras,\n      resolve,\n      reject,\n      promise,\n      currentSnapshot: this.routerState.snapshot,\n      currentRouterState: this.routerState\n    });\n    return promise.catch((e) => {\n      return Promise.reject(e);\n    });\n  }\n  static \\u0275fac = function Router_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _Router)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _Router,\n    factory: _Router.\\u0275fac,\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(Router, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], () => [], null);\n})();\nfunction validateCommands(commands) {\n  for (let i = 0; i < commands.length; i++) {\n    const cmd = commands[i];\n    if (cmd == null) {\n      throw new RuntimeError(4008, (typeof ngDevMode === \"undefined\" || ngDevMode) && `The requested path contains ${cmd} segment at index ${i}`);\n    }\n  }\n}\nfunction isPublicRouterEvent(e) {\n  return !(e instanceof BeforeActivateRoutes) && !(e instanceof RedirectRequest);\n}\nvar RouterLink = class _RouterLink {\n  router;\n  route;\n  tabIndexAttribute;\n  renderer;\n  el;\n  locationStrategy;\n  /**\n   * Represents an `href` attribute value applied to a host element,\n   * when a host element is `<a>`. For other tags, the value is `null`.\n   */\n  href = null;\n  /**\n   * Represents the `target` attribute on a host element.\n   * This is only used when the host element is an `<a>` tag.\n   */\n  target;\n  /**\n   * Passed to {@link Router#createUrlTree} as part of the\n   * `UrlCreationOptions`.\n   * @see {@link UrlCreationOptions#queryParams}\n   * @see {@link Router#createUrlTree}\n   */\n  queryParams;\n  /**\n   * Passed to {@link Router#createUrlTree} as part of the\n   * `UrlCreationOptions`.\n   * @see {@link UrlCreationOptions#fragment}\n   * @see {@link Router#createUrlTree}\n   */\n  fragment;\n  /**\n   * Passed to {@link Router#createUrlTree} as part of the\n   * `UrlCreationOptions`.\n   * @see {@link UrlCreationOptions#queryParamsHandling}\n   * @see {@link Router#createUrlTree}\n   */\n  queryParamsHandling;\n  /**\n   * Passed to {@link Router#navigateByUrl} as part of the\n   * `NavigationBehaviorOptions`.\n   * @see {@link NavigationBehaviorOptions#state}\n   * @see {@link Router#navigateByUrl}\n   */\n  state;\n  /**\n   * Passed to {@link Router#navigateByUrl} as part of the\n   * `NavigationBehaviorOptions`.\n   * @see {@link NavigationBehaviorOptions#info}\n   * @see {@link Router#navigateByUrl}\n   */\n  info;\n  /**\n   * Passed to {@link Router#createUrlTree} as part of the\n   * `UrlCreationOptions`.\n   * Specify a value here when you do not want to use the default value\n   * for `routerLink`, which is the current activated route.\n   * Note that a value of `undefined` here will use the `routerLink` default.\n   * @see {@link UrlCreationOptions#relativeTo}\n   * @see {@link Router#createUrlTree}\n   */\n  relativeTo;\n  /** Whether a host element is an `<a>` tag. */\n  isAnchorElement;\n  subscription;\n  /** @internal */\n  onChanges = new Subject();\n  constructor(router, route, tabIndexAttribute, renderer, el, locationStrategy) {\n    this.router = router;\n    this.route = route;\n    this.tabIndexAttribute = tabIndexAttribute;\n    this.renderer = renderer;\n    this.el = el;\n    this.locationStrategy = locationStrategy;\n    const tagName = el.nativeElement.tagName?.toLowerCase();\n    this.isAnchorElement = tagName === \"a\" || tagName === \"area\";\n    if (this.isAnchorElement) {\n      this.subscription = router.events.subscribe((s) => {\n        if (s instanceof NavigationEnd) {\n          this.updateHref();\n        }\n      });\n    } else {\n      this.setTabIndexIfNotOnNativeEl(\"0\");\n    }\n  }\n  /**\n   * Passed to {@link Router#createUrlTree} as part of the\n   * `UrlCreationOptions`.\n   * @see {@link UrlCreationOptions#preserveFragment}\n   * @see {@link Router#createUrlTree}\n   */\n  preserveFragment = false;\n  /**\n   * Passed to {@link Router#navigateByUrl} as part of the\n   * `NavigationBehaviorOptions`.\n   * @see {@link NavigationBehaviorOptions#skipLocationChange}\n   * @see {@link Router#navigateByUrl}\n   */\n  skipLocationChange = false;\n  /**\n   * Passed to {@link Router#navigateByUrl} as part of the\n   * `NavigationBehaviorOptions`.\n   * @see {@link NavigationBehaviorOptions#replaceUrl}\n   * @see {@link Router#navigateByUrl}\n   */\n  replaceUrl = false;\n  /**\n   * Modifies the tab index if there was not a tabindex attribute on the element during\n   * instantiation.\n   */\n  setTabIndexIfNotOnNativeEl(newTabIndex) {\n    if (this.tabIndexAttribute != null || this.isAnchorElement) {\n      return;\n    }\n    this.applyAttributeValue(\"tabindex\", newTabIndex);\n  }\n  /** @nodoc */\n  // TODO(atscott): Remove changes parameter in major version as a breaking change.\n  ngOnChanges(changes) {\n    if (ngDevMode && isUrlTree(this.routerLinkInput) && (this.fragment !== void 0 || this.queryParams || this.queryParamsHandling || this.preserveFragment || this.relativeTo)) {\n      throw new RuntimeError(4016, \"Cannot configure queryParams or fragment when using a UrlTree as the routerLink input value.\");\n    }\n    if (this.isAnchorElement) {\n      this.updateHref();\n    }\n    this.onChanges.next(this);\n  }\n  routerLinkInput = null;\n  /**\n   * Commands to pass to {@link Router#createUrlTree} or a `UrlTree`.\n   *   - **array**: commands to pass to {@link Router#createUrlTree}.\n   *   - **string**: shorthand for array of commands with just the string, i.e. `['/route']`\n   *   - **UrlTree**: a `UrlTree` for this link rather than creating one from the commands\n   *     and other inputs that correspond to properties of `UrlCreationOptions`.\n   *   - **null|undefined**: effectively disables the `routerLink`\n   * @see {@link Router#createUrlTree}\n   */\n  set routerLink(commandsOrUrlTree) {\n    if (commandsOrUrlTree == null) {\n      this.routerLinkInput = null;\n      this.setTabIndexIfNotOnNativeEl(null);\n    } else {\n      if (isUrlTree(commandsOrUrlTree)) {\n        this.routerLinkInput = commandsOrUrlTree;\n      } else {\n        this.routerLinkInput = Array.isArray(commandsOrUrlTree) ? commandsOrUrlTree : [commandsOrUrlTree];\n      }\n      this.setTabIndexIfNotOnNativeEl(\"0\");\n    }\n  }\n  /** @nodoc */\n  onClick(button, ctrlKey, shiftKey, altKey, metaKey) {\n    const urlTree = this.urlTree;\n    if (urlTree === null) {\n      return true;\n    }\n    if (this.isAnchorElement) {\n      if (button !== 0 || ctrlKey || shiftKey || altKey || metaKey) {\n        return true;\n      }\n      if (typeof this.target === \"string\" && this.target != \"_self\") {\n        return true;\n      }\n    }\n    const extras = {\n      skipLocationChange: this.skipLocationChange,\n      replaceUrl: this.replaceUrl,\n      state: this.state,\n      info: this.info\n    };\n    this.router.navigateByUrl(urlTree, extras);\n    return !this.isAnchorElement;\n  }\n  /** @nodoc */\n  ngOnDestroy() {\n    this.subscription?.unsubscribe();\n  }\n  updateHref() {\n    const urlTree = this.urlTree;\n    this.href = urlTree !== null && this.locationStrategy ? this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(urlTree)) : null;\n    const sanitizedValue = this.href === null ? null : (\n      // This class represents a directive that can be added to both `<a>` elements,\n      // as well as other elements. As a result, we can't define security context at\n      // compile time. So the security context is deferred to runtime.\n      // The `ɵɵsanitizeUrlOrResourceUrl` selects the necessary sanitizer function\n      // based on the tag and property names. The logic mimics the one from\n      // `packages/compiler/src/schema/dom_security_schema.ts`, which is used at compile time.\n      //\n      // Note: we should investigate whether we can switch to using `@HostBinding('attr.href')`\n      // instead of applying a value via a renderer, after a final merge of the\n      // `RouterLinkWithHref` directive.\n      \\u0275\\u0275sanitizeUrlOrResourceUrl(this.href, this.el.nativeElement.tagName.toLowerCase(), \"href\")\n    );\n    this.applyAttributeValue(\"href\", sanitizedValue);\n  }\n  applyAttributeValue(attrName, attrValue) {\n    const renderer = this.renderer;\n    const nativeElement = this.el.nativeElement;\n    if (attrValue !== null) {\n      renderer.setAttribute(nativeElement, attrName, attrValue);\n    } else {\n      renderer.removeAttribute(nativeElement, attrName);\n    }\n  }\n  get urlTree() {\n    if (this.routerLinkInput === null) {\n      return null;\n    } else if (isUrlTree(this.routerLinkInput)) {\n      return this.routerLinkInput;\n    }\n    return this.router.createUrlTree(this.routerLinkInput, {\n      // If the `relativeTo` input is not defined, we want to use `this.route` by default.\n      // Otherwise, we should use the value provided by the user in the input.\n      relativeTo: this.relativeTo !== void 0 ? this.relativeTo : this.route,\n      queryParams: this.queryParams,\n      fragment: this.fragment,\n      queryParamsHandling: this.queryParamsHandling,\n      preserveFragment: this.preserveFragment\n    });\n  }\n  static \\u0275fac = function RouterLink_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _RouterLink)(\\u0275\\u0275directiveInject(Router), \\u0275\\u0275directiveInject(ActivatedRoute), \\u0275\\u0275injectAttribute(\"tabindex\"), \\u0275\\u0275directiveInject(Renderer2), \\u0275\\u0275directiveInject(ElementRef), \\u0275\\u0275directiveInject(LocationStrategy));\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _RouterLink,\n    selectors: [[\"\", \"routerLink\", \"\"]],\n    hostVars: 1,\n    hostBindings: function RouterLink_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        \\u0275\\u0275listener(\"click\", function RouterLink_click_HostBindingHandler($event) {\n          return ctx.onClick($event.button, $event.ctrlKey, $event.shiftKey, $event.altKey, $event.metaKey);\n        });\n      }\n      if (rf & 2) {\n        \\u0275\\u0275attribute(\"target\", ctx.target);\n      }\n    },\n    inputs: {\n      target: \"target\",\n      queryParams: \"queryParams\",\n      fragment: \"fragment\",\n      queryParamsHandling: \"queryParamsHandling\",\n      state: \"state\",\n      info: \"info\",\n      relativeTo: \"relativeTo\",\n      preserveFragment: [2, \"preserveFragment\", \"preserveFragment\", booleanAttribute],\n      skipLocationChange: [2, \"skipLocationChange\", \"skipLocationChange\", booleanAttribute],\n      replaceUrl: [2, \"replaceUrl\", \"replaceUrl\", booleanAttribute],\n      routerLink: \"routerLink\"\n    },\n    features: [\\u0275\\u0275NgOnChangesFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(RouterLink, [{\n    type: Directive,\n    args: [{\n      selector: \"[routerLink]\"\n    }]\n  }], () => [{\n    type: Router\n  }, {\n    type: ActivatedRoute\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Attribute,\n      args: [\"tabindex\"]\n    }]\n  }, {\n    type: Renderer2\n  }, {\n    type: ElementRef\n  }, {\n    type: LocationStrategy\n  }], {\n    target: [{\n      type: HostBinding,\n      args: [\"attr.target\"]\n    }, {\n      type: Input\n    }],\n    queryParams: [{\n      type: Input\n    }],\n    fragment: [{\n      type: Input\n    }],\n    queryParamsHandling: [{\n      type: Input\n    }],\n    state: [{\n      type: Input\n    }],\n    info: [{\n      type: Input\n    }],\n    relativeTo: [{\n      type: Input\n    }],\n    preserveFragment: [{\n      type: Input,\n      args: [{\n        transform: booleanAttribute\n      }]\n    }],\n    skipLocationChange: [{\n      type: Input,\n      args: [{\n        transform: booleanAttribute\n      }]\n    }],\n    replaceUrl: [{\n      type: Input,\n      args: [{\n        transform: booleanAttribute\n      }]\n    }],\n    routerLink: [{\n      type: Input\n    }],\n    onClick: [{\n      type: HostListener,\n      args: [\"click\", [\"$event.button\", \"$event.ctrlKey\", \"$event.shiftKey\", \"$event.altKey\", \"$event.metaKey\"]]\n    }]\n  });\n})();\nvar RouterLinkActive = class _RouterLinkActive {\n  router;\n  element;\n  renderer;\n  cdr;\n  link;\n  links;\n  classes = [];\n  routerEventsSubscription;\n  linkInputChangesSubscription;\n  _isActive = false;\n  get isActive() {\n    return this._isActive;\n  }\n  /**\n   * Options to configure how to determine if the router link is active.\n   *\n   * These options are passed to the `Router.isActive()` function.\n   *\n   * @see {@link Router#isActive}\n   */\n  routerLinkActiveOptions = {\n    exact: false\n  };\n  /**\n   * Aria-current attribute to apply when the router link is active.\n   *\n   * Possible values: `'page'` | `'step'` | `'location'` | `'date'` | `'time'` | `true` | `false`.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Attributes/aria-current}\n   */\n  ariaCurrentWhenActive;\n  /**\n   *\n   * You can use the output `isActiveChange` to get notified each time the link becomes\n   * active or inactive.\n   *\n   * Emits:\n   * true  -> Route is active\n   * false -> Route is inactive\n   *\n   * ```html\n   * <a\n   *  routerLink=\"/user/bob\"\n   *  routerLinkActive=\"active-link\"\n   *  (isActiveChange)=\"this.onRouterLinkActive($event)\">Bob</a>\n   * ```\n   */\n  isActiveChange = new EventEmitter();\n  constructor(router, element, renderer, cdr, link) {\n    this.router = router;\n    this.element = element;\n    this.renderer = renderer;\n    this.cdr = cdr;\n    this.link = link;\n    this.routerEventsSubscription = router.events.subscribe((s) => {\n      if (s instanceof NavigationEnd) {\n        this.update();\n      }\n    });\n  }\n  /** @nodoc */\n  ngAfterContentInit() {\n    of(this.links.changes, of(null)).pipe(mergeAll()).subscribe((_) => {\n      this.update();\n      this.subscribeToEachLinkOnChanges();\n    });\n  }\n  subscribeToEachLinkOnChanges() {\n    this.linkInputChangesSubscription?.unsubscribe();\n    const allLinkChanges = [...this.links.toArray(), this.link].filter((link) => !!link).map((link) => link.onChanges);\n    this.linkInputChangesSubscription = from(allLinkChanges).pipe(mergeAll()).subscribe((link) => {\n      if (this._isActive !== this.isLinkActive(this.router)(link)) {\n        this.update();\n      }\n    });\n  }\n  set routerLinkActive(data) {\n    const classes = Array.isArray(data) ? data : data.split(\" \");\n    this.classes = classes.filter((c) => !!c);\n  }\n  /** @nodoc */\n  ngOnChanges(changes) {\n    this.update();\n  }\n  /** @nodoc */\n  ngOnDestroy() {\n    this.routerEventsSubscription.unsubscribe();\n    this.linkInputChangesSubscription?.unsubscribe();\n  }\n  update() {\n    if (!this.links || !this.router.navigated) return;\n    queueMicrotask(() => {\n      const hasActiveLinks = this.hasActiveLinks();\n      this.classes.forEach((c) => {\n        if (hasActiveLinks) {\n          this.renderer.addClass(this.element.nativeElement, c);\n        } else {\n          this.renderer.removeClass(this.element.nativeElement, c);\n        }\n      });\n      if (hasActiveLinks && this.ariaCurrentWhenActive !== void 0) {\n        this.renderer.setAttribute(this.element.nativeElement, \"aria-current\", this.ariaCurrentWhenActive.toString());\n      } else {\n        this.renderer.removeAttribute(this.element.nativeElement, \"aria-current\");\n      }\n      if (this._isActive !== hasActiveLinks) {\n        this._isActive = hasActiveLinks;\n        this.cdr.markForCheck();\n        this.isActiveChange.emit(hasActiveLinks);\n      }\n    });\n  }\n  isLinkActive(router) {\n    const options = isActiveMatchOptions(this.routerLinkActiveOptions) ? this.routerLinkActiveOptions : (\n      // While the types should disallow `undefined` here, it's possible without strict inputs\n      this.routerLinkActiveOptions.exact || false\n    );\n    return (link) => {\n      const urlTree = link.urlTree;\n      return urlTree ? router.isActive(urlTree, options) : false;\n    };\n  }\n  hasActiveLinks() {\n    const isActiveCheckFn = this.isLinkActive(this.router);\n    return this.link && isActiveCheckFn(this.link) || this.links.some(isActiveCheckFn);\n  }\n  static \\u0275fac = function RouterLinkActive_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _RouterLinkActive)(\\u0275\\u0275directiveInject(Router), \\u0275\\u0275directiveInject(ElementRef), \\u0275\\u0275directiveInject(Renderer2), \\u0275\\u0275directiveInject(ChangeDetectorRef), \\u0275\\u0275directiveInject(RouterLink, 8));\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _RouterLinkActive,\n    selectors: [[\"\", \"routerLinkActive\", \"\"]],\n    contentQueries: function RouterLinkActive_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        \\u0275\\u0275contentQuery(dirIndex, RouterLink, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        \\u0275\\u0275queryRefresh(_t = \\u0275\\u0275loadQuery()) && (ctx.links = _t);\n      }\n    },\n    inputs: {\n      routerLinkActiveOptions: \"routerLinkActiveOptions\",\n      ariaCurrentWhenActive: \"ariaCurrentWhenActive\",\n      routerLinkActive: \"routerLinkActive\"\n    },\n    outputs: {\n      isActiveChange: \"isActiveChange\"\n    },\n    exportAs: [\"routerLinkActive\"],\n    features: [\\u0275\\u0275NgOnChangesFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(RouterLinkActive, [{\n    type: Directive,\n    args: [{\n      selector: \"[routerLinkActive]\",\n      exportAs: \"routerLinkActive\"\n    }]\n  }], () => [{\n    type: Router\n  }, {\n    type: ElementRef\n  }, {\n    type: Renderer2\n  }, {\n    type: ChangeDetectorRef\n  }, {\n    type: RouterLink,\n    decorators: [{\n      type: Optional\n    }]\n  }], {\n    links: [{\n      type: ContentChildren,\n      args: [RouterLink, {\n        descendants: true\n      }]\n    }],\n    routerLinkActiveOptions: [{\n      type: Input\n    }],\n    ariaCurrentWhenActive: [{\n      type: Input\n    }],\n    isActiveChange: [{\n      type: Output\n    }],\n    routerLinkActive: [{\n      type: Input\n    }]\n  });\n})();\nfunction isActiveMatchOptions(options) {\n  return !!options.paths;\n}\nvar PreloadingStrategy = class {\n};\nvar PreloadAllModules = class _PreloadAllModules {\n  preload(route, fn) {\n    return fn().pipe(catchError(() => of(null)));\n  }\n  static \\u0275fac = function PreloadAllModules_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _PreloadAllModules)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _PreloadAllModules,\n    factory: _PreloadAllModules.\\u0275fac,\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(PreloadAllModules, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], null, null);\n})();\nvar NoPreloading = class _NoPreloading {\n  preload(route, fn) {\n    return of(null);\n  }\n  static \\u0275fac = function NoPreloading_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _NoPreloading)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _NoPreloading,\n    factory: _NoPreloading.\\u0275fac,\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(NoPreloading, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], null, null);\n})();\nvar RouterPreloader = class _RouterPreloader {\n  router;\n  injector;\n  preloadingStrategy;\n  loader;\n  subscription;\n  constructor(router, compiler, injector, preloadingStrategy, loader) {\n    this.router = router;\n    this.injector = injector;\n    this.preloadingStrategy = preloadingStrategy;\n    this.loader = loader;\n  }\n  setUpPreloading() {\n    this.subscription = this.router.events.pipe(filter((e) => e instanceof NavigationEnd), concatMap(() => this.preload())).subscribe(() => {\n    });\n  }\n  preload() {\n    return this.processRoutes(this.injector, this.router.config);\n  }\n  /** @nodoc */\n  ngOnDestroy() {\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n    }\n  }\n  processRoutes(injector, routes2) {\n    const res = [];\n    for (const route of routes2) {\n      if (route.providers && !route._injector) {\n        route._injector = createEnvironmentInjector(route.providers, injector, `Route: ${route.path}`);\n      }\n      const injectorForCurrentRoute = route._injector ?? injector;\n      const injectorForChildren = route._loadedInjector ?? injectorForCurrentRoute;\n      if (route.loadChildren && !route._loadedRoutes && route.canLoad === void 0 || route.loadComponent && !route._loadedComponent) {\n        res.push(this.preloadConfig(injectorForCurrentRoute, route));\n      }\n      if (route.children || route._loadedRoutes) {\n        res.push(this.processRoutes(injectorForChildren, route.children ?? route._loadedRoutes));\n      }\n    }\n    return from(res).pipe(mergeAll());\n  }\n  preloadConfig(injector, route) {\n    return this.preloadingStrategy.preload(route, () => {\n      let loadedChildren$;\n      if (route.loadChildren && route.canLoad === void 0) {\n        loadedChildren$ = this.loader.loadChildren(injector, route);\n      } else {\n        loadedChildren$ = of(null);\n      }\n      const recursiveLoadChildren$ = loadedChildren$.pipe(mergeMap((config2) => {\n        if (config2 === null) {\n          return of(void 0);\n        }\n        route._loadedRoutes = config2.routes;\n        route._loadedInjector = config2.injector;\n        return this.processRoutes(config2.injector ?? injector, config2.routes);\n      }));\n      if (route.loadComponent && !route._loadedComponent) {\n        const loadComponent$ = this.loader.loadComponent(route);\n        return from([recursiveLoadChildren$, loadComponent$]).pipe(mergeAll());\n      } else {\n        return recursiveLoadChildren$;\n      }\n    });\n  }\n  static \\u0275fac = function RouterPreloader_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _RouterPreloader)(\\u0275\\u0275inject(Router), \\u0275\\u0275inject(Compiler), \\u0275\\u0275inject(EnvironmentInjector), \\u0275\\u0275inject(PreloadingStrategy), \\u0275\\u0275inject(RouterConfigLoader));\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _RouterPreloader,\n    factory: _RouterPreloader.\\u0275fac,\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(RouterPreloader, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], () => [{\n    type: Router\n  }, {\n    type: Compiler\n  }, {\n    type: EnvironmentInjector\n  }, {\n    type: PreloadingStrategy\n  }, {\n    type: RouterConfigLoader\n  }], null);\n})();\nvar ROUTER_SCROLLER = new InjectionToken(\"\");\nvar RouterScroller = class _RouterScroller {\n  urlSerializer;\n  transitions;\n  viewportScroller;\n  zone;\n  options;\n  routerEventsSubscription;\n  scrollEventsSubscription;\n  lastId = 0;\n  lastSource = \"imperative\";\n  restoredId = 0;\n  store = {};\n  /** @nodoc */\n  constructor(urlSerializer, transitions, viewportScroller, zone, options = {}) {\n    this.urlSerializer = urlSerializer;\n    this.transitions = transitions;\n    this.viewportScroller = viewportScroller;\n    this.zone = zone;\n    this.options = options;\n    options.scrollPositionRestoration ||= \"disabled\";\n    options.anchorScrolling ||= \"disabled\";\n  }\n  init() {\n    if (this.options.scrollPositionRestoration !== \"disabled\") {\n      this.viewportScroller.setHistoryScrollRestoration(\"manual\");\n    }\n    this.routerEventsSubscription = this.createScrollEvents();\n    this.scrollEventsSubscription = this.consumeScrollEvents();\n  }\n  createScrollEvents() {\n    return this.transitions.events.subscribe((e) => {\n      if (e instanceof NavigationStart) {\n        this.store[this.lastId] = this.viewportScroller.getScrollPosition();\n        this.lastSource = e.navigationTrigger;\n        this.restoredId = e.restoredState ? e.restoredState.navigationId : 0;\n      } else if (e instanceof NavigationEnd) {\n        this.lastId = e.id;\n        this.scheduleScrollEvent(e, this.urlSerializer.parse(e.urlAfterRedirects).fragment);\n      } else if (e instanceof NavigationSkipped && e.code === NavigationSkippedCode.IgnoredSameUrlNavigation) {\n        this.lastSource = void 0;\n        this.restoredId = 0;\n        this.scheduleScrollEvent(e, this.urlSerializer.parse(e.url).fragment);\n      }\n    });\n  }\n  consumeScrollEvents() {\n    return this.transitions.events.subscribe((e) => {\n      if (!(e instanceof Scroll)) return;\n      if (e.position) {\n        if (this.options.scrollPositionRestoration === \"top\") {\n          this.viewportScroller.scrollToPosition([0, 0]);\n        } else if (this.options.scrollPositionRestoration === \"enabled\") {\n          this.viewportScroller.scrollToPosition(e.position);\n        }\n      } else {\n        if (e.anchor && this.options.anchorScrolling === \"enabled\") {\n          this.viewportScroller.scrollToAnchor(e.anchor);\n        } else if (this.options.scrollPositionRestoration !== \"disabled\") {\n          this.viewportScroller.scrollToPosition([0, 0]);\n        }\n      }\n    });\n  }\n  scheduleScrollEvent(routerEvent, anchor) {\n    this.zone.runOutsideAngular(() => {\n      setTimeout(() => {\n        this.zone.run(() => {\n          this.transitions.events.next(new Scroll(routerEvent, this.lastSource === \"popstate\" ? this.store[this.restoredId] : null, anchor));\n        });\n      }, 0);\n    });\n  }\n  /** @nodoc */\n  ngOnDestroy() {\n    this.routerEventsSubscription?.unsubscribe();\n    this.scrollEventsSubscription?.unsubscribe();\n  }\n  static \\u0275fac = function RouterScroller_Factory(__ngFactoryType__) {\n    \\u0275\\u0275invalidFactory();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _RouterScroller,\n    factory: _RouterScroller.\\u0275fac\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(RouterScroller, [{\n    type: Injectable\n  }], () => [{\n    type: UrlSerializer\n  }, {\n    type: NavigationTransitions\n  }, {\n    type: ViewportScroller\n  }, {\n    type: NgZone\n  }, {\n    type: void 0\n  }], null);\n})();\nfunction provideRouter(routes2, ...features) {\n  return makeEnvironmentProviders([{\n    provide: ROUTES,\n    multi: true,\n    useValue: routes2\n  }, typeof ngDevMode === \"undefined\" || ngDevMode ? {\n    provide: ROUTER_IS_PROVIDED,\n    useValue: true\n  } : [], {\n    provide: ActivatedRoute,\n    useFactory: rootRoute,\n    deps: [Router]\n  }, {\n    provide: APP_BOOTSTRAP_LISTENER,\n    multi: true,\n    useFactory: getBootstrapListener\n  }, features.map((feature) => feature.\\u0275providers)]);\n}\nfunction rootRoute(router) {\n  return router.routerState.root;\n}\nfunction routerFeature(kind, providers) {\n  return {\n    \\u0275kind: kind,\n    \\u0275providers: providers\n  };\n}\nvar ROUTER_IS_PROVIDED = new InjectionToken(\"\", {\n  providedIn: \"root\",\n  factory: () => false\n});\nfunction getBootstrapListener() {\n  const injector = inject(Injector);\n  return (bootstrappedComponentRef) => {\n    const ref = injector.get(ApplicationRef);\n    if (bootstrappedComponentRef !== ref.components[0]) {\n      return;\n    }\n    const router = injector.get(Router);\n    const bootstrapDone = injector.get(BOOTSTRAP_DONE);\n    if (injector.get(INITIAL_NAVIGATION) === 1) {\n      router.initialNavigation();\n    }\n    injector.get(ROUTER_PRELOADER, null, InjectFlags.Optional)?.setUpPreloading();\n    injector.get(ROUTER_SCROLLER, null, InjectFlags.Optional)?.init();\n    router.resetRootComponentType(ref.componentTypes[0]);\n    if (!bootstrapDone.closed) {\n      bootstrapDone.next();\n      bootstrapDone.complete();\n      bootstrapDone.unsubscribe();\n    }\n  };\n}\nvar BOOTSTRAP_DONE = new InjectionToken(typeof ngDevMode === \"undefined\" || ngDevMode ? \"bootstrap done indicator\" : \"\", {\n  factory: () => {\n    return new Subject();\n  }\n});\nvar INITIAL_NAVIGATION = new InjectionToken(typeof ngDevMode === \"undefined\" || ngDevMode ? \"initial navigation\" : \"\", {\n  providedIn: \"root\",\n  factory: () => 1\n  /* InitialNavigation.EnabledNonBlocking */\n});\nfunction withEnabledBlockingInitialNavigation() {\n  const providers = [{\n    provide: INITIAL_NAVIGATION,\n    useValue: 0\n    /* InitialNavigation.EnabledBlocking */\n  }, {\n    provide: APP_INITIALIZER,\n    multi: true,\n    deps: [Injector],\n    useFactory: (injector) => {\n      const locationInitialized = injector.get(LOCATION_INITIALIZED, Promise.resolve());\n      return () => {\n        return locationInitialized.then(() => {\n          return new Promise((resolve) => {\n            const router = injector.get(Router);\n            const bootstrapDone = injector.get(BOOTSTRAP_DONE);\n            afterNextNavigation(router, () => {\n              resolve(true);\n            });\n            injector.get(NavigationTransitions).afterPreactivation = () => {\n              resolve(true);\n              return bootstrapDone.closed ? of(void 0) : bootstrapDone;\n            };\n            router.initialNavigation();\n          });\n        });\n      };\n    }\n  }];\n  return routerFeature(2, providers);\n}\nfunction withDisabledInitialNavigation() {\n  const providers = [{\n    provide: APP_INITIALIZER,\n    multi: true,\n    useFactory: () => {\n      const router = inject(Router);\n      return () => {\n        router.setUpLocationChangeListener();\n      };\n    }\n  }, {\n    provide: INITIAL_NAVIGATION,\n    useValue: 2\n    /* InitialNavigation.Disabled */\n  }];\n  return routerFeature(3, providers);\n}\nfunction withDebugTracing() {\n  let providers = [];\n  if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n    providers = [{\n      provide: ENVIRONMENT_INITIALIZER,\n      multi: true,\n      useFactory: () => {\n        const router = inject(Router);\n        return () => router.events.subscribe((e) => {\n          console.group?.(`Router Event: ${e.constructor.name}`);\n          console.log(stringifyEvent(e));\n          console.log(e);\n          console.groupEnd?.();\n        });\n      }\n    }];\n  } else {\n    providers = [];\n  }\n  return routerFeature(1, providers);\n}\nvar ROUTER_PRELOADER = new InjectionToken(typeof ngDevMode === \"undefined\" || ngDevMode ? \"router preloader\" : \"\");\nfunction withPreloading(preloadingStrategy) {\n  const providers = [{\n    provide: ROUTER_PRELOADER,\n    useExisting: RouterPreloader\n  }, {\n    provide: PreloadingStrategy,\n    useExisting: preloadingStrategy\n  }];\n  return routerFeature(0, providers);\n}\nfunction withComponentInputBinding() {\n  const providers = [RoutedComponentInputBinder, {\n    provide: INPUT_BINDER,\n    useExisting: RoutedComponentInputBinder\n  }];\n  return routerFeature(8, providers);\n}\nfunction withViewTransitions(options) {\n  const providers = [{\n    provide: CREATE_VIEW_TRANSITION,\n    useValue: createViewTransition\n  }, {\n    provide: VIEW_TRANSITION_OPTIONS,\n    useValue: __spreadValues({\n      skipNextTransition: !!options?.skipInitialTransition\n    }, options)\n  }];\n  return routerFeature(9, providers);\n}\nvar ROUTER_DIRECTIVES = [RouterOutlet, RouterLink, RouterLinkActive, \\u0275EmptyOutletComponent];\nvar ROUTER_FORROOT_GUARD = new InjectionToken(typeof ngDevMode === \"undefined\" || ngDevMode ? \"router duplicate forRoot guard\" : \"\");\nvar ROUTER_PROVIDERS = [\n  Location,\n  {\n    provide: UrlSerializer,\n    useClass: DefaultUrlSerializer\n  },\n  Router,\n  ChildrenOutletContexts,\n  {\n    provide: ActivatedRoute,\n    useFactory: rootRoute,\n    deps: [Router]\n  },\n  RouterConfigLoader,\n  // Only used to warn when `provideRoutes` is used without `RouterModule` or `provideRouter`. Can\n  // be removed when `provideRoutes` is removed.\n  typeof ngDevMode === \"undefined\" || ngDevMode ? {\n    provide: ROUTER_IS_PROVIDED,\n    useValue: true\n  } : []\n];\nvar RouterModule = class _RouterModule {\n  constructor() {\n    if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n      inject(ROUTER_FORROOT_GUARD, {\n        optional: true\n      });\n    }\n  }\n  /**\n   * Creates and configures a module with all the router providers and directives.\n   * Optionally sets up an application listener to perform an initial navigation.\n   *\n   * When registering the NgModule at the root, import as follows:\n   *\n   * ```ts\n   * @NgModule({\n   *   imports: [RouterModule.forRoot(ROUTES)]\n   * })\n   * class MyNgModule {}\n   * ```\n   *\n   * @param routes An array of `Route` objects that define the navigation paths for the application.\n   * @param config An `ExtraOptions` configuration object that controls how navigation is performed.\n   * @return The new `NgModule`.\n   *\n   */\n  static forRoot(routes2, config2) {\n    return {\n      ngModule: _RouterModule,\n      providers: [ROUTER_PROVIDERS, typeof ngDevMode === \"undefined\" || ngDevMode ? config2?.enableTracing ? withDebugTracing().\\u0275providers : [] : [], {\n        provide: ROUTES,\n        multi: true,\n        useValue: routes2\n      }, typeof ngDevMode === \"undefined\" || ngDevMode ? {\n        provide: ROUTER_FORROOT_GUARD,\n        useFactory: provideForRootGuard,\n        deps: [[Router, new Optional(), new SkipSelf()]]\n      } : [], config2?.errorHandler ? {\n        provide: NAVIGATION_ERROR_HANDLER,\n        useValue: config2.errorHandler\n      } : [], {\n        provide: ROUTER_CONFIGURATION,\n        useValue: config2 ? config2 : {}\n      }, config2?.useHash ? provideHashLocationStrategy() : providePathLocationStrategy(), provideRouterScroller(), config2?.preloadingStrategy ? withPreloading(config2.preloadingStrategy).\\u0275providers : [], config2?.initialNavigation ? provideInitialNavigation(config2) : [], config2?.bindToComponentInputs ? withComponentInputBinding().\\u0275providers : [], config2?.enableViewTransitions ? withViewTransitions().\\u0275providers : [], provideRouterInitializer()]\n    };\n  }\n  /**\n   * Creates a module with all the router directives and a provider registering routes,\n   * without creating a new Router service.\n   * When registering for submodules and lazy-loaded submodules, create the NgModule as follows:\n   *\n   * ```ts\n   * @NgModule({\n   *   imports: [RouterModule.forChild(ROUTES)]\n   * })\n   * class MyNgModule {}\n   * ```\n   *\n   * @param routes An array of `Route` objects that define the navigation paths for the submodule.\n   * @return The new NgModule.\n   *\n   */\n  static forChild(routes2) {\n    return {\n      ngModule: _RouterModule,\n      providers: [{\n        provide: ROUTES,\n        multi: true,\n        useValue: routes2\n      }]\n    };\n  }\n  static \\u0275fac = function RouterModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _RouterModule)();\n  };\n  static \\u0275mod = /* @__PURE__ */ \\u0275\\u0275defineNgModule({\n    type: _RouterModule\n  });\n  static \\u0275inj = /* @__PURE__ */ \\u0275\\u0275defineInjector({});\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(RouterModule, [{\n    type: NgModule,\n    args: [{\n      imports: ROUTER_DIRECTIVES,\n      exports: ROUTER_DIRECTIVES\n    }]\n  }], () => [], null);\n})();\nfunction provideRouterScroller() {\n  return {\n    provide: ROUTER_SCROLLER,\n    useFactory: () => {\n      const viewportScroller = inject(ViewportScroller);\n      const zone = inject(NgZone);\n      const config2 = inject(ROUTER_CONFIGURATION);\n      const transitions = inject(NavigationTransitions);\n      const urlSerializer = inject(UrlSerializer);\n      if (config2.scrollOffset) {\n        viewportScroller.setOffset(config2.scrollOffset);\n      }\n      return new RouterScroller(urlSerializer, transitions, viewportScroller, zone, config2);\n    }\n  };\n}\nfunction provideHashLocationStrategy() {\n  return {\n    provide: LocationStrategy,\n    useClass: HashLocationStrategy\n  };\n}\nfunction providePathLocationStrategy() {\n  return {\n    provide: LocationStrategy,\n    useClass: PathLocationStrategy\n  };\n}\nfunction provideForRootGuard(router) {\n  if (router) {\n    throw new RuntimeError(4007, `The Router was provided more than once. This can happen if 'forRoot' is used outside of the root injector. Lazy loaded modules should use RouterModule.forChild() instead.`);\n  }\n  return \"guarded\";\n}\nfunction provideInitialNavigation(config2) {\n  return [config2.initialNavigation === \"disabled\" ? withDisabledInitialNavigation().\\u0275providers : [], config2.initialNavigation === \"enabledBlocking\" ? withEnabledBlockingInitialNavigation().\\u0275providers : []];\n}\nvar ROUTER_INITIALIZER = new InjectionToken(typeof ngDevMode === \"undefined\" || ngDevMode ? \"Router Initializer\" : \"\");\nfunction provideRouterInitializer() {\n  return [\n    // ROUTER_INITIALIZER token should be removed. It's public API but shouldn't be. We can just\n    // have `getBootstrapListener` directly attached to APP_BOOTSTRAP_LISTENER.\n    {\n      provide: ROUTER_INITIALIZER,\n      useFactory: getBootstrapListener\n    },\n    {\n      provide: APP_BOOTSTRAP_LISTENER,\n      multi: true,\n      useExisting: ROUTER_INITIALIZER\n    }\n  ];\n}\nvar VERSION4 = new Version(\"19.2.3\");\n\n// node_modules/@angular/forms/fesm2022/forms.mjs\nvar BaseControlValueAccessor = class _BaseControlValueAccessor {\n  _renderer;\n  _elementRef;\n  /**\n   * The registered callback function called when a change or input event occurs on the input\n   * element.\n   * @nodoc\n   */\n  onChange = (_) => {\n  };\n  /**\n   * The registered callback function called when a blur event occurs on the input element.\n   * @nodoc\n   */\n  onTouched = () => {\n  };\n  constructor(_renderer, _elementRef) {\n    this._renderer = _renderer;\n    this._elementRef = _elementRef;\n  }\n  /**\n   * Helper method that sets a property on a target element using the current Renderer\n   * implementation.\n   * @nodoc\n   */\n  setProperty(key, value) {\n    this._renderer.setProperty(this._elementRef.nativeElement, key, value);\n  }\n  /**\n   * Registers a function called when the control is touched.\n   * @nodoc\n   */\n  registerOnTouched(fn) {\n    this.onTouched = fn;\n  }\n  /**\n   * Registers a function called when the control value changes.\n   * @nodoc\n   */\n  registerOnChange(fn) {\n    this.onChange = fn;\n  }\n  /**\n   * Sets the \"disabled\" property on the range input element.\n   * @nodoc\n   */\n  setDisabledState(isDisabled) {\n    this.setProperty(\"disabled\", isDisabled);\n  }\n  static \\u0275fac = function BaseControlValueAccessor_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _BaseControlValueAccessor)(\\u0275\\u0275directiveInject(Renderer2), \\u0275\\u0275directiveInject(ElementRef));\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _BaseControlValueAccessor\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(BaseControlValueAccessor, [{\n    type: Directive\n  }], () => [{\n    type: Renderer2\n  }, {\n    type: ElementRef\n  }], null);\n})();\nvar BuiltInControlValueAccessor = class _BuiltInControlValueAccessor extends BaseControlValueAccessor {\n  static \\u0275fac = /* @__PURE__ */ (() => {\n    let \\u0275BuiltInControlValueAccessor_BaseFactory;\n    return function BuiltInControlValueAccessor_Factory(__ngFactoryType__) {\n      return (\\u0275BuiltInControlValueAccessor_BaseFactory || (\\u0275BuiltInControlValueAccessor_BaseFactory = \\u0275\\u0275getInheritedFactory(_BuiltInControlValueAccessor)))(__ngFactoryType__ || _BuiltInControlValueAccessor);\n    };\n  })();\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _BuiltInControlValueAccessor,\n    features: [\\u0275\\u0275InheritDefinitionFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(BuiltInControlValueAccessor, [{\n    type: Directive\n  }], null, null);\n})();\nvar NG_VALUE_ACCESSOR = new InjectionToken(ngDevMode ? \"NgValueAccessor\" : \"\");\nvar CHECKBOX_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => CheckboxControlValueAccessor),\n  multi: true\n};\nvar CheckboxControlValueAccessor = class _CheckboxControlValueAccessor extends BuiltInControlValueAccessor {\n  /**\n   * Sets the \"checked\" property on the input element.\n   * @nodoc\n   */\n  writeValue(value) {\n    this.setProperty(\"checked\", value);\n  }\n  static \\u0275fac = /* @__PURE__ */ (() => {\n    let \\u0275CheckboxControlValueAccessor_BaseFactory;\n    return function CheckboxControlValueAccessor_Factory(__ngFactoryType__) {\n      return (\\u0275CheckboxControlValueAccessor_BaseFactory || (\\u0275CheckboxControlValueAccessor_BaseFactory = \\u0275\\u0275getInheritedFactory(_CheckboxControlValueAccessor)))(__ngFactoryType__ || _CheckboxControlValueAccessor);\n    };\n  })();\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _CheckboxControlValueAccessor,\n    selectors: [[\"input\", \"type\", \"checkbox\", \"formControlName\", \"\"], [\"input\", \"type\", \"checkbox\", \"formControl\", \"\"], [\"input\", \"type\", \"checkbox\", \"ngModel\", \"\"]],\n    hostBindings: function CheckboxControlValueAccessor_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        \\u0275\\u0275listener(\"change\", function CheckboxControlValueAccessor_change_HostBindingHandler($event) {\n          return ctx.onChange($event.target.checked);\n        })(\"blur\", function CheckboxControlValueAccessor_blur_HostBindingHandler() {\n          return ctx.onTouched();\n        });\n      }\n    },\n    standalone: false,\n    features: [\\u0275\\u0275ProvidersFeature([CHECKBOX_VALUE_ACCESSOR]), \\u0275\\u0275InheritDefinitionFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(CheckboxControlValueAccessor, [{\n    type: Directive,\n    args: [{\n      selector: \"input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]\",\n      host: {\n        \"(change)\": \"onChange($event.target.checked)\",\n        \"(blur)\": \"onTouched()\"\n      },\n      providers: [CHECKBOX_VALUE_ACCESSOR],\n      standalone: false\n    }]\n  }], null, null);\n})();\nvar DEFAULT_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => DefaultValueAccessor),\n  multi: true\n};\nfunction _isAndroid() {\n  const userAgent = getDOM() ? getDOM().getUserAgent() : \"\";\n  return /android (\\d+)/.test(userAgent.toLowerCase());\n}\nvar COMPOSITION_BUFFER_MODE = new InjectionToken(ngDevMode ? \"CompositionEventMode\" : \"\");\nvar DefaultValueAccessor = class _DefaultValueAccessor extends BaseControlValueAccessor {\n  _compositionMode;\n  /** Whether the user is creating a composition string (IME events). */\n  _composing = false;\n  constructor(renderer, elementRef, _compositionMode) {\n    super(renderer, elementRef);\n    this._compositionMode = _compositionMode;\n    if (this._compositionMode == null) {\n      this._compositionMode = !_isAndroid();\n    }\n  }\n  /**\n   * Sets the \"value\" property on the input element.\n   * @nodoc\n   */\n  writeValue(value) {\n    const normalizedValue = value == null ? \"\" : value;\n    this.setProperty(\"value\", normalizedValue);\n  }\n  /** @internal */\n  _handleInput(value) {\n    if (!this._compositionMode || this._compositionMode && !this._composing) {\n      this.onChange(value);\n    }\n  }\n  /** @internal */\n  _compositionStart() {\n    this._composing = true;\n  }\n  /** @internal */\n  _compositionEnd(value) {\n    this._composing = false;\n    this._compositionMode && this.onChange(value);\n  }\n  static \\u0275fac = function DefaultValueAccessor_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _DefaultValueAccessor)(\\u0275\\u0275directiveInject(Renderer2), \\u0275\\u0275directiveInject(ElementRef), \\u0275\\u0275directiveInject(COMPOSITION_BUFFER_MODE, 8));\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _DefaultValueAccessor,\n    selectors: [[\"input\", \"formControlName\", \"\", 3, \"type\", \"checkbox\"], [\"textarea\", \"formControlName\", \"\"], [\"input\", \"formControl\", \"\", 3, \"type\", \"checkbox\"], [\"textarea\", \"formControl\", \"\"], [\"input\", \"ngModel\", \"\", 3, \"type\", \"checkbox\"], [\"textarea\", \"ngModel\", \"\"], [\"\", \"ngDefaultControl\", \"\"]],\n    hostBindings: function DefaultValueAccessor_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        \\u0275\\u0275listener(\"input\", function DefaultValueAccessor_input_HostBindingHandler($event) {\n          return ctx._handleInput($event.target.value);\n        })(\"blur\", function DefaultValueAccessor_blur_HostBindingHandler() {\n          return ctx.onTouched();\n        })(\"compositionstart\", function DefaultValueAccessor_compositionstart_HostBindingHandler() {\n          return ctx._compositionStart();\n        })(\"compositionend\", function DefaultValueAccessor_compositionend_HostBindingHandler($event) {\n          return ctx._compositionEnd($event.target.value);\n        });\n      }\n    },\n    standalone: false,\n    features: [\\u0275\\u0275ProvidersFeature([DEFAULT_VALUE_ACCESSOR]), \\u0275\\u0275InheritDefinitionFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(DefaultValueAccessor, [{\n    type: Directive,\n    args: [{\n      selector: \"input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]\",\n      // TODO: vsavkin replace the above selector with the one below it once\n      // https://github.com/angular/angular/issues/3011 is implemented\n      // selector: '[ngModel],[formControl],[formControlName]',\n      host: {\n        \"(input)\": \"$any(this)._handleInput($event.target.value)\",\n        \"(blur)\": \"onTouched()\",\n        \"(compositionstart)\": \"$any(this)._compositionStart()\",\n        \"(compositionend)\": \"$any(this)._compositionEnd($event.target.value)\"\n      },\n      providers: [DEFAULT_VALUE_ACCESSOR],\n      standalone: false\n    }]\n  }], () => [{\n    type: Renderer2\n  }, {\n    type: ElementRef\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [COMPOSITION_BUFFER_MODE]\n    }]\n  }], null);\n})();\nfunction isEmptyInputValue(value) {\n  return value == null || lengthOrSize(value) === 0;\n}\nfunction lengthOrSize(value) {\n  if (value == null) {\n    return null;\n  } else if (Array.isArray(value) || typeof value === \"string\") {\n    return value.length;\n  } else if (value instanceof Set) {\n    return value.size;\n  }\n  return null;\n}\nvar NG_VALIDATORS = new InjectionToken(ngDevMode ? \"NgValidators\" : \"\");\nvar NG_ASYNC_VALIDATORS = new InjectionToken(ngDevMode ? \"NgAsyncValidators\" : \"\");\nvar EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\nvar Validators = class {\n  /**\n   * @description\n   * Validator that requires the control's value to be greater than or equal to the provided number.\n   *\n   * @usageNotes\n   *\n   * ### Validate against a minimum of 3\n   *\n   * ```ts\n   * const control = new FormControl(2, Validators.min(3));\n   *\n   * console.log(control.errors); // {min: {min: 3, actual: 2}}\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `min` property if the validation check fails, otherwise `null`.\n   *\n   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}\n   *\n   */\n  static min(min) {\n    return minValidator(min);\n  }\n  /**\n   * @description\n   * Validator that requires the control's value to be less than or equal to the provided number.\n   *\n   * @usageNotes\n   *\n   * ### Validate against a maximum of 15\n   *\n   * ```ts\n   * const control = new FormControl(16, Validators.max(15));\n   *\n   * console.log(control.errors); // {max: {max: 15, actual: 16}}\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `max` property if the validation check fails, otherwise `null`.\n   *\n   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}\n   *\n   */\n  static max(max) {\n    return maxValidator(max);\n  }\n  /**\n   * @description\n   * Validator that requires the control have a non-empty value.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field is non-empty\n   *\n   * ```ts\n   * const control = new FormControl('', Validators.required);\n   *\n   * console.log(control.errors); // {required: true}\n   * ```\n   *\n   * @returns An error map with the `required` property\n   * if the validation check fails, otherwise `null`.\n   *\n   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}\n   *\n   */\n  static required(control) {\n    return requiredValidator(control);\n  }\n  /**\n   * @description\n   * Validator that requires the control's value be true. This validator is commonly\n   * used for required checkboxes.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field value is true\n   *\n   * ```ts\n   * const control = new FormControl('some value', Validators.requiredTrue);\n   *\n   * console.log(control.errors); // {required: true}\n   * ```\n   *\n   * @returns An error map that contains the `required` property\n   * set to `true` if the validation check fails, otherwise `null`.\n   *\n   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}\n   *\n   */\n  static requiredTrue(control) {\n    return requiredTrueValidator(control);\n  }\n  /**\n   * @description\n   * Validator that requires the control's value pass an email validation test.\n   *\n   * Tests the value using a [regular\n   * expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)\n   * pattern suitable for common use cases. The pattern is based on the definition of a valid email\n   * address in the [WHATWG HTML\n   * specification](https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address) with\n   * some enhancements to incorporate more RFC rules (such as rules related to domain names and the\n   * lengths of different parts of the address).\n   *\n   * The differences from the WHATWG version include:\n   * - Disallow `local-part` (the part before the `@` symbol) to begin or end with a period (`.`).\n   * - Disallow `local-part` to be longer than 64 characters.\n   * - Disallow the whole address to be longer than 254 characters.\n   *\n   * If this pattern does not satisfy your business needs, you can use `Validators.pattern()` to\n   * validate the value against a different pattern.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field matches a valid email pattern\n   *\n   * ```ts\n   * const control = new FormControl('bad@', Validators.email);\n   *\n   * console.log(control.errors); // {email: true}\n   * ```\n   *\n   * @returns An error map with the `email` property\n   * if the validation check fails, otherwise `null`.\n   *\n   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}\n   *\n   */\n  static email(control) {\n    return emailValidator(control);\n  }\n  /**\n   * @description\n   * Validator that requires the number of items in the control's value to be greater than or equal\n   * to the provided minimum length. This validator is also provided by default if you use\n   * the HTML5 `minlength` attribute. Note that the `minLength` validator is intended to be used\n   * only for types that have a numeric `length` or `size` property, such as strings, arrays or\n   * sets. The `minLength` validator logic is also not invoked for values when their `length` or\n   * `size` property is 0 (for example in case of an empty string or an empty array), to support\n   * optional controls. You can use the standard `required` validator if empty values should not be\n   * considered valid.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field has a minimum of 3 characters\n   *\n   * ```ts\n   * const control = new FormControl('ng', Validators.minLength(3));\n   *\n   * console.log(control.errors); // {minlength: {requiredLength: 3, actualLength: 2}}\n   * ```\n   *\n   * ```html\n   * <input minlength=\"5\">\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `minlength` property if the validation check fails, otherwise `null`.\n   *\n   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}\n   *\n   */\n  static minLength(minLength) {\n    return minLengthValidator(minLength);\n  }\n  /**\n   * @description\n   * Validator that requires the number of items in the control's value to be less than or equal\n   * to the provided maximum length. This validator is also provided by default if you use\n   * the HTML5 `maxlength` attribute. Note that the `maxLength` validator is intended to be used\n   * only for types that have a numeric `length` or `size` property, such as strings, arrays or\n   * sets.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field has maximum of 5 characters\n   *\n   * ```ts\n   * const control = new FormControl('Angular', Validators.maxLength(5));\n   *\n   * console.log(control.errors); // {maxlength: {requiredLength: 5, actualLength: 7}}\n   * ```\n   *\n   * ```html\n   * <input maxlength=\"5\">\n   * ```\n   *\n   * @returns A validator function that returns an error map with the\n   * `maxlength` property if the validation check fails, otherwise `null`.\n   *\n   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}\n   *\n   */\n  static maxLength(maxLength) {\n    return maxLengthValidator(maxLength);\n  }\n  /**\n   * @description\n   * Validator that requires the control's value to match a regex pattern. This validator is also\n   * provided by default if you use the HTML5 `pattern` attribute.\n   *\n   * @usageNotes\n   *\n   * ### Validate that the field only contains letters or spaces\n   *\n   * ```ts\n   * const control = new FormControl('1', Validators.pattern('[a-zA-Z ]*'));\n   *\n   * console.log(control.errors); // {pattern: {requiredPattern: '^[a-zA-Z ]*$', actualValue: '1'}}\n   * ```\n   *\n   * ```html\n   * <input pattern=\"[a-zA-Z ]*\">\n   * ```\n   *\n   * ### Pattern matching with the global or sticky flag\n   *\n   * `RegExp` objects created with the `g` or `y` flags that are passed into `Validators.pattern`\n   * can produce different results on the same input when validations are run consecutively. This is\n   * due to how the behavior of `RegExp.prototype.test` is\n   * specified in [ECMA-262](https://tc39.es/ecma262/#sec-regexpbuiltinexec)\n   * (`RegExp` preserves the index of the last match when the global or sticky flag is used).\n   * Due to this behavior, it is recommended that when using\n   * `Validators.pattern` you **do not** pass in a `RegExp` object with either the global or sticky\n   * flag enabled.\n   *\n   * ```ts\n   * // Not recommended (since the `g` flag is used)\n   * const controlOne = new FormControl('1', Validators.pattern(/foo/g));\n   *\n   * // Good\n   * const controlTwo = new FormControl('1', Validators.pattern(/foo/));\n   * ```\n   *\n   * @param pattern A regular expression to be used as is to test the values, or a string.\n   * If a string is passed, the `^` character is prepended and the `$` character is\n   * appended to the provided string (if not already present), and the resulting regular\n   * expression is used to test the values.\n   *\n   * @returns A validator function that returns an error map with the\n   * `pattern` property if the validation check fails, otherwise `null`.\n   *\n   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}\n   *\n   */\n  static pattern(pattern) {\n    return patternValidator(pattern);\n  }\n  /**\n   * @description\n   * Validator that performs no operation.\n   *\n   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}\n   *\n   */\n  static nullValidator(control) {\n    return nullValidator();\n  }\n  static compose(validators) {\n    return compose(validators);\n  }\n  /**\n   * @description\n   * Compose multiple async validators into a single function that returns the union\n   * of the individual error objects for the provided control.\n   *\n   * @returns A validator function that returns an error map with the\n   * merged error objects of the async validators if the validation check fails, otherwise `null`.\n   *\n   * @see {@link /api/forms/AbstractControl#updateValueAndValidity updateValueAndValidity}\n   *\n   */\n  static composeAsync(validators) {\n    return composeAsync(validators);\n  }\n};\nfunction minValidator(min) {\n  return (control) => {\n    if (control.value == null || min == null) {\n      return null;\n    }\n    const value = parseFloat(control.value);\n    return !isNaN(value) && value < min ? {\n      \"min\": {\n        \"min\": min,\n        \"actual\": control.value\n      }\n    } : null;\n  };\n}\nfunction maxValidator(max) {\n  return (control) => {\n    if (control.value == null || max == null) {\n      return null;\n    }\n    const value = parseFloat(control.value);\n    return !isNaN(value) && value > max ? {\n      \"max\": {\n        \"max\": max,\n        \"actual\": control.value\n      }\n    } : null;\n  };\n}\nfunction requiredValidator(control) {\n  return isEmptyInputValue(control.value) ? {\n    \"required\": true\n  } : null;\n}\nfunction requiredTrueValidator(control) {\n  return control.value === true ? null : {\n    \"required\": true\n  };\n}\nfunction emailValidator(control) {\n  if (isEmptyInputValue(control.value)) {\n    return null;\n  }\n  return EMAIL_REGEXP.test(control.value) ? null : {\n    \"email\": true\n  };\n}\nfunction minLengthValidator(minLength) {\n  return (control) => {\n    const length = control.value?.length ?? lengthOrSize(control.value);\n    if (length === null || length === 0) {\n      return null;\n    }\n    return length < minLength ? {\n      \"minlength\": {\n        \"requiredLength\": minLength,\n        \"actualLength\": length\n      }\n    } : null;\n  };\n}\nfunction maxLengthValidator(maxLength) {\n  return (control) => {\n    const length = control.value?.length ?? lengthOrSize(control.value);\n    if (length !== null && length > maxLength) {\n      return {\n        \"maxlength\": {\n          \"requiredLength\": maxLength,\n          \"actualLength\": length\n        }\n      };\n    }\n    return null;\n  };\n}\nfunction patternValidator(pattern) {\n  if (!pattern) return nullValidator;\n  let regex;\n  let regexStr;\n  if (typeof pattern === \"string\") {\n    regexStr = \"\";\n    if (pattern.charAt(0) !== \"^\") regexStr += \"^\";\n    regexStr += pattern;\n    if (pattern.charAt(pattern.length - 1) !== \"$\") regexStr += \"$\";\n    regex = new RegExp(regexStr);\n  } else {\n    regexStr = pattern.toString();\n    regex = pattern;\n  }\n  return (control) => {\n    if (isEmptyInputValue(control.value)) {\n      return null;\n    }\n    const value = control.value;\n    return regex.test(value) ? null : {\n      \"pattern\": {\n        \"requiredPattern\": regexStr,\n        \"actualValue\": value\n      }\n    };\n  };\n}\nfunction nullValidator(control) {\n  return null;\n}\nfunction isPresent(o) {\n  return o != null;\n}\nfunction toObservable(value) {\n  const obs = isPromise2(value) ? from(value) : value;\n  if ((typeof ngDevMode === \"undefined\" || ngDevMode) && !isSubscribable(obs)) {\n    let errorMessage = `Expected async validator to return Promise or Observable.`;\n    if (typeof value === \"object\") {\n      errorMessage += \" Are you using a synchronous validator where an async validator is expected?\";\n    }\n    throw new RuntimeError(-1101, errorMessage);\n  }\n  return obs;\n}\nfunction mergeErrors(arrayOfErrors) {\n  let res = {};\n  arrayOfErrors.forEach((errors) => {\n    res = errors != null ? __spreadValues(__spreadValues({}, res), errors) : res;\n  });\n  return Object.keys(res).length === 0 ? null : res;\n}\nfunction executeValidators(control, validators) {\n  return validators.map((validator) => validator(control));\n}\nfunction isValidatorFn(validator) {\n  return !validator.validate;\n}\nfunction normalizeValidators(validators) {\n  return validators.map((validator) => {\n    return isValidatorFn(validator) ? validator : (c) => validator.validate(c);\n  });\n}\nfunction compose(validators) {\n  if (!validators) return null;\n  const presentValidators = validators.filter(isPresent);\n  if (presentValidators.length == 0) return null;\n  return function(control) {\n    return mergeErrors(executeValidators(control, presentValidators));\n  };\n}\nfunction composeValidators(validators) {\n  return validators != null ? compose(normalizeValidators(validators)) : null;\n}\nfunction composeAsync(validators) {\n  if (!validators) return null;\n  const presentValidators = validators.filter(isPresent);\n  if (presentValidators.length == 0) return null;\n  return function(control) {\n    const observables = executeValidators(control, presentValidators).map(toObservable);\n    return forkJoin(observables).pipe(map(mergeErrors));\n  };\n}\nfunction composeAsyncValidators(validators) {\n  return validators != null ? composeAsync(normalizeValidators(validators)) : null;\n}\nfunction mergeValidators(controlValidators, dirValidator) {\n  if (controlValidators === null) return [dirValidator];\n  return Array.isArray(controlValidators) ? [...controlValidators, dirValidator] : [controlValidators, dirValidator];\n}\nfunction getControlValidators(control) {\n  return control._rawValidators;\n}\nfunction getControlAsyncValidators(control) {\n  return control._rawAsyncValidators;\n}\nfunction makeValidatorsArray(validators) {\n  if (!validators) return [];\n  return Array.isArray(validators) ? validators : [validators];\n}\nfunction hasValidator(validators, validator) {\n  return Array.isArray(validators) ? validators.includes(validator) : validators === validator;\n}\nfunction addValidators(validators, currentValidators) {\n  const current = makeValidatorsArray(currentValidators);\n  const validatorsToAdd = makeValidatorsArray(validators);\n  validatorsToAdd.forEach((v) => {\n    if (!hasValidator(current, v)) {\n      current.push(v);\n    }\n  });\n  return current;\n}\nfunction removeValidators(validators, currentValidators) {\n  return makeValidatorsArray(currentValidators).filter((v) => !hasValidator(validators, v));\n}\nvar AbstractControlDirective = class {\n  /**\n   * @description\n   * Reports the value of the control if it is present, otherwise null.\n   */\n  get value() {\n    return this.control ? this.control.value : null;\n  }\n  /**\n   * @description\n   * Reports whether the control is valid. A control is considered valid if no\n   * validation errors exist with the current value.\n   * If the control is not present, null is returned.\n   */\n  get valid() {\n    return this.control ? this.control.valid : null;\n  }\n  /**\n   * @description\n   * Reports whether the control is invalid, meaning that an error exists in the input value.\n   * If the control is not present, null is returned.\n   */\n  get invalid() {\n    return this.control ? this.control.invalid : null;\n  }\n  /**\n   * @description\n   * Reports whether a control is pending, meaning that async validation is occurring and\n   * errors are not yet available for the input value. If the control is not present, null is\n   * returned.\n   */\n  get pending() {\n    return this.control ? this.control.pending : null;\n  }\n  /**\n   * @description\n   * Reports whether the control is disabled, meaning that the control is disabled\n   * in the UI and is exempt from validation checks and excluded from aggregate\n   * values of ancestor controls. If the control is not present, null is returned.\n   */\n  get disabled() {\n    return this.control ? this.control.disabled : null;\n  }\n  /**\n   * @description\n   * Reports whether the control is enabled, meaning that the control is included in ancestor\n   * calculations of validity or value. If the control is not present, null is returned.\n   */\n  get enabled() {\n    return this.control ? this.control.enabled : null;\n  }\n  /**\n   * @description\n   * Reports the control's validation errors. If the control is not present, null is returned.\n   */\n  get errors() {\n    return this.control ? this.control.errors : null;\n  }\n  /**\n   * @description\n   * Reports whether the control is pristine, meaning that the user has not yet changed\n   * the value in the UI. If the control is not present, null is returned.\n   */\n  get pristine() {\n    return this.control ? this.control.pristine : null;\n  }\n  /**\n   * @description\n   * Reports whether the control is dirty, meaning that the user has changed\n   * the value in the UI. If the control is not present, null is returned.\n   */\n  get dirty() {\n    return this.control ? this.control.dirty : null;\n  }\n  /**\n   * @description\n   * Reports whether the control is touched, meaning that the user has triggered\n   * a `blur` event on it. If the control is not present, null is returned.\n   */\n  get touched() {\n    return this.control ? this.control.touched : null;\n  }\n  /**\n   * @description\n   * Reports the validation status of the control. Possible values include:\n   * 'VALID', 'INVALID', 'DISABLED', and 'PENDING'.\n   * If the control is not present, null is returned.\n   */\n  get status() {\n    return this.control ? this.control.status : null;\n  }\n  /**\n   * @description\n   * Reports whether the control is untouched, meaning that the user has not yet triggered\n   * a `blur` event on it. If the control is not present, null is returned.\n   */\n  get untouched() {\n    return this.control ? this.control.untouched : null;\n  }\n  /**\n   * @description\n   * Returns a multicasting observable that emits a validation status whenever it is\n   * calculated for the control. If the control is not present, null is returned.\n   */\n  get statusChanges() {\n    return this.control ? this.control.statusChanges : null;\n  }\n  /**\n   * @description\n   * Returns a multicasting observable of value changes for the control that emits every time the\n   * value of the control changes in the UI or programmatically.\n   * If the control is not present, null is returned.\n   */\n  get valueChanges() {\n    return this.control ? this.control.valueChanges : null;\n  }\n  /**\n   * @description\n   * Returns an array that represents the path from the top-level form to this control.\n   * Each index is the string name of the control on that level.\n   */\n  get path() {\n    return null;\n  }\n  /**\n   * Contains the result of merging synchronous validators into a single validator function\n   * (combined using `Validators.compose`).\n   */\n  _composedValidatorFn;\n  /**\n   * Contains the result of merging asynchronous validators into a single validator function\n   * (combined using `Validators.composeAsync`).\n   */\n  _composedAsyncValidatorFn;\n  /**\n   * Set of synchronous validators as they were provided while calling `setValidators` function.\n   * @internal\n   */\n  _rawValidators = [];\n  /**\n   * Set of asynchronous validators as they were provided while calling `setAsyncValidators`\n   * function.\n   * @internal\n   */\n  _rawAsyncValidators = [];\n  /**\n   * Sets synchronous validators for this directive.\n   * @internal\n   */\n  _setValidators(validators) {\n    this._rawValidators = validators || [];\n    this._composedValidatorFn = composeValidators(this._rawValidators);\n  }\n  /**\n   * Sets asynchronous validators for this directive.\n   * @internal\n   */\n  _setAsyncValidators(validators) {\n    this._rawAsyncValidators = validators || [];\n    this._composedAsyncValidatorFn = composeAsyncValidators(this._rawAsyncValidators);\n  }\n  /**\n   * @description\n   * Synchronous validator function composed of all the synchronous validators registered with this\n   * directive.\n   */\n  get validator() {\n    return this._composedValidatorFn || null;\n  }\n  /**\n   * @description\n   * Asynchronous validator function composed of all the asynchronous validators registered with\n   * this directive.\n   */\n  get asyncValidator() {\n    return this._composedAsyncValidatorFn || null;\n  }\n  /*\n   * The set of callbacks to be invoked when directive instance is being destroyed.\n   */\n  _onDestroyCallbacks = [];\n  /**\n   * Internal function to register callbacks that should be invoked\n   * when directive instance is being destroyed.\n   * @internal\n   */\n  _registerOnDestroy(fn) {\n    this._onDestroyCallbacks.push(fn);\n  }\n  /**\n   * Internal function to invoke all registered \"on destroy\" callbacks.\n   * Note: calling this function also clears the list of callbacks.\n   * @internal\n   */\n  _invokeOnDestroyCallbacks() {\n    this._onDestroyCallbacks.forEach((fn) => fn());\n    this._onDestroyCallbacks = [];\n  }\n  /**\n   * @description\n   * Resets the control with the provided value if the control is present.\n   */\n  reset(value = void 0) {\n    if (this.control) this.control.reset(value);\n  }\n  /**\n   * @description\n   * Reports whether the control with the given path has the error specified.\n   *\n   * @param errorCode The code of the error to check\n   * @param path A list of control names that designates how to move from the current control\n   * to the control that should be queried for errors.\n   *\n   * @usageNotes\n   * For example, for the following `FormGroup`:\n   *\n   * ```ts\n   * form = new FormGroup({\n   *   address: new FormGroup({ street: new FormControl() })\n   * });\n   * ```\n   *\n   * The path to the 'street' control from the root form would be 'address' -> 'street'.\n   *\n   * It can be provided to this method in one of two formats:\n   *\n   * 1. An array of string control names, e.g. `['address', 'street']`\n   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n   *\n   * If no path is given, this method checks for the error on the current control.\n   *\n   * @returns whether the given error is present in the control at the given path.\n   *\n   * If the control is not present, false is returned.\n   */\n  hasError(errorCode, path) {\n    return this.control ? this.control.hasError(errorCode, path) : false;\n  }\n  /**\n   * @description\n   * Reports error data for the control with the given path.\n   *\n   * @param errorCode The code of the error to check\n   * @param path A list of control names that designates how to move from the current control\n   * to the control that should be queried for errors.\n   *\n   * @usageNotes\n   * For example, for the following `FormGroup`:\n   *\n   * ```ts\n   * form = new FormGroup({\n   *   address: new FormGroup({ street: new FormControl() })\n   * });\n   * ```\n   *\n   * The path to the 'street' control from the root form would be 'address' -> 'street'.\n   *\n   * It can be provided to this method in one of two formats:\n   *\n   * 1. An array of string control names, e.g. `['address', 'street']`\n   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n   *\n   * @returns error data for that particular error. If the control or error is not present,\n   * null is returned.\n   */\n  getError(errorCode, path) {\n    return this.control ? this.control.getError(errorCode, path) : null;\n  }\n};\nvar ControlContainer = class extends AbstractControlDirective {\n  /**\n   * @description\n   * The name for the control\n   */\n  // TODO(issue/24571): remove '!'.\n  name;\n  /**\n   * @description\n   * The top-level form directive for the control.\n   */\n  get formDirective() {\n    return null;\n  }\n  /**\n   * @description\n   * The path to this group.\n   */\n  get path() {\n    return null;\n  }\n};\nvar NgControl = class extends AbstractControlDirective {\n  /**\n   * @description\n   * The parent form for the control.\n   *\n   * @internal\n   */\n  _parent = null;\n  /**\n   * @description\n   * The name for the control\n   */\n  name = null;\n  /**\n   * @description\n   * The value accessor for the control\n   */\n  valueAccessor = null;\n};\nvar AbstractControlStatus = class {\n  _cd;\n  constructor(cd) {\n    this._cd = cd;\n  }\n  get isTouched() {\n    this._cd?.control?._touched?.();\n    return !!this._cd?.control?.touched;\n  }\n  get isUntouched() {\n    return !!this._cd?.control?.untouched;\n  }\n  get isPristine() {\n    this._cd?.control?._pristine?.();\n    return !!this._cd?.control?.pristine;\n  }\n  get isDirty() {\n    return !!this._cd?.control?.dirty;\n  }\n  get isValid() {\n    this._cd?.control?._status?.();\n    return !!this._cd?.control?.valid;\n  }\n  get isInvalid() {\n    return !!this._cd?.control?.invalid;\n  }\n  get isPending() {\n    return !!this._cd?.control?.pending;\n  }\n  get isSubmitted() {\n    this._cd?._submitted?.();\n    return !!this._cd?.submitted;\n  }\n};\nvar ngControlStatusHost = {\n  \"[class.ng-untouched]\": \"isUntouched\",\n  \"[class.ng-touched]\": \"isTouched\",\n  \"[class.ng-pristine]\": \"isPristine\",\n  \"[class.ng-dirty]\": \"isDirty\",\n  \"[class.ng-valid]\": \"isValid\",\n  \"[class.ng-invalid]\": \"isInvalid\",\n  \"[class.ng-pending]\": \"isPending\"\n};\nvar ngGroupStatusHost = __spreadProps(__spreadValues({}, ngControlStatusHost), {\n  \"[class.ng-submitted]\": \"isSubmitted\"\n});\nvar NgControlStatus = class _NgControlStatus extends AbstractControlStatus {\n  constructor(cd) {\n    super(cd);\n  }\n  static \\u0275fac = function NgControlStatus_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _NgControlStatus)(\\u0275\\u0275directiveInject(NgControl, 2));\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _NgControlStatus,\n    selectors: [[\"\", \"formControlName\", \"\"], [\"\", \"ngModel\", \"\"], [\"\", \"formControl\", \"\"]],\n    hostVars: 14,\n    hostBindings: function NgControlStatus_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        \\u0275\\u0275classProp(\"ng-untouched\", ctx.isUntouched)(\"ng-touched\", ctx.isTouched)(\"ng-pristine\", ctx.isPristine)(\"ng-dirty\", ctx.isDirty)(\"ng-valid\", ctx.isValid)(\"ng-invalid\", ctx.isInvalid)(\"ng-pending\", ctx.isPending);\n      }\n    },\n    standalone: false,\n    features: [\\u0275\\u0275InheritDefinitionFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(NgControlStatus, [{\n    type: Directive,\n    args: [{\n      selector: \"[formControlName],[ngModel],[formControl]\",\n      host: ngControlStatusHost,\n      standalone: false\n    }]\n  }], () => [{\n    type: NgControl,\n    decorators: [{\n      type: Self\n    }]\n  }], null);\n})();\nvar NgControlStatusGroup = class _NgControlStatusGroup extends AbstractControlStatus {\n  constructor(cd) {\n    super(cd);\n  }\n  static \\u0275fac = function NgControlStatusGroup_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _NgControlStatusGroup)(\\u0275\\u0275directiveInject(ControlContainer, 10));\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _NgControlStatusGroup,\n    selectors: [[\"\", \"formGroupName\", \"\"], [\"\", \"formArrayName\", \"\"], [\"\", \"ngModelGroup\", \"\"], [\"\", \"formGroup\", \"\"], [\"form\", 3, \"ngNoForm\", \"\"], [\"\", \"ngForm\", \"\"]],\n    hostVars: 16,\n    hostBindings: function NgControlStatusGroup_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        \\u0275\\u0275classProp(\"ng-untouched\", ctx.isUntouched)(\"ng-touched\", ctx.isTouched)(\"ng-pristine\", ctx.isPristine)(\"ng-dirty\", ctx.isDirty)(\"ng-valid\", ctx.isValid)(\"ng-invalid\", ctx.isInvalid)(\"ng-pending\", ctx.isPending)(\"ng-submitted\", ctx.isSubmitted);\n      }\n    },\n    standalone: false,\n    features: [\\u0275\\u0275InheritDefinitionFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(NgControlStatusGroup, [{\n    type: Directive,\n    args: [{\n      selector: \"[formGroupName],[formArrayName],[ngModelGroup],[formGroup],form:not([ngNoForm]),[ngForm]\",\n      host: ngGroupStatusHost,\n      standalone: false\n    }]\n  }], () => [{\n    type: ControlContainer,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }]\n  }], null);\n})();\nvar formControlNameExample = `\n  <div [formGroup]=\"myGroup\">\n    <input formControlName=\"firstName\">\n  </div>\n\n  In your class:\n\n  this.myGroup = new FormGroup({\n      firstName: new FormControl()\n  });`;\nvar formGroupNameExample = `\n  <div [formGroup]=\"myGroup\">\n      <div formGroupName=\"person\">\n        <input formControlName=\"firstName\">\n      </div>\n  </div>\n\n  In your class:\n\n  this.myGroup = new FormGroup({\n      person: new FormGroup({ firstName: new FormControl() })\n  });`;\nvar formArrayNameExample = `\n  <div [formGroup]=\"myGroup\">\n    <div formArrayName=\"cities\">\n      <div *ngFor=\"let city of cityArray.controls; index as i\">\n        <input [formControlName]=\"i\">\n      </div>\n    </div>\n  </div>\n\n  In your class:\n\n  this.cityArray = new FormArray([new FormControl('SF')]);\n  this.myGroup = new FormGroup({\n    cities: this.cityArray\n  });`;\nvar ngModelGroupExample = `\n  <form>\n      <div ngModelGroup=\"person\">\n        <input [(ngModel)]=\"person.name\" name=\"firstName\">\n      </div>\n  </form>`;\nvar ngModelWithFormGroupExample = `\n  <div [formGroup]=\"myGroup\">\n      <input formControlName=\"firstName\">\n      <input [(ngModel)]=\"showMoreControls\" [ngModelOptions]=\"{standalone: true}\">\n  </div>\n`;\nfunction controlParentException(nameOrIndex) {\n  return new RuntimeError(1050, `formControlName must be used with a parent formGroup directive. You'll want to add a formGroup\n      directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      ${describeFormControl(nameOrIndex)}\n\n    Example:\n\n    ${formControlNameExample}`);\n}\nfunction describeFormControl(nameOrIndex) {\n  if (nameOrIndex == null || nameOrIndex === \"\") {\n    return \"\";\n  }\n  const valueType = typeof nameOrIndex === \"string\" ? \"name\" : \"index\";\n  return `Affected Form Control ${valueType}: \"${nameOrIndex}\"`;\n}\nfunction ngModelGroupException() {\n  return new RuntimeError(1051, `formControlName cannot be used with an ngModelGroup parent. It is only compatible with parents\n      that also have a \"form\" prefix: formGroupName, formArrayName, or formGroup.\n\n      Option 1:  Update the parent to be formGroupName (reactive form strategy)\n\n      ${formGroupNameExample}\n\n      Option 2: Use ngModel instead of formControlName (template-driven strategy)\n\n      ${ngModelGroupExample}`);\n}\nfunction missingFormException() {\n  return new RuntimeError(1052, `formGroup expects a FormGroup instance. Please pass one in.\n\n      Example:\n\n      ${formControlNameExample}`);\n}\nfunction groupParentException() {\n  return new RuntimeError(1053, `formGroupName must be used with a parent formGroup directive.  You'll want to add a formGroup\n    directive and pass it an existing FormGroup instance (you can create one in your class).\n\n    Example:\n\n    ${formGroupNameExample}`);\n}\nfunction arrayParentException() {\n  return new RuntimeError(1054, `formArrayName must be used with a parent formGroup directive.  You'll want to add a formGroup\n      directive and pass it an existing FormGroup instance (you can create one in your class).\n\n      Example:\n\n      ${formArrayNameExample}`);\n}\nvar disabledAttrWarning = `\n  It looks like you're using the disabled attribute with a reactive form directive. If you set disabled to true\n  when you set up this control in your component class, the disabled attribute will actually be set in the DOM for\n  you. We recommend using this approach to avoid 'changed after checked' errors.\n\n  Example:\n  // Specify the \\`disabled\\` property at control creation time:\n  form = new FormGroup({\n    first: new FormControl({value: 'Nancy', disabled: true}, Validators.required),\n    last: new FormControl('Drew', Validators.required)\n  });\n\n  // Controls can also be enabled/disabled after creation:\n  form.get('first')?.enable();\n  form.get('last')?.disable();\n`;\nvar asyncValidatorsDroppedWithOptsWarning = `\n  It looks like you're constructing using a FormControl with both an options argument and an\n  async validators argument. Mixing these arguments will cause your async validators to be dropped.\n  You should either put all your validators in the options object, or in separate validators\n  arguments. For example:\n\n  // Using validators arguments\n  fc = new FormControl(42, Validators.required, myAsyncValidator);\n\n  // Using AbstractControlOptions\n  fc = new FormControl(42, {validators: Validators.required, asyncValidators: myAV});\n\n  // Do NOT mix them: async validators will be dropped!\n  fc = new FormControl(42, {validators: Validators.required}, /* Oops! */ myAsyncValidator);\n`;\nfunction ngModelWarning(directiveName) {\n  return `\n  It looks like you're using ngModel on the same form field as ${directiveName}.\n  Support for using the ngModel input property and ngModelChange event with\n  reactive form directives has been deprecated in Angular v6 and will be removed\n  in a future version of Angular.\n\n  For more information on this, see our API docs here:\n  https://angular.io/api/forms/${directiveName === \"formControl\" ? \"FormControlDirective\" : \"FormControlName\"}#use-with-ngmodel\n  `;\n}\nfunction describeKey(isFormGroup, key) {\n  return isFormGroup ? `with name: '${key}'` : `at index: ${key}`;\n}\nfunction noControlsError(isFormGroup) {\n  return `\n    There are no form controls registered with this ${isFormGroup ? \"group\" : \"array\"} yet. If you're using ngModel,\n    you may want to check next tick (e.g. use setTimeout).\n  `;\n}\nfunction missingControlError(isFormGroup, key) {\n  return `Cannot find form control ${describeKey(isFormGroup, key)}`;\n}\nfunction missingControlValueError(isFormGroup, key) {\n  return `Must supply a value for form control ${describeKey(isFormGroup, key)}`;\n}\nvar VALID = \"VALID\";\nvar INVALID = \"INVALID\";\nvar PENDING = \"PENDING\";\nvar DISABLED = \"DISABLED\";\nvar ControlEvent = class {\n};\nvar ValueChangeEvent = class extends ControlEvent {\n  value;\n  source;\n  constructor(value, source) {\n    super();\n    this.value = value;\n    this.source = source;\n  }\n};\nvar PristineChangeEvent = class extends ControlEvent {\n  pristine;\n  source;\n  constructor(pristine, source) {\n    super();\n    this.pristine = pristine;\n    this.source = source;\n  }\n};\nvar TouchedChangeEvent = class extends ControlEvent {\n  touched;\n  source;\n  constructor(touched, source) {\n    super();\n    this.touched = touched;\n    this.source = source;\n  }\n};\nvar StatusChangeEvent = class extends ControlEvent {\n  status;\n  source;\n  constructor(status, source) {\n    super();\n    this.status = status;\n    this.source = source;\n  }\n};\nvar FormSubmittedEvent = class extends ControlEvent {\n  source;\n  constructor(source) {\n    super();\n    this.source = source;\n  }\n};\nvar FormResetEvent = class extends ControlEvent {\n  source;\n  constructor(source) {\n    super();\n    this.source = source;\n  }\n};\nfunction pickValidators(validatorOrOpts) {\n  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.validators : validatorOrOpts) || null;\n}\nfunction coerceToValidator(validator) {\n  return Array.isArray(validator) ? composeValidators(validator) : validator || null;\n}\nfunction pickAsyncValidators(asyncValidator, validatorOrOpts) {\n  if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n    if (isOptionsObj(validatorOrOpts) && asyncValidator) {\n      console.warn(asyncValidatorsDroppedWithOptsWarning);\n    }\n  }\n  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.asyncValidators : asyncValidator) || null;\n}\nfunction coerceToAsyncValidator(asyncValidator) {\n  return Array.isArray(asyncValidator) ? composeAsyncValidators(asyncValidator) : asyncValidator || null;\n}\nfunction isOptionsObj(validatorOrOpts) {\n  return validatorOrOpts != null && !Array.isArray(validatorOrOpts) && typeof validatorOrOpts === \"object\";\n}\nfunction assertControlPresent(parent, isGroup, key) {\n  const controls = parent.controls;\n  const collection = isGroup ? Object.keys(controls) : controls;\n  if (!collection.length) {\n    throw new RuntimeError(1e3, typeof ngDevMode === \"undefined\" || ngDevMode ? noControlsError(isGroup) : \"\");\n  }\n  if (!controls[key]) {\n    throw new RuntimeError(1001, typeof ngDevMode === \"undefined\" || ngDevMode ? missingControlError(isGroup, key) : \"\");\n  }\n}\nfunction assertAllValuesPresent(control, isGroup, value) {\n  control._forEachChild((_, key) => {\n    if (value[key] === void 0) {\n      throw new RuntimeError(1002, typeof ngDevMode === \"undefined\" || ngDevMode ? missingControlValueError(isGroup, key) : \"\");\n    }\n  });\n}\nvar AbstractControl = class {\n  /** @internal */\n  _pendingDirty = false;\n  /**\n   * Indicates that a control has its own pending asynchronous validation in progress.\n   * It also stores if the control should emit events when the validation status changes.\n   *\n   * @internal\n   */\n  _hasOwnPendingAsyncValidator = null;\n  /** @internal */\n  _pendingTouched = false;\n  /** @internal */\n  _onCollectionChange = () => {\n  };\n  /** @internal */\n  _updateOn;\n  _parent = null;\n  _asyncValidationSubscription;\n  /**\n   * Contains the result of merging synchronous validators into a single validator function\n   * (combined using `Validators.compose`).\n   *\n   * @internal\n   */\n  _composedValidatorFn;\n  /**\n   * Contains the result of merging asynchronous validators into a single validator function\n   * (combined using `Validators.composeAsync`).\n   *\n   * @internal\n   */\n  _composedAsyncValidatorFn;\n  /**\n   * Synchronous validators as they were provided:\n   *  - in `AbstractControl` constructor\n   *  - as an argument while calling `setValidators` function\n   *  - while calling the setter on the `validator` field (e.g. `control.validator = validatorFn`)\n   *\n   * @internal\n   */\n  _rawValidators;\n  /**\n   * Asynchronous validators as they were provided:\n   *  - in `AbstractControl` constructor\n   *  - as an argument while calling `setAsyncValidators` function\n   *  - while calling the setter on the `asyncValidator` field (e.g. `control.asyncValidator =\n   * asyncValidatorFn`)\n   *\n   * @internal\n   */\n  _rawAsyncValidators;\n  /**\n   * The current value of the control.\n   *\n   * * For a `FormControl`, the current value.\n   * * For an enabled `FormGroup`, the values of enabled controls as an object\n   * with a key-value pair for each member of the group.\n   * * For a disabled `FormGroup`, the values of all controls as an object\n   * with a key-value pair for each member of the group.\n   * * For a `FormArray`, the values of enabled controls as an array.\n   *\n   */\n  value;\n  /**\n   * Initialize the AbstractControl instance.\n   *\n   * @param validators The function or array of functions that is used to determine the validity of\n   *     this control synchronously.\n   * @param asyncValidators The function or array of functions that is used to determine validity of\n   *     this control asynchronously.\n   */\n  constructor(validators, asyncValidators) {\n    this._assignValidators(validators);\n    this._assignAsyncValidators(asyncValidators);\n  }\n  /**\n   * Returns the function that is used to determine the validity of this control synchronously.\n   * If multiple validators have been added, this will be a single composed function.\n   * See `Validators.compose()` for additional information.\n   */\n  get validator() {\n    return this._composedValidatorFn;\n  }\n  set validator(validatorFn) {\n    this._rawValidators = this._composedValidatorFn = validatorFn;\n  }\n  /**\n   * Returns the function that is used to determine the validity of this control asynchronously.\n   * If multiple validators have been added, this will be a single composed function.\n   * See `Validators.compose()` for additional information.\n   */\n  get asyncValidator() {\n    return this._composedAsyncValidatorFn;\n  }\n  set asyncValidator(asyncValidatorFn) {\n    this._rawAsyncValidators = this._composedAsyncValidatorFn = asyncValidatorFn;\n  }\n  /**\n   * The parent control.\n   */\n  get parent() {\n    return this._parent;\n  }\n  /**\n   * The validation status of the control.\n   *\n   * @see {@link FormControlStatus}\n   *\n   * These status values are mutually exclusive, so a control cannot be\n   * both valid AND invalid or invalid AND disabled.\n   */\n  get status() {\n    return untracked2(this.statusReactive);\n  }\n  set status(v) {\n    untracked2(() => this.statusReactive.set(v));\n  }\n  /** @internal */\n  _status = computed(() => this.statusReactive());\n  statusReactive = signal(void 0);\n  /**\n   * A control is `valid` when its `status` is `VALID`.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @returns True if the control has passed all of its validation tests,\n   * false otherwise.\n   */\n  get valid() {\n    return this.status === VALID;\n  }\n  /**\n   * A control is `invalid` when its `status` is `INVALID`.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @returns True if this control has failed one or more of its validation checks,\n   * false otherwise.\n   */\n  get invalid() {\n    return this.status === INVALID;\n  }\n  /**\n   * A control is `pending` when its `status` is `PENDING`.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @returns True if this control is in the process of conducting a validation check,\n   * false otherwise.\n   */\n  get pending() {\n    return this.status == PENDING;\n  }\n  /**\n   * A control is `disabled` when its `status` is `DISABLED`.\n   *\n   * Disabled controls are exempt from validation checks and\n   * are not included in the aggregate value of their ancestor\n   * controls.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @returns True if the control is disabled, false otherwise.\n   */\n  get disabled() {\n    return this.status === DISABLED;\n  }\n  /**\n   * A control is `enabled` as long as its `status` is not `DISABLED`.\n   *\n   * @returns True if the control has any status other than 'DISABLED',\n   * false if the status is 'DISABLED'.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   */\n  get enabled() {\n    return this.status !== DISABLED;\n  }\n  /**\n   * An object containing any errors generated by failing validation,\n   * or null if there are no errors.\n   */\n  errors;\n  /**\n   * A control is `pristine` if the user has not yet changed\n   * the value in the UI.\n   *\n   * @returns True if the user has not yet changed the value in the UI; compare `dirty`.\n   * Programmatic changes to a control's value do not mark it dirty.\n   */\n  get pristine() {\n    return untracked2(this.pristineReactive);\n  }\n  set pristine(v) {\n    untracked2(() => this.pristineReactive.set(v));\n  }\n  /** @internal */\n  _pristine = computed(() => this.pristineReactive());\n  pristineReactive = signal(true);\n  /**\n   * A control is `dirty` if the user has changed the value\n   * in the UI.\n   *\n   * @returns True if the user has changed the value of this control in the UI; compare `pristine`.\n   * Programmatic changes to a control's value do not mark it dirty.\n   */\n  get dirty() {\n    return !this.pristine;\n  }\n  /**\n   * True if the control is marked as `touched`.\n   *\n   * A control is marked `touched` once the user has triggered\n   * a `blur` event on it.\n   */\n  get touched() {\n    return untracked2(this.touchedReactive);\n  }\n  set touched(v) {\n    untracked2(() => this.touchedReactive.set(v));\n  }\n  /** @internal */\n  _touched = computed(() => this.touchedReactive());\n  touchedReactive = signal(false);\n  /**\n   * True if the control has not been marked as touched\n   *\n   * A control is `untouched` if the user has not yet triggered\n   * a `blur` event on it.\n   */\n  get untouched() {\n    return !this.touched;\n  }\n  /**\n   * Exposed as observable, see below.\n   *\n   * @internal\n   */\n  _events = new Subject();\n  /**\n   * A multicasting observable that emits an event every time the state of the control changes.\n   * It emits for value, status, pristine or touched changes.\n   *\n   * **Note**: On value change, the emit happens right after a value of this control is updated. The\n   * value of a parent control (for example if this FormControl is a part of a FormGroup) is updated\n   * later, so accessing a value of a parent control (using the `value` property) from the callback\n   * of this event might result in getting a value that has not been updated yet. Subscribe to the\n   * `events` of the parent control instead.\n   * For other event types, the events are emitted after the parent control has been updated.\n   *\n   */\n  events = this._events.asObservable();\n  /**\n   * A multicasting observable that emits an event every time the value of the control changes, in\n   * the UI or programmatically. It also emits an event each time you call enable() or disable()\n   * without passing along {emitEvent: false} as a function argument.\n   *\n   * **Note**: the emit happens right after a value of this control is updated. The value of a\n   * parent control (for example if this FormControl is a part of a FormGroup) is updated later, so\n   * accessing a value of a parent control (using the `value` property) from the callback of this\n   * event might result in getting a value that has not been updated yet. Subscribe to the\n   * `valueChanges` event of the parent control instead.\n   */\n  valueChanges;\n  /**\n   * A multicasting observable that emits an event every time the validation `status` of the control\n   * recalculates.\n   *\n   * @see {@link FormControlStatus}\n   * @see {@link AbstractControl.status}\n   */\n  statusChanges;\n  /**\n   * Reports the update strategy of the `AbstractControl` (meaning\n   * the event on which the control updates itself).\n   * Possible values: `'change'` | `'blur'` | `'submit'`\n   * Default value: `'change'`\n   */\n  get updateOn() {\n    return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : \"change\";\n  }\n  /**\n   * Sets the synchronous validators that are active on this control.  Calling\n   * this overwrites any existing synchronous validators.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   * If you want to add a new validator without affecting existing ones, consider\n   * using `addValidators()` method instead.\n   */\n  setValidators(validators) {\n    this._assignValidators(validators);\n  }\n  /**\n   * Sets the asynchronous validators that are active on this control. Calling this\n   * overwrites any existing asynchronous validators.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   * If you want to add a new validator without affecting existing ones, consider\n   * using `addAsyncValidators()` method instead.\n   */\n  setAsyncValidators(validators) {\n    this._assignAsyncValidators(validators);\n  }\n  /**\n   * Add a synchronous validator or validators to this control, without affecting other validators.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   * Adding a validator that already exists will have no effect. If duplicate validator functions\n   * are present in the `validators` array, only the first instance would be added to a form\n   * control.\n   *\n   * @param validators The new validator function or functions to add to this control.\n   */\n  addValidators(validators) {\n    this.setValidators(addValidators(validators, this._rawValidators));\n  }\n  /**\n   * Add an asynchronous validator or validators to this control, without affecting other\n   * validators.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   * Adding a validator that already exists will have no effect.\n   *\n   * @param validators The new asynchronous validator function or functions to add to this control.\n   */\n  addAsyncValidators(validators) {\n    this.setAsyncValidators(addValidators(validators, this._rawAsyncValidators));\n  }\n  /**\n   * Remove a synchronous validator from this control, without affecting other validators.\n   * Validators are compared by function reference; you must pass a reference to the exact same\n   * validator function as the one that was originally set. If a provided validator is not found,\n   * it is ignored.\n   *\n   * @usageNotes\n   *\n   * ### Reference to a ValidatorFn\n   *\n   * ```\n   * // Reference to the RequiredValidator\n   * const ctrl = new FormControl<string | null>('', Validators.required);\n   * ctrl.removeValidators(Validators.required);\n   *\n   * // Reference to anonymous function inside MinValidator\n   * const minValidator = Validators.min(3);\n   * const ctrl = new FormControl<string | null>('', minValidator);\n   * expect(ctrl.hasValidator(minValidator)).toEqual(true)\n   * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)\n   *\n   * ctrl.removeValidators(minValidator);\n   * ```\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   * @param validators The validator or validators to remove.\n   */\n  removeValidators(validators) {\n    this.setValidators(removeValidators(validators, this._rawValidators));\n  }\n  /**\n   * Remove an asynchronous validator from this control, without affecting other validators.\n   * Validators are compared by function reference; you must pass a reference to the exact same\n   * validator function as the one that was originally set. If a provided validator is not found, it\n   * is ignored.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   * @param validators The asynchronous validator or validators to remove.\n   */\n  removeAsyncValidators(validators) {\n    this.setAsyncValidators(removeValidators(validators, this._rawAsyncValidators));\n  }\n  /**\n   * Check whether a synchronous validator function is present on this control. The provided\n   * validator must be a reference to the exact same function that was provided.\n   *\n   * @usageNotes\n   *\n   * ### Reference to a ValidatorFn\n   *\n   * ```\n   * // Reference to the RequiredValidator\n   * const ctrl = new FormControl<number | null>(0, Validators.required);\n   * expect(ctrl.hasValidator(Validators.required)).toEqual(true)\n   *\n   * // Reference to anonymous function inside MinValidator\n   * const minValidator = Validators.min(3);\n   * const ctrl = new FormControl<number | null>(0, minValidator);\n   * expect(ctrl.hasValidator(minValidator)).toEqual(true)\n   * expect(ctrl.hasValidator(Validators.min(3))).toEqual(false)\n   * ```\n   *\n   * @param validator The validator to check for presence. Compared by function reference.\n   * @returns Whether the provided validator was found on this control.\n   */\n  hasValidator(validator) {\n    return hasValidator(this._rawValidators, validator);\n  }\n  /**\n   * Check whether an asynchronous validator function is present on this control. The provided\n   * validator must be a reference to the exact same function that was provided.\n   *\n   * @param validator The asynchronous validator to check for presence. Compared by function\n   *     reference.\n   * @returns Whether the provided asynchronous validator was found on this control.\n   */\n  hasAsyncValidator(validator) {\n    return hasValidator(this._rawAsyncValidators, validator);\n  }\n  /**\n   * Empties out the synchronous validator list.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   */\n  clearValidators() {\n    this.validator = null;\n  }\n  /**\n   * Empties out the async validator list.\n   *\n   * When you add or remove a validator at run time, you must call\n   * `updateValueAndValidity()` for the new validation to take effect.\n   *\n   */\n  clearAsyncValidators() {\n    this.asyncValidator = null;\n  }\n  markAsTouched(opts = {}) {\n    const changed = this.touched === false;\n    this.touched = true;\n    const sourceControl = opts.sourceControl ?? this;\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsTouched(__spreadProps(__spreadValues({}, opts), {\n        sourceControl\n      }));\n    }\n    if (changed && opts.emitEvent !== false) {\n      this._events.next(new TouchedChangeEvent(true, sourceControl));\n    }\n  }\n  /**\n   * Marks the control and all its descendant controls as `touched`.\n   * @see {@link markAsTouched()}\n   *\n   * @param opts Configuration options that determine how the control propagates changes\n   * and emits events after marking is applied.\n   * * `emitEvent`: When true or not supplied (the default), the `events`\n   * observable emits a `TouchedChangeEvent` with the `touched` property being `true`.\n   * When false, no events are emitted.\n   */\n  markAllAsTouched(opts = {}) {\n    this.markAsTouched({\n      onlySelf: true,\n      emitEvent: opts.emitEvent,\n      sourceControl: this\n    });\n    this._forEachChild((control) => control.markAllAsTouched(opts));\n  }\n  markAsUntouched(opts = {}) {\n    const changed = this.touched === true;\n    this.touched = false;\n    this._pendingTouched = false;\n    const sourceControl = opts.sourceControl ?? this;\n    this._forEachChild((control) => {\n      control.markAsUntouched({\n        onlySelf: true,\n        emitEvent: opts.emitEvent,\n        sourceControl\n      });\n    });\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updateTouched(opts, sourceControl);\n    }\n    if (changed && opts.emitEvent !== false) {\n      this._events.next(new TouchedChangeEvent(false, sourceControl));\n    }\n  }\n  markAsDirty(opts = {}) {\n    const changed = this.pristine === true;\n    this.pristine = false;\n    const sourceControl = opts.sourceControl ?? this;\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsDirty(__spreadProps(__spreadValues({}, opts), {\n        sourceControl\n      }));\n    }\n    if (changed && opts.emitEvent !== false) {\n      this._events.next(new PristineChangeEvent(false, sourceControl));\n    }\n  }\n  markAsPristine(opts = {}) {\n    const changed = this.pristine === false;\n    this.pristine = true;\n    this._pendingDirty = false;\n    const sourceControl = opts.sourceControl ?? this;\n    this._forEachChild((control) => {\n      control.markAsPristine({\n        onlySelf: true,\n        emitEvent: opts.emitEvent\n      });\n    });\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updatePristine(opts, sourceControl);\n    }\n    if (changed && opts.emitEvent !== false) {\n      this._events.next(new PristineChangeEvent(true, sourceControl));\n    }\n  }\n  markAsPending(opts = {}) {\n    this.status = PENDING;\n    const sourceControl = opts.sourceControl ?? this;\n    if (opts.emitEvent !== false) {\n      this._events.next(new StatusChangeEvent(this.status, sourceControl));\n      this.statusChanges.emit(this.status);\n    }\n    if (this._parent && !opts.onlySelf) {\n      this._parent.markAsPending(__spreadProps(__spreadValues({}, opts), {\n        sourceControl\n      }));\n    }\n  }\n  disable(opts = {}) {\n    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);\n    this.status = DISABLED;\n    this.errors = null;\n    this._forEachChild((control) => {\n      control.disable(__spreadProps(__spreadValues({}, opts), {\n        onlySelf: true\n      }));\n    });\n    this._updateValue();\n    const sourceControl = opts.sourceControl ?? this;\n    if (opts.emitEvent !== false) {\n      this._events.next(new ValueChangeEvent(this.value, sourceControl));\n      this._events.next(new StatusChangeEvent(this.status, sourceControl));\n      this.valueChanges.emit(this.value);\n      this.statusChanges.emit(this.status);\n    }\n    this._updateAncestors(__spreadProps(__spreadValues({}, opts), {\n      skipPristineCheck\n    }), this);\n    this._onDisabledChange.forEach((changeFn) => changeFn(true));\n  }\n  /**\n   * Enables the control. This means the control is included in validation checks and\n   * the aggregate value of its parent. Its status recalculates based on its value and\n   * its validators.\n   *\n   * By default, if the control has children, all children are enabled.\n   *\n   * @see {@link AbstractControl.status}\n   *\n   * @param opts Configure options that control how the control propagates changes and\n   * emits events when marked as untouched\n   * * `onlySelf`: When true, mark only this control. When false or not supplied,\n   * marks all direct ancestors. Default is false.\n   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`,\n   * `valueChanges` and `events`\n   * observables emit events with the latest status and value when the control is enabled.\n   * When false, no events are emitted.\n   */\n  enable(opts = {}) {\n    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);\n    this.status = VALID;\n    this._forEachChild((control) => {\n      control.enable(__spreadProps(__spreadValues({}, opts), {\n        onlySelf: true\n      }));\n    });\n    this.updateValueAndValidity({\n      onlySelf: true,\n      emitEvent: opts.emitEvent\n    });\n    this._updateAncestors(__spreadProps(__spreadValues({}, opts), {\n      skipPristineCheck\n    }), this);\n    this._onDisabledChange.forEach((changeFn) => changeFn(false));\n  }\n  _updateAncestors(opts, sourceControl) {\n    if (this._parent && !opts.onlySelf) {\n      this._parent.updateValueAndValidity(opts);\n      if (!opts.skipPristineCheck) {\n        this._parent._updatePristine({}, sourceControl);\n      }\n      this._parent._updateTouched({}, sourceControl);\n    }\n  }\n  /**\n   * Sets the parent of the control\n   *\n   * @param parent The new parent.\n   */\n  setParent(parent) {\n    this._parent = parent;\n  }\n  /**\n   * The raw value of this control. For most control implementations, the raw value will include\n   * disabled children.\n   */\n  getRawValue() {\n    return this.value;\n  }\n  updateValueAndValidity(opts = {}) {\n    this._setInitialStatus();\n    this._updateValue();\n    if (this.enabled) {\n      const shouldHaveEmitted = this._cancelExistingSubscription();\n      this.errors = this._runValidator();\n      this.status = this._calculateStatus();\n      if (this.status === VALID || this.status === PENDING) {\n        this._runAsyncValidator(shouldHaveEmitted, opts.emitEvent);\n      }\n    }\n    const sourceControl = opts.sourceControl ?? this;\n    if (opts.emitEvent !== false) {\n      this._events.next(new ValueChangeEvent(this.value, sourceControl));\n      this._events.next(new StatusChangeEvent(this.status, sourceControl));\n      this.valueChanges.emit(this.value);\n      this.statusChanges.emit(this.status);\n    }\n    if (this._parent && !opts.onlySelf) {\n      this._parent.updateValueAndValidity(__spreadProps(__spreadValues({}, opts), {\n        sourceControl\n      }));\n    }\n  }\n  /** @internal */\n  _updateTreeValidity(opts = {\n    emitEvent: true\n  }) {\n    this._forEachChild((ctrl) => ctrl._updateTreeValidity(opts));\n    this.updateValueAndValidity({\n      onlySelf: true,\n      emitEvent: opts.emitEvent\n    });\n  }\n  _setInitialStatus() {\n    this.status = this._allControlsDisabled() ? DISABLED : VALID;\n  }\n  _runValidator() {\n    return this.validator ? this.validator(this) : null;\n  }\n  _runAsyncValidator(shouldHaveEmitted, emitEvent) {\n    if (this.asyncValidator) {\n      this.status = PENDING;\n      this._hasOwnPendingAsyncValidator = {\n        emitEvent: emitEvent !== false\n      };\n      const obs = toObservable(this.asyncValidator(this));\n      this._asyncValidationSubscription = obs.subscribe((errors) => {\n        this._hasOwnPendingAsyncValidator = null;\n        this.setErrors(errors, {\n          emitEvent,\n          shouldHaveEmitted\n        });\n      });\n    }\n  }\n  _cancelExistingSubscription() {\n    if (this._asyncValidationSubscription) {\n      this._asyncValidationSubscription.unsubscribe();\n      const shouldHaveEmitted = this._hasOwnPendingAsyncValidator?.emitEvent ?? false;\n      this._hasOwnPendingAsyncValidator = null;\n      return shouldHaveEmitted;\n    }\n    return false;\n  }\n  setErrors(errors, opts = {}) {\n    this.errors = errors;\n    this._updateControlsErrors(opts.emitEvent !== false, this, opts.shouldHaveEmitted);\n  }\n  /**\n   * Retrieves a child control given the control's name or path.\n   *\n   * @param path A dot-delimited string or array of string/number values that define the path to the\n   * control. If a string is provided, passing it as a string literal will result in improved type\n   * information. Likewise, if an array is provided, passing it `as const` will cause improved type\n   * information to be available.\n   *\n   * @usageNotes\n   * ### Retrieve a nested control\n   *\n   * For example, to get a `name` control nested within a `person` sub-group:\n   *\n   * * `this.form.get('person.name');`\n   *\n   * -OR-\n   *\n   * * `this.form.get(['person', 'name'] as const);` // `as const` gives improved typings\n   *\n   * ### Retrieve a control in a FormArray\n   *\n   * When accessing an element inside a FormArray, you can use an element index.\n   * For example, to get a `price` control from the first element in an `items` array you can use:\n   *\n   * * `this.form.get('items.0.price');`\n   *\n   * -OR-\n   *\n   * * `this.form.get(['items', 0, 'price']);`\n   */\n  get(path) {\n    let currPath = path;\n    if (currPath == null) return null;\n    if (!Array.isArray(currPath)) currPath = currPath.split(\".\");\n    if (currPath.length === 0) return null;\n    return currPath.reduce((control, name) => control && control._find(name), this);\n  }\n  /**\n   * @description\n   * Reports error data for the control with the given path.\n   *\n   * @param errorCode The code of the error to check\n   * @param path A list of control names that designates how to move from the current control\n   * to the control that should be queried for errors.\n   *\n   * @usageNotes\n   * For example, for the following `FormGroup`:\n   *\n   * ```ts\n   * form = new FormGroup({\n   *   address: new FormGroup({ street: new FormControl() })\n   * });\n   * ```\n   *\n   * The path to the 'street' control from the root form would be 'address' -> 'street'.\n   *\n   * It can be provided to this method in one of two formats:\n   *\n   * 1. An array of string control names, e.g. `['address', 'street']`\n   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n   *\n   * @returns error data for that particular error. If the control or error is not present,\n   * null is returned.\n   */\n  getError(errorCode, path) {\n    const control = path ? this.get(path) : this;\n    return control && control.errors ? control.errors[errorCode] : null;\n  }\n  /**\n   * @description\n   * Reports whether the control with the given path has the error specified.\n   *\n   * @param errorCode The code of the error to check\n   * @param path A list of control names that designates how to move from the current control\n   * to the control that should be queried for errors.\n   *\n   * @usageNotes\n   * For example, for the following `FormGroup`:\n   *\n   * ```ts\n   * form = new FormGroup({\n   *   address: new FormGroup({ street: new FormControl() })\n   * });\n   * ```\n   *\n   * The path to the 'street' control from the root form would be 'address' -> 'street'.\n   *\n   * It can be provided to this method in one of two formats:\n   *\n   * 1. An array of string control names, e.g. `['address', 'street']`\n   * 1. A period-delimited list of control names in one string, e.g. `'address.street'`\n   *\n   * If no path is given, this method checks for the error on the current control.\n   *\n   * @returns whether the given error is present in the control at the given path.\n   *\n   * If the control is not present, false is returned.\n   */\n  hasError(errorCode, path) {\n    return !!this.getError(errorCode, path);\n  }\n  /**\n   * Retrieves the top-level ancestor of this control.\n   */\n  get root() {\n    let x = this;\n    while (x._parent) {\n      x = x._parent;\n    }\n    return x;\n  }\n  /** @internal */\n  _updateControlsErrors(emitEvent, changedControl, shouldHaveEmitted) {\n    this.status = this._calculateStatus();\n    if (emitEvent) {\n      this.statusChanges.emit(this.status);\n    }\n    if (emitEvent || shouldHaveEmitted) {\n      this._events.next(new StatusChangeEvent(this.status, changedControl));\n    }\n    if (this._parent) {\n      this._parent._updateControlsErrors(emitEvent, changedControl, shouldHaveEmitted);\n    }\n  }\n  /** @internal */\n  _initObservables() {\n    this.valueChanges = new EventEmitter();\n    this.statusChanges = new EventEmitter();\n  }\n  _calculateStatus() {\n    if (this._allControlsDisabled()) return DISABLED;\n    if (this.errors) return INVALID;\n    if (this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(PENDING)) return PENDING;\n    if (this._anyControlsHaveStatus(INVALID)) return INVALID;\n    return VALID;\n  }\n  /** @internal */\n  _anyControlsHaveStatus(status) {\n    return this._anyControls((control) => control.status === status);\n  }\n  /** @internal */\n  _anyControlsDirty() {\n    return this._anyControls((control) => control.dirty);\n  }\n  /** @internal */\n  _anyControlsTouched() {\n    return this._anyControls((control) => control.touched);\n  }\n  /** @internal */\n  _updatePristine(opts, changedControl) {\n    const newPristine = !this._anyControlsDirty();\n    const changed = this.pristine !== newPristine;\n    this.pristine = newPristine;\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updatePristine(opts, changedControl);\n    }\n    if (changed) {\n      this._events.next(new PristineChangeEvent(this.pristine, changedControl));\n    }\n  }\n  /** @internal */\n  _updateTouched(opts = {}, changedControl) {\n    this.touched = this._anyControlsTouched();\n    this._events.next(new TouchedChangeEvent(this.touched, changedControl));\n    if (this._parent && !opts.onlySelf) {\n      this._parent._updateTouched(opts, changedControl);\n    }\n  }\n  /** @internal */\n  _onDisabledChange = [];\n  /** @internal */\n  _registerOnCollectionChange(fn) {\n    this._onCollectionChange = fn;\n  }\n  /** @internal */\n  _setUpdateStrategy(opts) {\n    if (isOptionsObj(opts) && opts.updateOn != null) {\n      this._updateOn = opts.updateOn;\n    }\n  }\n  /**\n   * Check to see if parent has been marked artificially dirty.\n   *\n   * @internal\n   */\n  _parentMarkedDirty(onlySelf) {\n    const parentDirty = this._parent && this._parent.dirty;\n    return !onlySelf && !!parentDirty && !this._parent._anyControlsDirty();\n  }\n  /** @internal */\n  _find(name) {\n    return null;\n  }\n  /**\n   * Internal implementation of the `setValidators` method. Needs to be separated out into a\n   * different method, because it is called in the constructor and it can break cases where\n   * a control is extended.\n   */\n  _assignValidators(validators) {\n    this._rawValidators = Array.isArray(validators) ? validators.slice() : validators;\n    this._composedValidatorFn = coerceToValidator(this._rawValidators);\n  }\n  /**\n   * Internal implementation of the `setAsyncValidators` method. Needs to be separated out into a\n   * different method, because it is called in the constructor and it can break cases where\n   * a control is extended.\n   */\n  _assignAsyncValidators(validators) {\n    this._rawAsyncValidators = Array.isArray(validators) ? validators.slice() : validators;\n    this._composedAsyncValidatorFn = coerceToAsyncValidator(this._rawAsyncValidators);\n  }\n};\nvar FormGroup = class extends AbstractControl {\n  /**\n   * Creates a new `FormGroup` instance.\n   *\n   * @param controls A collection of child controls. The key for each child is the name\n   * under which it is registered.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of\n   * such functions, or an `AbstractControlOptions` object that contains validation functions\n   * and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator functions\n   *\n   */\n  constructor(controls, validatorOrOpts, asyncValidator) {\n    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));\n    (typeof ngDevMode === \"undefined\" || ngDevMode) && validateFormGroupControls(controls);\n    this.controls = controls;\n    this._initObservables();\n    this._setUpdateStrategy(validatorOrOpts);\n    this._setUpControls();\n    this.updateValueAndValidity({\n      onlySelf: true,\n      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to\n      // `VALID` or `INVALID`. The status should be broadcasted via the `statusChanges` observable,\n      // so we set `emitEvent` to `true` to allow that during the control creation process.\n      emitEvent: !!this.asyncValidator\n    });\n  }\n  controls;\n  registerControl(name, control) {\n    if (this.controls[name]) return this.controls[name];\n    this.controls[name] = control;\n    control.setParent(this);\n    control._registerOnCollectionChange(this._onCollectionChange);\n    return control;\n  }\n  addControl(name, control, options = {}) {\n    this.registerControl(name, control);\n    this.updateValueAndValidity({\n      emitEvent: options.emitEvent\n    });\n    this._onCollectionChange();\n  }\n  /**\n   * Remove a control from this group. In a strongly-typed group, required controls cannot be\n   * removed.\n   *\n   * This method also updates the value and validity of the control.\n   *\n   * @param name The control name to remove from the collection\n   * @param options Specifies whether this FormGroup instance should emit events after a\n   *     control is removed.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control is\n   * removed. When false, no events are emitted.\n   */\n  removeControl(name, options = {}) {\n    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {\n    });\n    delete this.controls[name];\n    this.updateValueAndValidity({\n      emitEvent: options.emitEvent\n    });\n    this._onCollectionChange();\n  }\n  setControl(name, control, options = {}) {\n    if (this.controls[name]) this.controls[name]._registerOnCollectionChange(() => {\n    });\n    delete this.controls[name];\n    if (control) this.registerControl(name, control);\n    this.updateValueAndValidity({\n      emitEvent: options.emitEvent\n    });\n    this._onCollectionChange();\n  }\n  contains(controlName) {\n    return this.controls.hasOwnProperty(controlName) && this.controls[controlName].enabled;\n  }\n  /**\n   * Sets the value of the `FormGroup`. It accepts an object that matches\n   * the structure of the group, with control names as keys.\n   *\n   * @usageNotes\n   * ### Set the complete value for the form group\n   *\n   * ```ts\n   * const form = new FormGroup({\n   *   first: new FormControl(),\n   *   last: new FormControl()\n   * });\n   *\n   * console.log(form.value);   // {first: null, last: null}\n   *\n   * form.setValue({first: 'Nancy', last: 'Drew'});\n   * console.log(form.value);   // {first: 'Nancy', last: 'Drew'}\n   * ```\n   *\n   * @throws When strict checks fail, such as setting the value of a control\n   * that doesn't exist or if you exclude a value of a control that does exist.\n   *\n   * @param value The new value for the control that matches the structure of the group.\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events after the value changes.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   */\n  setValue(value, options = {}) {\n    assertAllValuesPresent(this, true, value);\n    Object.keys(value).forEach((name) => {\n      assertControlPresent(this, true, name);\n      this.controls[name].setValue(value[name], {\n        onlySelf: true,\n        emitEvent: options.emitEvent\n      });\n    });\n    this.updateValueAndValidity(options);\n  }\n  /**\n   * Patches the value of the `FormGroup`. It accepts an object with control\n   * names as keys, and does its best to match the values to the correct controls\n   * in the group.\n   *\n   * It accepts both super-sets and sub-sets of the group without throwing an error.\n   *\n   * @usageNotes\n   * ### Patch the value for a form group\n   *\n   * ```ts\n   * const form = new FormGroup({\n   *    first: new FormControl(),\n   *    last: new FormControl()\n   * });\n   * console.log(form.value);   // {first: null, last: null}\n   *\n   * form.patchValue({first: 'Nancy'});\n   * console.log(form.value);   // {first: 'Nancy', last: null}\n   * ```\n   *\n   * @param value The object that matches the structure of the group.\n   * @param options Configuration options that determine how the control propagates changes and\n   * emits events after the value is patched.\n   * * `onlySelf`: When true, each change only affects this control and not its parent. Default is\n   * true.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control value\n   * is updated. When false, no events are emitted. The configuration options are passed to\n   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.\n   */\n  patchValue(value, options = {}) {\n    if (value == null) return;\n    Object.keys(value).forEach((name) => {\n      const control = this.controls[name];\n      if (control) {\n        control.patchValue(\n          /* Guaranteed to be present, due to the outer forEach. */\n          value[name],\n          {\n            onlySelf: true,\n            emitEvent: options.emitEvent\n          }\n        );\n      }\n    });\n    this.updateValueAndValidity(options);\n  }\n  /**\n   * Resets the `FormGroup`, marks all descendants `pristine` and `untouched` and sets\n   * the value of all descendants to their default values, or null if no defaults were provided.\n   *\n   * You reset to a specific form state by passing in a map of states\n   * that matches the structure of your form, with control names as keys. The state\n   * is a standalone value or a form state object with both a value and a disabled\n   * status.\n   *\n   * @param value Resets the control with an initial value,\n   * or an object that defines the initial value and disabled state.\n   *\n   * @param options Configuration options that determine how the control propagates changes\n   * and emits events when the group is reset.\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default is\n   * false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is reset.\n   * When false, no events are emitted.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   *\n   * @usageNotes\n   *\n   * ### Reset the form group values\n   *\n   * ```ts\n   * const form = new FormGroup({\n   *   first: new FormControl('first name'),\n   *   last: new FormControl('last name')\n   * });\n   *\n   * console.log(form.value);  // {first: 'first name', last: 'last name'}\n   *\n   * form.reset({ first: 'name', last: 'last name' });\n   *\n   * console.log(form.value);  // {first: 'name', last: 'last name'}\n   * ```\n   *\n   * ### Reset the form group values and disabled status\n   *\n   * ```ts\n   * const form = new FormGroup({\n   *   first: new FormControl('first name'),\n   *   last: new FormControl('last name')\n   * });\n   *\n   * form.reset({\n   *   first: {value: 'name', disabled: true},\n   *   last: 'last'\n   * });\n   *\n   * console.log(form.value);  // {last: 'last'}\n   * console.log(form.get('first').status);  // 'DISABLED'\n   * ```\n   */\n  reset(value = {}, options = {}) {\n    this._forEachChild((control, name) => {\n      control.reset(value ? value[name] : null, {\n        onlySelf: true,\n        emitEvent: options.emitEvent\n      });\n    });\n    this._updatePristine(options, this);\n    this._updateTouched(options, this);\n    this.updateValueAndValidity(options);\n  }\n  /**\n   * The aggregate value of the `FormGroup`, including any disabled controls.\n   *\n   * Retrieves all values regardless of disabled status.\n   */\n  getRawValue() {\n    return this._reduceChildren({}, (acc, control, name) => {\n      acc[name] = control.getRawValue();\n      return acc;\n    });\n  }\n  /** @internal */\n  _syncPendingControls() {\n    let subtreeUpdated = this._reduceChildren(false, (updated, child) => {\n      return child._syncPendingControls() ? true : updated;\n    });\n    if (subtreeUpdated) this.updateValueAndValidity({\n      onlySelf: true\n    });\n    return subtreeUpdated;\n  }\n  /** @internal */\n  _forEachChild(cb) {\n    Object.keys(this.controls).forEach((key) => {\n      const control = this.controls[key];\n      control && cb(control, key);\n    });\n  }\n  /** @internal */\n  _setUpControls() {\n    this._forEachChild((control) => {\n      control.setParent(this);\n      control._registerOnCollectionChange(this._onCollectionChange);\n    });\n  }\n  /** @internal */\n  _updateValue() {\n    this.value = this._reduceValue();\n  }\n  /** @internal */\n  _anyControls(condition) {\n    for (const [controlName, control] of Object.entries(this.controls)) {\n      if (this.contains(controlName) && condition(control)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /** @internal */\n  _reduceValue() {\n    let acc = {};\n    return this._reduceChildren(acc, (acc2, control, name) => {\n      if (control.enabled || this.disabled) {\n        acc2[name] = control.value;\n      }\n      return acc2;\n    });\n  }\n  /** @internal */\n  _reduceChildren(initValue, fn) {\n    let res = initValue;\n    this._forEachChild((control, name) => {\n      res = fn(res, control, name);\n    });\n    return res;\n  }\n  /** @internal */\n  _allControlsDisabled() {\n    for (const controlName of Object.keys(this.controls)) {\n      if (this.controls[controlName].enabled) {\n        return false;\n      }\n    }\n    return Object.keys(this.controls).length > 0 || this.disabled;\n  }\n  /** @internal */\n  _find(name) {\n    return this.controls.hasOwnProperty(name) ? this.controls[name] : null;\n  }\n};\nfunction validateFormGroupControls(controls) {\n  const invalidKeys = Object.keys(controls).filter((key) => key.includes(\".\"));\n  if (invalidKeys.length > 0) {\n    console.warn(`FormGroup keys cannot include \\`.\\`, please replace the keys for: ${invalidKeys.join(\",\")}.`);\n  }\n}\nvar FormRecord = class extends FormGroup {\n};\nvar CALL_SET_DISABLED_STATE = new InjectionToken(typeof ngDevMode === \"undefined\" || ngDevMode ? \"CallSetDisabledState\" : \"\", {\n  providedIn: \"root\",\n  factory: () => setDisabledStateDefault\n});\nvar setDisabledStateDefault = \"always\";\nfunction controlPath(name, parent) {\n  return [...parent.path, name];\n}\nfunction setUpControl(control, dir, callSetDisabledState = setDisabledStateDefault) {\n  if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n    if (!control) _throwError(dir, \"Cannot find control with\");\n    if (!dir.valueAccessor) _throwMissingValueAccessorError(dir);\n  }\n  setUpValidators(control, dir);\n  dir.valueAccessor.writeValue(control.value);\n  if (control.disabled || callSetDisabledState === \"always\") {\n    dir.valueAccessor.setDisabledState?.(control.disabled);\n  }\n  setUpViewChangePipeline(control, dir);\n  setUpModelChangePipeline(control, dir);\n  setUpBlurPipeline(control, dir);\n  setUpDisabledChangeHandler(control, dir);\n}\nfunction cleanUpControl(control, dir, validateControlPresenceOnChange = true) {\n  const noop4 = () => {\n    if (validateControlPresenceOnChange && (typeof ngDevMode === \"undefined\" || ngDevMode)) {\n      _noControlError(dir);\n    }\n  };\n  if (dir.valueAccessor) {\n    dir.valueAccessor.registerOnChange(noop4);\n    dir.valueAccessor.registerOnTouched(noop4);\n  }\n  cleanUpValidators(control, dir);\n  if (control) {\n    dir._invokeOnDestroyCallbacks();\n    control._registerOnCollectionChange(() => {\n    });\n  }\n}\nfunction registerOnValidatorChange(validators, onChange) {\n  validators.forEach((validator) => {\n    if (validator.registerOnValidatorChange) validator.registerOnValidatorChange(onChange);\n  });\n}\nfunction setUpDisabledChangeHandler(control, dir) {\n  if (dir.valueAccessor.setDisabledState) {\n    const onDisabledChange = (isDisabled) => {\n      dir.valueAccessor.setDisabledState(isDisabled);\n    };\n    control.registerOnDisabledChange(onDisabledChange);\n    dir._registerOnDestroy(() => {\n      control._unregisterOnDisabledChange(onDisabledChange);\n    });\n  }\n}\nfunction setUpValidators(control, dir) {\n  const validators = getControlValidators(control);\n  if (dir.validator !== null) {\n    control.setValidators(mergeValidators(validators, dir.validator));\n  } else if (typeof validators === \"function\") {\n    control.setValidators([validators]);\n  }\n  const asyncValidators = getControlAsyncValidators(control);\n  if (dir.asyncValidator !== null) {\n    control.setAsyncValidators(mergeValidators(asyncValidators, dir.asyncValidator));\n  } else if (typeof asyncValidators === \"function\") {\n    control.setAsyncValidators([asyncValidators]);\n  }\n  const onValidatorChange = () => control.updateValueAndValidity();\n  registerOnValidatorChange(dir._rawValidators, onValidatorChange);\n  registerOnValidatorChange(dir._rawAsyncValidators, onValidatorChange);\n}\nfunction cleanUpValidators(control, dir) {\n  let isControlUpdated = false;\n  if (control !== null) {\n    if (dir.validator !== null) {\n      const validators = getControlValidators(control);\n      if (Array.isArray(validators) && validators.length > 0) {\n        const updatedValidators = validators.filter((validator) => validator !== dir.validator);\n        if (updatedValidators.length !== validators.length) {\n          isControlUpdated = true;\n          control.setValidators(updatedValidators);\n        }\n      }\n    }\n    if (dir.asyncValidator !== null) {\n      const asyncValidators = getControlAsyncValidators(control);\n      if (Array.isArray(asyncValidators) && asyncValidators.length > 0) {\n        const updatedAsyncValidators = asyncValidators.filter((asyncValidator) => asyncValidator !== dir.asyncValidator);\n        if (updatedAsyncValidators.length !== asyncValidators.length) {\n          isControlUpdated = true;\n          control.setAsyncValidators(updatedAsyncValidators);\n        }\n      }\n    }\n  }\n  const noop4 = () => {\n  };\n  registerOnValidatorChange(dir._rawValidators, noop4);\n  registerOnValidatorChange(dir._rawAsyncValidators, noop4);\n  return isControlUpdated;\n}\nfunction setUpViewChangePipeline(control, dir) {\n  dir.valueAccessor.registerOnChange((newValue) => {\n    control._pendingValue = newValue;\n    control._pendingChange = true;\n    control._pendingDirty = true;\n    if (control.updateOn === \"change\") updateControl(control, dir);\n  });\n}\nfunction setUpBlurPipeline(control, dir) {\n  dir.valueAccessor.registerOnTouched(() => {\n    control._pendingTouched = true;\n    if (control.updateOn === \"blur\" && control._pendingChange) updateControl(control, dir);\n    if (control.updateOn !== \"submit\") control.markAsTouched();\n  });\n}\nfunction updateControl(control, dir) {\n  if (control._pendingDirty) control.markAsDirty();\n  control.setValue(control._pendingValue, {\n    emitModelToViewChange: false\n  });\n  dir.viewToModelUpdate(control._pendingValue);\n  control._pendingChange = false;\n}\nfunction setUpModelChangePipeline(control, dir) {\n  const onChange = (newValue, emitModelEvent) => {\n    dir.valueAccessor.writeValue(newValue);\n    if (emitModelEvent) dir.viewToModelUpdate(newValue);\n  };\n  control.registerOnChange(onChange);\n  dir._registerOnDestroy(() => {\n    control._unregisterOnChange(onChange);\n  });\n}\nfunction setUpFormContainer(control, dir) {\n  if (control == null && (typeof ngDevMode === \"undefined\" || ngDevMode)) _throwError(dir, \"Cannot find control with\");\n  setUpValidators(control, dir);\n}\nfunction cleanUpFormContainer(control, dir) {\n  return cleanUpValidators(control, dir);\n}\nfunction _noControlError(dir) {\n  return _throwError(dir, \"There is no FormControl instance attached to form control element with\");\n}\nfunction _throwError(dir, message) {\n  const messageEnd = _describeControlLocation(dir);\n  throw new Error(`${message} ${messageEnd}`);\n}\nfunction _describeControlLocation(dir) {\n  const path = dir.path;\n  if (path && path.length > 1) return `path: '${path.join(\" -> \")}'`;\n  if (path?.[0]) return `name: '${path}'`;\n  return \"unspecified name attribute\";\n}\nfunction _throwMissingValueAccessorError(dir) {\n  const loc = _describeControlLocation(dir);\n  throw new RuntimeError(-1203, `No value accessor for form control ${loc}.`);\n}\nfunction _throwInvalidValueAccessorError(dir) {\n  const loc = _describeControlLocation(dir);\n  throw new RuntimeError(1200, `Value accessor was not provided as an array for form control with ${loc}. Check that the \\`NG_VALUE_ACCESSOR\\` token is configured as a \\`multi: true\\` provider.`);\n}\nfunction isPropertyUpdated(changes, viewModel) {\n  if (!changes.hasOwnProperty(\"model\")) return false;\n  const change = changes[\"model\"];\n  if (change.isFirstChange()) return true;\n  return !Object.is(viewModel, change.currentValue);\n}\nfunction isBuiltInAccessor(valueAccessor) {\n  return Object.getPrototypeOf(valueAccessor.constructor) === BuiltInControlValueAccessor;\n}\nfunction syncPendingControls(form, directives) {\n  form._syncPendingControls();\n  directives.forEach((dir) => {\n    const control = dir.control;\n    if (control.updateOn === \"submit\" && control._pendingChange) {\n      dir.viewToModelUpdate(control._pendingValue);\n      control._pendingChange = false;\n    }\n  });\n}\nfunction selectValueAccessor(dir, valueAccessors) {\n  if (!valueAccessors) return null;\n  if (!Array.isArray(valueAccessors) && (typeof ngDevMode === \"undefined\" || ngDevMode)) _throwInvalidValueAccessorError(dir);\n  let defaultAccessor = void 0;\n  let builtinAccessor = void 0;\n  let customAccessor = void 0;\n  valueAccessors.forEach((v) => {\n    if (v.constructor === DefaultValueAccessor) {\n      defaultAccessor = v;\n    } else if (isBuiltInAccessor(v)) {\n      if (builtinAccessor && (typeof ngDevMode === \"undefined\" || ngDevMode)) _throwError(dir, \"More than one built-in value accessor matches form control with\");\n      builtinAccessor = v;\n    } else {\n      if (customAccessor && (typeof ngDevMode === \"undefined\" || ngDevMode)) _throwError(dir, \"More than one custom value accessor matches form control with\");\n      customAccessor = v;\n    }\n  });\n  if (customAccessor) return customAccessor;\n  if (builtinAccessor) return builtinAccessor;\n  if (defaultAccessor) return defaultAccessor;\n  if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n    _throwError(dir, \"No valid value accessor for form control with\");\n  }\n  return null;\n}\nfunction removeListItem$1(list, el) {\n  const index = list.indexOf(el);\n  if (index > -1) list.splice(index, 1);\n}\nfunction _ngModelWarning(name, type, instance, warningConfig) {\n  if (warningConfig === \"never\") return;\n  if ((warningConfig === null || warningConfig === \"once\") && !type._ngModelWarningSentOnce || warningConfig === \"always\" && !instance._ngModelWarningSent) {\n    console.warn(ngModelWarning(name));\n    type._ngModelWarningSentOnce = true;\n    instance._ngModelWarningSent = true;\n  }\n}\nvar formDirectiveProvider$1 = {\n  provide: ControlContainer,\n  useExisting: forwardRef(() => NgForm)\n};\nvar resolvedPromise$1 = (() => Promise.resolve())();\nvar NgForm = class _NgForm extends ControlContainer {\n  callSetDisabledState;\n  /**\n   * @description\n   * Returns whether the form submission has been triggered.\n   */\n  get submitted() {\n    return untracked2(this.submittedReactive);\n  }\n  /** @internal */\n  _submitted = computed(() => this.submittedReactive());\n  submittedReactive = signal(false);\n  _directives = /* @__PURE__ */ new Set();\n  /**\n   * @description\n   * The `FormGroup` instance created for this form.\n   */\n  form;\n  /**\n   * @description\n   * Event emitter for the \"ngSubmit\" event\n   */\n  ngSubmit = new EventEmitter();\n  /**\n   * @description\n   * Tracks options for the `NgForm` instance.\n   *\n   * **updateOn**: Sets the default `updateOn` value for all child `NgModels` below it\n   * unless explicitly set by a child `NgModel` using `ngModelOptions`). Defaults to 'change'.\n   * Possible values: `'change'` | `'blur'` | `'submit'`.\n   *\n   */\n  // TODO(issue/24571): remove '!'.\n  options;\n  constructor(validators, asyncValidators, callSetDisabledState) {\n    super();\n    this.callSetDisabledState = callSetDisabledState;\n    this.form = new FormGroup({}, composeValidators(validators), composeAsyncValidators(asyncValidators));\n  }\n  /** @nodoc */\n  ngAfterViewInit() {\n    this._setUpdateStrategy();\n  }\n  /**\n   * @description\n   * The directive instance.\n   */\n  get formDirective() {\n    return this;\n  }\n  /**\n   * @description\n   * The internal `FormGroup` instance.\n   */\n  get control() {\n    return this.form;\n  }\n  /**\n   * @description\n   * Returns an array representing the path to this group. Because this directive\n   * always lives at the top level of a form, it is always an empty array.\n   */\n  get path() {\n    return [];\n  }\n  /**\n   * @description\n   * Returns a map of the controls in this group.\n   */\n  get controls() {\n    return this.form.controls;\n  }\n  /**\n   * @description\n   * Method that sets up the control directive in this group, re-calculates its value\n   * and validity, and adds the instance to the internal list of directives.\n   *\n   * @param dir The `NgModel` directive instance.\n   */\n  addControl(dir) {\n    resolvedPromise$1.then(() => {\n      const container = this._findContainer(dir.path);\n      dir.control = container.registerControl(dir.name, dir.control);\n      setUpControl(dir.control, dir, this.callSetDisabledState);\n      dir.control.updateValueAndValidity({\n        emitEvent: false\n      });\n      this._directives.add(dir);\n    });\n  }\n  /**\n   * @description\n   * Retrieves the `FormControl` instance from the provided `NgModel` directive.\n   *\n   * @param dir The `NgModel` directive instance.\n   */\n  getControl(dir) {\n    return this.form.get(dir.path);\n  }\n  /**\n   * @description\n   * Removes the `NgModel` instance from the internal list of directives\n   *\n   * @param dir The `NgModel` directive instance.\n   */\n  removeControl(dir) {\n    resolvedPromise$1.then(() => {\n      const container = this._findContainer(dir.path);\n      if (container) {\n        container.removeControl(dir.name);\n      }\n      this._directives.delete(dir);\n    });\n  }\n  /**\n   * @description\n   * Adds a new `NgModelGroup` directive instance to the form.\n   *\n   * @param dir The `NgModelGroup` directive instance.\n   */\n  addFormGroup(dir) {\n    resolvedPromise$1.then(() => {\n      const container = this._findContainer(dir.path);\n      const group = new FormGroup({});\n      setUpFormContainer(group, dir);\n      container.registerControl(dir.name, group);\n      group.updateValueAndValidity({\n        emitEvent: false\n      });\n    });\n  }\n  /**\n   * @description\n   * Removes the `NgModelGroup` directive instance from the form.\n   *\n   * @param dir The `NgModelGroup` directive instance.\n   */\n  removeFormGroup(dir) {\n    resolvedPromise$1.then(() => {\n      const container = this._findContainer(dir.path);\n      if (container) {\n        container.removeControl(dir.name);\n      }\n    });\n  }\n  /**\n   * @description\n   * Retrieves the `FormGroup` for a provided `NgModelGroup` directive instance\n   *\n   * @param dir The `NgModelGroup` directive instance.\n   */\n  getFormGroup(dir) {\n    return this.form.get(dir.path);\n  }\n  /**\n   * Sets the new value for the provided `NgControl` directive.\n   *\n   * @param dir The `NgControl` directive instance.\n   * @param value The new value for the directive's control.\n   */\n  updateModel(dir, value) {\n    resolvedPromise$1.then(() => {\n      const ctrl = this.form.get(dir.path);\n      ctrl.setValue(value);\n    });\n  }\n  /**\n   * @description\n   * Sets the value for this `FormGroup`.\n   *\n   * @param value The new value\n   */\n  setValue(value) {\n    this.control.setValue(value);\n  }\n  /**\n   * @description\n   * Method called when the \"submit\" event is triggered on the form.\n   * Triggers the `ngSubmit` emitter to emit the \"submit\" event as its payload.\n   *\n   * @param $event The \"submit\" event object\n   */\n  onSubmit($event) {\n    this.submittedReactive.set(true);\n    syncPendingControls(this.form, this._directives);\n    this.ngSubmit.emit($event);\n    return $event?.target?.method === \"dialog\";\n  }\n  /**\n   * @description\n   * Method called when the \"reset\" event is triggered on the form.\n   */\n  onReset() {\n    this.resetForm();\n  }\n  /**\n   * @description\n   * Resets the form to an initial value and resets its submitted status.\n   *\n   * @param value The new value for the form.\n   */\n  resetForm(value = void 0) {\n    this.form.reset(value);\n    this.submittedReactive.set(false);\n  }\n  _setUpdateStrategy() {\n    if (this.options && this.options.updateOn != null) {\n      this.form._updateOn = this.options.updateOn;\n    }\n  }\n  _findContainer(path) {\n    path.pop();\n    return path.length ? this.form.get(path) : this.form;\n  }\n  static \\u0275fac = function NgForm_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _NgForm)(\\u0275\\u0275directiveInject(NG_VALIDATORS, 10), \\u0275\\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \\u0275\\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _NgForm,\n    selectors: [[\"form\", 3, \"ngNoForm\", \"\", 3, \"formGroup\", \"\"], [\"ng-form\"], [\"\", \"ngForm\", \"\"]],\n    hostBindings: function NgForm_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        \\u0275\\u0275listener(\"submit\", function NgForm_submit_HostBindingHandler($event) {\n          return ctx.onSubmit($event);\n        })(\"reset\", function NgForm_reset_HostBindingHandler() {\n          return ctx.onReset();\n        });\n      }\n    },\n    inputs: {\n      options: [0, \"ngFormOptions\", \"options\"]\n    },\n    outputs: {\n      ngSubmit: \"ngSubmit\"\n    },\n    exportAs: [\"ngForm\"],\n    standalone: false,\n    features: [\\u0275\\u0275ProvidersFeature([formDirectiveProvider$1]), \\u0275\\u0275InheritDefinitionFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(NgForm, [{\n    type: Directive,\n    args: [{\n      selector: \"form:not([ngNoForm]):not([formGroup]),ng-form,[ngForm]\",\n      providers: [formDirectiveProvider$1],\n      host: {\n        \"(submit)\": \"onSubmit($event)\",\n        \"(reset)\": \"onReset()\"\n      },\n      outputs: [\"ngSubmit\"],\n      exportAs: \"ngForm\",\n      standalone: false\n    }]\n  }], () => [{\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_VALIDATORS]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_ASYNC_VALIDATORS]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [CALL_SET_DISABLED_STATE]\n    }]\n  }], {\n    options: [{\n      type: Input,\n      args: [\"ngFormOptions\"]\n    }]\n  });\n})();\nfunction removeListItem(list, el) {\n  const index = list.indexOf(el);\n  if (index > -1) list.splice(index, 1);\n}\nfunction isFormControlState(formState) {\n  return typeof formState === \"object\" && formState !== null && Object.keys(formState).length === 2 && \"value\" in formState && \"disabled\" in formState;\n}\nvar FormControl = class FormControl2 extends AbstractControl {\n  /** @publicApi */\n  defaultValue = null;\n  /** @internal */\n  _onChange = [];\n  /** @internal */\n  _pendingValue;\n  /** @internal */\n  _pendingChange = false;\n  constructor(formState = null, validatorOrOpts, asyncValidator) {\n    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));\n    this._applyFormState(formState);\n    this._setUpdateStrategy(validatorOrOpts);\n    this._initObservables();\n    this.updateValueAndValidity({\n      onlySelf: true,\n      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to\n      // `VALID` or `INVALID`.\n      // The status should be broadcasted via the `statusChanges` observable, so we set\n      // `emitEvent` to `true` to allow that during the control creation process.\n      emitEvent: !!this.asyncValidator\n    });\n    if (isOptionsObj(validatorOrOpts) && (validatorOrOpts.nonNullable || validatorOrOpts.initialValueIsDefault)) {\n      if (isFormControlState(formState)) {\n        this.defaultValue = formState.value;\n      } else {\n        this.defaultValue = formState;\n      }\n    }\n  }\n  setValue(value, options = {}) {\n    this.value = this._pendingValue = value;\n    if (this._onChange.length && options.emitModelToViewChange !== false) {\n      this._onChange.forEach((changeFn) => changeFn(this.value, options.emitViewToModelChange !== false));\n    }\n    this.updateValueAndValidity(options);\n  }\n  patchValue(value, options = {}) {\n    this.setValue(value, options);\n  }\n  reset(formState = this.defaultValue, options = {}) {\n    this._applyFormState(formState);\n    this.markAsPristine(options);\n    this.markAsUntouched(options);\n    this.setValue(this.value, options);\n    this._pendingChange = false;\n  }\n  /**  @internal */\n  _updateValue() {\n  }\n  /**  @internal */\n  _anyControls(condition) {\n    return false;\n  }\n  /**  @internal */\n  _allControlsDisabled() {\n    return this.disabled;\n  }\n  registerOnChange(fn) {\n    this._onChange.push(fn);\n  }\n  /** @internal */\n  _unregisterOnChange(fn) {\n    removeListItem(this._onChange, fn);\n  }\n  registerOnDisabledChange(fn) {\n    this._onDisabledChange.push(fn);\n  }\n  /** @internal */\n  _unregisterOnDisabledChange(fn) {\n    removeListItem(this._onDisabledChange, fn);\n  }\n  /** @internal */\n  _forEachChild(cb) {\n  }\n  /** @internal */\n  _syncPendingControls() {\n    if (this.updateOn === \"submit\") {\n      if (this._pendingDirty) this.markAsDirty();\n      if (this._pendingTouched) this.markAsTouched();\n      if (this._pendingChange) {\n        this.setValue(this._pendingValue, {\n          onlySelf: true,\n          emitModelToViewChange: false\n        });\n        return true;\n      }\n    }\n    return false;\n  }\n  _applyFormState(formState) {\n    if (isFormControlState(formState)) {\n      this.value = this._pendingValue = formState.value;\n      formState.disabled ? this.disable({\n        onlySelf: true,\n        emitEvent: false\n      }) : this.enable({\n        onlySelf: true,\n        emitEvent: false\n      });\n    } else {\n      this.value = this._pendingValue = formState;\n    }\n  }\n};\nvar isFormControl = (control) => control instanceof FormControl;\nvar AbstractFormGroupDirective = class _AbstractFormGroupDirective extends ControlContainer {\n  /**\n   * @description\n   * The parent control for the group\n   *\n   * @internal\n   */\n  // TODO(issue/24571): remove '!'.\n  _parent;\n  /** @nodoc */\n  ngOnInit() {\n    this._checkParentType();\n    this.formDirective.addFormGroup(this);\n  }\n  /** @nodoc */\n  ngOnDestroy() {\n    if (this.formDirective) {\n      this.formDirective.removeFormGroup(this);\n    }\n  }\n  /**\n   * @description\n   * The `FormGroup` bound to this directive.\n   */\n  get control() {\n    return this.formDirective.getFormGroup(this);\n  }\n  /**\n   * @description\n   * The path to this group from the top-level directive.\n   */\n  get path() {\n    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);\n  }\n  /**\n   * @description\n   * The top-level directive for this group if present, otherwise null.\n   */\n  get formDirective() {\n    return this._parent ? this._parent.formDirective : null;\n  }\n  /** @internal */\n  _checkParentType() {\n  }\n  static \\u0275fac = /* @__PURE__ */ (() => {\n    let \\u0275AbstractFormGroupDirective_BaseFactory;\n    return function AbstractFormGroupDirective_Factory(__ngFactoryType__) {\n      return (\\u0275AbstractFormGroupDirective_BaseFactory || (\\u0275AbstractFormGroupDirective_BaseFactory = \\u0275\\u0275getInheritedFactory(_AbstractFormGroupDirective)))(__ngFactoryType__ || _AbstractFormGroupDirective);\n    };\n  })();\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _AbstractFormGroupDirective,\n    standalone: false,\n    features: [\\u0275\\u0275InheritDefinitionFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(AbstractFormGroupDirective, [{\n    type: Directive,\n    args: [{\n      standalone: false\n    }]\n  }], null, null);\n})();\nfunction modelParentException() {\n  return new RuntimeError(1350, `\n    ngModel cannot be used to register form controls with a parent formGroup directive.  Try using\n    formGroup's partner directive \"formControlName\" instead.  Example:\n\n    ${formControlNameExample}\n\n    Or, if you'd like to avoid registering this form control, indicate that it's standalone in ngModelOptions:\n\n    Example:\n\n    ${ngModelWithFormGroupExample}`);\n}\nfunction formGroupNameException() {\n  return new RuntimeError(1351, `\n    ngModel cannot be used to register form controls with a parent formGroupName or formArrayName directive.\n\n    Option 1: Use formControlName instead of ngModel (reactive strategy):\n\n    ${formGroupNameExample}\n\n    Option 2:  Update ngModel's parent be ngModelGroup (template-driven strategy):\n\n    ${ngModelGroupExample}`);\n}\nfunction missingNameException() {\n  return new RuntimeError(1352, `If ngModel is used within a form tag, either the name attribute must be set or the form\n    control must be defined as 'standalone' in ngModelOptions.\n\n    Example 1: <input [(ngModel)]=\"person.firstName\" name=\"first\">\n    Example 2: <input [(ngModel)]=\"person.firstName\" [ngModelOptions]=\"{standalone: true}\">`);\n}\nfunction modelGroupParentException() {\n  return new RuntimeError(1353, `\n    ngModelGroup cannot be used with a parent formGroup directive.\n\n    Option 1: Use formGroupName instead of ngModelGroup (reactive strategy):\n\n    ${formGroupNameExample}\n\n    Option 2:  Use a regular form tag instead of the formGroup directive (template-driven strategy):\n\n    ${ngModelGroupExample}`);\n}\nvar modelGroupProvider = {\n  provide: ControlContainer,\n  useExisting: forwardRef(() => NgModelGroup)\n};\nvar NgModelGroup = class _NgModelGroup extends AbstractFormGroupDirective {\n  /**\n   * @description\n   * Tracks the name of the `NgModelGroup` bound to the directive. The name corresponds\n   * to a key in the parent `NgForm`.\n   */\n  name = \"\";\n  constructor(parent, validators, asyncValidators) {\n    super();\n    this._parent = parent;\n    this._setValidators(validators);\n    this._setAsyncValidators(asyncValidators);\n  }\n  /** @internal */\n  _checkParentType() {\n    if (!(this._parent instanceof _NgModelGroup) && !(this._parent instanceof NgForm) && (typeof ngDevMode === \"undefined\" || ngDevMode)) {\n      throw modelGroupParentException();\n    }\n  }\n  static \\u0275fac = function NgModelGroup_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _NgModelGroup)(\\u0275\\u0275directiveInject(ControlContainer, 5), \\u0275\\u0275directiveInject(NG_VALIDATORS, 10), \\u0275\\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _NgModelGroup,\n    selectors: [[\"\", \"ngModelGroup\", \"\"]],\n    inputs: {\n      name: [0, \"ngModelGroup\", \"name\"]\n    },\n    exportAs: [\"ngModelGroup\"],\n    standalone: false,\n    features: [\\u0275\\u0275ProvidersFeature([modelGroupProvider]), \\u0275\\u0275InheritDefinitionFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(NgModelGroup, [{\n    type: Directive,\n    args: [{\n      selector: \"[ngModelGroup]\",\n      providers: [modelGroupProvider],\n      exportAs: \"ngModelGroup\",\n      standalone: false\n    }]\n  }], () => [{\n    type: ControlContainer,\n    decorators: [{\n      type: Host\n    }, {\n      type: SkipSelf\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_VALIDATORS]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_ASYNC_VALIDATORS]\n    }]\n  }], {\n    name: [{\n      type: Input,\n      args: [\"ngModelGroup\"]\n    }]\n  });\n})();\nvar formControlBinding$1 = {\n  provide: NgControl,\n  useExisting: forwardRef(() => NgModel)\n};\nvar resolvedPromise = (() => Promise.resolve())();\nvar NgModel = class _NgModel extends NgControl {\n  _changeDetectorRef;\n  callSetDisabledState;\n  control = new FormControl();\n  // At runtime we coerce arbitrary values assigned to the \"disabled\" input to a \"boolean\".\n  // This is not reflected in the type of the property because outside of templates, consumers\n  // should only deal with booleans. In templates, a string is allowed for convenience and to\n  // match the native \"disabled attribute\" semantics which can be observed on input elements.\n  // This static member tells the compiler that values of type \"string\" can also be assigned\n  // to the input in a template.\n  /** @nodoc */\n  static ngAcceptInputType_isDisabled;\n  /** @internal */\n  _registered = false;\n  /**\n   * Internal reference to the view model value.\n   * @nodoc\n   */\n  viewModel;\n  /**\n   * @description\n   * Tracks the name bound to the directive. If a parent form exists, it\n   * uses this name as a key to retrieve this control's value.\n   */\n  name = \"\";\n  /**\n   * @description\n   * Tracks whether the control is disabled.\n   */\n  // TODO(issue/24571): remove '!'.\n  isDisabled;\n  /**\n   * @description\n   * Tracks the value bound to this directive.\n   */\n  model;\n  /**\n   * @description\n   * Tracks the configuration options for this `ngModel` instance.\n   *\n   * **name**: An alternative to setting the name attribute on the form control element. See\n   * the [example](api/forms/NgModel#using-ngmodel-on-a-standalone-control) for using `NgModel`\n   * as a standalone control.\n   *\n   * **standalone**: When set to true, the `ngModel` will not register itself with its parent form,\n   * and acts as if it's not in the form. Defaults to false. If no parent form exists, this option\n   * has no effect.\n   *\n   * **updateOn**: Defines the event upon which the form control value and validity update.\n   * Defaults to 'change'. Possible values: `'change'` | `'blur'` | `'submit'`.\n   *\n   */\n  // TODO(issue/24571): remove '!'.\n  options;\n  /**\n   * @description\n   * Event emitter for producing the `ngModelChange` event after\n   * the view model updates.\n   */\n  update = new EventEmitter();\n  constructor(parent, validators, asyncValidators, valueAccessors, _changeDetectorRef, callSetDisabledState) {\n    super();\n    this._changeDetectorRef = _changeDetectorRef;\n    this.callSetDisabledState = callSetDisabledState;\n    this._parent = parent;\n    this._setValidators(validators);\n    this._setAsyncValidators(asyncValidators);\n    this.valueAccessor = selectValueAccessor(this, valueAccessors);\n  }\n  /** @nodoc */\n  ngOnChanges(changes) {\n    this._checkForErrors();\n    if (!this._registered || \"name\" in changes) {\n      if (this._registered) {\n        this._checkName();\n        if (this.formDirective) {\n          const oldName = changes[\"name\"].previousValue;\n          this.formDirective.removeControl({\n            name: oldName,\n            path: this._getPath(oldName)\n          });\n        }\n      }\n      this._setUpControl();\n    }\n    if (\"isDisabled\" in changes) {\n      this._updateDisabled(changes);\n    }\n    if (isPropertyUpdated(changes, this.viewModel)) {\n      this._updateValue(this.model);\n      this.viewModel = this.model;\n    }\n  }\n  /** @nodoc */\n  ngOnDestroy() {\n    this.formDirective && this.formDirective.removeControl(this);\n  }\n  /**\n   * @description\n   * Returns an array that represents the path from the top-level form to this control.\n   * Each index is the string name of the control on that level.\n   */\n  get path() {\n    return this._getPath(this.name);\n  }\n  /**\n   * @description\n   * The top-level directive for this control if present, otherwise null.\n   */\n  get formDirective() {\n    return this._parent ? this._parent.formDirective : null;\n  }\n  /**\n   * @description\n   * Sets the new value for the view model and emits an `ngModelChange` event.\n   *\n   * @param newValue The new value emitted by `ngModelChange`.\n   */\n  viewToModelUpdate(newValue) {\n    this.viewModel = newValue;\n    this.update.emit(newValue);\n  }\n  _setUpControl() {\n    this._setUpdateStrategy();\n    this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this);\n    this._registered = true;\n  }\n  _setUpdateStrategy() {\n    if (this.options && this.options.updateOn != null) {\n      this.control._updateOn = this.options.updateOn;\n    }\n  }\n  _isStandalone() {\n    return !this._parent || !!(this.options && this.options.standalone);\n  }\n  _setUpStandalone() {\n    setUpControl(this.control, this, this.callSetDisabledState);\n    this.control.updateValueAndValidity({\n      emitEvent: false\n    });\n  }\n  _checkForErrors() {\n    if ((typeof ngDevMode === \"undefined\" || ngDevMode) && !this._isStandalone()) {\n      checkParentType$1(this._parent);\n    }\n    this._checkName();\n  }\n  _checkName() {\n    if (this.options && this.options.name) this.name = this.options.name;\n    if (!this._isStandalone() && !this.name && (typeof ngDevMode === \"undefined\" || ngDevMode)) {\n      throw missingNameException();\n    }\n  }\n  _updateValue(value) {\n    resolvedPromise.then(() => {\n      this.control.setValue(value, {\n        emitViewToModelChange: false\n      });\n      this._changeDetectorRef?.markForCheck();\n    });\n  }\n  _updateDisabled(changes) {\n    const disabledValue = changes[\"isDisabled\"].currentValue;\n    const isDisabled = disabledValue !== 0 && booleanAttribute(disabledValue);\n    resolvedPromise.then(() => {\n      if (isDisabled && !this.control.disabled) {\n        this.control.disable();\n      } else if (!isDisabled && this.control.disabled) {\n        this.control.enable();\n      }\n      this._changeDetectorRef?.markForCheck();\n    });\n  }\n  _getPath(controlName) {\n    return this._parent ? controlPath(controlName, this._parent) : [controlName];\n  }\n  static \\u0275fac = function NgModel_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _NgModel)(\\u0275\\u0275directiveInject(ControlContainer, 9), \\u0275\\u0275directiveInject(NG_VALIDATORS, 10), \\u0275\\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \\u0275\\u0275directiveInject(NG_VALUE_ACCESSOR, 10), \\u0275\\u0275directiveInject(ChangeDetectorRef, 8), \\u0275\\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _NgModel,\n    selectors: [[\"\", \"ngModel\", \"\", 3, \"formControlName\", \"\", 3, \"formControl\", \"\"]],\n    inputs: {\n      name: \"name\",\n      isDisabled: [0, \"disabled\", \"isDisabled\"],\n      model: [0, \"ngModel\", \"model\"],\n      options: [0, \"ngModelOptions\", \"options\"]\n    },\n    outputs: {\n      update: \"ngModelChange\"\n    },\n    exportAs: [\"ngModel\"],\n    standalone: false,\n    features: [\\u0275\\u0275ProvidersFeature([formControlBinding$1]), \\u0275\\u0275InheritDefinitionFeature, \\u0275\\u0275NgOnChangesFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(NgModel, [{\n    type: Directive,\n    args: [{\n      selector: \"[ngModel]:not([formControlName]):not([formControl])\",\n      providers: [formControlBinding$1],\n      exportAs: \"ngModel\",\n      standalone: false\n    }]\n  }], () => [{\n    type: ControlContainer,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Host\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_VALIDATORS]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_ASYNC_VALIDATORS]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_VALUE_ACCESSOR]\n    }]\n  }, {\n    type: ChangeDetectorRef,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [ChangeDetectorRef]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [CALL_SET_DISABLED_STATE]\n    }]\n  }], {\n    name: [{\n      type: Input\n    }],\n    isDisabled: [{\n      type: Input,\n      args: [\"disabled\"]\n    }],\n    model: [{\n      type: Input,\n      args: [\"ngModel\"]\n    }],\n    options: [{\n      type: Input,\n      args: [\"ngModelOptions\"]\n    }],\n    update: [{\n      type: Output,\n      args: [\"ngModelChange\"]\n    }]\n  });\n})();\nfunction checkParentType$1(parent) {\n  if (!(parent instanceof NgModelGroup) && parent instanceof AbstractFormGroupDirective) {\n    throw formGroupNameException();\n  } else if (!(parent instanceof NgModelGroup) && !(parent instanceof NgForm)) {\n    throw modelParentException();\n  }\n}\nvar \\u0275NgNoValidate = class _\\u0275NgNoValidate {\n  static \\u0275fac = function \\u0275NgNoValidate_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _\\u0275NgNoValidate)();\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _\\u0275NgNoValidate,\n    selectors: [[\"form\", 3, \"ngNoForm\", \"\", 3, \"ngNativeValidate\", \"\"]],\n    hostAttrs: [\"novalidate\", \"\"],\n    standalone: false\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(\\u0275NgNoValidate, [{\n    type: Directive,\n    args: [{\n      selector: \"form:not([ngNoForm]):not([ngNativeValidate])\",\n      host: {\n        \"novalidate\": \"\"\n      },\n      standalone: false\n    }]\n  }], null, null);\n})();\nvar NUMBER_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => NumberValueAccessor),\n  multi: true\n};\nvar NumberValueAccessor = class _NumberValueAccessor extends BuiltInControlValueAccessor {\n  /**\n   * Sets the \"value\" property on the input element.\n   * @nodoc\n   */\n  writeValue(value) {\n    const normalizedValue = value == null ? \"\" : value;\n    this.setProperty(\"value\", normalizedValue);\n  }\n  /**\n   * Registers a function called when the control value changes.\n   * @nodoc\n   */\n  registerOnChange(fn) {\n    this.onChange = (value) => {\n      fn(value == \"\" ? null : parseFloat(value));\n    };\n  }\n  static \\u0275fac = /* @__PURE__ */ (() => {\n    let \\u0275NumberValueAccessor_BaseFactory;\n    return function NumberValueAccessor_Factory(__ngFactoryType__) {\n      return (\\u0275NumberValueAccessor_BaseFactory || (\\u0275NumberValueAccessor_BaseFactory = \\u0275\\u0275getInheritedFactory(_NumberValueAccessor)))(__ngFactoryType__ || _NumberValueAccessor);\n    };\n  })();\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _NumberValueAccessor,\n    selectors: [[\"input\", \"type\", \"number\", \"formControlName\", \"\"], [\"input\", \"type\", \"number\", \"formControl\", \"\"], [\"input\", \"type\", \"number\", \"ngModel\", \"\"]],\n    hostBindings: function NumberValueAccessor_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        \\u0275\\u0275listener(\"input\", function NumberValueAccessor_input_HostBindingHandler($event) {\n          return ctx.onChange($event.target.value);\n        })(\"blur\", function NumberValueAccessor_blur_HostBindingHandler() {\n          return ctx.onTouched();\n        });\n      }\n    },\n    standalone: false,\n    features: [\\u0275\\u0275ProvidersFeature([NUMBER_VALUE_ACCESSOR]), \\u0275\\u0275InheritDefinitionFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(NumberValueAccessor, [{\n    type: Directive,\n    args: [{\n      selector: \"input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]\",\n      host: {\n        \"(input)\": \"onChange($event.target.value)\",\n        \"(blur)\": \"onTouched()\"\n      },\n      providers: [NUMBER_VALUE_ACCESSOR],\n      standalone: false\n    }]\n  }], null, null);\n})();\nvar RADIO_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => RadioControlValueAccessor),\n  multi: true\n};\nfunction throwNameError() {\n  throw new RuntimeError(1202, `\n      If you define both a name and a formControlName attribute on your radio button, their values\n      must match. Ex: <input type=\"radio\" formControlName=\"food\" name=\"food\">\n    `);\n}\nvar RadioControlRegistry = class _RadioControlRegistry {\n  _accessors = [];\n  /**\n   * @description\n   * Adds a control to the internal registry. For internal use only.\n   */\n  add(control, accessor) {\n    this._accessors.push([control, accessor]);\n  }\n  /**\n   * @description\n   * Removes a control from the internal registry. For internal use only.\n   */\n  remove(accessor) {\n    for (let i = this._accessors.length - 1; i >= 0; --i) {\n      if (this._accessors[i][1] === accessor) {\n        this._accessors.splice(i, 1);\n        return;\n      }\n    }\n  }\n  /**\n   * @description\n   * Selects a radio button. For internal use only.\n   */\n  select(accessor) {\n    this._accessors.forEach((c) => {\n      if (this._isSameGroup(c, accessor) && c[1] !== accessor) {\n        c[1].fireUncheck(accessor.value);\n      }\n    });\n  }\n  _isSameGroup(controlPair, accessor) {\n    if (!controlPair[0].control) return false;\n    return controlPair[0]._parent === accessor._control._parent && controlPair[1].name === accessor.name;\n  }\n  static \\u0275fac = function RadioControlRegistry_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _RadioControlRegistry)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _RadioControlRegistry,\n    factory: _RadioControlRegistry.\\u0275fac,\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(RadioControlRegistry, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], null, null);\n})();\nvar RadioControlValueAccessor = class _RadioControlValueAccessor extends BuiltInControlValueAccessor {\n  _registry;\n  _injector;\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _state;\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _control;\n  /** @internal */\n  // TODO(issue/24571): remove '!'.\n  _fn;\n  setDisabledStateFired = false;\n  /**\n   * The registered callback function called when a change event occurs on the input element.\n   * Note: we declare `onChange` here (also used as host listener) as a function with no arguments\n   * to override the `onChange` function (which expects 1 argument) in the parent\n   * `BaseControlValueAccessor` class.\n   * @nodoc\n   */\n  onChange = () => {\n  };\n  /**\n   * @description\n   * Tracks the name of the radio input element.\n   */\n  // TODO(issue/24571): remove '!'.\n  name;\n  /**\n   * @description\n   * Tracks the name of the `FormControl` bound to the directive. The name corresponds\n   * to a key in the parent `FormGroup` or `FormArray`.\n   */\n  // TODO(issue/24571): remove '!'.\n  formControlName;\n  /**\n   * @description\n   * Tracks the value of the radio input element\n   */\n  value;\n  callSetDisabledState = inject(CALL_SET_DISABLED_STATE, {\n    optional: true\n  }) ?? setDisabledStateDefault;\n  constructor(renderer, elementRef, _registry, _injector) {\n    super(renderer, elementRef);\n    this._registry = _registry;\n    this._injector = _injector;\n  }\n  /** @nodoc */\n  ngOnInit() {\n    this._control = this._injector.get(NgControl);\n    this._checkName();\n    this._registry.add(this._control, this);\n  }\n  /** @nodoc */\n  ngOnDestroy() {\n    this._registry.remove(this);\n  }\n  /**\n   * Sets the \"checked\" property value on the radio input element.\n   * @nodoc\n   */\n  writeValue(value) {\n    this._state = value === this.value;\n    this.setProperty(\"checked\", this._state);\n  }\n  /**\n   * Registers a function called when the control value changes.\n   * @nodoc\n   */\n  registerOnChange(fn) {\n    this._fn = fn;\n    this.onChange = () => {\n      fn(this.value);\n      this._registry.select(this);\n    };\n  }\n  /** @nodoc */\n  setDisabledState(isDisabled) {\n    if (this.setDisabledStateFired || isDisabled || this.callSetDisabledState === \"whenDisabledForLegacyCode\") {\n      this.setProperty(\"disabled\", isDisabled);\n    }\n    this.setDisabledStateFired = true;\n  }\n  /**\n   * Sets the \"value\" on the radio input element and unchecks it.\n   *\n   * @param value\n   */\n  fireUncheck(value) {\n    this.writeValue(value);\n  }\n  _checkName() {\n    if (this.name && this.formControlName && this.name !== this.formControlName && (typeof ngDevMode === \"undefined\" || ngDevMode)) {\n      throwNameError();\n    }\n    if (!this.name && this.formControlName) this.name = this.formControlName;\n  }\n  static \\u0275fac = function RadioControlValueAccessor_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _RadioControlValueAccessor)(\\u0275\\u0275directiveInject(Renderer2), \\u0275\\u0275directiveInject(ElementRef), \\u0275\\u0275directiveInject(RadioControlRegistry), \\u0275\\u0275directiveInject(Injector));\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _RadioControlValueAccessor,\n    selectors: [[\"input\", \"type\", \"radio\", \"formControlName\", \"\"], [\"input\", \"type\", \"radio\", \"formControl\", \"\"], [\"input\", \"type\", \"radio\", \"ngModel\", \"\"]],\n    hostBindings: function RadioControlValueAccessor_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        \\u0275\\u0275listener(\"change\", function RadioControlValueAccessor_change_HostBindingHandler() {\n          return ctx.onChange();\n        })(\"blur\", function RadioControlValueAccessor_blur_HostBindingHandler() {\n          return ctx.onTouched();\n        });\n      }\n    },\n    inputs: {\n      name: \"name\",\n      formControlName: \"formControlName\",\n      value: \"value\"\n    },\n    standalone: false,\n    features: [\\u0275\\u0275ProvidersFeature([RADIO_VALUE_ACCESSOR]), \\u0275\\u0275InheritDefinitionFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(RadioControlValueAccessor, [{\n    type: Directive,\n    args: [{\n      selector: \"input[type=radio][formControlName],input[type=radio][formControl],input[type=radio][ngModel]\",\n      host: {\n        \"(change)\": \"onChange()\",\n        \"(blur)\": \"onTouched()\"\n      },\n      providers: [RADIO_VALUE_ACCESSOR],\n      standalone: false\n    }]\n  }], () => [{\n    type: Renderer2\n  }, {\n    type: ElementRef\n  }, {\n    type: RadioControlRegistry\n  }, {\n    type: Injector\n  }], {\n    name: [{\n      type: Input\n    }],\n    formControlName: [{\n      type: Input\n    }],\n    value: [{\n      type: Input\n    }]\n  });\n})();\nvar RANGE_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => RangeValueAccessor),\n  multi: true\n};\nvar RangeValueAccessor = class _RangeValueAccessor extends BuiltInControlValueAccessor {\n  /**\n   * Sets the \"value\" property on the input element.\n   * @nodoc\n   */\n  writeValue(value) {\n    this.setProperty(\"value\", parseFloat(value));\n  }\n  /**\n   * Registers a function called when the control value changes.\n   * @nodoc\n   */\n  registerOnChange(fn) {\n    this.onChange = (value) => {\n      fn(value == \"\" ? null : parseFloat(value));\n    };\n  }\n  static \\u0275fac = /* @__PURE__ */ (() => {\n    let \\u0275RangeValueAccessor_BaseFactory;\n    return function RangeValueAccessor_Factory(__ngFactoryType__) {\n      return (\\u0275RangeValueAccessor_BaseFactory || (\\u0275RangeValueAccessor_BaseFactory = \\u0275\\u0275getInheritedFactory(_RangeValueAccessor)))(__ngFactoryType__ || _RangeValueAccessor);\n    };\n  })();\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _RangeValueAccessor,\n    selectors: [[\"input\", \"type\", \"range\", \"formControlName\", \"\"], [\"input\", \"type\", \"range\", \"formControl\", \"\"], [\"input\", \"type\", \"range\", \"ngModel\", \"\"]],\n    hostBindings: function RangeValueAccessor_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        \\u0275\\u0275listener(\"change\", function RangeValueAccessor_change_HostBindingHandler($event) {\n          return ctx.onChange($event.target.value);\n        })(\"input\", function RangeValueAccessor_input_HostBindingHandler($event) {\n          return ctx.onChange($event.target.value);\n        })(\"blur\", function RangeValueAccessor_blur_HostBindingHandler() {\n          return ctx.onTouched();\n        });\n      }\n    },\n    standalone: false,\n    features: [\\u0275\\u0275ProvidersFeature([RANGE_VALUE_ACCESSOR]), \\u0275\\u0275InheritDefinitionFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(RangeValueAccessor, [{\n    type: Directive,\n    args: [{\n      selector: \"input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]\",\n      host: {\n        \"(change)\": \"onChange($event.target.value)\",\n        \"(input)\": \"onChange($event.target.value)\",\n        \"(blur)\": \"onTouched()\"\n      },\n      providers: [RANGE_VALUE_ACCESSOR],\n      standalone: false\n    }]\n  }], null, null);\n})();\nvar NG_MODEL_WITH_FORM_CONTROL_WARNING = new InjectionToken(ngDevMode ? \"NgModelWithFormControlWarning\" : \"\");\nvar formControlBinding = {\n  provide: NgControl,\n  useExisting: forwardRef(() => FormControlDirective)\n};\nvar FormControlDirective = class _FormControlDirective extends NgControl {\n  _ngModelWarningConfig;\n  callSetDisabledState;\n  /**\n   * Internal reference to the view model value.\n   * @nodoc\n   */\n  viewModel;\n  /**\n   * @description\n   * Tracks the `FormControl` instance bound to the directive.\n   */\n  // TODO(issue/24571): remove '!'.\n  form;\n  /**\n   * @description\n   * Triggers a warning in dev mode that this input should not be used with reactive forms.\n   */\n  set isDisabled(isDisabled) {\n    if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n      console.warn(disabledAttrWarning);\n    }\n  }\n  // TODO(kara): remove next 4 properties once deprecation period is over\n  /** @deprecated as of v6 */\n  model;\n  /** @deprecated as of v6 */\n  update = new EventEmitter();\n  /**\n   * @description\n   * Static property used to track whether any ngModel warnings have been sent across\n   * all instances of FormControlDirective. Used to support warning config of \"once\".\n   *\n   * @internal\n   */\n  static _ngModelWarningSentOnce = false;\n  /**\n   * @description\n   * Instance property used to track whether an ngModel warning has been sent out for this\n   * particular `FormControlDirective` instance. Used to support warning config of \"always\".\n   *\n   * @internal\n   */\n  _ngModelWarningSent = false;\n  constructor(validators, asyncValidators, valueAccessors, _ngModelWarningConfig, callSetDisabledState) {\n    super();\n    this._ngModelWarningConfig = _ngModelWarningConfig;\n    this.callSetDisabledState = callSetDisabledState;\n    this._setValidators(validators);\n    this._setAsyncValidators(asyncValidators);\n    this.valueAccessor = selectValueAccessor(this, valueAccessors);\n  }\n  /** @nodoc */\n  ngOnChanges(changes) {\n    if (this._isControlChanged(changes)) {\n      const previousForm = changes[\"form\"].previousValue;\n      if (previousForm) {\n        cleanUpControl(\n          previousForm,\n          this,\n          /* validateControlPresenceOnChange */\n          false\n        );\n      }\n      setUpControl(this.form, this, this.callSetDisabledState);\n      this.form.updateValueAndValidity({\n        emitEvent: false\n      });\n    }\n    if (isPropertyUpdated(changes, this.viewModel)) {\n      if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n        _ngModelWarning(\"formControl\", _FormControlDirective, this, this._ngModelWarningConfig);\n      }\n      this.form.setValue(this.model);\n      this.viewModel = this.model;\n    }\n  }\n  /** @nodoc */\n  ngOnDestroy() {\n    if (this.form) {\n      cleanUpControl(\n        this.form,\n        this,\n        /* validateControlPresenceOnChange */\n        false\n      );\n    }\n  }\n  /**\n   * @description\n   * Returns an array that represents the path from the top-level form to this control.\n   * Each index is the string name of the control on that level.\n   */\n  get path() {\n    return [];\n  }\n  /**\n   * @description\n   * The `FormControl` bound to this directive.\n   */\n  get control() {\n    return this.form;\n  }\n  /**\n   * @description\n   * Sets the new value for the view model and emits an `ngModelChange` event.\n   *\n   * @param newValue The new value for the view model.\n   */\n  viewToModelUpdate(newValue) {\n    this.viewModel = newValue;\n    this.update.emit(newValue);\n  }\n  _isControlChanged(changes) {\n    return changes.hasOwnProperty(\"form\");\n  }\n  static \\u0275fac = function FormControlDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _FormControlDirective)(\\u0275\\u0275directiveInject(NG_VALIDATORS, 10), \\u0275\\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \\u0275\\u0275directiveInject(NG_VALUE_ACCESSOR, 10), \\u0275\\u0275directiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8), \\u0275\\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _FormControlDirective,\n    selectors: [[\"\", \"formControl\", \"\"]],\n    inputs: {\n      form: [0, \"formControl\", \"form\"],\n      isDisabled: [0, \"disabled\", \"isDisabled\"],\n      model: [0, \"ngModel\", \"model\"]\n    },\n    outputs: {\n      update: \"ngModelChange\"\n    },\n    exportAs: [\"ngForm\"],\n    standalone: false,\n    features: [\\u0275\\u0275ProvidersFeature([formControlBinding]), \\u0275\\u0275InheritDefinitionFeature, \\u0275\\u0275NgOnChangesFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(FormControlDirective, [{\n    type: Directive,\n    args: [{\n      selector: \"[formControl]\",\n      providers: [formControlBinding],\n      exportAs: \"ngForm\",\n      standalone: false\n    }]\n  }], () => [{\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_VALIDATORS]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_ASYNC_VALIDATORS]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_VALUE_ACCESSOR]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [CALL_SET_DISABLED_STATE]\n    }]\n  }], {\n    form: [{\n      type: Input,\n      args: [\"formControl\"]\n    }],\n    isDisabled: [{\n      type: Input,\n      args: [\"disabled\"]\n    }],\n    model: [{\n      type: Input,\n      args: [\"ngModel\"]\n    }],\n    update: [{\n      type: Output,\n      args: [\"ngModelChange\"]\n    }]\n  });\n})();\nvar formDirectiveProvider = {\n  provide: ControlContainer,\n  useExisting: forwardRef(() => FormGroupDirective)\n};\nvar FormGroupDirective = class _FormGroupDirective extends ControlContainer {\n  callSetDisabledState;\n  /**\n   * @description\n   * Reports whether the form submission has been triggered.\n   */\n  get submitted() {\n    return untracked2(this._submittedReactive);\n  }\n  // TODO(atscott): Remove once invalid API usage is cleaned up internally\n  set submitted(value) {\n    this._submittedReactive.set(value);\n  }\n  /** @internal */\n  _submitted = computed(() => this._submittedReactive());\n  _submittedReactive = signal(false);\n  /**\n   * Reference to an old form group input value, which is needed to cleanup\n   * old instance in case it was replaced with a new one.\n   */\n  _oldForm;\n  /**\n   * Callback that should be invoked when controls in FormGroup or FormArray collection change\n   * (added or removed). This callback triggers corresponding DOM updates.\n   */\n  _onCollectionChange = () => this._updateDomValue();\n  /**\n   * @description\n   * Tracks the list of added `FormControlName` instances\n   */\n  directives = [];\n  /**\n   * @description\n   * Tracks the `FormGroup` bound to this directive.\n   */\n  form = null;\n  /**\n   * @description\n   * Emits an event when the form submission has been triggered.\n   */\n  ngSubmit = new EventEmitter();\n  constructor(validators, asyncValidators, callSetDisabledState) {\n    super();\n    this.callSetDisabledState = callSetDisabledState;\n    this._setValidators(validators);\n    this._setAsyncValidators(asyncValidators);\n  }\n  /** @nodoc */\n  ngOnChanges(changes) {\n    if ((typeof ngDevMode === \"undefined\" || ngDevMode) && !this.form) {\n      throw missingFormException();\n    }\n    if (changes.hasOwnProperty(\"form\")) {\n      this._updateValidators();\n      this._updateDomValue();\n      this._updateRegistrations();\n      this._oldForm = this.form;\n    }\n  }\n  /** @nodoc */\n  ngOnDestroy() {\n    if (this.form) {\n      cleanUpValidators(this.form, this);\n      if (this.form._onCollectionChange === this._onCollectionChange) {\n        this.form._registerOnCollectionChange(() => {\n        });\n      }\n    }\n  }\n  /**\n   * @description\n   * Returns this directive's instance.\n   */\n  get formDirective() {\n    return this;\n  }\n  /**\n   * @description\n   * Returns the `FormGroup` bound to this directive.\n   */\n  get control() {\n    return this.form;\n  }\n  /**\n   * @description\n   * Returns an array representing the path to this group. Because this directive\n   * always lives at the top level of a form, it always an empty array.\n   */\n  get path() {\n    return [];\n  }\n  /**\n   * @description\n   * Method that sets up the control directive in this group, re-calculates its value\n   * and validity, and adds the instance to the internal list of directives.\n   *\n   * @param dir The `FormControlName` directive instance.\n   */\n  addControl(dir) {\n    const ctrl = this.form.get(dir.path);\n    setUpControl(ctrl, dir, this.callSetDisabledState);\n    ctrl.updateValueAndValidity({\n      emitEvent: false\n    });\n    this.directives.push(dir);\n    return ctrl;\n  }\n  /**\n   * @description\n   * Retrieves the `FormControl` instance from the provided `FormControlName` directive\n   *\n   * @param dir The `FormControlName` directive instance.\n   */\n  getControl(dir) {\n    return this.form.get(dir.path);\n  }\n  /**\n   * @description\n   * Removes the `FormControlName` instance from the internal list of directives\n   *\n   * @param dir The `FormControlName` directive instance.\n   */\n  removeControl(dir) {\n    cleanUpControl(\n      dir.control || null,\n      dir,\n      /* validateControlPresenceOnChange */\n      false\n    );\n    removeListItem$1(this.directives, dir);\n  }\n  /**\n   * Adds a new `FormGroupName` directive instance to the form.\n   *\n   * @param dir The `FormGroupName` directive instance.\n   */\n  addFormGroup(dir) {\n    this._setUpFormContainer(dir);\n  }\n  /**\n   * Performs the necessary cleanup when a `FormGroupName` directive instance is removed from the\n   * view.\n   *\n   * @param dir The `FormGroupName` directive instance.\n   */\n  removeFormGroup(dir) {\n    this._cleanUpFormContainer(dir);\n  }\n  /**\n   * @description\n   * Retrieves the `FormGroup` for a provided `FormGroupName` directive instance\n   *\n   * @param dir The `FormGroupName` directive instance.\n   */\n  getFormGroup(dir) {\n    return this.form.get(dir.path);\n  }\n  /**\n   * Performs the necessary setup when a `FormArrayName` directive instance is added to the view.\n   *\n   * @param dir The `FormArrayName` directive instance.\n   */\n  addFormArray(dir) {\n    this._setUpFormContainer(dir);\n  }\n  /**\n   * Performs the necessary cleanup when a `FormArrayName` directive instance is removed from the\n   * view.\n   *\n   * @param dir The `FormArrayName` directive instance.\n   */\n  removeFormArray(dir) {\n    this._cleanUpFormContainer(dir);\n  }\n  /**\n   * @description\n   * Retrieves the `FormArray` for a provided `FormArrayName` directive instance.\n   *\n   * @param dir The `FormArrayName` directive instance.\n   */\n  getFormArray(dir) {\n    return this.form.get(dir.path);\n  }\n  /**\n   * Sets the new value for the provided `FormControlName` directive.\n   *\n   * @param dir The `FormControlName` directive instance.\n   * @param value The new value for the directive's control.\n   */\n  updateModel(dir, value) {\n    const ctrl = this.form.get(dir.path);\n    ctrl.setValue(value);\n  }\n  /**\n   * @description\n   * Method called with the \"submit\" event is triggered on the form.\n   * Triggers the `ngSubmit` emitter to emit the \"submit\" event as its payload.\n   *\n   * @param $event The \"submit\" event object\n   */\n  onSubmit($event) {\n    this._submittedReactive.set(true);\n    syncPendingControls(this.form, this.directives);\n    this.ngSubmit.emit($event);\n    this.form._events.next(new FormSubmittedEvent(this.control));\n    return $event?.target?.method === \"dialog\";\n  }\n  /**\n   * @description\n   * Method called when the \"reset\" event is triggered on the form.\n   */\n  onReset() {\n    this.resetForm();\n  }\n  /**\n   * @description\n   * Resets the form to an initial value and resets its submitted status.\n   *\n   * @param value The new value for the form.\n   */\n  resetForm(value = void 0) {\n    this.form.reset(value);\n    this._submittedReactive.set(false);\n    this.form._events.next(new FormResetEvent(this.form));\n  }\n  /** @internal */\n  _updateDomValue() {\n    this.directives.forEach((dir) => {\n      const oldCtrl = dir.control;\n      const newCtrl = this.form.get(dir.path);\n      if (oldCtrl !== newCtrl) {\n        cleanUpControl(oldCtrl || null, dir);\n        if (isFormControl(newCtrl)) {\n          setUpControl(newCtrl, dir, this.callSetDisabledState);\n          dir.control = newCtrl;\n        }\n      }\n    });\n    this.form._updateTreeValidity({\n      emitEvent: false\n    });\n  }\n  _setUpFormContainer(dir) {\n    const ctrl = this.form.get(dir.path);\n    setUpFormContainer(ctrl, dir);\n    ctrl.updateValueAndValidity({\n      emitEvent: false\n    });\n  }\n  _cleanUpFormContainer(dir) {\n    if (this.form) {\n      const ctrl = this.form.get(dir.path);\n      if (ctrl) {\n        const isControlUpdated = cleanUpFormContainer(ctrl, dir);\n        if (isControlUpdated) {\n          ctrl.updateValueAndValidity({\n            emitEvent: false\n          });\n        }\n      }\n    }\n  }\n  _updateRegistrations() {\n    this.form._registerOnCollectionChange(this._onCollectionChange);\n    if (this._oldForm) {\n      this._oldForm._registerOnCollectionChange(() => {\n      });\n    }\n  }\n  _updateValidators() {\n    setUpValidators(this.form, this);\n    if (this._oldForm) {\n      cleanUpValidators(this._oldForm, this);\n    }\n  }\n  static \\u0275fac = function FormGroupDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _FormGroupDirective)(\\u0275\\u0275directiveInject(NG_VALIDATORS, 10), \\u0275\\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \\u0275\\u0275directiveInject(CALL_SET_DISABLED_STATE, 8));\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _FormGroupDirective,\n    selectors: [[\"\", \"formGroup\", \"\"]],\n    hostBindings: function FormGroupDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        \\u0275\\u0275listener(\"submit\", function FormGroupDirective_submit_HostBindingHandler($event) {\n          return ctx.onSubmit($event);\n        })(\"reset\", function FormGroupDirective_reset_HostBindingHandler() {\n          return ctx.onReset();\n        });\n      }\n    },\n    inputs: {\n      form: [0, \"formGroup\", \"form\"]\n    },\n    outputs: {\n      ngSubmit: \"ngSubmit\"\n    },\n    exportAs: [\"ngForm\"],\n    standalone: false,\n    features: [\\u0275\\u0275ProvidersFeature([formDirectiveProvider]), \\u0275\\u0275InheritDefinitionFeature, \\u0275\\u0275NgOnChangesFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(FormGroupDirective, [{\n    type: Directive,\n    args: [{\n      selector: \"[formGroup]\",\n      providers: [formDirectiveProvider],\n      host: {\n        \"(submit)\": \"onSubmit($event)\",\n        \"(reset)\": \"onReset()\"\n      },\n      exportAs: \"ngForm\",\n      standalone: false\n    }]\n  }], () => [{\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_VALIDATORS]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_ASYNC_VALIDATORS]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [CALL_SET_DISABLED_STATE]\n    }]\n  }], {\n    form: [{\n      type: Input,\n      args: [\"formGroup\"]\n    }],\n    ngSubmit: [{\n      type: Output\n    }]\n  });\n})();\nvar formGroupNameProvider = {\n  provide: ControlContainer,\n  useExisting: forwardRef(() => FormGroupName)\n};\nvar FormGroupName = class _FormGroupName extends AbstractFormGroupDirective {\n  /**\n   * @description\n   * Tracks the name of the `FormGroup` bound to the directive. The name corresponds\n   * to a key in the parent `FormGroup` or `FormArray`.\n   * Accepts a name as a string or a number.\n   * The name in the form of a string is useful for individual forms,\n   * while the numerical form allows for form groups to be bound\n   * to indices when iterating over groups in a `FormArray`.\n   */\n  name = null;\n  constructor(parent, validators, asyncValidators) {\n    super();\n    this._parent = parent;\n    this._setValidators(validators);\n    this._setAsyncValidators(asyncValidators);\n  }\n  /** @internal */\n  _checkParentType() {\n    if (hasInvalidParent(this._parent) && (typeof ngDevMode === \"undefined\" || ngDevMode)) {\n      throw groupParentException();\n    }\n  }\n  static \\u0275fac = function FormGroupName_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _FormGroupName)(\\u0275\\u0275directiveInject(ControlContainer, 13), \\u0275\\u0275directiveInject(NG_VALIDATORS, 10), \\u0275\\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _FormGroupName,\n    selectors: [[\"\", \"formGroupName\", \"\"]],\n    inputs: {\n      name: [0, \"formGroupName\", \"name\"]\n    },\n    standalone: false,\n    features: [\\u0275\\u0275ProvidersFeature([formGroupNameProvider]), \\u0275\\u0275InheritDefinitionFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(FormGroupName, [{\n    type: Directive,\n    args: [{\n      selector: \"[formGroupName]\",\n      providers: [formGroupNameProvider],\n      standalone: false\n    }]\n  }], () => [{\n    type: ControlContainer,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Host\n    }, {\n      type: SkipSelf\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_VALIDATORS]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_ASYNC_VALIDATORS]\n    }]\n  }], {\n    name: [{\n      type: Input,\n      args: [\"formGroupName\"]\n    }]\n  });\n})();\nvar formArrayNameProvider = {\n  provide: ControlContainer,\n  useExisting: forwardRef(() => FormArrayName)\n};\nvar FormArrayName = class _FormArrayName extends ControlContainer {\n  /** @internal */\n  _parent;\n  /**\n   * @description\n   * Tracks the name of the `FormArray` bound to the directive. The name corresponds\n   * to a key in the parent `FormGroup` or `FormArray`.\n   * Accepts a name as a string or a number.\n   * The name in the form of a string is useful for individual forms,\n   * while the numerical form allows for form arrays to be bound\n   * to indices when iterating over arrays in a `FormArray`.\n   */\n  name = null;\n  constructor(parent, validators, asyncValidators) {\n    super();\n    this._parent = parent;\n    this._setValidators(validators);\n    this._setAsyncValidators(asyncValidators);\n  }\n  /**\n   * A lifecycle method called when the directive's inputs are initialized. For internal use only.\n   * @throws If the directive does not have a valid parent.\n   * @nodoc\n   */\n  ngOnInit() {\n    if (hasInvalidParent(this._parent) && (typeof ngDevMode === \"undefined\" || ngDevMode)) {\n      throw arrayParentException();\n    }\n    this.formDirective.addFormArray(this);\n  }\n  /**\n   * A lifecycle method called before the directive's instance is destroyed. For internal use only.\n   * @nodoc\n   */\n  ngOnDestroy() {\n    this.formDirective?.removeFormArray(this);\n  }\n  /**\n   * @description\n   * The `FormArray` bound to this directive.\n   */\n  get control() {\n    return this.formDirective.getFormArray(this);\n  }\n  /**\n   * @description\n   * The top-level directive for this group if present, otherwise null.\n   */\n  get formDirective() {\n    return this._parent ? this._parent.formDirective : null;\n  }\n  /**\n   * @description\n   * Returns an array that represents the path from the top-level form to this control.\n   * Each index is the string name of the control on that level.\n   */\n  get path() {\n    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);\n  }\n  static \\u0275fac = function FormArrayName_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _FormArrayName)(\\u0275\\u0275directiveInject(ControlContainer, 13), \\u0275\\u0275directiveInject(NG_VALIDATORS, 10), \\u0275\\u0275directiveInject(NG_ASYNC_VALIDATORS, 10));\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _FormArrayName,\n    selectors: [[\"\", \"formArrayName\", \"\"]],\n    inputs: {\n      name: [0, \"formArrayName\", \"name\"]\n    },\n    standalone: false,\n    features: [\\u0275\\u0275ProvidersFeature([formArrayNameProvider]), \\u0275\\u0275InheritDefinitionFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(FormArrayName, [{\n    type: Directive,\n    args: [{\n      selector: \"[formArrayName]\",\n      providers: [formArrayNameProvider],\n      standalone: false\n    }]\n  }], () => [{\n    type: ControlContainer,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Host\n    }, {\n      type: SkipSelf\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_VALIDATORS]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_ASYNC_VALIDATORS]\n    }]\n  }], {\n    name: [{\n      type: Input,\n      args: [\"formArrayName\"]\n    }]\n  });\n})();\nfunction hasInvalidParent(parent) {\n  return !(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) && !(parent instanceof FormArrayName);\n}\nvar controlNameBinding = {\n  provide: NgControl,\n  useExisting: forwardRef(() => FormControlName)\n};\nvar FormControlName = class _FormControlName extends NgControl {\n  _ngModelWarningConfig;\n  _added = false;\n  /**\n   * Internal reference to the view model value.\n   * @internal\n   */\n  viewModel;\n  /**\n   * @description\n   * Tracks the `FormControl` instance bound to the directive.\n   */\n  // TODO(issue/24571): remove '!'.\n  control;\n  /**\n   * @description\n   * Tracks the name of the `FormControl` bound to the directive. The name corresponds\n   * to a key in the parent `FormGroup` or `FormArray`.\n   * Accepts a name as a string or a number.\n   * The name in the form of a string is useful for individual forms,\n   * while the numerical form allows for form controls to be bound\n   * to indices when iterating over controls in a `FormArray`.\n   */\n  name = null;\n  /**\n   * @description\n   * Triggers a warning in dev mode that this input should not be used with reactive forms.\n   */\n  set isDisabled(isDisabled) {\n    if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n      console.warn(disabledAttrWarning);\n    }\n  }\n  // TODO(kara): remove next 4 properties once deprecation period is over\n  /** @deprecated as of v6 */\n  model;\n  /** @deprecated as of v6 */\n  update = new EventEmitter();\n  /**\n   * @description\n   * Static property used to track whether any ngModel warnings have been sent across\n   * all instances of FormControlName. Used to support warning config of \"once\".\n   *\n   * @internal\n   */\n  static _ngModelWarningSentOnce = false;\n  /**\n   * @description\n   * Instance property used to track whether an ngModel warning has been sent out for this\n   * particular FormControlName instance. Used to support warning config of \"always\".\n   *\n   * @internal\n   */\n  _ngModelWarningSent = false;\n  constructor(parent, validators, asyncValidators, valueAccessors, _ngModelWarningConfig) {\n    super();\n    this._ngModelWarningConfig = _ngModelWarningConfig;\n    this._parent = parent;\n    this._setValidators(validators);\n    this._setAsyncValidators(asyncValidators);\n    this.valueAccessor = selectValueAccessor(this, valueAccessors);\n  }\n  /** @nodoc */\n  ngOnChanges(changes) {\n    if (!this._added) this._setUpControl();\n    if (isPropertyUpdated(changes, this.viewModel)) {\n      if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n        _ngModelWarning(\"formControlName\", _FormControlName, this, this._ngModelWarningConfig);\n      }\n      this.viewModel = this.model;\n      this.formDirective.updateModel(this, this.model);\n    }\n  }\n  /** @nodoc */\n  ngOnDestroy() {\n    if (this.formDirective) {\n      this.formDirective.removeControl(this);\n    }\n  }\n  /**\n   * @description\n   * Sets the new value for the view model and emits an `ngModelChange` event.\n   *\n   * @param newValue The new value for the view model.\n   */\n  viewToModelUpdate(newValue) {\n    this.viewModel = newValue;\n    this.update.emit(newValue);\n  }\n  /**\n   * @description\n   * Returns an array that represents the path from the top-level form to this control.\n   * Each index is the string name of the control on that level.\n   */\n  get path() {\n    return controlPath(this.name == null ? this.name : this.name.toString(), this._parent);\n  }\n  /**\n   * @description\n   * The top-level directive for this group if present, otherwise null.\n   */\n  get formDirective() {\n    return this._parent ? this._parent.formDirective : null;\n  }\n  _setUpControl() {\n    if (typeof ngDevMode === \"undefined\" || ngDevMode) {\n      checkParentType(this._parent, this.name);\n    }\n    this.control = this.formDirective.addControl(this);\n    this._added = true;\n  }\n  static \\u0275fac = function FormControlName_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _FormControlName)(\\u0275\\u0275directiveInject(ControlContainer, 13), \\u0275\\u0275directiveInject(NG_VALIDATORS, 10), \\u0275\\u0275directiveInject(NG_ASYNC_VALIDATORS, 10), \\u0275\\u0275directiveInject(NG_VALUE_ACCESSOR, 10), \\u0275\\u0275directiveInject(NG_MODEL_WITH_FORM_CONTROL_WARNING, 8));\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _FormControlName,\n    selectors: [[\"\", \"formControlName\", \"\"]],\n    inputs: {\n      name: [0, \"formControlName\", \"name\"],\n      isDisabled: [0, \"disabled\", \"isDisabled\"],\n      model: [0, \"ngModel\", \"model\"]\n    },\n    outputs: {\n      update: \"ngModelChange\"\n    },\n    standalone: false,\n    features: [\\u0275\\u0275ProvidersFeature([controlNameBinding]), \\u0275\\u0275InheritDefinitionFeature, \\u0275\\u0275NgOnChangesFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(FormControlName, [{\n    type: Directive,\n    args: [{\n      selector: \"[formControlName]\",\n      providers: [controlNameBinding],\n      standalone: false\n    }]\n  }], () => [{\n    type: ControlContainer,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Host\n    }, {\n      type: SkipSelf\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_VALIDATORS]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_ASYNC_VALIDATORS]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Self\n    }, {\n      type: Inject,\n      args: [NG_VALUE_ACCESSOR]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [NG_MODEL_WITH_FORM_CONTROL_WARNING]\n    }]\n  }], {\n    name: [{\n      type: Input,\n      args: [\"formControlName\"]\n    }],\n    isDisabled: [{\n      type: Input,\n      args: [\"disabled\"]\n    }],\n    model: [{\n      type: Input,\n      args: [\"ngModel\"]\n    }],\n    update: [{\n      type: Output,\n      args: [\"ngModelChange\"]\n    }]\n  });\n})();\nfunction checkParentType(parent, name) {\n  if (!(parent instanceof FormGroupName) && parent instanceof AbstractFormGroupDirective) {\n    throw ngModelGroupException();\n  } else if (!(parent instanceof FormGroupName) && !(parent instanceof FormGroupDirective) && !(parent instanceof FormArrayName)) {\n    throw controlParentException(name);\n  }\n}\nvar SELECT_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => SelectControlValueAccessor),\n  multi: true\n};\nfunction _buildValueString$1(id, value) {\n  if (id == null) return `${value}`;\n  if (value && typeof value === \"object\") value = \"Object\";\n  return `${id}: ${value}`.slice(0, 50);\n}\nfunction _extractId$1(valueString) {\n  return valueString.split(\":\")[0];\n}\nvar SelectControlValueAccessor = class _SelectControlValueAccessor extends BuiltInControlValueAccessor {\n  /** @nodoc */\n  value;\n  /** @internal */\n  _optionMap = /* @__PURE__ */ new Map();\n  /** @internal */\n  _idCounter = 0;\n  /**\n   * @description\n   * Tracks the option comparison algorithm for tracking identities when\n   * checking for changes.\n   */\n  set compareWith(fn) {\n    if (typeof fn !== \"function\" && (typeof ngDevMode === \"undefined\" || ngDevMode)) {\n      throw new RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);\n    }\n    this._compareWith = fn;\n  }\n  _compareWith = Object.is;\n  /**\n   * Sets the \"value\" property on the select element.\n   * @nodoc\n   */\n  writeValue(value) {\n    this.value = value;\n    const id = this._getOptionId(value);\n    const valueString = _buildValueString$1(id, value);\n    this.setProperty(\"value\", valueString);\n  }\n  /**\n   * Registers a function called when the control value changes.\n   * @nodoc\n   */\n  registerOnChange(fn) {\n    this.onChange = (valueString) => {\n      this.value = this._getOptionValue(valueString);\n      fn(this.value);\n    };\n  }\n  /** @internal */\n  _registerOption() {\n    return (this._idCounter++).toString();\n  }\n  /** @internal */\n  _getOptionId(value) {\n    for (const id of this._optionMap.keys()) {\n      if (this._compareWith(this._optionMap.get(id), value)) return id;\n    }\n    return null;\n  }\n  /** @internal */\n  _getOptionValue(valueString) {\n    const id = _extractId$1(valueString);\n    return this._optionMap.has(id) ? this._optionMap.get(id) : valueString;\n  }\n  static \\u0275fac = /* @__PURE__ */ (() => {\n    let \\u0275SelectControlValueAccessor_BaseFactory;\n    return function SelectControlValueAccessor_Factory(__ngFactoryType__) {\n      return (\\u0275SelectControlValueAccessor_BaseFactory || (\\u0275SelectControlValueAccessor_BaseFactory = \\u0275\\u0275getInheritedFactory(_SelectControlValueAccessor)))(__ngFactoryType__ || _SelectControlValueAccessor);\n    };\n  })();\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _SelectControlValueAccessor,\n    selectors: [[\"select\", \"formControlName\", \"\", 3, \"multiple\", \"\"], [\"select\", \"formControl\", \"\", 3, \"multiple\", \"\"], [\"select\", \"ngModel\", \"\", 3, \"multiple\", \"\"]],\n    hostBindings: function SelectControlValueAccessor_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        \\u0275\\u0275listener(\"change\", function SelectControlValueAccessor_change_HostBindingHandler($event) {\n          return ctx.onChange($event.target.value);\n        })(\"blur\", function SelectControlValueAccessor_blur_HostBindingHandler() {\n          return ctx.onTouched();\n        });\n      }\n    },\n    inputs: {\n      compareWith: \"compareWith\"\n    },\n    standalone: false,\n    features: [\\u0275\\u0275ProvidersFeature([SELECT_VALUE_ACCESSOR]), \\u0275\\u0275InheritDefinitionFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(SelectControlValueAccessor, [{\n    type: Directive,\n    args: [{\n      selector: \"select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]\",\n      host: {\n        \"(change)\": \"onChange($event.target.value)\",\n        \"(blur)\": \"onTouched()\"\n      },\n      providers: [SELECT_VALUE_ACCESSOR],\n      standalone: false\n    }]\n  }], null, {\n    compareWith: [{\n      type: Input\n    }]\n  });\n})();\nvar NgSelectOption = class _NgSelectOption {\n  _element;\n  _renderer;\n  _select;\n  /**\n   * @description\n   * ID of the option element\n   */\n  // TODO(issue/24571): remove '!'.\n  id;\n  constructor(_element, _renderer, _select) {\n    this._element = _element;\n    this._renderer = _renderer;\n    this._select = _select;\n    if (this._select) this.id = this._select._registerOption();\n  }\n  /**\n   * @description\n   * Tracks the value bound to the option element. Unlike the value binding,\n   * ngValue supports binding to objects.\n   */\n  set ngValue(value) {\n    if (this._select == null) return;\n    this._select._optionMap.set(this.id, value);\n    this._setElementValue(_buildValueString$1(this.id, value));\n    this._select.writeValue(this._select.value);\n  }\n  /**\n   * @description\n   * Tracks simple string values bound to the option element.\n   * For objects, use the `ngValue` input binding.\n   */\n  set value(value) {\n    this._setElementValue(value);\n    if (this._select) this._select.writeValue(this._select.value);\n  }\n  /** @internal */\n  _setElementValue(value) {\n    this._renderer.setProperty(this._element.nativeElement, \"value\", value);\n  }\n  /** @nodoc */\n  ngOnDestroy() {\n    if (this._select) {\n      this._select._optionMap.delete(this.id);\n      this._select.writeValue(this._select.value);\n    }\n  }\n  static \\u0275fac = function NgSelectOption_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _NgSelectOption)(\\u0275\\u0275directiveInject(ElementRef), \\u0275\\u0275directiveInject(Renderer2), \\u0275\\u0275directiveInject(SelectControlValueAccessor, 9));\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _NgSelectOption,\n    selectors: [[\"option\"]],\n    inputs: {\n      ngValue: \"ngValue\",\n      value: \"value\"\n    },\n    standalone: false\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(NgSelectOption, [{\n    type: Directive,\n    args: [{\n      selector: \"option\",\n      standalone: false\n    }]\n  }], () => [{\n    type: ElementRef\n  }, {\n    type: Renderer2\n  }, {\n    type: SelectControlValueAccessor,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Host\n    }]\n  }], {\n    ngValue: [{\n      type: Input,\n      args: [\"ngValue\"]\n    }],\n    value: [{\n      type: Input,\n      args: [\"value\"]\n    }]\n  });\n})();\nvar SELECT_MULTIPLE_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => SelectMultipleControlValueAccessor),\n  multi: true\n};\nfunction _buildValueString(id, value) {\n  if (id == null) return `${value}`;\n  if (typeof value === \"string\") value = `'${value}'`;\n  if (value && typeof value === \"object\") value = \"Object\";\n  return `${id}: ${value}`.slice(0, 50);\n}\nfunction _extractId(valueString) {\n  return valueString.split(\":\")[0];\n}\nvar SelectMultipleControlValueAccessor = class _SelectMultipleControlValueAccessor extends BuiltInControlValueAccessor {\n  /**\n   * The current value.\n   * @nodoc\n   */\n  value;\n  /** @internal */\n  _optionMap = /* @__PURE__ */ new Map();\n  /** @internal */\n  _idCounter = 0;\n  /**\n   * @description\n   * Tracks the option comparison algorithm for tracking identities when\n   * checking for changes.\n   */\n  set compareWith(fn) {\n    if (typeof fn !== \"function\" && (typeof ngDevMode === \"undefined\" || ngDevMode)) {\n      throw new RuntimeError(1201, `compareWith must be a function, but received ${JSON.stringify(fn)}`);\n    }\n    this._compareWith = fn;\n  }\n  _compareWith = Object.is;\n  /**\n   * Sets the \"value\" property on one or of more of the select's options.\n   * @nodoc\n   */\n  writeValue(value) {\n    this.value = value;\n    let optionSelectedStateSetter;\n    if (Array.isArray(value)) {\n      const ids = value.map((v) => this._getOptionId(v));\n      optionSelectedStateSetter = (opt, o) => {\n        opt._setSelected(ids.indexOf(o.toString()) > -1);\n      };\n    } else {\n      optionSelectedStateSetter = (opt, o) => {\n        opt._setSelected(false);\n      };\n    }\n    this._optionMap.forEach(optionSelectedStateSetter);\n  }\n  /**\n   * Registers a function called when the control value changes\n   * and writes an array of the selected options.\n   * @nodoc\n   */\n  registerOnChange(fn) {\n    this.onChange = (element) => {\n      const selected = [];\n      const selectedOptions = element.selectedOptions;\n      if (selectedOptions !== void 0) {\n        const options = selectedOptions;\n        for (let i = 0; i < options.length; i++) {\n          const opt = options[i];\n          const val = this._getOptionValue(opt.value);\n          selected.push(val);\n        }\n      } else {\n        const options = element.options;\n        for (let i = 0; i < options.length; i++) {\n          const opt = options[i];\n          if (opt.selected) {\n            const val = this._getOptionValue(opt.value);\n            selected.push(val);\n          }\n        }\n      }\n      this.value = selected;\n      fn(selected);\n    };\n  }\n  /** @internal */\n  _registerOption(value) {\n    const id = (this._idCounter++).toString();\n    this._optionMap.set(id, value);\n    return id;\n  }\n  /** @internal */\n  _getOptionId(value) {\n    for (const id of this._optionMap.keys()) {\n      if (this._compareWith(this._optionMap.get(id)._value, value)) return id;\n    }\n    return null;\n  }\n  /** @internal */\n  _getOptionValue(valueString) {\n    const id = _extractId(valueString);\n    return this._optionMap.has(id) ? this._optionMap.get(id)._value : valueString;\n  }\n  static \\u0275fac = /* @__PURE__ */ (() => {\n    let \\u0275SelectMultipleControlValueAccessor_BaseFactory;\n    return function SelectMultipleControlValueAccessor_Factory(__ngFactoryType__) {\n      return (\\u0275SelectMultipleControlValueAccessor_BaseFactory || (\\u0275SelectMultipleControlValueAccessor_BaseFactory = \\u0275\\u0275getInheritedFactory(_SelectMultipleControlValueAccessor)))(__ngFactoryType__ || _SelectMultipleControlValueAccessor);\n    };\n  })();\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _SelectMultipleControlValueAccessor,\n    selectors: [[\"select\", \"multiple\", \"\", \"formControlName\", \"\"], [\"select\", \"multiple\", \"\", \"formControl\", \"\"], [\"select\", \"multiple\", \"\", \"ngModel\", \"\"]],\n    hostBindings: function SelectMultipleControlValueAccessor_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        \\u0275\\u0275listener(\"change\", function SelectMultipleControlValueAccessor_change_HostBindingHandler($event) {\n          return ctx.onChange($event.target);\n        })(\"blur\", function SelectMultipleControlValueAccessor_blur_HostBindingHandler() {\n          return ctx.onTouched();\n        });\n      }\n    },\n    inputs: {\n      compareWith: \"compareWith\"\n    },\n    standalone: false,\n    features: [\\u0275\\u0275ProvidersFeature([SELECT_MULTIPLE_VALUE_ACCESSOR]), \\u0275\\u0275InheritDefinitionFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(SelectMultipleControlValueAccessor, [{\n    type: Directive,\n    args: [{\n      selector: \"select[multiple][formControlName],select[multiple][formControl],select[multiple][ngModel]\",\n      host: {\n        \"(change)\": \"onChange($event.target)\",\n        \"(blur)\": \"onTouched()\"\n      },\n      providers: [SELECT_MULTIPLE_VALUE_ACCESSOR],\n      standalone: false\n    }]\n  }], null, {\n    compareWith: [{\n      type: Input\n    }]\n  });\n})();\nvar \\u0275NgSelectMultipleOption = class _\\u0275NgSelectMultipleOption {\n  _element;\n  _renderer;\n  _select;\n  // TODO(issue/24571): remove '!'.\n  id;\n  /** @internal */\n  _value;\n  constructor(_element, _renderer, _select) {\n    this._element = _element;\n    this._renderer = _renderer;\n    this._select = _select;\n    if (this._select) {\n      this.id = this._select._registerOption(this);\n    }\n  }\n  /**\n   * @description\n   * Tracks the value bound to the option element. Unlike the value binding,\n   * ngValue supports binding to objects.\n   */\n  set ngValue(value) {\n    if (this._select == null) return;\n    this._value = value;\n    this._setElementValue(_buildValueString(this.id, value));\n    this._select.writeValue(this._select.value);\n  }\n  /**\n   * @description\n   * Tracks simple string values bound to the option element.\n   * For objects, use the `ngValue` input binding.\n   */\n  set value(value) {\n    if (this._select) {\n      this._value = value;\n      this._setElementValue(_buildValueString(this.id, value));\n      this._select.writeValue(this._select.value);\n    } else {\n      this._setElementValue(value);\n    }\n  }\n  /** @internal */\n  _setElementValue(value) {\n    this._renderer.setProperty(this._element.nativeElement, \"value\", value);\n  }\n  /** @internal */\n  _setSelected(selected) {\n    this._renderer.setProperty(this._element.nativeElement, \"selected\", selected);\n  }\n  /** @nodoc */\n  ngOnDestroy() {\n    if (this._select) {\n      this._select._optionMap.delete(this.id);\n      this._select.writeValue(this._select.value);\n    }\n  }\n  static \\u0275fac = function \\u0275NgSelectMultipleOption_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _\\u0275NgSelectMultipleOption)(\\u0275\\u0275directiveInject(ElementRef), \\u0275\\u0275directiveInject(Renderer2), \\u0275\\u0275directiveInject(SelectMultipleControlValueAccessor, 9));\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _\\u0275NgSelectMultipleOption,\n    selectors: [[\"option\"]],\n    inputs: {\n      ngValue: \"ngValue\",\n      value: \"value\"\n    },\n    standalone: false\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(\\u0275NgSelectMultipleOption, [{\n    type: Directive,\n    args: [{\n      selector: \"option\",\n      standalone: false\n    }]\n  }], () => [{\n    type: ElementRef\n  }, {\n    type: Renderer2\n  }, {\n    type: SelectMultipleControlValueAccessor,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Host\n    }]\n  }], {\n    ngValue: [{\n      type: Input,\n      args: [\"ngValue\"]\n    }],\n    value: [{\n      type: Input,\n      args: [\"value\"]\n    }]\n  });\n})();\nfunction toInteger(value) {\n  return typeof value === \"number\" ? value : parseInt(value, 10);\n}\nfunction toFloat(value) {\n  return typeof value === \"number\" ? value : parseFloat(value);\n}\nvar AbstractValidatorDirective = class _AbstractValidatorDirective {\n  _validator = nullValidator;\n  _onChange;\n  /**\n   * A flag that tracks whether this validator is enabled.\n   *\n   * Marking it `internal` (vs `protected`), so that this flag can be used in host bindings of\n   * directive classes that extend this base class.\n   * @internal\n   */\n  _enabled;\n  /** @nodoc */\n  ngOnChanges(changes) {\n    if (this.inputName in changes) {\n      const input2 = this.normalizeInput(changes[this.inputName].currentValue);\n      this._enabled = this.enabled(input2);\n      this._validator = this._enabled ? this.createValidator(input2) : nullValidator;\n      if (this._onChange) {\n        this._onChange();\n      }\n    }\n  }\n  /** @nodoc */\n  validate(control) {\n    return this._validator(control);\n  }\n  /** @nodoc */\n  registerOnValidatorChange(fn) {\n    this._onChange = fn;\n  }\n  /**\n   * @description\n   * Determines whether this validator should be active or not based on an input.\n   * Base class implementation checks whether an input is defined (if the value is different from\n   * `null` and `undefined`). Validator classes that extend this base class can override this\n   * function with the logic specific to a particular validator directive.\n   */\n  enabled(input2) {\n    return input2 != null;\n  }\n  static \\u0275fac = function AbstractValidatorDirective_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _AbstractValidatorDirective)();\n  };\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _AbstractValidatorDirective,\n    features: [\\u0275\\u0275NgOnChangesFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(AbstractValidatorDirective, [{\n    type: Directive\n  }], null, null);\n})();\nvar MAX_VALIDATOR = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => MaxValidator),\n  multi: true\n};\nvar MaxValidator = class _MaxValidator extends AbstractValidatorDirective {\n  /**\n   * @description\n   * Tracks changes to the max bound to this directive.\n   */\n  max;\n  /** @internal */\n  inputName = \"max\";\n  /** @internal */\n  normalizeInput = (input2) => toFloat(input2);\n  /** @internal */\n  createValidator = (max) => maxValidator(max);\n  static \\u0275fac = /* @__PURE__ */ (() => {\n    let \\u0275MaxValidator_BaseFactory;\n    return function MaxValidator_Factory(__ngFactoryType__) {\n      return (\\u0275MaxValidator_BaseFactory || (\\u0275MaxValidator_BaseFactory = \\u0275\\u0275getInheritedFactory(_MaxValidator)))(__ngFactoryType__ || _MaxValidator);\n    };\n  })();\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _MaxValidator,\n    selectors: [[\"input\", \"type\", \"number\", \"max\", \"\", \"formControlName\", \"\"], [\"input\", \"type\", \"number\", \"max\", \"\", \"formControl\", \"\"], [\"input\", \"type\", \"number\", \"max\", \"\", \"ngModel\", \"\"]],\n    hostVars: 1,\n    hostBindings: function MaxValidator_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        \\u0275\\u0275attribute(\"max\", ctx._enabled ? ctx.max : null);\n      }\n    },\n    inputs: {\n      max: \"max\"\n    },\n    standalone: false,\n    features: [\\u0275\\u0275ProvidersFeature([MAX_VALIDATOR]), \\u0275\\u0275InheritDefinitionFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(MaxValidator, [{\n    type: Directive,\n    args: [{\n      selector: \"input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]\",\n      providers: [MAX_VALIDATOR],\n      host: {\n        \"[attr.max]\": \"_enabled ? max : null\"\n      },\n      standalone: false\n    }]\n  }], null, {\n    max: [{\n      type: Input\n    }]\n  });\n})();\nvar MIN_VALIDATOR = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => MinValidator),\n  multi: true\n};\nvar MinValidator = class _MinValidator extends AbstractValidatorDirective {\n  /**\n   * @description\n   * Tracks changes to the min bound to this directive.\n   */\n  min;\n  /** @internal */\n  inputName = \"min\";\n  /** @internal */\n  normalizeInput = (input2) => toFloat(input2);\n  /** @internal */\n  createValidator = (min) => minValidator(min);\n  static \\u0275fac = /* @__PURE__ */ (() => {\n    let \\u0275MinValidator_BaseFactory;\n    return function MinValidator_Factory(__ngFactoryType__) {\n      return (\\u0275MinValidator_BaseFactory || (\\u0275MinValidator_BaseFactory = \\u0275\\u0275getInheritedFactory(_MinValidator)))(__ngFactoryType__ || _MinValidator);\n    };\n  })();\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _MinValidator,\n    selectors: [[\"input\", \"type\", \"number\", \"min\", \"\", \"formControlName\", \"\"], [\"input\", \"type\", \"number\", \"min\", \"\", \"formControl\", \"\"], [\"input\", \"type\", \"number\", \"min\", \"\", \"ngModel\", \"\"]],\n    hostVars: 1,\n    hostBindings: function MinValidator_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        \\u0275\\u0275attribute(\"min\", ctx._enabled ? ctx.min : null);\n      }\n    },\n    inputs: {\n      min: \"min\"\n    },\n    standalone: false,\n    features: [\\u0275\\u0275ProvidersFeature([MIN_VALIDATOR]), \\u0275\\u0275InheritDefinitionFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(MinValidator, [{\n    type: Directive,\n    args: [{\n      selector: \"input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]\",\n      providers: [MIN_VALIDATOR],\n      host: {\n        \"[attr.min]\": \"_enabled ? min : null\"\n      },\n      standalone: false\n    }]\n  }], null, {\n    min: [{\n      type: Input\n    }]\n  });\n})();\nvar REQUIRED_VALIDATOR = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => RequiredValidator),\n  multi: true\n};\nvar CHECKBOX_REQUIRED_VALIDATOR = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => CheckboxRequiredValidator),\n  multi: true\n};\nvar RequiredValidator = class _RequiredValidator extends AbstractValidatorDirective {\n  /**\n   * @description\n   * Tracks changes to the required attribute bound to this directive.\n   */\n  required;\n  /** @internal */\n  inputName = \"required\";\n  /** @internal */\n  normalizeInput = booleanAttribute;\n  /** @internal */\n  createValidator = (input2) => requiredValidator;\n  /** @nodoc */\n  enabled(input2) {\n    return input2;\n  }\n  static \\u0275fac = /* @__PURE__ */ (() => {\n    let \\u0275RequiredValidator_BaseFactory;\n    return function RequiredValidator_Factory(__ngFactoryType__) {\n      return (\\u0275RequiredValidator_BaseFactory || (\\u0275RequiredValidator_BaseFactory = \\u0275\\u0275getInheritedFactory(_RequiredValidator)))(__ngFactoryType__ || _RequiredValidator);\n    };\n  })();\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _RequiredValidator,\n    selectors: [[\"\", \"required\", \"\", \"formControlName\", \"\", 3, \"type\", \"checkbox\"], [\"\", \"required\", \"\", \"formControl\", \"\", 3, \"type\", \"checkbox\"], [\"\", \"required\", \"\", \"ngModel\", \"\", 3, \"type\", \"checkbox\"]],\n    hostVars: 1,\n    hostBindings: function RequiredValidator_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        \\u0275\\u0275attribute(\"required\", ctx._enabled ? \"\" : null);\n      }\n    },\n    inputs: {\n      required: \"required\"\n    },\n    standalone: false,\n    features: [\\u0275\\u0275ProvidersFeature([REQUIRED_VALIDATOR]), \\u0275\\u0275InheritDefinitionFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(RequiredValidator, [{\n    type: Directive,\n    args: [{\n      selector: \":not([type=checkbox])[required][formControlName],:not([type=checkbox])[required][formControl],:not([type=checkbox])[required][ngModel]\",\n      providers: [REQUIRED_VALIDATOR],\n      host: {\n        \"[attr.required]\": '_enabled ? \"\" : null'\n      },\n      standalone: false\n    }]\n  }], null, {\n    required: [{\n      type: Input\n    }]\n  });\n})();\nvar CheckboxRequiredValidator = class _CheckboxRequiredValidator extends RequiredValidator {\n  /** @internal */\n  createValidator = (input2) => requiredTrueValidator;\n  static \\u0275fac = /* @__PURE__ */ (() => {\n    let \\u0275CheckboxRequiredValidator_BaseFactory;\n    return function CheckboxRequiredValidator_Factory(__ngFactoryType__) {\n      return (\\u0275CheckboxRequiredValidator_BaseFactory || (\\u0275CheckboxRequiredValidator_BaseFactory = \\u0275\\u0275getInheritedFactory(_CheckboxRequiredValidator)))(__ngFactoryType__ || _CheckboxRequiredValidator);\n    };\n  })();\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _CheckboxRequiredValidator,\n    selectors: [[\"input\", \"type\", \"checkbox\", \"required\", \"\", \"formControlName\", \"\"], [\"input\", \"type\", \"checkbox\", \"required\", \"\", \"formControl\", \"\"], [\"input\", \"type\", \"checkbox\", \"required\", \"\", \"ngModel\", \"\"]],\n    hostVars: 1,\n    hostBindings: function CheckboxRequiredValidator_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        \\u0275\\u0275attribute(\"required\", ctx._enabled ? \"\" : null);\n      }\n    },\n    standalone: false,\n    features: [\\u0275\\u0275ProvidersFeature([CHECKBOX_REQUIRED_VALIDATOR]), \\u0275\\u0275InheritDefinitionFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(CheckboxRequiredValidator, [{\n    type: Directive,\n    args: [{\n      selector: \"input[type=checkbox][required][formControlName],input[type=checkbox][required][formControl],input[type=checkbox][required][ngModel]\",\n      providers: [CHECKBOX_REQUIRED_VALIDATOR],\n      host: {\n        \"[attr.required]\": '_enabled ? \"\" : null'\n      },\n      standalone: false\n    }]\n  }], null, null);\n})();\nvar EMAIL_VALIDATOR = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => EmailValidator),\n  multi: true\n};\nvar EmailValidator = class _EmailValidator extends AbstractValidatorDirective {\n  /**\n   * @description\n   * Tracks changes to the email attribute bound to this directive.\n   */\n  email;\n  /** @internal */\n  inputName = \"email\";\n  /** @internal */\n  normalizeInput = booleanAttribute;\n  /** @internal */\n  createValidator = (input2) => emailValidator;\n  /** @nodoc */\n  enabled(input2) {\n    return input2;\n  }\n  static \\u0275fac = /* @__PURE__ */ (() => {\n    let \\u0275EmailValidator_BaseFactory;\n    return function EmailValidator_Factory(__ngFactoryType__) {\n      return (\\u0275EmailValidator_BaseFactory || (\\u0275EmailValidator_BaseFactory = \\u0275\\u0275getInheritedFactory(_EmailValidator)))(__ngFactoryType__ || _EmailValidator);\n    };\n  })();\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _EmailValidator,\n    selectors: [[\"\", \"email\", \"\", \"formControlName\", \"\"], [\"\", \"email\", \"\", \"formControl\", \"\"], [\"\", \"email\", \"\", \"ngModel\", \"\"]],\n    inputs: {\n      email: \"email\"\n    },\n    standalone: false,\n    features: [\\u0275\\u0275ProvidersFeature([EMAIL_VALIDATOR]), \\u0275\\u0275InheritDefinitionFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(EmailValidator, [{\n    type: Directive,\n    args: [{\n      selector: \"[email][formControlName],[email][formControl],[email][ngModel]\",\n      providers: [EMAIL_VALIDATOR],\n      standalone: false\n    }]\n  }], null, {\n    email: [{\n      type: Input\n    }]\n  });\n})();\nvar MIN_LENGTH_VALIDATOR = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => MinLengthValidator),\n  multi: true\n};\nvar MinLengthValidator = class _MinLengthValidator extends AbstractValidatorDirective {\n  /**\n   * @description\n   * Tracks changes to the minimum length bound to this directive.\n   */\n  minlength;\n  /** @internal */\n  inputName = \"minlength\";\n  /** @internal */\n  normalizeInput = (input2) => toInteger(input2);\n  /** @internal */\n  createValidator = (minlength) => minLengthValidator(minlength);\n  static \\u0275fac = /* @__PURE__ */ (() => {\n    let \\u0275MinLengthValidator_BaseFactory;\n    return function MinLengthValidator_Factory(__ngFactoryType__) {\n      return (\\u0275MinLengthValidator_BaseFactory || (\\u0275MinLengthValidator_BaseFactory = \\u0275\\u0275getInheritedFactory(_MinLengthValidator)))(__ngFactoryType__ || _MinLengthValidator);\n    };\n  })();\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _MinLengthValidator,\n    selectors: [[\"\", \"minlength\", \"\", \"formControlName\", \"\"], [\"\", \"minlength\", \"\", \"formControl\", \"\"], [\"\", \"minlength\", \"\", \"ngModel\", \"\"]],\n    hostVars: 1,\n    hostBindings: function MinLengthValidator_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        \\u0275\\u0275attribute(\"minlength\", ctx._enabled ? ctx.minlength : null);\n      }\n    },\n    inputs: {\n      minlength: \"minlength\"\n    },\n    standalone: false,\n    features: [\\u0275\\u0275ProvidersFeature([MIN_LENGTH_VALIDATOR]), \\u0275\\u0275InheritDefinitionFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(MinLengthValidator, [{\n    type: Directive,\n    args: [{\n      selector: \"[minlength][formControlName],[minlength][formControl],[minlength][ngModel]\",\n      providers: [MIN_LENGTH_VALIDATOR],\n      host: {\n        \"[attr.minlength]\": \"_enabled ? minlength : null\"\n      },\n      standalone: false\n    }]\n  }], null, {\n    minlength: [{\n      type: Input\n    }]\n  });\n})();\nvar MAX_LENGTH_VALIDATOR = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => MaxLengthValidator),\n  multi: true\n};\nvar MaxLengthValidator = class _MaxLengthValidator extends AbstractValidatorDirective {\n  /**\n   * @description\n   * Tracks changes to the maximum length bound to this directive.\n   */\n  maxlength;\n  /** @internal */\n  inputName = \"maxlength\";\n  /** @internal */\n  normalizeInput = (input2) => toInteger(input2);\n  /** @internal */\n  createValidator = (maxlength) => maxLengthValidator(maxlength);\n  static \\u0275fac = /* @__PURE__ */ (() => {\n    let \\u0275MaxLengthValidator_BaseFactory;\n    return function MaxLengthValidator_Factory(__ngFactoryType__) {\n      return (\\u0275MaxLengthValidator_BaseFactory || (\\u0275MaxLengthValidator_BaseFactory = \\u0275\\u0275getInheritedFactory(_MaxLengthValidator)))(__ngFactoryType__ || _MaxLengthValidator);\n    };\n  })();\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _MaxLengthValidator,\n    selectors: [[\"\", \"maxlength\", \"\", \"formControlName\", \"\"], [\"\", \"maxlength\", \"\", \"formControl\", \"\"], [\"\", \"maxlength\", \"\", \"ngModel\", \"\"]],\n    hostVars: 1,\n    hostBindings: function MaxLengthValidator_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        \\u0275\\u0275attribute(\"maxlength\", ctx._enabled ? ctx.maxlength : null);\n      }\n    },\n    inputs: {\n      maxlength: \"maxlength\"\n    },\n    standalone: false,\n    features: [\\u0275\\u0275ProvidersFeature([MAX_LENGTH_VALIDATOR]), \\u0275\\u0275InheritDefinitionFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(MaxLengthValidator, [{\n    type: Directive,\n    args: [{\n      selector: \"[maxlength][formControlName],[maxlength][formControl],[maxlength][ngModel]\",\n      providers: [MAX_LENGTH_VALIDATOR],\n      host: {\n        \"[attr.maxlength]\": \"_enabled ? maxlength : null\"\n      },\n      standalone: false\n    }]\n  }], null, {\n    maxlength: [{\n      type: Input\n    }]\n  });\n})();\nvar PATTERN_VALIDATOR = {\n  provide: NG_VALIDATORS,\n  useExisting: forwardRef(() => PatternValidator),\n  multi: true\n};\nvar PatternValidator = class _PatternValidator extends AbstractValidatorDirective {\n  /**\n   * @description\n   * Tracks changes to the pattern bound to this directive.\n   */\n  pattern;\n  // This input is always defined, since the name matches selector.\n  /** @internal */\n  inputName = \"pattern\";\n  /** @internal */\n  normalizeInput = (input2) => input2;\n  /** @internal */\n  createValidator = (input2) => patternValidator(input2);\n  static \\u0275fac = /* @__PURE__ */ (() => {\n    let \\u0275PatternValidator_BaseFactory;\n    return function PatternValidator_Factory(__ngFactoryType__) {\n      return (\\u0275PatternValidator_BaseFactory || (\\u0275PatternValidator_BaseFactory = \\u0275\\u0275getInheritedFactory(_PatternValidator)))(__ngFactoryType__ || _PatternValidator);\n    };\n  })();\n  static \\u0275dir = /* @__PURE__ */ \\u0275\\u0275defineDirective({\n    type: _PatternValidator,\n    selectors: [[\"\", \"pattern\", \"\", \"formControlName\", \"\"], [\"\", \"pattern\", \"\", \"formControl\", \"\"], [\"\", \"pattern\", \"\", \"ngModel\", \"\"]],\n    hostVars: 1,\n    hostBindings: function PatternValidator_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        \\u0275\\u0275attribute(\"pattern\", ctx._enabled ? ctx.pattern : null);\n      }\n    },\n    inputs: {\n      pattern: \"pattern\"\n    },\n    standalone: false,\n    features: [\\u0275\\u0275ProvidersFeature([PATTERN_VALIDATOR]), \\u0275\\u0275InheritDefinitionFeature]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(PatternValidator, [{\n    type: Directive,\n    args: [{\n      selector: \"[pattern][formControlName],[pattern][formControl],[pattern][ngModel]\",\n      providers: [PATTERN_VALIDATOR],\n      host: {\n        \"[attr.pattern]\": \"_enabled ? pattern : null\"\n      },\n      standalone: false\n    }]\n  }], null, {\n    pattern: [{\n      type: Input\n    }]\n  });\n})();\nvar SHARED_FORM_DIRECTIVES = [\\u0275NgNoValidate, NgSelectOption, \\u0275NgSelectMultipleOption, DefaultValueAccessor, NumberValueAccessor, RangeValueAccessor, CheckboxControlValueAccessor, SelectControlValueAccessor, SelectMultipleControlValueAccessor, RadioControlValueAccessor, NgControlStatus, NgControlStatusGroup, RequiredValidator, MinLengthValidator, MaxLengthValidator, PatternValidator, CheckboxRequiredValidator, EmailValidator, MinValidator, MaxValidator];\nvar TEMPLATE_DRIVEN_DIRECTIVES = [NgModel, NgModelGroup, NgForm];\nvar REACTIVE_DRIVEN_DIRECTIVES = [FormControlDirective, FormGroupDirective, FormControlName, FormGroupName, FormArrayName];\nvar \\u0275InternalFormsSharedModule = class _\\u0275InternalFormsSharedModule {\n  static \\u0275fac = function \\u0275InternalFormsSharedModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _\\u0275InternalFormsSharedModule)();\n  };\n  static \\u0275mod = /* @__PURE__ */ \\u0275\\u0275defineNgModule({\n    type: _\\u0275InternalFormsSharedModule\n  });\n  static \\u0275inj = /* @__PURE__ */ \\u0275\\u0275defineInjector({});\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(\\u0275InternalFormsSharedModule, [{\n    type: NgModule,\n    args: [{\n      declarations: SHARED_FORM_DIRECTIVES,\n      exports: SHARED_FORM_DIRECTIVES\n    }]\n  }], null, null);\n})();\nvar FormArray = class extends AbstractControl {\n  /**\n   * Creates a new `FormArray` instance.\n   *\n   * @param controls An array of child controls. Each child control is given an index\n   * where it is registered.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of\n   * such functions, or an `AbstractControlOptions` object that contains validation functions\n   * and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator functions\n   *\n   */\n  constructor(controls, validatorOrOpts, asyncValidator) {\n    super(pickValidators(validatorOrOpts), pickAsyncValidators(asyncValidator, validatorOrOpts));\n    this.controls = controls;\n    this._initObservables();\n    this._setUpdateStrategy(validatorOrOpts);\n    this._setUpControls();\n    this.updateValueAndValidity({\n      onlySelf: true,\n      // If `asyncValidator` is present, it will trigger control status change from `PENDING` to\n      // `VALID` or `INVALID`.\n      // The status should be broadcasted via the `statusChanges` observable, so we set `emitEvent`\n      // to `true` to allow that during the control creation process.\n      emitEvent: !!this.asyncValidator\n    });\n  }\n  controls;\n  /**\n   * Get the `AbstractControl` at the given `index` in the array.\n   *\n   * @param index Index in the array to retrieve the control. If `index` is negative, it will wrap\n   *     around from the back, and if index is greatly negative (less than `-length`), the result is\n   * undefined. This behavior is the same as `Array.at(index)`.\n   */\n  at(index) {\n    return this.controls[this._adjustIndex(index)];\n  }\n  /**\n   * Insert a new `AbstractControl` at the end of the array.\n   *\n   * @param control Form control to be inserted\n   * @param options Specifies whether this FormArray instance should emit events after a new\n   *     control is added.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control is\n   * inserted. When false, no events are emitted.\n   */\n  push(control, options = {}) {\n    this.controls.push(control);\n    this._registerControl(control);\n    this.updateValueAndValidity({\n      emitEvent: options.emitEvent\n    });\n    this._onCollectionChange();\n  }\n  /**\n   * Insert a new `AbstractControl` at the given `index` in the array.\n   *\n   * @param index Index in the array to insert the control. If `index` is negative, wraps around\n   *     from the back. If `index` is greatly negative (less than `-length`), prepends to the array.\n   * This behavior is the same as `Array.splice(index, 0, control)`.\n   * @param control Form control to be inserted\n   * @param options Specifies whether this FormArray instance should emit events after a new\n   *     control is inserted.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control is\n   * inserted. When false, no events are emitted.\n   */\n  insert(index, control, options = {}) {\n    this.controls.splice(index, 0, control);\n    this._registerControl(control);\n    this.updateValueAndValidity({\n      emitEvent: options.emitEvent\n    });\n  }\n  /**\n   * Remove the control at the given `index` in the array.\n   *\n   * @param index Index in the array to remove the control.  If `index` is negative, wraps around\n   *     from the back. If `index` is greatly negative (less than `-length`), removes the first\n   *     element. This behavior is the same as `Array.splice(index, 1)`.\n   * @param options Specifies whether this FormArray instance should emit events after a\n   *     control is removed.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control is\n   * removed. When false, no events are emitted.\n   */\n  removeAt(index, options = {}) {\n    let adjustedIndex = this._adjustIndex(index);\n    if (adjustedIndex < 0) adjustedIndex = 0;\n    if (this.controls[adjustedIndex]) this.controls[adjustedIndex]._registerOnCollectionChange(() => {\n    });\n    this.controls.splice(adjustedIndex, 1);\n    this.updateValueAndValidity({\n      emitEvent: options.emitEvent\n    });\n  }\n  /**\n   * Replace an existing control.\n   *\n   * @param index Index in the array to replace the control. If `index` is negative, wraps around\n   *     from the back. If `index` is greatly negative (less than `-length`), replaces the first\n   *     element. This behavior is the same as `Array.splice(index, 1, control)`.\n   * @param control The `AbstractControl` control to replace the existing control\n   * @param options Specifies whether this FormArray instance should emit events after an\n   *     existing control is replaced with a new one.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control is\n   * replaced with a new one. When false, no events are emitted.\n   */\n  setControl(index, control, options = {}) {\n    let adjustedIndex = this._adjustIndex(index);\n    if (adjustedIndex < 0) adjustedIndex = 0;\n    if (this.controls[adjustedIndex]) this.controls[adjustedIndex]._registerOnCollectionChange(() => {\n    });\n    this.controls.splice(adjustedIndex, 1);\n    if (control) {\n      this.controls.splice(adjustedIndex, 0, control);\n      this._registerControl(control);\n    }\n    this.updateValueAndValidity({\n      emitEvent: options.emitEvent\n    });\n    this._onCollectionChange();\n  }\n  /**\n   * Length of the control array.\n   */\n  get length() {\n    return this.controls.length;\n  }\n  /**\n   * Sets the value of the `FormArray`. It accepts an array that matches\n   * the structure of the control.\n   *\n   * This method performs strict checks, and throws an error if you try\n   * to set the value of a control that doesn't exist or if you exclude the\n   * value of a control.\n   *\n   * @usageNotes\n   * ### Set the values for the controls in the form array\n   *\n   * ```ts\n   * const arr = new FormArray([\n   *   new FormControl(),\n   *   new FormControl()\n   * ]);\n   * console.log(arr.value);   // [null, null]\n   *\n   * arr.setValue(['Nancy', 'Drew']);\n   * console.log(arr.value);   // ['Nancy', 'Drew']\n   * ```\n   *\n   * @param value Array of values for the controls\n   * @param options Configure options that determine how the control propagates changes and\n   * emits events after the value changes\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n   * is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control value is updated.\n   * When false, no events are emitted.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   */\n  setValue(value, options = {}) {\n    assertAllValuesPresent(this, false, value);\n    value.forEach((newValue, index) => {\n      assertControlPresent(this, false, index);\n      this.at(index).setValue(newValue, {\n        onlySelf: true,\n        emitEvent: options.emitEvent\n      });\n    });\n    this.updateValueAndValidity(options);\n  }\n  /**\n   * Patches the value of the `FormArray`. It accepts an array that matches the\n   * structure of the control, and does its best to match the values to the correct\n   * controls in the group.\n   *\n   * It accepts both super-sets and sub-sets of the array without throwing an error.\n   *\n   * @usageNotes\n   * ### Patch the values for controls in a form array\n   *\n   * ```ts\n   * const arr = new FormArray([\n   *    new FormControl(),\n   *    new FormControl()\n   * ]);\n   * console.log(arr.value);   // [null, null]\n   *\n   * arr.patchValue(['Nancy']);\n   * console.log(arr.value);   // ['Nancy', null]\n   * ```\n   *\n   * @param value Array of latest values for the controls\n   * @param options Configure options that determine how the control propagates changes and\n   * emits events after the value changes\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n   * is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when the control\n   * value is updated. When false, no events are emitted. The configuration options are passed to\n   * the {@link AbstractControl#updateValueAndValidity updateValueAndValidity} method.\n   */\n  patchValue(value, options = {}) {\n    if (value == null) return;\n    value.forEach((newValue, index) => {\n      if (this.at(index)) {\n        this.at(index).patchValue(newValue, {\n          onlySelf: true,\n          emitEvent: options.emitEvent\n        });\n      }\n    });\n    this.updateValueAndValidity(options);\n  }\n  /**\n   * Resets the `FormArray` and all descendants are marked `pristine` and `untouched`, and the\n   * value of all descendants to null or null maps.\n   *\n   * You reset to a specific form state by passing in an array of states\n   * that matches the structure of the control. The state is a standalone value\n   * or a form state object with both a value and a disabled status.\n   *\n   * @usageNotes\n   * ### Reset the values in a form array\n   *\n   * ```ts\n   * const arr = new FormArray([\n   *    new FormControl(),\n   *    new FormControl()\n   * ]);\n   * arr.reset(['name', 'last name']);\n   *\n   * console.log(arr.value);  // ['name', 'last name']\n   * ```\n   *\n   * ### Reset the values in a form array and the disabled status for the first control\n   *\n   * ```ts\n   * arr.reset([\n   *   {value: 'name', disabled: true},\n   *   'last'\n   * ]);\n   *\n   * console.log(arr.value);  // ['last']\n   * console.log(arr.at(0).status);  // 'DISABLED'\n   * ```\n   *\n   * @param value Array of values for the controls\n   * @param options Configure options that determine how the control propagates changes and\n   * emits events after the value changes\n   *\n   * * `onlySelf`: When true, each change only affects this control, and not its parent. Default\n   * is false.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges`\n   * observables emit events with the latest status and value when the control is reset.\n   * When false, no events are emitted.\n   * The configuration options are passed to the {@link AbstractControl#updateValueAndValidity\n   * updateValueAndValidity} method.\n   */\n  reset(value = [], options = {}) {\n    this._forEachChild((control, index) => {\n      control.reset(value[index], {\n        onlySelf: true,\n        emitEvent: options.emitEvent\n      });\n    });\n    this._updatePristine(options, this);\n    this._updateTouched(options, this);\n    this.updateValueAndValidity(options);\n  }\n  /**\n   * The aggregate value of the array, including any disabled controls.\n   *\n   * Reports all values regardless of disabled status.\n   */\n  getRawValue() {\n    return this.controls.map((control) => control.getRawValue());\n  }\n  /**\n   * Remove all controls in the `FormArray`.\n   *\n   * @param options Specifies whether this FormArray instance should emit events after all\n   *     controls are removed.\n   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and\n   * `valueChanges` observables emit events with the latest status and value when all controls\n   * in this FormArray instance are removed. When false, no events are emitted.\n   *\n   * @usageNotes\n   * ### Remove all elements from a FormArray\n   *\n   * ```ts\n   * const arr = new FormArray([\n   *    new FormControl(),\n   *    new FormControl()\n   * ]);\n   * console.log(arr.length);  // 2\n   *\n   * arr.clear();\n   * console.log(arr.length);  // 0\n   * ```\n   *\n   * It's a simpler and more efficient alternative to removing all elements one by one:\n   *\n   * ```ts\n   * const arr = new FormArray([\n   *    new FormControl(),\n   *    new FormControl()\n   * ]);\n   *\n   * while (arr.length) {\n   *    arr.removeAt(0);\n   * }\n   * ```\n   */\n  clear(options = {}) {\n    if (this.controls.length < 1) return;\n    this._forEachChild((control) => control._registerOnCollectionChange(() => {\n    }));\n    this.controls.splice(0);\n    this.updateValueAndValidity({\n      emitEvent: options.emitEvent\n    });\n  }\n  /**\n   * Adjusts a negative index by summing it with the length of the array. For very negative\n   * indices, the result may remain negative.\n   * @internal\n   */\n  _adjustIndex(index) {\n    return index < 0 ? index + this.length : index;\n  }\n  /** @internal */\n  _syncPendingControls() {\n    let subtreeUpdated = this.controls.reduce((updated, child) => {\n      return child._syncPendingControls() ? true : updated;\n    }, false);\n    if (subtreeUpdated) this.updateValueAndValidity({\n      onlySelf: true\n    });\n    return subtreeUpdated;\n  }\n  /** @internal */\n  _forEachChild(cb) {\n    this.controls.forEach((control, index) => {\n      cb(control, index);\n    });\n  }\n  /** @internal */\n  _updateValue() {\n    this.value = this.controls.filter((control) => control.enabled || this.disabled).map((control) => control.value);\n  }\n  /** @internal */\n  _anyControls(condition) {\n    return this.controls.some((control) => control.enabled && condition(control));\n  }\n  /** @internal */\n  _setUpControls() {\n    this._forEachChild((control) => this._registerControl(control));\n  }\n  /** @internal */\n  _allControlsDisabled() {\n    for (const control of this.controls) {\n      if (control.enabled) return false;\n    }\n    return this.controls.length > 0 || this.disabled;\n  }\n  _registerControl(control) {\n    control.setParent(this);\n    control._registerOnCollectionChange(this._onCollectionChange);\n  }\n  /** @internal */\n  _find(name) {\n    return this.at(name) ?? null;\n  }\n};\nfunction isAbstractControlOptions(options) {\n  return !!options && (options.asyncValidators !== void 0 || options.validators !== void 0 || options.updateOn !== void 0);\n}\nvar FormBuilder = class _FormBuilder {\n  useNonNullable = false;\n  /**\n   * @description\n   * Returns a FormBuilder in which automatically constructed `FormControl` elements\n   * have `{nonNullable: true}` and are non-nullable.\n   *\n   * **Constructing non-nullable controls**\n   *\n   * When constructing a control, it will be non-nullable, and will reset to its initial value.\n   *\n   * ```ts\n   * let nnfb = new FormBuilder().nonNullable;\n   * let name = nnfb.control('Alex'); // FormControl<string>\n   * name.reset();\n   * console.log(name); // 'Alex'\n   * ```\n   *\n   * **Constructing non-nullable groups or arrays**\n   *\n   * When constructing a group or array, all automatically created inner controls will be\n   * non-nullable, and will reset to their initial values.\n   *\n   * ```ts\n   * let nnfb = new FormBuilder().nonNullable;\n   * let name = nnfb.group({who: 'Alex'}); // FormGroup<{who: FormControl<string>}>\n   * name.reset();\n   * console.log(name); // {who: 'Alex'}\n   * ```\n   * **Constructing *nullable* fields on groups or arrays**\n   *\n   * It is still possible to have a nullable field. In particular, any `FormControl` which is\n   * *already* constructed will not be altered. For example:\n   *\n   * ```ts\n   * let nnfb = new FormBuilder().nonNullable;\n   * // FormGroup<{who: FormControl<string|null>}>\n   * let name = nnfb.group({who: new FormControl('Alex')});\n   * name.reset(); console.log(name); // {who: null}\n   * ```\n   *\n   * Because the inner control is constructed explicitly by the caller, the builder has\n   * no control over how it is created, and cannot exclude the `null`.\n   */\n  get nonNullable() {\n    const nnfb = new _FormBuilder();\n    nnfb.useNonNullable = true;\n    return nnfb;\n  }\n  group(controls, options = null) {\n    const reducedControls = this._reduceControls(controls);\n    let newOptions = {};\n    if (isAbstractControlOptions(options)) {\n      newOptions = options;\n    } else if (options !== null) {\n      newOptions.validators = options.validator;\n      newOptions.asyncValidators = options.asyncValidator;\n    }\n    return new FormGroup(reducedControls, newOptions);\n  }\n  /**\n   * @description\n   * Constructs a new `FormRecord` instance. Accepts a single generic argument, which is an object\n   * containing all the keys and corresponding inner control types.\n   *\n   * @param controls A collection of child controls. The key for each child is the name\n   * under which it is registered.\n   *\n   * @param options Configuration options object for the `FormRecord`. The object should have the\n   * `AbstractControlOptions` type and might contain the following fields:\n   * * `validators`: A synchronous validator function, or an array of validator functions.\n   * * `asyncValidators`: A single async validator or array of async validator functions.\n   * * `updateOn`: The event upon which the control should be updated (options: 'change' | 'blur'\n   * | submit').\n   */\n  record(controls, options = null) {\n    const reducedControls = this._reduceControls(controls);\n    return new FormRecord(reducedControls, options);\n  }\n  /**\n   * @description\n   * Constructs a new `FormControl` with the given state, validators and options. Sets\n   * `{nonNullable: true}` in the options to get a non-nullable control. Otherwise, the\n   * control will be nullable. Accepts a single generic argument, which is the type  of the\n   * control's value.\n   *\n   * @param formState Initializes the control with an initial state value, or\n   * with an object that contains both a value and a disabled status.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of\n   * such functions, or a `FormControlOptions` object that contains\n   * validation functions and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator\n   * functions.\n   *\n   * @usageNotes\n   *\n   * ### Initialize a control as disabled\n   *\n   * The following example returns a control with an initial value in a disabled state.\n   *\n   * {@example forms/ts/formBuilder/form_builder_example.ts region='disabled-control'}\n   */\n  control(formState, validatorOrOpts, asyncValidator) {\n    let newOptions = {};\n    if (!this.useNonNullable) {\n      return new FormControl(formState, validatorOrOpts, asyncValidator);\n    }\n    if (isAbstractControlOptions(validatorOrOpts)) {\n      newOptions = validatorOrOpts;\n    } else {\n      newOptions.validators = validatorOrOpts;\n      newOptions.asyncValidators = asyncValidator;\n    }\n    return new FormControl(formState, __spreadProps(__spreadValues({}, newOptions), {\n      nonNullable: true\n    }));\n  }\n  /**\n   * Constructs a new `FormArray` from the given array of configurations,\n   * validators and options. Accepts a single generic argument, which is the type of each control\n   * inside the array.\n   *\n   * @param controls An array of child controls or control configs. Each child control is given an\n   *     index when it is registered.\n   *\n   * @param validatorOrOpts A synchronous validator function, or an array of such functions, or an\n   *     `AbstractControlOptions` object that contains\n   * validation functions and a validation trigger.\n   *\n   * @param asyncValidator A single async validator or array of async validator functions.\n   */\n  array(controls, validatorOrOpts, asyncValidator) {\n    const createdControls = controls.map((c) => this._createControl(c));\n    return new FormArray(createdControls, validatorOrOpts, asyncValidator);\n  }\n  /** @internal */\n  _reduceControls(controls) {\n    const createdControls = {};\n    Object.keys(controls).forEach((controlName) => {\n      createdControls[controlName] = this._createControl(controls[controlName]);\n    });\n    return createdControls;\n  }\n  /** @internal */\n  _createControl(controls) {\n    if (controls instanceof FormControl) {\n      return controls;\n    } else if (controls instanceof AbstractControl) {\n      return controls;\n    } else if (Array.isArray(controls)) {\n      const value = controls[0];\n      const validator = controls.length > 1 ? controls[1] : null;\n      const asyncValidator = controls.length > 2 ? controls[2] : null;\n      return this.control(value, validator, asyncValidator);\n    } else {\n      return this.control(controls);\n    }\n  }\n  static \\u0275fac = function FormBuilder_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _FormBuilder)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _FormBuilder,\n    factory: _FormBuilder.\\u0275fac,\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(FormBuilder, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], null, null);\n})();\nvar NonNullableFormBuilder = class _NonNullableFormBuilder {\n  static \\u0275fac = function NonNullableFormBuilder_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _NonNullableFormBuilder)();\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _NonNullableFormBuilder,\n    factory: () => (() => inject(FormBuilder).nonNullable)(),\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(NonNullableFormBuilder, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\",\n      useFactory: () => inject(FormBuilder).nonNullable\n    }]\n  }], null, null);\n})();\nvar UntypedFormBuilder = class _UntypedFormBuilder extends FormBuilder {\n  group(controlsConfig, options = null) {\n    return super.group(controlsConfig, options);\n  }\n  /**\n   * Like `FormBuilder#control`, except the resulting control is untyped.\n   */\n  control(formState, validatorOrOpts, asyncValidator) {\n    return super.control(formState, validatorOrOpts, asyncValidator);\n  }\n  /**\n   * Like `FormBuilder#array`, except the resulting array is untyped.\n   */\n  array(controlsConfig, validatorOrOpts, asyncValidator) {\n    return super.array(controlsConfig, validatorOrOpts, asyncValidator);\n  }\n  static \\u0275fac = /* @__PURE__ */ (() => {\n    let \\u0275UntypedFormBuilder_BaseFactory;\n    return function UntypedFormBuilder_Factory(__ngFactoryType__) {\n      return (\\u0275UntypedFormBuilder_BaseFactory || (\\u0275UntypedFormBuilder_BaseFactory = \\u0275\\u0275getInheritedFactory(_UntypedFormBuilder)))(__ngFactoryType__ || _UntypedFormBuilder);\n    };\n  })();\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n    token: _UntypedFormBuilder,\n    factory: _UntypedFormBuilder.\\u0275fac,\n    providedIn: \"root\"\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(UntypedFormBuilder, [{\n    type: Injectable,\n    args: [{\n      providedIn: \"root\"\n    }]\n  }], null, null);\n})();\nvar VERSION5 = new Version(\"19.2.3\");\nvar FormsModule = class _FormsModule {\n  /**\n   * @description\n   * Provides options for configuring the forms module.\n   *\n   * @param opts An object of configuration options\n   * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more\n   * correct, or to only call it `whenDisabled`, which is the legacy behavior.\n   */\n  static withConfig(opts) {\n    return {\n      ngModule: _FormsModule,\n      providers: [{\n        provide: CALL_SET_DISABLED_STATE,\n        useValue: opts.callSetDisabledState ?? setDisabledStateDefault\n      }]\n    };\n  }\n  static \\u0275fac = function FormsModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _FormsModule)();\n  };\n  static \\u0275mod = /* @__PURE__ */ \\u0275\\u0275defineNgModule({\n    type: _FormsModule\n  });\n  static \\u0275inj = /* @__PURE__ */ \\u0275\\u0275defineInjector({\n    imports: [\\u0275InternalFormsSharedModule]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(FormsModule, [{\n    type: NgModule,\n    args: [{\n      declarations: TEMPLATE_DRIVEN_DIRECTIVES,\n      exports: [\\u0275InternalFormsSharedModule, TEMPLATE_DRIVEN_DIRECTIVES]\n    }]\n  }], null, null);\n})();\nvar ReactiveFormsModule = class _ReactiveFormsModule {\n  /**\n   * @description\n   * Provides options for configuring the reactive forms module.\n   *\n   * @param opts An object of configuration options\n   * * `warnOnNgModelWithFormControl` Configures when to emit a warning when an `ngModel`\n   * binding is used with reactive form directives.\n   * * `callSetDisabledState` Configures whether to `always` call `setDisabledState`, which is more\n   * correct, or to only call it `whenDisabled`, which is the legacy behavior.\n   */\n  static withConfig(opts) {\n    return {\n      ngModule: _ReactiveFormsModule,\n      providers: [{\n        provide: NG_MODEL_WITH_FORM_CONTROL_WARNING,\n        useValue: opts.warnOnNgModelWithFormControl ?? \"always\"\n      }, {\n        provide: CALL_SET_DISABLED_STATE,\n        useValue: opts.callSetDisabledState ?? setDisabledStateDefault\n      }]\n    };\n  }\n  static \\u0275fac = function ReactiveFormsModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _ReactiveFormsModule)();\n  };\n  static \\u0275mod = /* @__PURE__ */ \\u0275\\u0275defineNgModule({\n    type: _ReactiveFormsModule\n  });\n  static \\u0275inj = /* @__PURE__ */ \\u0275\\u0275defineInjector({\n    imports: [\\u0275InternalFormsSharedModule]\n  });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(ReactiveFormsModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [REACTIVE_DRIVEN_DIRECTIVES],\n      exports: [\\u0275InternalFormsSharedModule, REACTIVE_DRIVEN_DIRECTIVES]\n    }]\n  }], null, null);\n})();\n\n// node_modules/@angular/core/fesm2022/rxjs-interop.mjs\nfunction toSignal(source, options) {\n  ngDevMode && assertNotInReactiveContext(toSignal, \"Invoking `toSignal` causes new subscriptions every time. Consider moving `toSignal` outside of the reactive context and read the signal value where needed.\");\n  const requiresCleanup = !options?.manualCleanup;\n  requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\n  const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;\n  const equal = makeToSignalEqual(options?.equal);\n  let state;\n  if (options?.requireSync) {\n    state = signal({\n      kind: 0\n      /* StateKind.NoValue */\n    }, {\n      equal\n    });\n  } else {\n    state = signal({\n      kind: 1,\n      value: options?.initialValue\n    }, {\n      equal\n    });\n  }\n  const sub = source.subscribe({\n    next: (value) => state.set({\n      kind: 1,\n      value\n    }),\n    error: (error) => {\n      if (options?.rejectErrors) {\n        throw error;\n      }\n      state.set({\n        kind: 2,\n        error\n      });\n    }\n    // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n    // \"complete\".\n  });\n  if (options?.requireSync && state().kind === 0) {\n    throw new RuntimeError(601, (typeof ngDevMode === \"undefined\" || ngDevMode) && \"`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.\");\n  }\n  cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n  return computed(() => {\n    const current = state();\n    switch (current.kind) {\n      case 1:\n        return current.value;\n      case 2:\n        throw current.error;\n      case 0:\n        throw new RuntimeError(601, (typeof ngDevMode === \"undefined\" || ngDevMode) && \"`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.\");\n    }\n  }, {\n    equal: options?.equal\n  });\n}\nfunction makeToSignalEqual(userEquality = Object.is) {\n  return (a, b) => a.kind === 1 && b.kind === 1 && userEquality(a.value, b.value);\n}\n\n// node_modules/@ngrx/store/fesm2022/ngrx-store.mjs\nvar REGISTERED_ACTION_TYPES = {};\nfunction createAction(type, config2) {\n  REGISTERED_ACTION_TYPES[type] = (REGISTERED_ACTION_TYPES[type] || 0) + 1;\n  if (typeof config2 === \"function\") {\n    return defineType(type, (...args) => __spreadProps(__spreadValues({}, config2(...args)), {\n      type\n    }));\n  }\n  const as = config2 ? config2._as : \"empty\";\n  switch (as) {\n    case \"empty\":\n      return defineType(type, () => ({\n        type\n      }));\n    case \"props\":\n      return defineType(type, (props2) => __spreadProps(__spreadValues({}, props2), {\n        type\n      }));\n    default:\n      throw new Error(\"Unexpected config.\");\n  }\n}\nfunction props() {\n  return {\n    _as: \"props\",\n    _p: void 0\n  };\n}\nfunction defineType(type, creator) {\n  return Object.defineProperty(creator, \"type\", {\n    value: type,\n    writable: false\n  });\n}\nfunction assertDefined2(value, name) {\n  if (value === null || value === void 0) {\n    throw new Error(`${name} must be defined.`);\n  }\n}\nvar INIT = \"@ngrx/store/init\";\nvar ActionsSubject = class _ActionsSubject extends BehaviorSubject {\n  constructor() {\n    super({\n      type: INIT\n    });\n  }\n  next(action) {\n    if (typeof action === \"function\") {\n      throw new TypeError(`\n        Dispatch expected an object, instead it received a function.\n        If you're using the createAction function, make sure to invoke the function\n        before dispatching the action. For example, someAction should be someAction().`);\n    } else if (typeof action === \"undefined\") {\n      throw new TypeError(`Actions must be objects`);\n    } else if (typeof action.type === \"undefined\") {\n      throw new TypeError(`Actions must have a type property`);\n    }\n    super.next(action);\n  }\n  complete() {\n  }\n  ngOnDestroy() {\n    super.complete();\n  }\n  static {\n    this.\\u0275fac = function ActionsSubject_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _ActionsSubject)();\n    };\n  }\n  static {\n    this.\\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n      token: _ActionsSubject,\n      factory: _ActionsSubject.\\u0275fac\n    });\n  }\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(ActionsSubject, [{\n    type: Injectable\n  }], () => [], null);\n})();\nvar ACTIONS_SUBJECT_PROVIDERS = [ActionsSubject];\nvar _ROOT_STORE_GUARD = new InjectionToken(\"@ngrx/store Internal Root Guard\");\nvar _INITIAL_STATE = new InjectionToken(\"@ngrx/store Internal Initial State\");\nvar INITIAL_STATE = new InjectionToken(\"@ngrx/store Initial State\");\nvar REDUCER_FACTORY = new InjectionToken(\"@ngrx/store Reducer Factory\");\nvar _REDUCER_FACTORY = new InjectionToken(\"@ngrx/store Internal Reducer Factory Provider\");\nvar INITIAL_REDUCERS = new InjectionToken(\"@ngrx/store Initial Reducers\");\nvar _INITIAL_REDUCERS = new InjectionToken(\"@ngrx/store Internal Initial Reducers\");\nvar STORE_FEATURES = new InjectionToken(\"@ngrx/store Store Features\");\nvar _STORE_REDUCERS = new InjectionToken(\"@ngrx/store Internal Store Reducers\");\nvar _FEATURE_REDUCERS = new InjectionToken(\"@ngrx/store Internal Feature Reducers\");\nvar _FEATURE_CONFIGS = new InjectionToken(\"@ngrx/store Internal Feature Configs\");\nvar _STORE_FEATURES = new InjectionToken(\"@ngrx/store Internal Store Features\");\nvar _FEATURE_REDUCERS_TOKEN = new InjectionToken(\"@ngrx/store Internal Feature Reducers Token\");\nvar FEATURE_REDUCERS = new InjectionToken(\"@ngrx/store Feature Reducers\");\nvar USER_PROVIDED_META_REDUCERS = new InjectionToken(\"@ngrx/store User Provided Meta Reducers\");\nvar META_REDUCERS = new InjectionToken(\"@ngrx/store Meta Reducers\");\nvar _RESOLVED_META_REDUCERS = new InjectionToken(\"@ngrx/store Internal Resolved Meta Reducers\");\nvar USER_RUNTIME_CHECKS = new InjectionToken(\"@ngrx/store User Runtime Checks Config\");\nvar _USER_RUNTIME_CHECKS = new InjectionToken(\"@ngrx/store Internal User Runtime Checks Config\");\nvar ACTIVE_RUNTIME_CHECKS = new InjectionToken(\"@ngrx/store Internal Runtime Checks\");\nvar _ACTION_TYPE_UNIQUENESS_CHECK = new InjectionToken(\"@ngrx/store Check if Action types are unique\");\nvar ROOT_STORE_PROVIDER = new InjectionToken(\"@ngrx/store Root Store Provider\");\nvar FEATURE_STATE_PROVIDER = new InjectionToken(\"@ngrx/store Feature State Provider\");\nfunction combineReducers(reducers, initialState2 = {}) {\n  const reducerKeys = Object.keys(reducers);\n  const finalReducers = {};\n  for (let i = 0; i < reducerKeys.length; i++) {\n    const key = reducerKeys[i];\n    if (typeof reducers[key] === \"function\") {\n      finalReducers[key] = reducers[key];\n    }\n  }\n  const finalReducerKeys = Object.keys(finalReducers);\n  return function combination(state, action) {\n    state = state === void 0 ? initialState2 : state;\n    let hasChanged = false;\n    const nextState = {};\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i];\n      const reducer = finalReducers[key];\n      const previousStateForKey = state[key];\n      const nextStateForKey = reducer(previousStateForKey, action);\n      nextState[key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n    return hasChanged ? nextState : state;\n  };\n}\nfunction omit(object, keyToRemove) {\n  return Object.keys(object).filter((key) => key !== keyToRemove).reduce((result, key) => Object.assign(result, {\n    [key]: object[key]\n  }), {});\n}\nfunction compose2(...functions) {\n  return function(arg) {\n    if (functions.length === 0) {\n      return arg;\n    }\n    const last4 = functions[functions.length - 1];\n    const rest = functions.slice(0, -1);\n    return rest.reduceRight((composed, fn) => fn(composed), last4(arg));\n  };\n}\nfunction createReducerFactory(reducerFactory, metaReducers) {\n  if (Array.isArray(metaReducers) && metaReducers.length > 0) {\n    reducerFactory = compose2.apply(null, [...metaReducers, reducerFactory]);\n  }\n  return (reducers, initialState2) => {\n    const reducer = reducerFactory(reducers);\n    return (state, action) => {\n      state = state === void 0 ? initialState2 : state;\n      return reducer(state, action);\n    };\n  };\n}\nfunction createFeatureReducerFactory(metaReducers) {\n  const reducerFactory = Array.isArray(metaReducers) && metaReducers.length > 0 ? compose2(...metaReducers) : (r) => r;\n  return (reducer, initialState2) => {\n    reducer = reducerFactory(reducer);\n    return (state, action) => {\n      state = state === void 0 ? initialState2 : state;\n      return reducer(state, action);\n    };\n  };\n}\nvar ReducerObservable = class extends Observable {\n};\nvar ReducerManagerDispatcher = class extends ActionsSubject {\n};\nvar UPDATE = \"@ngrx/store/update-reducers\";\nvar ReducerManager = class _ReducerManager extends BehaviorSubject {\n  get currentReducers() {\n    return this.reducers;\n  }\n  constructor(dispatcher, initialState2, reducers, reducerFactory) {\n    super(reducerFactory(reducers, initialState2));\n    this.dispatcher = dispatcher;\n    this.initialState = initialState2;\n    this.reducers = reducers;\n    this.reducerFactory = reducerFactory;\n  }\n  addFeature(feature) {\n    this.addFeatures([feature]);\n  }\n  addFeatures(features) {\n    const reducers = features.reduce((reducerDict, {\n      reducers: reducers2,\n      reducerFactory,\n      metaReducers,\n      initialState: initialState2,\n      key\n    }) => {\n      const reducer = typeof reducers2 === \"function\" ? createFeatureReducerFactory(metaReducers)(reducers2, initialState2) : createReducerFactory(reducerFactory, metaReducers)(reducers2, initialState2);\n      reducerDict[key] = reducer;\n      return reducerDict;\n    }, {});\n    this.addReducers(reducers);\n  }\n  removeFeature(feature) {\n    this.removeFeatures([feature]);\n  }\n  removeFeatures(features) {\n    this.removeReducers(features.map((p) => p.key));\n  }\n  addReducer(key, reducer) {\n    this.addReducers({\n      [key]: reducer\n    });\n  }\n  addReducers(reducers) {\n    this.reducers = __spreadValues(__spreadValues({}, this.reducers), reducers);\n    this.updateReducers(Object.keys(reducers));\n  }\n  removeReducer(featureKey) {\n    this.removeReducers([featureKey]);\n  }\n  removeReducers(featureKeys) {\n    featureKeys.forEach((key) => {\n      this.reducers = omit(this.reducers, key);\n    });\n    this.updateReducers(featureKeys);\n  }\n  updateReducers(featureKeys) {\n    this.next(this.reducerFactory(this.reducers, this.initialState));\n    this.dispatcher.next({\n      type: UPDATE,\n      features: featureKeys\n    });\n  }\n  ngOnDestroy() {\n    this.complete();\n  }\n  static {\n    this.\\u0275fac = function ReducerManager_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _ReducerManager)(\\u0275\\u0275inject(ReducerManagerDispatcher), \\u0275\\u0275inject(INITIAL_STATE), \\u0275\\u0275inject(INITIAL_REDUCERS), \\u0275\\u0275inject(REDUCER_FACTORY));\n    };\n  }\n  static {\n    this.\\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n      token: _ReducerManager,\n      factory: _ReducerManager.\\u0275fac\n    });\n  }\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(ReducerManager, [{\n    type: Injectable\n  }], () => [{\n    type: ReducerManagerDispatcher\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [INITIAL_STATE]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [INITIAL_REDUCERS]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [REDUCER_FACTORY]\n    }]\n  }], null);\n})();\nvar REDUCER_MANAGER_PROVIDERS = [ReducerManager, {\n  provide: ReducerObservable,\n  useExisting: ReducerManager\n}, {\n  provide: ReducerManagerDispatcher,\n  useExisting: ActionsSubject\n}];\nvar ScannedActionsSubject = class _ScannedActionsSubject extends Subject {\n  ngOnDestroy() {\n    this.complete();\n  }\n  static {\n    this.\\u0275fac = /* @__PURE__ */ (() => {\n      let \\u0275ScannedActionsSubject_BaseFactory;\n      return function ScannedActionsSubject_Factory(__ngFactoryType__) {\n        return (\\u0275ScannedActionsSubject_BaseFactory || (\\u0275ScannedActionsSubject_BaseFactory = \\u0275\\u0275getInheritedFactory(_ScannedActionsSubject)))(__ngFactoryType__ || _ScannedActionsSubject);\n      };\n    })();\n  }\n  static {\n    this.\\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n      token: _ScannedActionsSubject,\n      factory: _ScannedActionsSubject.\\u0275fac\n    });\n  }\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(ScannedActionsSubject, [{\n    type: Injectable\n  }], null, null);\n})();\nvar SCANNED_ACTIONS_SUBJECT_PROVIDERS = [ScannedActionsSubject];\nvar StateObservable = class extends Observable {\n};\nvar State = class _State extends BehaviorSubject {\n  static {\n    this.INIT = INIT;\n  }\n  constructor(actions$, reducer$, scannedActions, initialState2) {\n    super(initialState2);\n    const actionsOnQueue$ = actions$.pipe(observeOn(queueScheduler));\n    const withLatestReducer$ = actionsOnQueue$.pipe(withLatestFrom(reducer$));\n    const seed = {\n      state: initialState2\n    };\n    const stateAndAction$ = withLatestReducer$.pipe(scan(reduceState, seed));\n    this.stateSubscription = stateAndAction$.subscribe(({\n      state,\n      action\n    }) => {\n      this.next(state);\n      scannedActions.next(action);\n    });\n    this.state = toSignal(this, {\n      manualCleanup: true,\n      requireSync: true\n    });\n  }\n  ngOnDestroy() {\n    this.stateSubscription.unsubscribe();\n    this.complete();\n  }\n  static {\n    this.\\u0275fac = function State_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _State)(\\u0275\\u0275inject(ActionsSubject), \\u0275\\u0275inject(ReducerObservable), \\u0275\\u0275inject(ScannedActionsSubject), \\u0275\\u0275inject(INITIAL_STATE));\n    };\n  }\n  static {\n    this.\\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n      token: _State,\n      factory: _State.\\u0275fac\n    });\n  }\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(State, [{\n    type: Injectable\n  }], () => [{\n    type: ActionsSubject\n  }, {\n    type: ReducerObservable\n  }, {\n    type: ScannedActionsSubject\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [INITIAL_STATE]\n    }]\n  }], null);\n})();\nfunction reduceState(stateActionPair = {\n  state: void 0\n}, [action, reducer]) {\n  const {\n    state\n  } = stateActionPair;\n  return {\n    state: reducer(state, action),\n    action\n  };\n}\nvar STATE_PROVIDERS = [State, {\n  provide: StateObservable,\n  useExisting: State\n}];\nvar Store = class _Store extends Observable {\n  constructor(state$, actionsObserver, reducerManager, injector) {\n    super();\n    this.actionsObserver = actionsObserver;\n    this.reducerManager = reducerManager;\n    this.injector = injector;\n    this.source = state$;\n    this.state = state$.state;\n  }\n  select(pathOrMapFn, ...paths) {\n    return select.call(null, pathOrMapFn, ...paths)(this);\n  }\n  /**\n   * Returns a signal of the provided selector.\n   *\n   * @param selector selector function\n   * @param options select signal options\n   */\n  selectSignal(selector, options) {\n    return computed(() => selector(this.state()), options);\n  }\n  lift(operator) {\n    const store2 = new _Store(this, this.actionsObserver, this.reducerManager);\n    store2.operator = operator;\n    return store2;\n  }\n  dispatch(actionOrDispatchFn, config2) {\n    if (typeof actionOrDispatchFn === \"function\") {\n      return this.processDispatchFn(actionOrDispatchFn, config2);\n    }\n    this.actionsObserver.next(actionOrDispatchFn);\n  }\n  next(action) {\n    this.actionsObserver.next(action);\n  }\n  error(err) {\n    this.actionsObserver.error(err);\n  }\n  complete() {\n    this.actionsObserver.complete();\n  }\n  addReducer(key, reducer) {\n    this.reducerManager.addReducer(key, reducer);\n  }\n  removeReducer(key) {\n    this.reducerManager.removeReducer(key);\n  }\n  processDispatchFn(dispatchFn, config2) {\n    assertDefined2(this.injector, \"Store Injector\");\n    const effectInjector = config2?.injector ?? getCallerInjector() ?? this.injector;\n    return effect(() => {\n      const action = dispatchFn();\n      untracked2(() => this.dispatch(action));\n    }, {\n      injector: effectInjector\n    });\n  }\n  static {\n    this.\\u0275fac = function Store_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _Store)(\\u0275\\u0275inject(StateObservable), \\u0275\\u0275inject(ActionsSubject), \\u0275\\u0275inject(ReducerManager), \\u0275\\u0275inject(Injector));\n    };\n  }\n  static {\n    this.\\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n      token: _Store,\n      factory: _Store.\\u0275fac\n    });\n  }\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(Store, [{\n    type: Injectable\n  }], () => [{\n    type: StateObservable\n  }, {\n    type: ActionsSubject\n  }, {\n    type: ReducerManager\n  }, {\n    type: Injector\n  }], null);\n})();\nvar STORE_PROVIDERS = [Store];\nfunction select(pathOrMapFn, propsOrPath, ...paths) {\n  return function selectOperator(source$) {\n    let mapped$;\n    if (typeof pathOrMapFn === \"string\") {\n      const pathSlices = [propsOrPath, ...paths].filter(Boolean);\n      mapped$ = source$.pipe(pluck(pathOrMapFn, ...pathSlices));\n    } else if (typeof pathOrMapFn === \"function\") {\n      mapped$ = source$.pipe(map((source) => pathOrMapFn(source, propsOrPath)));\n    } else {\n      throw new TypeError(`Unexpected type '${typeof pathOrMapFn}' in select operator, expected 'string' or 'function'`);\n    }\n    return mapped$.pipe(distinctUntilChanged());\n  };\n}\nfunction getCallerInjector() {\n  try {\n    return inject(Injector);\n  } catch (_) {\n    return void 0;\n  }\n}\nvar RUNTIME_CHECK_URL = \"https://ngrx.io/guide/store/configuration/runtime-checks\";\nfunction isUndefined(target) {\n  return target === void 0;\n}\nfunction isNull(target) {\n  return target === null;\n}\nfunction isArray3(target) {\n  return Array.isArray(target);\n}\nfunction isString(target) {\n  return typeof target === \"string\";\n}\nfunction isBoolean2(target) {\n  return typeof target === \"boolean\";\n}\nfunction isNumber(target) {\n  return typeof target === \"number\";\n}\nfunction isObjectLike(target) {\n  return typeof target === \"object\" && target !== null;\n}\nfunction isObject(target) {\n  return isObjectLike(target) && !isArray3(target);\n}\nfunction isPlainObject(target) {\n  if (!isObject(target)) {\n    return false;\n  }\n  const targetPrototype = Object.getPrototypeOf(target);\n  return targetPrototype === Object.prototype || targetPrototype === null;\n}\nfunction isFunction3(target) {\n  return typeof target === \"function\";\n}\nfunction isComponent2(target) {\n  return isFunction3(target) && target.hasOwnProperty(\"\\u0275cmp\");\n}\nfunction hasOwnProperty(target, propertyName) {\n  return Object.prototype.hasOwnProperty.call(target, propertyName);\n}\nvar _ngrxMockEnvironment = false;\nfunction isNgrxMockEnvironment() {\n  return _ngrxMockEnvironment;\n}\nfunction isEqualCheck(a, b) {\n  return a === b;\n}\nfunction isArgumentsChanged(args, lastArguments, comparator) {\n  for (let i = 0; i < args.length; i++) {\n    if (!comparator(args[i], lastArguments[i])) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction defaultMemoize(projectionFn, isArgumentsEqual = isEqualCheck, isResultEqual = isEqualCheck) {\n  let lastArguments = null;\n  let lastResult = null;\n  let overrideResult;\n  function reset() {\n    lastArguments = null;\n    lastResult = null;\n  }\n  function setResult(result = void 0) {\n    overrideResult = {\n      result\n    };\n  }\n  function clearResult() {\n    overrideResult = void 0;\n  }\n  function memoized() {\n    if (overrideResult !== void 0) {\n      return overrideResult.result;\n    }\n    if (!lastArguments) {\n      lastResult = projectionFn.apply(null, arguments);\n      lastArguments = arguments;\n      return lastResult;\n    }\n    if (!isArgumentsChanged(arguments, lastArguments, isArgumentsEqual)) {\n      return lastResult;\n    }\n    const newResult = projectionFn.apply(null, arguments);\n    lastArguments = arguments;\n    if (isResultEqual(lastResult, newResult)) {\n      return lastResult;\n    }\n    lastResult = newResult;\n    return newResult;\n  }\n  return {\n    memoized,\n    reset,\n    setResult,\n    clearResult\n  };\n}\nfunction createSelector(...input2) {\n  return createSelectorFactory(defaultMemoize)(...input2);\n}\nfunction defaultStateFn(state, selectors, props2, memoizedProjector) {\n  if (props2 === void 0) {\n    const args2 = selectors.map((fn) => fn(state));\n    return memoizedProjector.memoized.apply(null, args2);\n  }\n  const args = selectors.map((fn) => fn(state, props2));\n  return memoizedProjector.memoized.apply(null, [...args, props2]);\n}\nfunction createSelectorFactory(memoize, options = {\n  stateFn: defaultStateFn\n}) {\n  return function(...input2) {\n    let args = input2;\n    if (Array.isArray(args[0])) {\n      const [head, ...tail] = args;\n      args = [...head, ...tail];\n    } else if (args.length === 1 && isSelectorsDictionary(args[0])) {\n      args = extractArgsFromSelectorsDictionary(args[0]);\n    }\n    const selectors = args.slice(0, args.length - 1);\n    const projector = args[args.length - 1];\n    const memoizedSelectors = selectors.filter((selector) => selector.release && typeof selector.release === \"function\");\n    const memoizedProjector = memoize(function(...selectors2) {\n      return projector.apply(null, selectors2);\n    });\n    const memoizedState = defaultMemoize(function(state, props2) {\n      return options.stateFn.apply(null, [state, selectors, props2, memoizedProjector]);\n    });\n    function release() {\n      memoizedState.reset();\n      memoizedProjector.reset();\n      memoizedSelectors.forEach((selector) => selector.release());\n    }\n    return Object.assign(memoizedState.memoized, {\n      release,\n      projector: memoizedProjector.memoized,\n      setResult: memoizedState.setResult,\n      clearResult: memoizedState.clearResult\n    });\n  };\n}\nfunction createFeatureSelector(featureName) {\n  return createSelector((state) => {\n    const featureState = state[featureName];\n    if (!isNgrxMockEnvironment() && isDevMode() && !(featureName in state)) {\n      console.warn(`@ngrx/store: The feature name \"${featureName}\" does not exist in the state, therefore createFeatureSelector cannot access it.  Be sure it is imported in a loaded module using StoreModule.forRoot('${featureName}', ...) or StoreModule.forFeature('${featureName}', ...).  If the default state is intended to be undefined, as is the case with router state, this development-only warning message can be ignored.`);\n    }\n    return featureState;\n  }, (featureState) => featureState);\n}\nfunction isSelectorsDictionary(selectors) {\n  return !!selectors && typeof selectors === \"object\" && Object.values(selectors).every((selector) => typeof selector === \"function\");\n}\nfunction extractArgsFromSelectorsDictionary(selectorsDictionary) {\n  const selectors = Object.values(selectorsDictionary);\n  const resultKeys = Object.keys(selectorsDictionary);\n  const projector = (...selectorResults) => resultKeys.reduce((result, key, index) => __spreadProps(__spreadValues({}, result), {\n    [key]: selectorResults[index]\n  }), {});\n  return [...selectors, projector];\n}\nfunction _createStoreReducers(reducers) {\n  return reducers instanceof InjectionToken ? inject(reducers) : reducers;\n}\nfunction _createFeatureStore(configs, featureStores) {\n  return featureStores.map((feat, index) => {\n    if (configs[index] instanceof InjectionToken) {\n      const conf = inject(configs[index]);\n      return {\n        key: feat.key,\n        reducerFactory: conf.reducerFactory ? conf.reducerFactory : combineReducers,\n        metaReducers: conf.metaReducers ? conf.metaReducers : [],\n        initialState: conf.initialState\n      };\n    }\n    return feat;\n  });\n}\nfunction _createFeatureReducers(reducerCollection) {\n  return reducerCollection.map((reducer) => {\n    return reducer instanceof InjectionToken ? inject(reducer) : reducer;\n  });\n}\nfunction _initialStateFactory(initialState2) {\n  if (typeof initialState2 === \"function\") {\n    return initialState2();\n  }\n  return initialState2;\n}\nfunction _concatMetaReducers(metaReducers, userProvidedMetaReducers) {\n  return metaReducers.concat(userProvidedMetaReducers);\n}\nfunction _provideForRootGuard() {\n  const store2 = inject(Store, {\n    optional: true,\n    skipSelf: true\n  });\n  if (store2) {\n    throw new TypeError(`The root Store has been provided more than once. Feature modules should provide feature states instead.`);\n  }\n  return \"guarded\";\n}\nfunction immutabilityCheckMetaReducer(reducer, checks) {\n  return function(state, action) {\n    const act = checks.action(action) ? freeze(action) : action;\n    const nextState = reducer(state, act);\n    return checks.state() ? freeze(nextState) : nextState;\n  };\n}\nfunction freeze(target) {\n  Object.freeze(target);\n  const targetIsFunction = isFunction3(target);\n  Object.getOwnPropertyNames(target).forEach((prop) => {\n    if (prop.startsWith(\"\\u0275\")) {\n      return;\n    }\n    if (hasOwnProperty(target, prop) && (targetIsFunction ? prop !== \"caller\" && prop !== \"callee\" && prop !== \"arguments\" : true)) {\n      const propValue = target[prop];\n      if ((isObjectLike(propValue) || isFunction3(propValue)) && !Object.isFrozen(propValue)) {\n        freeze(propValue);\n      }\n    }\n  });\n  return target;\n}\nfunction serializationCheckMetaReducer(reducer, checks) {\n  return function(state, action) {\n    if (checks.action(action)) {\n      const unserializableAction = getUnserializable(action);\n      throwIfUnserializable(unserializableAction, \"action\");\n    }\n    const nextState = reducer(state, action);\n    if (checks.state()) {\n      const unserializableState = getUnserializable(nextState);\n      throwIfUnserializable(unserializableState, \"state\");\n    }\n    return nextState;\n  };\n}\nfunction getUnserializable(target, path = []) {\n  if ((isUndefined(target) || isNull(target)) && path.length === 0) {\n    return {\n      path: [\"root\"],\n      value: target\n    };\n  }\n  const keys = Object.keys(target);\n  return keys.reduce((result, key) => {\n    if (result) {\n      return result;\n    }\n    const value = target[key];\n    if (isComponent2(value)) {\n      return result;\n    }\n    if (isUndefined(value) || isNull(value) || isNumber(value) || isBoolean2(value) || isString(value) || isArray3(value)) {\n      return false;\n    }\n    if (isPlainObject(value)) {\n      return getUnserializable(value, [...path, key]);\n    }\n    return {\n      path: [...path, key],\n      value\n    };\n  }, false);\n}\nfunction throwIfUnserializable(unserializable, context2) {\n  if (unserializable === false) {\n    return;\n  }\n  const unserializablePath = unserializable.path.join(\".\");\n  const error = new Error(`Detected unserializable ${context2} at \"${unserializablePath}\". ${RUNTIME_CHECK_URL}#strict${context2}serializability`);\n  error.value = unserializable.value;\n  error.unserializablePath = unserializablePath;\n  throw error;\n}\nfunction inNgZoneAssertMetaReducer(reducer, checks) {\n  return function(state, action) {\n    if (checks.action(action) && !NgZone.isInAngularZone()) {\n      throw new Error(`Action '${action.type}' running outside NgZone. ${RUNTIME_CHECK_URL}#strictactionwithinngzone`);\n    }\n    return reducer(state, action);\n  };\n}\nfunction createActiveRuntimeChecks(runtimeChecks) {\n  if (isDevMode()) {\n    return __spreadValues({\n      strictStateSerializability: false,\n      strictActionSerializability: false,\n      strictStateImmutability: true,\n      strictActionImmutability: true,\n      strictActionWithinNgZone: false,\n      strictActionTypeUniqueness: false\n    }, runtimeChecks);\n  }\n  return {\n    strictStateSerializability: false,\n    strictActionSerializability: false,\n    strictStateImmutability: false,\n    strictActionImmutability: false,\n    strictActionWithinNgZone: false,\n    strictActionTypeUniqueness: false\n  };\n}\nfunction createSerializationCheckMetaReducer({\n  strictActionSerializability,\n  strictStateSerializability\n}) {\n  return (reducer) => strictActionSerializability || strictStateSerializability ? serializationCheckMetaReducer(reducer, {\n    action: (action) => strictActionSerializability && !ignoreNgrxAction(action),\n    state: () => strictStateSerializability\n  }) : reducer;\n}\nfunction createImmutabilityCheckMetaReducer({\n  strictActionImmutability,\n  strictStateImmutability\n}) {\n  return (reducer) => strictActionImmutability || strictStateImmutability ? immutabilityCheckMetaReducer(reducer, {\n    action: (action) => strictActionImmutability && !ignoreNgrxAction(action),\n    state: () => strictStateImmutability\n  }) : reducer;\n}\nfunction ignoreNgrxAction(action) {\n  return action.type.startsWith(\"@ngrx\");\n}\nfunction createInNgZoneCheckMetaReducer({\n  strictActionWithinNgZone\n}) {\n  return (reducer) => strictActionWithinNgZone ? inNgZoneAssertMetaReducer(reducer, {\n    action: (action) => strictActionWithinNgZone && !ignoreNgrxAction(action)\n  }) : reducer;\n}\nfunction provideRuntimeChecks(runtimeChecks) {\n  return [{\n    provide: _USER_RUNTIME_CHECKS,\n    useValue: runtimeChecks\n  }, {\n    provide: USER_RUNTIME_CHECKS,\n    useFactory: _runtimeChecksFactory,\n    deps: [_USER_RUNTIME_CHECKS]\n  }, {\n    provide: ACTIVE_RUNTIME_CHECKS,\n    deps: [USER_RUNTIME_CHECKS],\n    useFactory: createActiveRuntimeChecks\n  }, {\n    provide: META_REDUCERS,\n    multi: true,\n    deps: [ACTIVE_RUNTIME_CHECKS],\n    useFactory: createImmutabilityCheckMetaReducer\n  }, {\n    provide: META_REDUCERS,\n    multi: true,\n    deps: [ACTIVE_RUNTIME_CHECKS],\n    useFactory: createSerializationCheckMetaReducer\n  }, {\n    provide: META_REDUCERS,\n    multi: true,\n    deps: [ACTIVE_RUNTIME_CHECKS],\n    useFactory: createInNgZoneCheckMetaReducer\n  }];\n}\nfunction checkForActionTypeUniqueness() {\n  return [{\n    provide: _ACTION_TYPE_UNIQUENESS_CHECK,\n    multi: true,\n    deps: [ACTIVE_RUNTIME_CHECKS],\n    useFactory: _actionTypeUniquenessCheck\n  }];\n}\nfunction _runtimeChecksFactory(runtimeChecks) {\n  return runtimeChecks;\n}\nfunction _actionTypeUniquenessCheck(config2) {\n  if (!config2.strictActionTypeUniqueness) {\n    return;\n  }\n  const duplicates = Object.entries(REGISTERED_ACTION_TYPES).filter(([, registrations]) => registrations > 1).map(([type]) => type);\n  if (duplicates.length) {\n    throw new Error(`Action types are registered more than once, ${duplicates.map((type) => `\"${type}\"`).join(\", \")}. ${RUNTIME_CHECK_URL}#strictactiontypeuniqueness`);\n  }\n}\nfunction _provideStore(reducers = {}, config2 = {}) {\n  return [{\n    provide: _ROOT_STORE_GUARD,\n    useFactory: _provideForRootGuard\n  }, {\n    provide: _INITIAL_STATE,\n    useValue: config2.initialState\n  }, {\n    provide: INITIAL_STATE,\n    useFactory: _initialStateFactory,\n    deps: [_INITIAL_STATE]\n  }, {\n    provide: _INITIAL_REDUCERS,\n    useValue: reducers\n  }, {\n    provide: _STORE_REDUCERS,\n    useExisting: reducers instanceof InjectionToken ? reducers : _INITIAL_REDUCERS\n  }, {\n    provide: INITIAL_REDUCERS,\n    deps: [_INITIAL_REDUCERS, [new Inject(_STORE_REDUCERS)]],\n    useFactory: _createStoreReducers\n  }, {\n    provide: USER_PROVIDED_META_REDUCERS,\n    useValue: config2.metaReducers ? config2.metaReducers : []\n  }, {\n    provide: _RESOLVED_META_REDUCERS,\n    deps: [META_REDUCERS, USER_PROVIDED_META_REDUCERS],\n    useFactory: _concatMetaReducers\n  }, {\n    provide: _REDUCER_FACTORY,\n    useValue: config2.reducerFactory ? config2.reducerFactory : combineReducers\n  }, {\n    provide: REDUCER_FACTORY,\n    deps: [_REDUCER_FACTORY, _RESOLVED_META_REDUCERS],\n    useFactory: createReducerFactory\n  }, ACTIONS_SUBJECT_PROVIDERS, REDUCER_MANAGER_PROVIDERS, SCANNED_ACTIONS_SUBJECT_PROVIDERS, STATE_PROVIDERS, STORE_PROVIDERS, provideRuntimeChecks(config2.runtimeChecks), checkForActionTypeUniqueness()];\n}\nfunction rootStoreProviderFactory() {\n  inject(ActionsSubject);\n  inject(ReducerObservable);\n  inject(ScannedActionsSubject);\n  inject(Store);\n  inject(_ROOT_STORE_GUARD, {\n    optional: true\n  });\n  inject(_ACTION_TYPE_UNIQUENESS_CHECK, {\n    optional: true\n  });\n}\nvar ENVIRONMENT_STORE_PROVIDER = [{\n  provide: ROOT_STORE_PROVIDER,\n  useFactory: rootStoreProviderFactory\n}, {\n  provide: ENVIRONMENT_INITIALIZER,\n  multi: true,\n  useFactory() {\n    return () => inject(ROOT_STORE_PROVIDER);\n  }\n}];\nfunction provideStore(reducers, config2) {\n  return makeEnvironmentProviders([..._provideStore(reducers, config2), ENVIRONMENT_STORE_PROVIDER]);\n}\nfunction _provideState(featureNameOrSlice, reducers, config2 = {}) {\n  return [{\n    provide: _FEATURE_CONFIGS,\n    multi: true,\n    useValue: featureNameOrSlice instanceof Object ? {} : config2\n  }, {\n    provide: STORE_FEATURES,\n    multi: true,\n    useValue: {\n      key: featureNameOrSlice instanceof Object ? featureNameOrSlice.name : featureNameOrSlice,\n      reducerFactory: !(config2 instanceof InjectionToken) && config2.reducerFactory ? config2.reducerFactory : combineReducers,\n      metaReducers: !(config2 instanceof InjectionToken) && config2.metaReducers ? config2.metaReducers : [],\n      initialState: !(config2 instanceof InjectionToken) && config2.initialState ? config2.initialState : void 0\n    }\n  }, {\n    provide: _STORE_FEATURES,\n    deps: [_FEATURE_CONFIGS, STORE_FEATURES],\n    useFactory: _createFeatureStore\n  }, {\n    provide: _FEATURE_REDUCERS,\n    multi: true,\n    useValue: featureNameOrSlice instanceof Object ? featureNameOrSlice.reducer : reducers\n  }, {\n    provide: _FEATURE_REDUCERS_TOKEN,\n    multi: true,\n    useExisting: reducers instanceof InjectionToken ? reducers : _FEATURE_REDUCERS\n  }, {\n    provide: FEATURE_REDUCERS,\n    multi: true,\n    deps: [_FEATURE_REDUCERS, [new Inject(_FEATURE_REDUCERS_TOKEN)]],\n    useFactory: _createFeatureReducers\n  }, checkForActionTypeUniqueness()];\n}\nvar StoreRootModule = class _StoreRootModule {\n  constructor(actions$, reducer$, scannedActions$, store2, guard, actionCheck) {\n  }\n  static {\n    this.\\u0275fac = function StoreRootModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _StoreRootModule)(\\u0275\\u0275inject(ActionsSubject), \\u0275\\u0275inject(ReducerObservable), \\u0275\\u0275inject(ScannedActionsSubject), \\u0275\\u0275inject(Store), \\u0275\\u0275inject(_ROOT_STORE_GUARD, 8), \\u0275\\u0275inject(_ACTION_TYPE_UNIQUENESS_CHECK, 8));\n    };\n  }\n  static {\n    this.\\u0275mod = /* @__PURE__ */ \\u0275\\u0275defineNgModule({\n      type: _StoreRootModule\n    });\n  }\n  static {\n    this.\\u0275inj = /* @__PURE__ */ \\u0275\\u0275defineInjector({});\n  }\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(StoreRootModule, [{\n    type: NgModule,\n    args: [{}]\n  }], () => [{\n    type: ActionsSubject\n  }, {\n    type: ReducerObservable\n  }, {\n    type: ScannedActionsSubject\n  }, {\n    type: Store\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [_ROOT_STORE_GUARD]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [_ACTION_TYPE_UNIQUENESS_CHECK]\n    }]\n  }], null);\n})();\nvar StoreFeatureModule = class _StoreFeatureModule {\n  constructor(features, featureReducers, reducerManager, root, actionCheck) {\n    this.features = features;\n    this.featureReducers = featureReducers;\n    this.reducerManager = reducerManager;\n    const feats = features.map((feature, index) => {\n      const featureReducerCollection = featureReducers.shift();\n      const reducers = featureReducerCollection[index];\n      return __spreadProps(__spreadValues({}, feature), {\n        reducers,\n        initialState: _initialStateFactory(feature.initialState)\n      });\n    });\n    reducerManager.addFeatures(feats);\n  }\n  // eslint-disable-next-line @angular-eslint/contextual-lifecycle\n  ngOnDestroy() {\n    this.reducerManager.removeFeatures(this.features);\n  }\n  static {\n    this.\\u0275fac = function StoreFeatureModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _StoreFeatureModule)(\\u0275\\u0275inject(_STORE_FEATURES), \\u0275\\u0275inject(FEATURE_REDUCERS), \\u0275\\u0275inject(ReducerManager), \\u0275\\u0275inject(StoreRootModule), \\u0275\\u0275inject(_ACTION_TYPE_UNIQUENESS_CHECK, 8));\n    };\n  }\n  static {\n    this.\\u0275mod = /* @__PURE__ */ \\u0275\\u0275defineNgModule({\n      type: _StoreFeatureModule\n    });\n  }\n  static {\n    this.\\u0275inj = /* @__PURE__ */ \\u0275\\u0275defineInjector({});\n  }\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(StoreFeatureModule, [{\n    type: NgModule,\n    args: [{}]\n  }], () => [{\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [_STORE_FEATURES]\n    }]\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [FEATURE_REDUCERS]\n    }]\n  }, {\n    type: ReducerManager\n  }, {\n    type: StoreRootModule\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [_ACTION_TYPE_UNIQUENESS_CHECK]\n    }]\n  }], null);\n})();\nvar StoreModule = class _StoreModule {\n  static forRoot(reducers, config2) {\n    return {\n      ngModule: StoreRootModule,\n      providers: [..._provideStore(reducers, config2)]\n    };\n  }\n  static forFeature(featureNameOrSlice, reducers, config2 = {}) {\n    return {\n      ngModule: StoreFeatureModule,\n      providers: [..._provideState(featureNameOrSlice, reducers, config2)]\n    };\n  }\n  static {\n    this.\\u0275fac = function StoreModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _StoreModule)();\n    };\n  }\n  static {\n    this.\\u0275mod = /* @__PURE__ */ \\u0275\\u0275defineNgModule({\n      type: _StoreModule\n    });\n  }\n  static {\n    this.\\u0275inj = /* @__PURE__ */ \\u0275\\u0275defineInjector({});\n  }\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(StoreModule, [{\n    type: NgModule,\n    args: [{}]\n  }], null, null);\n})();\nfunction on(...args) {\n  const reducer = args.pop();\n  const types = args.map((creator) => creator.type);\n  return {\n    reducer,\n    types\n  };\n}\nfunction createReducer(initialState2, ...ons) {\n  const map2 = /* @__PURE__ */ new Map();\n  for (const on2 of ons) {\n    for (const type of on2.types) {\n      const existingReducer = map2.get(type);\n      if (existingReducer) {\n        const newReducer = (state, action) => on2.reducer(existingReducer(state, action), action);\n        map2.set(type, newReducer);\n      } else {\n        map2.set(type, on2.reducer);\n      }\n    }\n  }\n  return function(state = initialState2, action) {\n    const reducer = map2.get(action.type);\n    return reducer ? reducer(state, action) : state;\n  };\n}\n\n// src/app/store/auth/auth.selectors.ts\nvar selectAuthState = createFeatureSelector(\"auth\");\nvar selectAuthToken = createSelector(selectAuthState, (state) => state.token);\nvar selectAuthError = createSelector(selectAuthState, (state) => state.error);\n\n// src/app/store/auth/auth.actions.ts\nvar login = createAction(\"[Auth] Login\", props());\nvar loginSuccess = createAction(\"[Auth] Login Success\", props());\nvar loginFailure = createAction(\"[Auth] Login Failure\", props());\nvar logout = createAction(\"[Auth] Logout\");\n\n// src/app/login/login.component.ts\nvar LoginComponent = class _LoginComponent {\n  store;\n  router;\n  credentials = { username: \"\", password: \"\" };\n  errorMessage$;\n  constructor(store2, router) {\n    this.store = store2;\n    this.router = router;\n    this.errorMessage$ = this.store.pipe(select(selectAuthError));\n  }\n  login() {\n    this.store.dispatch(login({ credentials: this.credentials }));\n  }\n  static \\u0275fac = function LoginComponent_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _LoginComponent)(\\u0275\\u0275directiveInject(Store), \\u0275\\u0275directiveInject(Router));\n  };\n  static \\u0275cmp = /* @__PURE__ */ \\u0275\\u0275defineComponent({ type: _LoginComponent, selectors: [[\"app-login\"]], decls: 24, vars: 2, consts: [[\"f\", \"ngForm\"], [\"username\", \"ngModel\"], [\"password\", \"ngModel\"], [\"id\", \"login\", 1, \"container\", \"mt-5\"], [1, \"row\", \"justify-content-center\"], [1, \"col-md-6\"], [1, \"text-center\"], [\"name\", \"form\", \"novalidate\", \"\", 3, \"ngSubmit\"], [1, \"mb-3\"], [\"for\", \"username\", 1, \"form-label\"], [\"type\", \"text\", \"placeholder\", \"Enter your email\", \"name\", \"username\", 1, \"form-control\", 3, \"ngModelChange\", \"ngModel\"], [\"for\", \"password\", 1, \"form-label\"], [\"type\", \"password\", \"name\", \"password\", \"placeholder\", \"Enter password\", 1, \"form-control\", 3, \"ngModelChange\", \"ngModel\"], [\"type\", \"submit\", 1, \"btn\", \"btn-primary\", \"w-100\"], [1, \"text-center\", \"mt-3\"], [\"href\", \"#\", 1, \"d-block\"], [\"routerLink\", \"/register\", 1, \"d-block\"]], template: function LoginComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      const _r1 = \\u0275\\u0275getCurrentView();\n      \\u0275\\u0275elementStart(0, \"div\", 3)(1, \"div\", 4)(2, \"div\", 5)(3, \"h1\", 6);\n      \\u0275\\u0275text(4, \"Login\");\n      \\u0275\\u0275elementEnd();\n      \\u0275\\u0275elementStart(5, \"form\", 7, 0);\n      \\u0275\\u0275listener(\"ngSubmit\", function LoginComponent_Template_form_ngSubmit_5_listener() {\n        \\u0275\\u0275restoreView(_r1);\n        return \\u0275\\u0275resetView(ctx.login());\n      });\n      \\u0275\\u0275elementStart(7, \"div\", 8)(8, \"label\", 9);\n      \\u0275\\u0275text(9, \"Username\");\n      \\u0275\\u0275elementEnd();\n      \\u0275\\u0275elementStart(10, \"input\", 10, 1);\n      \\u0275\\u0275twoWayListener(\"ngModelChange\", function LoginComponent_Template_input_ngModelChange_10_listener($event) {\n        \\u0275\\u0275restoreView(_r1);\n        \\u0275\\u0275twoWayBindingSet(ctx.credentials.username, $event) || (ctx.credentials.username = $event);\n        return \\u0275\\u0275resetView($event);\n      });\n      \\u0275\\u0275elementEnd()();\n      \\u0275\\u0275elementStart(12, \"div\", 8)(13, \"label\", 11);\n      \\u0275\\u0275text(14, \"Password\");\n      \\u0275\\u0275elementEnd();\n      \\u0275\\u0275elementStart(15, \"input\", 12, 2);\n      \\u0275\\u0275twoWayListener(\"ngModelChange\", function LoginComponent_Template_input_ngModelChange_15_listener($event) {\n        \\u0275\\u0275restoreView(_r1);\n        \\u0275\\u0275twoWayBindingSet(ctx.credentials.password, $event) || (ctx.credentials.password = $event);\n        return \\u0275\\u0275resetView($event);\n      });\n      \\u0275\\u0275elementEnd()();\n      \\u0275\\u0275elementStart(17, \"button\", 13);\n      \\u0275\\u0275text(18, \"Login\");\n      \\u0275\\u0275elementEnd();\n      \\u0275\\u0275elementStart(19, \"div\", 14)(20, \"a\", 15);\n      \\u0275\\u0275text(21, \"Forgot Password?\");\n      \\u0275\\u0275elementEnd();\n      \\u0275\\u0275elementStart(22, \"a\", 16);\n      \\u0275\\u0275text(23, \"Don't have an account? Sign up\");\n      \\u0275\\u0275elementEnd()()()()()();\n    }\n    if (rf & 2) {\n      \\u0275\\u0275advance(10);\n      \\u0275\\u0275twoWayProperty(\"ngModel\", ctx.credentials.username);\n      \\u0275\\u0275advance(5);\n      \\u0275\\u0275twoWayProperty(\"ngModel\", ctx.credentials.password);\n    }\n  }, dependencies: [CommonModule, FormsModule, \\u0275NgNoValidate, DefaultValueAccessor, NgControlStatus, NgControlStatusGroup, NgModel, NgForm, RouterLink], encapsulation: 2 });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && \\u0275setClassDebugInfo(LoginComponent, { className: \"LoginComponent\", filePath: \"src/app/login/login.component.ts\", lineNumber: 38 });\n})();\n\n// src/app/home/home.component.ts\nvar HomeComponent = class _HomeComponent {\n  static \\u0275fac = function HomeComponent_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _HomeComponent)();\n  };\n  static \\u0275cmp = /* @__PURE__ */ \\u0275\\u0275defineComponent({ type: _HomeComponent, selectors: [[\"app-home\"]], decls: 2, vars: 0, template: function HomeComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      \\u0275\\u0275elementStart(0, \"p\");\n      \\u0275\\u0275text(1, \"home works!\");\n      \\u0275\\u0275elementEnd();\n    }\n  }, encapsulation: 2 });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && \\u0275setClassDebugInfo(HomeComponent, { className: \"HomeComponent\", filePath: \"src/app/home/home.component.ts\", lineNumber: 9 });\n})();\n\n// src/app/store/loan/loan.selectors.ts\nvar selectLoanState = createFeatureSelector(\"loan\");\nvar selectLoans = createSelector(selectLoanState, (state) => state.loans);\nvar selectSelectedLoan = createSelector(selectLoanState, (state) => state.selectedLoan);\n\n// src/app/store/loan/loan.actions.ts\nvar loadLoans = createAction(\"[Loan] Load Loans\");\nvar loadLoansSuccess = createAction(\"[Loan] Load Loans Success\", props());\nvar selectLoan = createAction(\"[Loan] Select Loan\", props());\nvar addLoan = createAction(\"[Loan] Add Loan\", props());\nvar addLoanSuccess = createAction(\"[Loan] Add Loan Success\", props());\n\n// src/app/environment/environment.ts\nvar environment = {\n  production: false,\n  apiUrl: `https://localhost:7194/api`\n};\n\n// src/app/services/loan/loan.service.ts\nvar LoanService = class _LoanService {\n  http;\n  store;\n  apiUrl = environment.apiUrl;\n  constructor(http, store2) {\n    this.http = http;\n    this.store = store2;\n  }\n  fetchLoans() {\n    this.http.get(`${this.apiUrl}/loans`).subscribe((loans) => {\n      this.store.dispatch(loadLoansSuccess({ loans }));\n      console.log(loans);\n    });\n  }\n  createLoan(loan) {\n    this.http.post(`${this.apiUrl}/loans`, loan).subscribe((newLoan) => {\n      this.store.dispatch(addLoanSuccess({ loan: newLoan }));\n    });\n  }\n  static \\u0275fac = function LoanService_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _LoanService)(\\u0275\\u0275inject(HttpClient), \\u0275\\u0275inject(Store));\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({ token: _LoanService, factory: _LoanService.\\u0275fac, providedIn: \"root\" });\n};\n\n// src/app/dashboard/dashboard.component.ts\nfunction DashboardComponent_tr_17_Template(rf, ctx) {\n  if (rf & 1) {\n    \\u0275\\u0275elementStart(0, \"tr\")(1, \"td\");\n    \\u0275\\u0275text(2);\n    \\u0275\\u0275elementEnd();\n    \\u0275\\u0275elementStart(3, \"td\");\n    \\u0275\\u0275text(4);\n    \\u0275\\u0275pipe(5, \"currency\");\n    \\u0275\\u0275elementEnd();\n    \\u0275\\u0275elementStart(6, \"td\");\n    \\u0275\\u0275text(7);\n    \\u0275\\u0275elementEnd();\n    \\u0275\\u0275elementStart(8, \"td\");\n    \\u0275\\u0275text(9);\n    \\u0275\\u0275elementEnd();\n    \\u0275\\u0275elementStart(10, \"td\");\n    \\u0275\\u0275text(11);\n    \\u0275\\u0275elementEnd()();\n  }\n  if (rf & 2) {\n    const loan_r1 = ctx.$implicit;\n    \\u0275\\u0275advance(2);\n    \\u0275\\u0275textInterpolate(loan_r1.LoanId);\n    \\u0275\\u0275advance(2);\n    \\u0275\\u0275textInterpolate(\\u0275\\u0275pipeBind1(5, 5, loan_r1.LoanAmount));\n    \\u0275\\u0275advance(3);\n    \\u0275\\u0275textInterpolate1(\"\", loan_r1.InterestRate, \"%\");\n    \\u0275\\u0275advance(2);\n    \\u0275\\u0275textInterpolate(loan_r1.LoanTermYears);\n    \\u0275\\u0275advance(2);\n    \\u0275\\u0275textInterpolate(loan_r1.ApplicationStatus);\n  }\n}\nvar DashboardComponent = class _DashboardComponent {\n  store;\n  loanService;\n  loans$;\n  constructor(store2, loanService) {\n    this.store = store2;\n    this.loanService = loanService;\n    this.loans$ = this.store.select(selectLoans);\n  }\n  ngOnInit() {\n    this.store.dispatch(loadLoans());\n    this.loanService.fetchLoans();\n  }\n  static \\u0275fac = function DashboardComponent_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _DashboardComponent)(\\u0275\\u0275directiveInject(Store), \\u0275\\u0275directiveInject(LoanService));\n  };\n  static \\u0275cmp = /* @__PURE__ */ \\u0275\\u0275defineComponent({ type: _DashboardComponent, selectors: [[\"app-dashboard\"]], decls: 19, vars: 3, consts: [[1, \"container\"], [1, \"table\"], [4, \"ngFor\", \"ngForOf\"]], template: function DashboardComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      \\u0275\\u0275elementStart(0, \"div\", 0)(1, \"h2\");\n      \\u0275\\u0275text(2, \"Loan Applications\");\n      \\u0275\\u0275elementEnd();\n      \\u0275\\u0275elementStart(3, \"table\", 1)(4, \"thead\")(5, \"tr\")(6, \"th\");\n      \\u0275\\u0275text(7, \"Loan ID\");\n      \\u0275\\u0275elementEnd();\n      \\u0275\\u0275elementStart(8, \"th\");\n      \\u0275\\u0275text(9, \"Amount\");\n      \\u0275\\u0275elementEnd();\n      \\u0275\\u0275elementStart(10, \"th\");\n      \\u0275\\u0275text(11, \"Interest Rate\");\n      \\u0275\\u0275elementEnd();\n      \\u0275\\u0275elementStart(12, \"th\");\n      \\u0275\\u0275text(13, \"Term (Years)\");\n      \\u0275\\u0275elementEnd();\n      \\u0275\\u0275elementStart(14, \"th\");\n      \\u0275\\u0275text(15, \"Status\");\n      \\u0275\\u0275elementEnd()()();\n      \\u0275\\u0275elementStart(16, \"tbody\");\n      \\u0275\\u0275template(17, DashboardComponent_tr_17_Template, 12, 7, \"tr\", 2);\n      \\u0275\\u0275pipe(18, \"async\");\n      \\u0275\\u0275elementEnd()()();\n    }\n    if (rf & 2) {\n      \\u0275\\u0275advance(17);\n      \\u0275\\u0275property(\"ngForOf\", \\u0275\\u0275pipeBind1(18, 1, ctx.loans$));\n    }\n  }, dependencies: [CurrencyPipe, CommonModule, NgForOf, AsyncPipe], encapsulation: 2 });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && \\u0275setClassDebugInfo(DashboardComponent, { className: \"DashboardComponent\", filePath: \"src/app/dashboard/dashboard.component.ts\", lineNumber: 16 });\n})();\n\n// src/app/loan-application/loan-application.component.ts\nfunction LoanApplicationComponent_div_8_Template(rf, ctx) {\n  if (rf & 1) {\n    \\u0275\\u0275elementStart(0, \"div\", 12);\n    \\u0275\\u0275text(1, \" Loan amount is required. \");\n    \\u0275\\u0275elementEnd();\n  }\n}\nfunction LoanApplicationComponent_div_13_Template(rf, ctx) {\n  if (rf & 1) {\n    \\u0275\\u0275elementStart(0, \"div\", 12);\n    \\u0275\\u0275text(1, \" Interest rate is required. \");\n    \\u0275\\u0275elementEnd();\n  }\n}\nfunction LoanApplicationComponent_div_18_Template(rf, ctx) {\n  if (rf & 1) {\n    \\u0275\\u0275elementStart(0, \"div\", 12);\n    \\u0275\\u0275text(1, \" Loan term is required. \");\n    \\u0275\\u0275elementEnd();\n  }\n}\nvar LoanApplicationComponent = class _LoanApplicationComponent {\n  fb;\n  store;\n  loanService;\n  loanForm;\n  constructor(fb, store2, loanService) {\n    this.fb = fb;\n    this.store = store2;\n    this.loanService = loanService;\n    this.loanForm = this.fb.group({\n      LoanAmount: [\"\", Validators.required],\n      InterestRate: [\"\", Validators.required],\n      LoanTermYears: [\"\", Validators.required]\n    });\n  }\n  submitLoan() {\n    if (this.loanForm.valid) {\n      const newLoan = __spreadProps(__spreadValues({\n        LoanId: 0\n      }, this.loanForm.value), {\n        ApplicationDate: (/* @__PURE__ */ new Date()).toISOString(),\n        ApplicationStatus: \"Pending\"\n      });\n      this.loanService.createLoan(newLoan);\n    }\n  }\n  static \\u0275fac = function LoanApplicationComponent_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _LoanApplicationComponent)(\\u0275\\u0275directiveInject(FormBuilder), \\u0275\\u0275directiveInject(Store), \\u0275\\u0275directiveInject(LoanService));\n  };\n  static \\u0275cmp = /* @__PURE__ */ \\u0275\\u0275defineComponent({ type: _LoanApplicationComponent, selectors: [[\"app-loan-application\"]], decls: 21, vars: 5, consts: [[1, \"container\"], [1, \"text-center\"], [1, \"loan-form\", 3, \"ngSubmit\", \"formGroup\"], [1, \"form-group\"], [\"for\", \"loanAmount\"], [\"type\", \"number\", \"id\", \"loanAmount\", \"formControlName\", \"LoanAmount\", \"placeholder\", \"Enter loan amount\", 1, \"form-control\"], [\"class\", \"text-danger\", 4, \"ngIf\"], [\"for\", \"interestRate\"], [\"type\", \"number\", \"id\", \"interestRate\", \"formControlName\", \"InterestRate\", \"placeholder\", \"Enter interest rate\", 1, \"form-control\"], [\"for\", \"loanTermYears\"], [\"type\", \"number\", \"id\", \"loanTermYears\", \"formControlName\", \"LoanTermYears\", \"placeholder\", \"Enter loan term in years\", 1, \"form-control\"], [\"type\", \"submit\", 1, \"btn\", \"btn-primary\", \"btn-block\", \"mt-3\", 3, \"disabled\"], [1, \"text-danger\"]], template: function LoanApplicationComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      \\u0275\\u0275elementStart(0, \"div\", 0)(1, \"h2\", 1);\n      \\u0275\\u0275text(2, \"Apply for a Loan\");\n      \\u0275\\u0275elementEnd();\n      \\u0275\\u0275elementStart(3, \"form\", 2);\n      \\u0275\\u0275listener(\"ngSubmit\", function LoanApplicationComponent_Template_form_ngSubmit_3_listener() {\n        return ctx.submitLoan();\n      });\n      \\u0275\\u0275elementStart(4, \"div\", 3)(5, \"label\", 4);\n      \\u0275\\u0275text(6, \"Loan Amount\");\n      \\u0275\\u0275elementEnd();\n      \\u0275\\u0275element(7, \"input\", 5);\n      \\u0275\\u0275template(8, LoanApplicationComponent_div_8_Template, 2, 0, \"div\", 6);\n      \\u0275\\u0275elementEnd();\n      \\u0275\\u0275elementStart(9, \"div\", 3)(10, \"label\", 7);\n      \\u0275\\u0275text(11, \"Interest Rate (%)\");\n      \\u0275\\u0275elementEnd();\n      \\u0275\\u0275element(12, \"input\", 8);\n      \\u0275\\u0275template(13, LoanApplicationComponent_div_13_Template, 2, 0, \"div\", 6);\n      \\u0275\\u0275elementEnd();\n      \\u0275\\u0275elementStart(14, \"div\", 3)(15, \"label\", 9);\n      \\u0275\\u0275text(16, \"Loan Term (Years)\");\n      \\u0275\\u0275elementEnd();\n      \\u0275\\u0275element(17, \"input\", 10);\n      \\u0275\\u0275template(18, LoanApplicationComponent_div_18_Template, 2, 0, \"div\", 6);\n      \\u0275\\u0275elementEnd();\n      \\u0275\\u0275elementStart(19, \"button\", 11);\n      \\u0275\\u0275text(20, \" Apply Now \");\n      \\u0275\\u0275elementEnd()()();\n    }\n    if (rf & 2) {\n      \\u0275\\u0275advance(3);\n      \\u0275\\u0275property(\"formGroup\", ctx.loanForm);\n      \\u0275\\u0275advance(5);\n      \\u0275\\u0275property(\"ngIf\", ctx.loanForm.controls[\"LoanAmount\"].invalid && ctx.loanForm.controls[\"LoanAmount\"].touched);\n      \\u0275\\u0275advance(5);\n      \\u0275\\u0275property(\"ngIf\", ctx.loanForm.controls[\"InterestRate\"].invalid && ctx.loanForm.controls[\"InterestRate\"].touched);\n      \\u0275\\u0275advance(5);\n      \\u0275\\u0275property(\"ngIf\", ctx.loanForm.controls[\"LoanTermYears\"].invalid && ctx.loanForm.controls[\"LoanTermYears\"].touched);\n      \\u0275\\u0275advance();\n      \\u0275\\u0275property(\"disabled\", ctx.loanForm.invalid);\n    }\n  }, dependencies: [CommonModule, NgIf, FormsModule, \\u0275NgNoValidate, DefaultValueAccessor, NumberValueAccessor, NgControlStatus, NgControlStatusGroup, ReactiveFormsModule, FormGroupDirective, FormControlName], styles: [\"\\n\\n.container[_ngcontent-%COMP%] {\\n  max-width: 500px;\\n  margin: auto;\\n  padding: 20px;\\n  background: #ffffff;\\n  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);\\n  border-radius: 10px;\\n}\\nh2[_ngcontent-%COMP%] {\\n  margin-bottom: 20px;\\n  font-size: 1.8rem;\\n  text-align: center;\\n}\\n.loan-form[_ngcontent-%COMP%]   .form-group[_ngcontent-%COMP%] {\\n  margin-bottom: 15px;\\n}\\n.loan-form[_ngcontent-%COMP%]   input[_ngcontent-%COMP%] {\\n  border-radius: 5px;\\n}\\n.btn-block[_ngcontent-%COMP%] {\\n  width: 100%;\\n  font-size: 1.1rem;\\n}\\n/*# sourceMappingURL=loan-application.component.css.map */\"] });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && \\u0275setClassDebugInfo(LoanApplicationComponent, { className: \"LoanApplicationComponent\", filePath: \"src/app/loan-application/loan-application.component.ts\", lineNumber: 14 });\n})();\n\n// src/app/app.routes.ts\nvar routes = [\n  {\n    path: \"loan-application\",\n    component: LoanApplicationComponent\n    // Home is authenticated\n  },\n  {\n    path: \"dashboard\",\n    component: DashboardComponent\n    // Home is authenticated\n  },\n  {\n    path: \"home\",\n    component: HomeComponent\n    // Home is authenticated\n  },\n  {\n    path: \"\",\n    component: LoginComponent\n    // Login is public\n  }\n];\n\n// src/app/services/auth/jwt.interceptor.ts\nvar jwtInterceptor = class _jwtInterceptor {\n  store;\n  token = null;\n  constructor(store2) {\n    this.store = store2;\n    this.store.pipe(select(selectAuthToken)).subscribe((token) => {\n      this.token = token;\n    });\n  }\n  intercept(request, next) {\n    if (this.token) {\n      request = request.clone({\n        setHeaders: {\n          Authorization: `Bearer ${this.token}`\n        }\n      });\n    }\n    return next.handle(request).pipe(catchError((error) => {\n      if (error instanceof HttpErrorResponse && error.status === 401) {\n        this.store.dispatch(logout());\n      }\n      throw error;\n    }));\n  }\n  static \\u0275fac = function jwtInterceptor_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _jwtInterceptor)(\\u0275\\u0275inject(Store));\n  };\n  static \\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({ token: _jwtInterceptor, factory: _jwtInterceptor.\\u0275fac, providedIn: \"root\" });\n};\n\n// src/app/store/auth/auth.state.ts\nvar initialAuthState = {\n  username: null,\n  token: null,\n  error: null\n};\n\n// src/app/store/auth/auth.reducer.ts\nvar authReducer = createReducer(\n  initialAuthState,\n  // Handle login success\n  on(loginSuccess, (state, { username, token }) => {\n    return __spreadProps(__spreadValues({}, state), { username, token, error: null });\n  }),\n  // Handle login failure\n  on(loginFailure, (state, { error }) => {\n    return __spreadProps(__spreadValues({}, state), { error });\n  }),\n  // Handle logout\n  on(logout, () => initialAuthState)\n);\n\n// node_modules/@ngrx/store-devtools/fesm2022/ngrx-store-devtools.mjs\nvar PERFORM_ACTION = \"PERFORM_ACTION\";\nvar REFRESH = \"REFRESH\";\nvar RESET = \"RESET\";\nvar ROLLBACK = \"ROLLBACK\";\nvar COMMIT = \"COMMIT\";\nvar SWEEP = \"SWEEP\";\nvar TOGGLE_ACTION = \"TOGGLE_ACTION\";\nvar SET_ACTIONS_ACTIVE = \"SET_ACTIONS_ACTIVE\";\nvar JUMP_TO_STATE = \"JUMP_TO_STATE\";\nvar JUMP_TO_ACTION = \"JUMP_TO_ACTION\";\nvar IMPORT_STATE = \"IMPORT_STATE\";\nvar LOCK_CHANGES = \"LOCK_CHANGES\";\nvar PAUSE_RECORDING = \"PAUSE_RECORDING\";\nvar PerformAction = class {\n  constructor(action, timestamp) {\n    this.action = action;\n    this.timestamp = timestamp;\n    this.type = PERFORM_ACTION;\n    if (typeof action.type === \"undefined\") {\n      throw new Error('Actions may not have an undefined \"type\" property. Have you misspelled a constant?');\n    }\n  }\n};\nvar Refresh = class {\n  constructor() {\n    this.type = REFRESH;\n  }\n};\nvar Reset = class {\n  constructor(timestamp) {\n    this.timestamp = timestamp;\n    this.type = RESET;\n  }\n};\nvar Rollback = class {\n  constructor(timestamp) {\n    this.timestamp = timestamp;\n    this.type = ROLLBACK;\n  }\n};\nvar Commit = class {\n  constructor(timestamp) {\n    this.timestamp = timestamp;\n    this.type = COMMIT;\n  }\n};\nvar Sweep = class {\n  constructor() {\n    this.type = SWEEP;\n  }\n};\nvar ToggleAction = class {\n  constructor(id) {\n    this.id = id;\n    this.type = TOGGLE_ACTION;\n  }\n};\nvar JumpToState = class {\n  constructor(index) {\n    this.index = index;\n    this.type = JUMP_TO_STATE;\n  }\n};\nvar JumpToAction = class {\n  constructor(actionId) {\n    this.actionId = actionId;\n    this.type = JUMP_TO_ACTION;\n  }\n};\nvar ImportState = class {\n  constructor(nextLiftedState) {\n    this.nextLiftedState = nextLiftedState;\n    this.type = IMPORT_STATE;\n  }\n};\nvar LockChanges = class {\n  constructor(status) {\n    this.status = status;\n    this.type = LOCK_CHANGES;\n  }\n};\nvar PauseRecording = class {\n  constructor(status) {\n    this.status = status;\n    this.type = PAUSE_RECORDING;\n  }\n};\nvar StoreDevtoolsConfig = class {\n  constructor() {\n    this.maxAge = false;\n  }\n};\nvar STORE_DEVTOOLS_CONFIG = new InjectionToken(\"@ngrx/store-devtools Options\");\nvar INITIAL_OPTIONS = new InjectionToken(\"@ngrx/store-devtools Initial Config\");\nfunction noMonitor() {\n  return null;\n}\nvar DEFAULT_NAME = \"NgRx Store DevTools\";\nfunction createConfig(optionsInput) {\n  const DEFAULT_OPTIONS = {\n    maxAge: false,\n    monitor: noMonitor,\n    actionSanitizer: void 0,\n    stateSanitizer: void 0,\n    name: DEFAULT_NAME,\n    serialize: false,\n    logOnly: false,\n    autoPause: false,\n    trace: false,\n    traceLimit: 75,\n    // Add all features explicitly. This prevent buggy behavior for\n    // options like \"lock\" which might otherwise not show up.\n    features: {\n      pause: true,\n      // Start/pause recording of dispatched actions\n      lock: true,\n      // Lock/unlock dispatching actions and side effects\n      persist: true,\n      // Persist states on page reloading\n      export: true,\n      // Export history of actions in a file\n      import: \"custom\",\n      // Import history of actions from a file\n      jump: true,\n      // Jump back and forth (time travelling)\n      skip: true,\n      // Skip (cancel) actions\n      reorder: true,\n      // Drag and drop actions in the history list\n      dispatch: true,\n      // Dispatch custom actions or action creators\n      test: true\n      // Generate tests for the selected actions\n    },\n    connectInZone: false\n  };\n  const options = typeof optionsInput === \"function\" ? optionsInput() : optionsInput;\n  const logOnly = options.logOnly ? {\n    pause: true,\n    export: true,\n    test: true\n  } : false;\n  const features = options.features || logOnly || DEFAULT_OPTIONS.features;\n  if (features.import === true) {\n    features.import = \"custom\";\n  }\n  const config2 = Object.assign({}, DEFAULT_OPTIONS, {\n    features\n  }, options);\n  if (config2.maxAge && config2.maxAge < 2) {\n    throw new Error(`Devtools 'maxAge' cannot be less than 2, got ${config2.maxAge}`);\n  }\n  return config2;\n}\nfunction difference(first2, second) {\n  return first2.filter((item) => second.indexOf(item) < 0);\n}\nfunction unliftState(liftedState) {\n  const {\n    computedStates,\n    currentStateIndex\n  } = liftedState;\n  if (currentStateIndex >= computedStates.length) {\n    const {\n      state: state2\n    } = computedStates[computedStates.length - 1];\n    return state2;\n  }\n  const {\n    state\n  } = computedStates[currentStateIndex];\n  return state;\n}\nfunction liftAction(action) {\n  return new PerformAction(action, +Date.now());\n}\nfunction sanitizeActions(actionSanitizer, actions) {\n  return Object.keys(actions).reduce((sanitizedActions, actionIdx) => {\n    const idx = Number(actionIdx);\n    sanitizedActions[idx] = sanitizeAction(actionSanitizer, actions[idx], idx);\n    return sanitizedActions;\n  }, {});\n}\nfunction sanitizeAction(actionSanitizer, action, actionIdx) {\n  return __spreadProps(__spreadValues({}, action), {\n    action: actionSanitizer(action.action, actionIdx)\n  });\n}\nfunction sanitizeStates(stateSanitizer, states) {\n  return states.map((computedState, idx) => ({\n    state: sanitizeState(stateSanitizer, computedState.state, idx),\n    error: computedState.error\n  }));\n}\nfunction sanitizeState(stateSanitizer, state, stateIdx) {\n  return stateSanitizer(state, stateIdx);\n}\nfunction shouldFilterActions(config2) {\n  return config2.predicate || config2.actionsSafelist || config2.actionsBlocklist;\n}\nfunction filterLiftedState(liftedState, predicate, safelist, blocklist) {\n  const filteredStagedActionIds = [];\n  const filteredActionsById = {};\n  const filteredComputedStates = [];\n  liftedState.stagedActionIds.forEach((id, idx) => {\n    const liftedAction = liftedState.actionsById[id];\n    if (!liftedAction) return;\n    if (idx && isActionFiltered(liftedState.computedStates[idx], liftedAction, predicate, safelist, blocklist)) {\n      return;\n    }\n    filteredActionsById[id] = liftedAction;\n    filteredStagedActionIds.push(id);\n    filteredComputedStates.push(liftedState.computedStates[idx]);\n  });\n  return __spreadProps(__spreadValues({}, liftedState), {\n    stagedActionIds: filteredStagedActionIds,\n    actionsById: filteredActionsById,\n    computedStates: filteredComputedStates\n  });\n}\nfunction isActionFiltered(state, action, predicate, safelist, blockedlist) {\n  const predicateMatch = predicate && !predicate(state, action.action);\n  const safelistMatch = safelist && !action.action.type.match(safelist.map((s) => escapeRegExp(s)).join(\"|\"));\n  const blocklistMatch = blockedlist && action.action.type.match(blockedlist.map((s) => escapeRegExp(s)).join(\"|\"));\n  return predicateMatch || safelistMatch || blocklistMatch;\n}\nfunction escapeRegExp(s) {\n  return s.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction injectZoneConfig(connectInZone) {\n  const ngZone = connectInZone ? inject(NgZone) : null;\n  return {\n    ngZone,\n    connectInZone\n  };\n}\nvar DevtoolsDispatcher = class _DevtoolsDispatcher extends ActionsSubject {\n  static {\n    this.\\u0275fac = /* @__PURE__ */ (() => {\n      let \\u0275DevtoolsDispatcher_BaseFactory;\n      return function DevtoolsDispatcher_Factory(__ngFactoryType__) {\n        return (\\u0275DevtoolsDispatcher_BaseFactory || (\\u0275DevtoolsDispatcher_BaseFactory = \\u0275\\u0275getInheritedFactory(_DevtoolsDispatcher)))(__ngFactoryType__ || _DevtoolsDispatcher);\n      };\n    })();\n  }\n  static {\n    this.\\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n      token: _DevtoolsDispatcher,\n      factory: _DevtoolsDispatcher.\\u0275fac\n    });\n  }\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(DevtoolsDispatcher, [{\n    type: Injectable\n  }], null, null);\n})();\nvar ExtensionActionTypes = {\n  START: \"START\",\n  DISPATCH: \"DISPATCH\",\n  STOP: \"STOP\",\n  ACTION: \"ACTION\"\n};\nvar REDUX_DEVTOOLS_EXTENSION = new InjectionToken(\"@ngrx/store-devtools Redux Devtools Extension\");\nvar DevtoolsExtension = class _DevtoolsExtension {\n  constructor(devtoolsExtension, config2, dispatcher) {\n    this.config = config2;\n    this.dispatcher = dispatcher;\n    this.zoneConfig = injectZoneConfig(this.config.connectInZone);\n    this.devtoolsExtension = devtoolsExtension;\n    this.createActionStreams();\n  }\n  notify(action, state) {\n    if (!this.devtoolsExtension) {\n      return;\n    }\n    if (action.type === PERFORM_ACTION) {\n      if (state.isLocked || state.isPaused) {\n        return;\n      }\n      const currentState = unliftState(state);\n      if (shouldFilterActions(this.config) && isActionFiltered(currentState, action, this.config.predicate, this.config.actionsSafelist, this.config.actionsBlocklist)) {\n        return;\n      }\n      const sanitizedState = this.config.stateSanitizer ? sanitizeState(this.config.stateSanitizer, currentState, state.currentStateIndex) : currentState;\n      const sanitizedAction = this.config.actionSanitizer ? sanitizeAction(this.config.actionSanitizer, action, state.nextActionId) : action;\n      this.sendToReduxDevtools(() => this.extensionConnection.send(sanitizedAction, sanitizedState));\n    } else {\n      const sanitizedLiftedState = __spreadProps(__spreadValues({}, state), {\n        stagedActionIds: state.stagedActionIds,\n        actionsById: this.config.actionSanitizer ? sanitizeActions(this.config.actionSanitizer, state.actionsById) : state.actionsById,\n        computedStates: this.config.stateSanitizer ? sanitizeStates(this.config.stateSanitizer, state.computedStates) : state.computedStates\n      });\n      this.sendToReduxDevtools(() => this.devtoolsExtension.send(null, sanitizedLiftedState, this.getExtensionConfig(this.config)));\n    }\n  }\n  createChangesObservable() {\n    if (!this.devtoolsExtension) {\n      return EMPTY;\n    }\n    return new Observable((subscriber) => {\n      const connection = this.zoneConfig.connectInZone ? (\n        // To reduce change detection cycles, we need to run the `connect` method\n        // outside of the Angular zone. The `connect` method adds a `message`\n        // event listener to communicate with an extension using `window.postMessage`\n        // and handle message events.\n        this.zoneConfig.ngZone.runOutsideAngular(() => this.devtoolsExtension.connect(this.getExtensionConfig(this.config)))\n      ) : this.devtoolsExtension.connect(this.getExtensionConfig(this.config));\n      this.extensionConnection = connection;\n      connection.init();\n      connection.subscribe((change) => subscriber.next(change));\n      return connection.unsubscribe;\n    });\n  }\n  createActionStreams() {\n    const changes$ = this.createChangesObservable().pipe(share());\n    const start$ = changes$.pipe(filter((change) => change.type === ExtensionActionTypes.START));\n    const stop$ = changes$.pipe(filter((change) => change.type === ExtensionActionTypes.STOP));\n    const liftedActions$ = changes$.pipe(filter((change) => change.type === ExtensionActionTypes.DISPATCH), map((change) => this.unwrapAction(change.payload)), concatMap((action) => {\n      if (action.type === IMPORT_STATE) {\n        return this.dispatcher.pipe(filter((action2) => action2.type === UPDATE), timeout(1e3), debounceTime(1e3), map(() => action), catchError(() => of(action)), take(1));\n      } else {\n        return of(action);\n      }\n    }));\n    const actions$ = changes$.pipe(filter((change) => change.type === ExtensionActionTypes.ACTION), map((change) => this.unwrapAction(change.payload)));\n    const actionsUntilStop$ = actions$.pipe(takeUntil(stop$));\n    const liftedUntilStop$ = liftedActions$.pipe(takeUntil(stop$));\n    this.start$ = start$.pipe(takeUntil(stop$));\n    this.actions$ = this.start$.pipe(switchMap(() => actionsUntilStop$));\n    this.liftedActions$ = this.start$.pipe(switchMap(() => liftedUntilStop$));\n  }\n  unwrapAction(action) {\n    return typeof action === \"string\" ? (0, eval)(`(${action})`) : action;\n  }\n  getExtensionConfig(config2) {\n    const extensionOptions = {\n      name: config2.name,\n      features: config2.features,\n      serialize: config2.serialize,\n      autoPause: config2.autoPause ?? false,\n      trace: config2.trace ?? false,\n      traceLimit: config2.traceLimit ?? 75\n      // The action/state sanitizers are not added to the config\n      // because sanitation is done in this class already.\n      // It is done before sending it to the devtools extension for consistency:\n      // - If we call extensionConnection.send(...),\n      //   the extension would call the sanitizers.\n      // - If we call devtoolsExtension.send(...) (aka full state update),\n      //   the extension would NOT call the sanitizers, so we have to do it ourselves.\n    };\n    if (config2.maxAge !== false) {\n      extensionOptions.maxAge = config2.maxAge;\n    }\n    return extensionOptions;\n  }\n  sendToReduxDevtools(send) {\n    try {\n      send();\n    } catch (err) {\n      console.warn(\"@ngrx/store-devtools: something went wrong inside the redux devtools\", err);\n    }\n  }\n  static {\n    this.\\u0275fac = function DevtoolsExtension_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _DevtoolsExtension)(\\u0275\\u0275inject(REDUX_DEVTOOLS_EXTENSION), \\u0275\\u0275inject(STORE_DEVTOOLS_CONFIG), \\u0275\\u0275inject(DevtoolsDispatcher));\n    };\n  }\n  static {\n    this.\\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n      token: _DevtoolsExtension,\n      factory: _DevtoolsExtension.\\u0275fac\n    });\n  }\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(DevtoolsExtension, [{\n    type: Injectable\n  }], () => [{\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [REDUX_DEVTOOLS_EXTENSION]\n    }]\n  }, {\n    type: StoreDevtoolsConfig,\n    decorators: [{\n      type: Inject,\n      args: [STORE_DEVTOOLS_CONFIG]\n    }]\n  }, {\n    type: DevtoolsDispatcher\n  }], null);\n})();\nvar INIT_ACTION = {\n  type: INIT\n};\nvar RECOMPUTE = \"@ngrx/store-devtools/recompute\";\nvar RECOMPUTE_ACTION = {\n  type: RECOMPUTE\n};\nfunction computeNextEntry(reducer, action, state, error, errorHandler2) {\n  if (error) {\n    return {\n      state,\n      error: \"Interrupted by an error up the chain\"\n    };\n  }\n  let nextState = state;\n  let nextError;\n  try {\n    nextState = reducer(state, action);\n  } catch (err) {\n    nextError = err.toString();\n    errorHandler2.handleError(err);\n  }\n  return {\n    state: nextState,\n    error: nextError\n  };\n}\nfunction recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler2, isPaused) {\n  if (minInvalidatedStateIndex >= computedStates.length && computedStates.length === stagedActionIds.length) {\n    return computedStates;\n  }\n  const nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\n  const lastIncludedActionId = stagedActionIds.length - (isPaused ? 1 : 0);\n  for (let i = minInvalidatedStateIndex; i < lastIncludedActionId; i++) {\n    const actionId = stagedActionIds[i];\n    const action = actionsById[actionId].action;\n    const previousEntry = nextComputedStates[i - 1];\n    const previousState = previousEntry ? previousEntry.state : committedState;\n    const previousError = previousEntry ? previousEntry.error : void 0;\n    const shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n    const entry = shouldSkip ? previousEntry : computeNextEntry(reducer, action, previousState, previousError, errorHandler2);\n    nextComputedStates.push(entry);\n  }\n  if (isPaused) {\n    nextComputedStates.push(computedStates[computedStates.length - 1]);\n  }\n  return nextComputedStates;\n}\nfunction liftInitialState(initialCommittedState, monitorReducer) {\n  return {\n    monitorState: monitorReducer(void 0, {}),\n    nextActionId: 1,\n    actionsById: {\n      0: liftAction(INIT_ACTION)\n    },\n    stagedActionIds: [0],\n    skippedActionIds: [],\n    committedState: initialCommittedState,\n    currentStateIndex: 0,\n    computedStates: [],\n    isLocked: false,\n    isPaused: false\n  };\n}\nfunction liftReducerWith(initialCommittedState, initialLiftedState, errorHandler2, monitorReducer, options = {}) {\n  return (reducer) => (liftedState, liftedAction) => {\n    let {\n      monitorState,\n      actionsById,\n      nextActionId,\n      stagedActionIds,\n      skippedActionIds,\n      committedState,\n      currentStateIndex,\n      computedStates,\n      isLocked,\n      isPaused\n    } = liftedState || initialLiftedState;\n    if (!liftedState) {\n      actionsById = Object.create(actionsById);\n    }\n    function commitExcessActions(n) {\n      let excess = n;\n      let idsToDelete = stagedActionIds.slice(1, excess + 1);\n      for (let i = 0; i < idsToDelete.length; i++) {\n        if (computedStates[i + 1].error) {\n          excess = i;\n          idsToDelete = stagedActionIds.slice(1, excess + 1);\n          break;\n        } else {\n          delete actionsById[idsToDelete[i]];\n        }\n      }\n      skippedActionIds = skippedActionIds.filter((id) => idsToDelete.indexOf(id) === -1);\n      stagedActionIds = [0, ...stagedActionIds.slice(excess + 1)];\n      committedState = computedStates[excess].state;\n      computedStates = computedStates.slice(excess);\n      currentStateIndex = currentStateIndex > excess ? currentStateIndex - excess : 0;\n    }\n    function commitChanges() {\n      actionsById = {\n        0: liftAction(INIT_ACTION)\n      };\n      nextActionId = 1;\n      stagedActionIds = [0];\n      skippedActionIds = [];\n      committedState = computedStates[currentStateIndex].state;\n      currentStateIndex = 0;\n      computedStates = [];\n    }\n    let minInvalidatedStateIndex = 0;\n    switch (liftedAction.type) {\n      case LOCK_CHANGES: {\n        isLocked = liftedAction.status;\n        minInvalidatedStateIndex = Infinity;\n        break;\n      }\n      case PAUSE_RECORDING: {\n        isPaused = liftedAction.status;\n        if (isPaused) {\n          stagedActionIds = [...stagedActionIds, nextActionId];\n          actionsById[nextActionId] = new PerformAction({\n            type: \"@ngrx/devtools/pause\"\n          }, +Date.now());\n          nextActionId++;\n          minInvalidatedStateIndex = stagedActionIds.length - 1;\n          computedStates = computedStates.concat(computedStates[computedStates.length - 1]);\n          if (currentStateIndex === stagedActionIds.length - 2) {\n            currentStateIndex++;\n          }\n          minInvalidatedStateIndex = Infinity;\n        } else {\n          commitChanges();\n        }\n        break;\n      }\n      case RESET: {\n        actionsById = {\n          0: liftAction(INIT_ACTION)\n        };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        committedState = initialCommittedState;\n        currentStateIndex = 0;\n        computedStates = [];\n        break;\n      }\n      case COMMIT: {\n        commitChanges();\n        break;\n      }\n      case ROLLBACK: {\n        actionsById = {\n          0: liftAction(INIT_ACTION)\n        };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        currentStateIndex = 0;\n        computedStates = [];\n        break;\n      }\n      case TOGGLE_ACTION: {\n        const {\n          id: actionId\n        } = liftedAction;\n        const index = skippedActionIds.indexOf(actionId);\n        if (index === -1) {\n          skippedActionIds = [actionId, ...skippedActionIds];\n        } else {\n          skippedActionIds = skippedActionIds.filter((id) => id !== actionId);\n        }\n        minInvalidatedStateIndex = stagedActionIds.indexOf(actionId);\n        break;\n      }\n      case SET_ACTIONS_ACTIVE: {\n        const {\n          start,\n          end,\n          active\n        } = liftedAction;\n        const actionIds = [];\n        for (let i = start; i < end; i++) actionIds.push(i);\n        if (active) {\n          skippedActionIds = difference(skippedActionIds, actionIds);\n        } else {\n          skippedActionIds = [...skippedActionIds, ...actionIds];\n        }\n        minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n        break;\n      }\n      case JUMP_TO_STATE: {\n        currentStateIndex = liftedAction.index;\n        minInvalidatedStateIndex = Infinity;\n        break;\n      }\n      case JUMP_TO_ACTION: {\n        const index = stagedActionIds.indexOf(liftedAction.actionId);\n        if (index !== -1) currentStateIndex = index;\n        minInvalidatedStateIndex = Infinity;\n        break;\n      }\n      case SWEEP: {\n        stagedActionIds = difference(stagedActionIds, skippedActionIds);\n        skippedActionIds = [];\n        currentStateIndex = Math.min(currentStateIndex, stagedActionIds.length - 1);\n        break;\n      }\n      case PERFORM_ACTION: {\n        if (isLocked) {\n          return liftedState || initialLiftedState;\n        }\n        if (isPaused || liftedState && isActionFiltered(liftedState.computedStates[currentStateIndex], liftedAction, options.predicate, options.actionsSafelist, options.actionsBlocklist)) {\n          const lastState = computedStates[computedStates.length - 1];\n          computedStates = [...computedStates.slice(0, -1), computeNextEntry(reducer, liftedAction.action, lastState.state, lastState.error, errorHandler2)];\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n        if (options.maxAge && stagedActionIds.length === options.maxAge) {\n          commitExcessActions(1);\n        }\n        if (currentStateIndex === stagedActionIds.length - 1) {\n          currentStateIndex++;\n        }\n        const actionId = nextActionId++;\n        actionsById[actionId] = liftedAction;\n        stagedActionIds = [...stagedActionIds, actionId];\n        minInvalidatedStateIndex = stagedActionIds.length - 1;\n        break;\n      }\n      case IMPORT_STATE: {\n        ({\n          monitorState,\n          actionsById,\n          nextActionId,\n          stagedActionIds,\n          skippedActionIds,\n          committedState,\n          currentStateIndex,\n          computedStates,\n          isLocked,\n          isPaused\n        } = liftedAction.nextLiftedState);\n        break;\n      }\n      case INIT: {\n        minInvalidatedStateIndex = 0;\n        if (options.maxAge && stagedActionIds.length > options.maxAge) {\n          computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler2, isPaused);\n          commitExcessActions(stagedActionIds.length - options.maxAge);\n          minInvalidatedStateIndex = Infinity;\n        }\n        break;\n      }\n      case UPDATE: {\n        const stateHasErrors = computedStates.filter((state) => state.error).length > 0;\n        if (stateHasErrors) {\n          minInvalidatedStateIndex = 0;\n          if (options.maxAge && stagedActionIds.length > options.maxAge) {\n            computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler2, isPaused);\n            commitExcessActions(stagedActionIds.length - options.maxAge);\n            minInvalidatedStateIndex = Infinity;\n          }\n        } else {\n          if (!isPaused && !isLocked) {\n            if (currentStateIndex === stagedActionIds.length - 1) {\n              currentStateIndex++;\n            }\n            const actionId = nextActionId++;\n            actionsById[actionId] = new PerformAction(liftedAction, +Date.now());\n            stagedActionIds = [...stagedActionIds, actionId];\n            minInvalidatedStateIndex = stagedActionIds.length - 1;\n            computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler2, isPaused);\n          }\n          computedStates = computedStates.map((cmp) => __spreadProps(__spreadValues({}, cmp), {\n            state: reducer(cmp.state, RECOMPUTE_ACTION)\n          }));\n          currentStateIndex = stagedActionIds.length - 1;\n          if (options.maxAge && stagedActionIds.length > options.maxAge) {\n            commitExcessActions(stagedActionIds.length - options.maxAge);\n          }\n          minInvalidatedStateIndex = Infinity;\n        }\n        break;\n      }\n      default: {\n        minInvalidatedStateIndex = Infinity;\n        break;\n      }\n    }\n    computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler2, isPaused);\n    monitorState = monitorReducer(monitorState, liftedAction);\n    return {\n      monitorState,\n      actionsById,\n      nextActionId,\n      stagedActionIds,\n      skippedActionIds,\n      committedState,\n      currentStateIndex,\n      computedStates,\n      isLocked,\n      isPaused\n    };\n  };\n}\nvar StoreDevtools = class _StoreDevtools {\n  constructor(dispatcher, actions$, reducers$, extension, scannedActions, errorHandler2, initialState2, config2) {\n    const liftedInitialState = liftInitialState(initialState2, config2.monitor);\n    const liftReducer = liftReducerWith(initialState2, liftedInitialState, errorHandler2, config2.monitor, config2);\n    const liftedAction$ = merge(merge(actions$.asObservable().pipe(skip(1)), extension.actions$).pipe(map(liftAction)), dispatcher, extension.liftedActions$).pipe(observeOn(queueScheduler));\n    const liftedReducer$ = reducers$.pipe(map(liftReducer));\n    const zoneConfig = injectZoneConfig(config2.connectInZone);\n    const liftedStateSubject = new ReplaySubject(1);\n    this.liftedStateSubscription = liftedAction$.pipe(\n      withLatestFrom(liftedReducer$),\n      // The extension would post messages back outside of the Angular zone\n      // because we call `connect()` wrapped with `runOutsideAngular`. We run change\n      // detection only once at the end after all the required asynchronous tasks have\n      // been processed (for instance, `setInterval` scheduled by the `timeout` operator).\n      // We have to re-enter the Angular zone before the `scan` since it runs the reducer\n      // which must be run within the Angular zone.\n      emitInZone(zoneConfig),\n      scan(({\n        state: liftedState\n      }, [action, reducer]) => {\n        let reducedLiftedState = reducer(liftedState, action);\n        if (action.type !== PERFORM_ACTION && shouldFilterActions(config2)) {\n          reducedLiftedState = filterLiftedState(reducedLiftedState, config2.predicate, config2.actionsSafelist, config2.actionsBlocklist);\n        }\n        extension.notify(action, reducedLiftedState);\n        return {\n          state: reducedLiftedState,\n          action\n        };\n      }, {\n        state: liftedInitialState,\n        action: null\n      })\n    ).subscribe(({\n      state,\n      action\n    }) => {\n      liftedStateSubject.next(state);\n      if (action.type === PERFORM_ACTION) {\n        const unliftedAction = action.action;\n        scannedActions.next(unliftedAction);\n      }\n    });\n    this.extensionStartSubscription = extension.start$.pipe(emitInZone(zoneConfig)).subscribe(() => {\n      this.refresh();\n    });\n    const liftedState$ = liftedStateSubject.asObservable();\n    const state$ = liftedState$.pipe(map(unliftState));\n    Object.defineProperty(state$, \"state\", {\n      value: toSignal(state$, {\n        manualCleanup: true,\n        requireSync: true\n      })\n    });\n    this.dispatcher = dispatcher;\n    this.liftedState = liftedState$;\n    this.state = state$;\n  }\n  ngOnDestroy() {\n    this.liftedStateSubscription.unsubscribe();\n    this.extensionStartSubscription.unsubscribe();\n  }\n  dispatch(action) {\n    this.dispatcher.next(action);\n  }\n  next(action) {\n    this.dispatcher.next(action);\n  }\n  error(error) {\n  }\n  complete() {\n  }\n  performAction(action) {\n    this.dispatch(new PerformAction(action, +Date.now()));\n  }\n  refresh() {\n    this.dispatch(new Refresh());\n  }\n  reset() {\n    this.dispatch(new Reset(+Date.now()));\n  }\n  rollback() {\n    this.dispatch(new Rollback(+Date.now()));\n  }\n  commit() {\n    this.dispatch(new Commit(+Date.now()));\n  }\n  sweep() {\n    this.dispatch(new Sweep());\n  }\n  toggleAction(id) {\n    this.dispatch(new ToggleAction(id));\n  }\n  jumpToAction(actionId) {\n    this.dispatch(new JumpToAction(actionId));\n  }\n  jumpToState(index) {\n    this.dispatch(new JumpToState(index));\n  }\n  importState(nextLiftedState) {\n    this.dispatch(new ImportState(nextLiftedState));\n  }\n  lockChanges(status) {\n    this.dispatch(new LockChanges(status));\n  }\n  pauseRecording(status) {\n    this.dispatch(new PauseRecording(status));\n  }\n  static {\n    this.\\u0275fac = function StoreDevtools_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _StoreDevtools)(\\u0275\\u0275inject(DevtoolsDispatcher), \\u0275\\u0275inject(ActionsSubject), \\u0275\\u0275inject(ReducerObservable), \\u0275\\u0275inject(DevtoolsExtension), \\u0275\\u0275inject(ScannedActionsSubject), \\u0275\\u0275inject(ErrorHandler), \\u0275\\u0275inject(INITIAL_STATE), \\u0275\\u0275inject(STORE_DEVTOOLS_CONFIG));\n    };\n  }\n  static {\n    this.\\u0275prov = /* @__PURE__ */ \\u0275\\u0275defineInjectable({\n      token: _StoreDevtools,\n      factory: _StoreDevtools.\\u0275fac\n    });\n  }\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(StoreDevtools, [{\n    type: Injectable\n  }], () => [{\n    type: DevtoolsDispatcher\n  }, {\n    type: ActionsSubject\n  }, {\n    type: ReducerObservable\n  }, {\n    type: DevtoolsExtension\n  }, {\n    type: ScannedActionsSubject\n  }, {\n    type: ErrorHandler\n  }, {\n    type: void 0,\n    decorators: [{\n      type: Inject,\n      args: [INITIAL_STATE]\n    }]\n  }, {\n    type: StoreDevtoolsConfig,\n    decorators: [{\n      type: Inject,\n      args: [STORE_DEVTOOLS_CONFIG]\n    }]\n  }], null);\n})();\nfunction emitInZone({\n  ngZone,\n  connectInZone\n}) {\n  return (source) => connectInZone ? new Observable((subscriber) => source.subscribe({\n    next: (value) => ngZone.run(() => subscriber.next(value)),\n    error: (error) => ngZone.run(() => subscriber.error(error)),\n    complete: () => ngZone.run(() => subscriber.complete())\n  })) : source;\n}\nvar IS_EXTENSION_OR_MONITOR_PRESENT = new InjectionToken(\"@ngrx/store-devtools Is Devtools Extension or Monitor Present\");\nfunction createIsExtensionOrMonitorPresent(extension, config2) {\n  return Boolean(extension) || config2.monitor !== noMonitor;\n}\nfunction createReduxDevtoolsExtension() {\n  const extensionKey = \"__REDUX_DEVTOOLS_EXTENSION__\";\n  if (typeof window === \"object\" && typeof window[extensionKey] !== \"undefined\") {\n    return window[extensionKey];\n  } else {\n    return null;\n  }\n}\nfunction createStateObservable(devtools) {\n  return devtools.state;\n}\nfunction provideStoreDevtools(options = {}) {\n  return makeEnvironmentProviders([DevtoolsExtension, DevtoolsDispatcher, StoreDevtools, {\n    provide: INITIAL_OPTIONS,\n    useValue: options\n  }, {\n    provide: IS_EXTENSION_OR_MONITOR_PRESENT,\n    deps: [REDUX_DEVTOOLS_EXTENSION, STORE_DEVTOOLS_CONFIG],\n    useFactory: createIsExtensionOrMonitorPresent\n  }, {\n    provide: REDUX_DEVTOOLS_EXTENSION,\n    useFactory: createReduxDevtoolsExtension\n  }, {\n    provide: STORE_DEVTOOLS_CONFIG,\n    deps: [INITIAL_OPTIONS],\n    useFactory: createConfig\n  }, {\n    provide: StateObservable,\n    deps: [StoreDevtools],\n    useFactory: createStateObservable\n  }, {\n    provide: ReducerManagerDispatcher,\n    useExisting: DevtoolsDispatcher\n  }]);\n}\nvar StoreDevtoolsModule = class _StoreDevtoolsModule {\n  static instrument(options = {}) {\n    return {\n      ngModule: _StoreDevtoolsModule,\n      providers: [provideStoreDevtools(options)]\n    };\n  }\n  static {\n    this.\\u0275fac = function StoreDevtoolsModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || _StoreDevtoolsModule)();\n    };\n  }\n  static {\n    this.\\u0275mod = /* @__PURE__ */ \\u0275\\u0275defineNgModule({\n      type: _StoreDevtoolsModule\n    });\n  }\n  static {\n    this.\\u0275inj = /* @__PURE__ */ \\u0275\\u0275defineInjector({});\n  }\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && setClassMetadata(StoreDevtoolsModule, [{\n    type: NgModule,\n    args: [{}]\n  }], null, null);\n})();\n\n// src/app/store/loan/loan.state.ts\nvar initialState = {\n  loans: [],\n  selectedLoan: null\n};\n\n// src/app/store/loan/loan.reducer.ts\nvar loanReducer = createReducer(initialState, on(loadLoansSuccess, (state, { loans }) => __spreadProps(__spreadValues({}, state), {\n  loans\n})), on(selectLoan, (state, { loanId }) => __spreadProps(__spreadValues({}, state), {\n  selectedLoan: state.loans.find((loan) => loan.LoanId === loanId) || null\n})), on(addLoanSuccess, (state, { loan }) => __spreadProps(__spreadValues({}, state), {\n  loans: [...state.loans, loan]\n})));\n\n// src/app/app.config.ts\nvar appConfig = {\n  providers: [\n    provideZoneChangeDetection({ eventCoalescing: true }),\n    provideRouter(routes),\n    provideHttpClient(withInterceptorsFromDi()),\n    {\n      provide: HTTP_INTERCEPTORS,\n      useClass: jwtInterceptor,\n      multi: true\n    },\n    provideStore({ auth: authReducer, loan: loanReducer }),\n    provideStoreDevtools()\n  ]\n};\n\n// src/app/app.component.ts\nvar AppComponent = class _AppComponent {\n  title = \"mortgage-app\";\n  static \\u0275fac = function AppComponent_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || _AppComponent)();\n  };\n  static \\u0275cmp = /* @__PURE__ */ \\u0275\\u0275defineComponent({ type: _AppComponent, selectors: [[\"app-root\"]], decls: 1, vars: 0, template: function AppComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      \\u0275\\u0275element(0, \"router-outlet\");\n    }\n  }, dependencies: [RouterOutlet], encapsulation: 2 });\n};\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && \\u0275setClassDebugInfo(AppComponent, { className: \"AppComponent\", filePath: \"src/app/app.component.ts\", lineNumber: 10 });\n})();\n\n// src/main.ts\nbootstrapApplication(AppComponent, appConfig).catch((err) => console.error(err));\n/*! Bundled license information:\n\n@angular/core/fesm2022/primitives/signals.mjs:\n  (**\n   * @license Angular v19.2.3\n   * (c) 2010-2025 Google LLC. https://angular.io/\n   * License: MIT\n   *)\n\n@angular/core/fesm2022/primitives/di.mjs:\n  (**\n   * @license Angular v19.2.3\n   * (c) 2010-2025 Google LLC. https://angular.io/\n   * License: MIT\n   *)\n\n@angular/core/fesm2022/core.mjs:\n  (**\n   * @license Angular v19.2.3\n   * (c) 2010-2025 Google LLC. https://angular.io/\n   * License: MIT\n   *)\n\n@angular/core/fesm2022/core.mjs:\n  (*!\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.dev/license\n   *)\n\n@angular/core/fesm2022/core.mjs:\n  (*!\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.dev/license\n   *)\n\n@angular/core/fesm2022/core.mjs:\n  (*!\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.dev/license\n   *)\n\n@angular/core/fesm2022/core.mjs:\n  (*!\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.dev/license\n   *)\n\n@angular/core/fesm2022/core.mjs:\n  (*!\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.dev/license\n   *)\n\n@angular/core/fesm2022/core.mjs:\n  (*!\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.dev/license\n   *)\n\n@angular/core/fesm2022/core.mjs:\n  (*!\n   * @license\n   * Copyright Google LLC All Rights Reserved.\n   *\n   * Use of this source code is governed by an MIT-style license that can be\n   * found in the LICENSE file at https://angular.dev/license\n   *)\n\n@angular/common/fesm2022/common.mjs:\n  (**\n   * @license Angular v19.2.3\n   * (c) 2010-2025 Google LLC. https://angular.io/\n   * License: MIT\n   *)\n\n@angular/common/fesm2022/http.mjs:\n  (**\n   * @license Angular v19.2.3\n   * (c) 2010-2025 Google LLC. https://angular.io/\n   * License: MIT\n   *)\n\n@angular/platform-browser/fesm2022/platform-browser.mjs:\n  (**\n   * @license Angular v19.2.3\n   * (c) 2010-2025 Google LLC. https://angular.io/\n   * License: MIT\n   *)\n\n@angular/router/fesm2022/router.mjs:\n  (**\n   * @license Angular v19.2.3\n   * (c) 2010-2025 Google LLC. https://angular.io/\n   * License: MIT\n   *)\n\n@angular/forms/fesm2022/forms.mjs:\n  (**\n   * @license Angular v19.2.3\n   * (c) 2010-2025 Google LLC. https://angular.io/\n   * License: MIT\n   *)\n\n@angular/core/fesm2022/rxjs-interop.mjs:\n  (**\n   * @license Angular v19.2.3\n   * (c) 2010-2025 Google LLC. https://angular.io/\n   * License: MIT\n   *)\n*/\n//# sourceMappingURL=main.js.map\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\dist\\mortgage-app\\browser\\polyfills.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\animations.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\amortization\\amortization.component.html","messages":[{"ruleId":"@angular-eslint/template/label-has-associated-control","severity":2,"message":"A label component must be associated with a form element","line":11,"column":13,"nodeType":null,"messageId":"labelHasAssociatedControl","endLine":11,"endColumn":57},{"ruleId":"@angular-eslint/template/label-has-associated-control","severity":2,"message":"A label component must be associated with a form element","line":42,"column":13,"nodeType":null,"messageId":"labelHasAssociatedControl","endLine":42,"endColumn":42},{"ruleId":"@angular-eslint/template/label-has-associated-control","severity":2,"message":"A label component must be associated with a form element","line":68,"column":13,"nodeType":null,"messageId":"labelHasAssociatedControl","endLine":68,"endColumn":45}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<div class=\"container mt-4\" @slideIn>\r\n  <h2 class=\"text-center pb-4\">Loan Amortization Calculator</h2>\r\n  <br>\r\n  <div class=\"row\">\r\n    <div class=\"col-md-6 mt-4\" @slideIn>\r\n      <form [formGroup]=\"amortizationForm\" (ngSubmit)=\"submitForm()\">\r\n\r\n        <!-- Loan Amount -->\r\n        <div class=\"form-group\">\r\n          <div class=\"input-row d-flex justify-content-between align-items-center mb-2\">\r\n            <label class=\"mb-0 me-2\">Loan Amount</label>\r\n            <div class=\"input-group input-group-sm\" style=\"width: 160px;\">\r\n              <span class=\"input-group-text\">$</span>\r\n              <input\r\n                type=\"text\"\r\n                formControlName=\"LoanAmount\"\r\n                [(ngModel)]=\"amortizationForm.value.LoanAmount\"\r\n                class=\"form-control text-end uniform-input\"\r\n              />\r\n            </div>\r\n\r\n        \r\n          </div>\r\n          <input\r\n            type=\"range\"\r\n            formControlName=\"LoanAmount\"\r\n            [(ngModel)]=\"amortizationForm.value.LoanAmount\"\r\n            min=\"100000\"\r\n            max=\"100000000\"\r\n            step=\"100000\"\r\n            class=\"custom-slider\"\r\n          />\r\n          <div class=\"slider-labels\">\r\n            <span>$100,000</span>\r\n            <span>$100M</span>\r\n          </div>\r\n        </div>\r\n\r\n        <!-- Loan Term -->\r\n        <div class=\"form-group\">\r\n          <div class=\"input-row\">\r\n            <label>Tenure (Years)</label>\r\n            <input\r\n              type=\"text\"\r\n              formControlName=\"LoanTermYears\"\r\n              [(ngModel)]=\"amortizationForm.value.LoanTermYears\"\r\n              class=\"form-control slim-input uniform-input\"\r\n            />\r\n          </div>\r\n          <input\r\n            type=\"range\"\r\n            formControlName=\"LoanTermYears\"\r\n            [(ngModel)]=\"amortizationForm.value.LoanTermYears\"\r\n            min=\"1\"\r\n            max=\"40\"\r\n            step=\"1\"\r\n            class=\"custom-slider\"\r\n          />\r\n          <div class=\"slider-labels\">\r\n            <span>1</span>\r\n            <span>40</span>\r\n          </div>\r\n        </div>\r\n\r\n        <!-- Interest Rate -->\r\n        <div class=\"form-group\">\r\n          <div class=\"input-row\">\r\n            <label>Interest Rate (%)</label>\r\n            <input\r\n              type=\"text\"\r\n              formControlName=\"InterestRate\"\r\n              [(ngModel)]=\"amortizationForm.value.InterestRate\"\r\n              class=\"form-control slim-input uniform-input\"\r\n            />\r\n          </div>\r\n          <input\r\n            type=\"range\"\r\n            formControlName=\"InterestRate\"\r\n            [(ngModel)]=\"amortizationForm.value.InterestRate\"\r\n            min=\"0.5\"\r\n            max=\"25\"\r\n            step=\"0.25\"\r\n            class=\"custom-slider\"\r\n          />\r\n          <div class=\"slider-labels\">\r\n            <span>0.5</span>\r\n            <span>25</span>\r\n          </div>\r\n        </div>\r\n\r\n        <!-- Submit Button -->\r\n        <button type=\"submit\" class=\"fancy-button mt-1 w-100\" style=\"--bg-color: black; --text-color: white; border: none;\">\r\n          <span class=\"text-wrapper\">\r\n            <span class=\"text-default\">Calculate EMI</span>\r\n            <span class=\"text-hover\">Calculate EMI</span>\r\n          </span>\r\n        </button>\r\n      </form>\r\n    </div>\r\n\r\n    <!-- Summary -->\r\n    <div class=\"col-md-6 text-center\">\r\n      <h4>Monthly EMI: {{ monthlyPayment | currency:'USD' }}</h4>\r\n      <p>Principal Amount: {{ amortizationForm.value.LoanAmount | currency:'USD' }}</p>\r\n      <p>Interest Amount: {{ totalInterest | currency:'USD' }}</p>\r\n      <p>Total Payable: {{ totalPayment | currency:'USD' }}</p>\r\n      <canvas id=\"pieChart\"></canvas>\r\n    </div>\r\n  </div>\r\n  <br>\r\n  <h4 class=\"text-center mt-4\">Amortization Schedule</h4>\r\n  <!-- Table -->\r\n  <table class=\"table text-center mt-4\">\r\n    <thead>\r\n      <tr>\r\n        <th>Month</th>\r\n        <th>Principal</th>\r\n        <th>Interest</th>\r\n        <th>Total Payment</th>\r\n        <th>Remaining Balance</th>\r\n      </tr>\r\n    </thead>\r\n    <tbody>\r\n      <tr *ngFor=\"let row of amortizationSchedule$ | async\">\r\n        <td>{{ row.PaymentNumber }}</td>\r\n        <td>{{ row.PrincipalPayment | currency:'USD' }}</td>\r\n        <td>{{ row.InterestPayment | currency:'USD' }}</td>\r\n        <td>{{ row.MonthlyPayment | currency:'USD' }}</td>\r\n        <td>{{ row.RemainingBalance | currency:'USD' }}</td>\r\n      </tr>\r\n    </tbody>\r\n  </table>\r\n</div>\r\n\r\n\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\amortization\\amortization.component.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\amortization\\amortization.component.ts","messages":[{"ruleId":"@typescript-eslint/no-inferrable-types","severity":2,"message":"Type number trivially inferred from a number literal, remove type annotation.","line":23,"column":3,"nodeType":"PropertyDefinition","messageId":"noInferrableType","endLine":23,"endColumn":29,"fix":{"range":[1218,1226],"text":""}},{"ruleId":"@typescript-eslint/no-inferrable-types","severity":2,"message":"Type number trivially inferred from a number literal, remove type annotation.","line":24,"column":3,"nodeType":"PropertyDefinition","messageId":"noInferrableType","endLine":24,"endColumn":28,"fix":{"range":[1247,1255],"text":""}},{"ruleId":"@typescript-eslint/no-inferrable-types","severity":2,"message":"Type number trivially inferred from a number literal, remove type annotation.","line":25,"column":3,"nodeType":"PropertyDefinition","messageId":"noInferrableType","endLine":25,"endColumn":30,"fix":{"range":[1278,1286],"text":""}}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":3,"fixableWarningCount":0,"source":"import { Component, OnInit, OnDestroy } from '@angular/core';\r\nimport { Chart, registerables } from 'chart.js';\r\nimport { FormBuilder, FormGroup, FormsModule, ReactiveFormsModule } from '@angular/forms';\r\nimport { filter, Observable, Subscription } from 'rxjs';\r\nimport { IAmortizationRequest, IAmortizationSchedule } from '../models/IAmortizationSchedule';\r\nimport { Store } from '@ngrx/store';\r\nimport { selectAmortizationSchedule } from '../store/amortization/amortization.selectors';\r\nimport { calculateAmortization, resetAmortization } from '../store/amortization/amortization.actions';\r\nimport { Router } from '@angular/router';\r\nimport { CommonModule, CurrencyPipe } from '@angular/common';\r\nimport { slideIn, slideOut, staggerList } from '../../animations';\r\n\r\n@Component({\r\n  selector: 'app-amortization',\r\n  imports: [FormsModule, ReactiveFormsModule, CommonModule, CurrencyPipe],\r\n  templateUrl: './amortization.component.html',\r\n  styleUrl: './amortization.component.css',\r\n  animations: [slideIn, slideOut, staggerList],\r\n})\r\nexport class AmortizationComponent implements OnInit, OnDestroy {\r\n  amortizationForm!: FormGroup;\r\n  amortizationSchedule$!: Observable<IAmortizationSchedule[]>;\r\n  totalInterest: number = 0;\r\n  totalPayment: number = 0;\r\n  monthlyPayment: number = 0;\r\n  chart!: Chart;\r\n  scheduleSubscription!: Subscription;\r\n\r\n  constructor(private fb: FormBuilder, private store: Store, private router: Router) {}\r\n\r\n  ngOnInit(): void {\r\n    Chart.register(...registerables);\r\n\r\n    // Initialize form with default values\r\n    this.amortizationForm = this.fb.group({\r\n      LoanAmount: [500000, []],\r\n      InterestRate: [7.5, []],\r\n      LoanTermYears: [5, []],\r\n    });\r\n\r\n    // Fetch amortization schedule from store\r\n    this.amortizationSchedule$ = this.store.select(selectAmortizationSchedule).pipe(\r\n      filter((schedule) => schedule !== null)\r\n    );\r\n\r\n    // Subscribe to schedule and calculate summary when it updates\r\n    this.scheduleSubscription = this.amortizationSchedule$.subscribe((schedule) => {\r\n      if (schedule.length > 0) {\r\n        this.calculateSummary(schedule);\r\n        this.renderChart();\r\n      }\r\n    });\r\n\r\n    // Load amortization schedule on initialization\r\n    this.loadDefaultAmortization();\r\n  }\r\n\r\n  submitForm(): void {\r\n    if (this.amortizationForm.valid) {\r\n      const request: IAmortizationRequest = this.amortizationForm.value;\r\n      this.store.dispatch(calculateAmortization({ request }));\r\n    }\r\n  }\r\n\r\n  private calculateSummary(schedule: IAmortizationSchedule[]): void {\r\n    this.totalInterest = schedule.reduce((sum, p) => sum + p.InterestPayment, 0);\r\n    this.totalPayment = schedule.reduce((sum, p) => sum + p.MonthlyPayment, 0);\r\n    this.monthlyPayment = schedule[0]?.MonthlyPayment || 0;\r\n  }\r\n\r\n  private renderChart(): void {\r\n    if (this.chart) {\r\n      this.chart.destroy();\r\n    }\r\n\r\n    this.chart = new Chart('pieChart', {\r\n      type: 'pie',\r\n      data: {\r\n        labels: ['Principal', 'Interest'],\r\n        datasets: [\r\n          {\r\n            data: [this.amortizationForm.value.LoanAmount, this.totalInterest],\r\n            backgroundColor: ['#4CAF50', '#FF5733'],\r\n          },\r\n        ],\r\n      },\r\n    });\r\n  }\r\n\r\n  private loadDefaultAmortization(): void {\r\n    const request: IAmortizationRequest = {\r\n      LoanAmount: 500000,\r\n      InterestRate: 7.5,\r\n      LoanTermYears: 5,\r\n    };\r\n    this.store.dispatch(calculateAmortization({ request }));\r\n  }\r\n\r\n  ngOnDestroy(): void {\r\n    // Unsubscribe from schedule observable to prevent memory leaks\r\n    if (this.scheduleSubscription) {\r\n      this.scheduleSubscription.unsubscribe();\r\n    }\r\n\r\n    if (this.chart) {\r\n      this.chart.destroy();\r\n    }\r\n\r\n    // Reset state when navigating away\r\n    this.store.dispatch(resetAmortization());\r\n\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\amortization\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\app.component.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\app.component.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'of' is defined but never used.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":12},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":13,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[574,577],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[574,577],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":74,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2361,2364],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2361,2364],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ComponentFixture, TestBed } from '@angular/core/testing';\r\nimport { AppComponent } from './app.component';\r\nimport { provideMockStore, MockStore } from '@ngrx/store/testing';\r\nimport { Router, NavigationEnd } from '@angular/router';\r\nimport { RouterTestingModule } from '@angular/router/testing';\r\nimport { loginSuccess } from './store/auth/auth.actions';\r\nimport { of, Subject } from 'rxjs';\r\n\r\ndescribe('App Component', () => {\r\n  let component: AppComponent;\r\n  let fixture: ComponentFixture<AppComponent>;\r\n  let store: MockStore;\r\n  let routerEvents$: Subject<any>;\r\n\r\n  beforeEach(async () => {\r\n    routerEvents$ = new Subject();\r\n\r\n    await TestBed.configureTestingModule({\r\n      imports: [AppComponent, RouterTestingModule],\r\n      providers: [\r\n        provideMockStore(),\r\n        {\r\n          provide: Router,\r\n          useValue: {\r\n            events: routerEvents$.asObservable(),\r\n          },\r\n        },\r\n      ],\r\n    }).compileComponents();\r\n\r\n    store = TestBed.inject(MockStore);\r\n    fixture = TestBed.createComponent(AppComponent);\r\n    component = fixture.componentInstance;\r\n    fixture.detectChanges();\r\n  });\r\n\r\n  it('should create the app', () => {\r\n    expect(component).toBeTruthy();\r\n  });\r\n\r\n  it('should hide the navbar on /login route', () => {\r\n    routerEvents$.next(new NavigationEnd(1, '/redirect', '/login'));\r\n    expect(component.hideNavbar).toBeTrue();\r\n  });\r\n\r\n  it('should show the navbar on non-login route', () => {\r\n    routerEvents$.next(new NavigationEnd(1, '/redirect', '/dashboard'));\r\n    expect(component.hideNavbar).toBeFalse();\r\n  });\r\n\r\n  it('should dispatch loginSuccess if auth data exists in localStorage', () => {\r\n    const dispatchSpy = spyOn(store, 'dispatch');\r\n    const mockAuth = {\r\n      token: 'mockToken',\r\n      username: 'john',\r\n    };\r\n    spyOn(localStorage, 'getItem').and.returnValue(JSON.stringify(mockAuth));\r\n\r\n    component.ngOnInit();\r\n\r\n    expect(dispatchSpy).toHaveBeenCalledWith(loginSuccess(mockAuth));\r\n  });\r\n\r\n  it('should not dispatch loginSuccess if auth data is missing', () => {\r\n    const dispatchSpy = spyOn(store, 'dispatch');\r\n    spyOn(localStorage, 'getItem').and.returnValue(null);\r\n\r\n    component.ngOnInit();\r\n\r\n    expect(dispatchSpy).not.toHaveBeenCalled();\r\n  });\r\n\r\n  it('should return route animation data', () => {\r\n    const mockOutlet: any = {\r\n      activatedRouteData: { animation: 'fade' },\r\n    };\r\n    const animation = component.getRouteAnimationData(mockOutlet);\r\n    expect(animation).toBe('fade');\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\app.component.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\app.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\app.routes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\common\\navbar\\navbar.component.html","messages":[{"ruleId":"@angular-eslint/template/click-events-have-key-events","severity":2,"message":"click must be accompanied by either keyup, keydown or keypress event for accessibility.","line":53,"column":15,"nodeType":null,"messageId":"clickEventsHaveKeyEvents","endLine":58,"endColumn":19},{"ruleId":"@angular-eslint/template/interactive-supports-focus","severity":2,"message":"Elements with interaction handlers must be focusable.","line":53,"column":15,"nodeType":null,"messageId":"interactiveSupportsFocus","endLine":58,"endColumn":19}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<nav class=\"navbar navbar-expand-lg\">\r\n    <div class=\"container-fluid\">\r\n      <button\r\n        class=\"navbar-toggler\"\r\n        type=\"button\"\r\n        data-bs-toggle=\"collapse\"\r\n        data-bs-target=\"#navbarTogglerDemo01\"\r\n        aria-controls=\"navbarTogglerDemo01\"\r\n        aria-expanded=\"false\"\r\n        aria-label=\"Toggle navigation\"\r\n      >\r\n        <span class=\"navbar-toggler-icon\"></span>\r\n      </button>\r\n      <div class=\"collapse navbar-collapse\" id=\"navbarTogglerDemo01\">\r\n        <a class=\"navbar-brand mr-4\"><i class=\"bi bi-piggy-bank-fill\"></i> Loan Calculation App</a>\r\n        <ul class=\"navbar-nav me-auto mb-2 mb-lg-0\">\r\n          <li class=\"nav-item\" *ngIf=\"isLoggedIn$ | async\">\r\n            <a\r\n              class=\"nav-link\"\r\n              routerLink=\"/dashboard\"\r\n              routerLinkActive=\"active\"\r\n               [routerLinkActiveOptions]=\"{ exact: false }\"\r\n              >Dashboard</a\r\n            >\r\n          </li>\r\n          <li class=\"nav-item\" *ngIf=\"isLoggedIn$ | async\">\r\n            <a\r\n              class=\"nav-link\"\r\n              routerLink=\"/amortization\"\r\n              routerLinkActive=\"active\"\r\n               [routerLinkActiveOptions]=\"{ exact: true }\"\r\n              >Amortization Calculator</a\r\n            >\r\n          </li>\r\n          <li class=\"nav-item\" *ngIf=\"isLoggedIn$ | async\">\r\n            <a\r\n              class=\"nav-link\"\r\n              routerLink=\"/loan-application\"\r\n              routerLinkActive=\"active\"\r\n               [routerLinkActiveOptions]=\"{ exact: true }\"\r\n              >Loan Application</a\r\n            >\r\n          </li>\r\n        </ul>\r\n        <ul class=\"navbar-nav ms-auto\">\r\n\r\n          <li class=\"nav-item\" *ngIf=\"isLoggedIn$ | async\">\r\n            <span class=\"nav-link no-hover mr-4\">Hi, {{  username$ | async  }}!!</span>\r\n          </li>\r\n\r\n          <li class=\"nav-item\" *ngIf=\"isLoggedIn$ | async\">\r\n            <div class=\"fancy-button-wrapper\">\r\n              <a class=\"fancy-button\" (click)=\"logout()\">\r\n                <span class=\"text-wrapper\">\r\n                  <span class=\"text-default\">Logout</span>\r\n                  <span class=\"text-hover\">Logout</span>\r\n                </span>\r\n              </a>\r\n            </div>\r\n          </li>\r\n        </ul>\r\n      </div>\r\n    </div>\r\n  </nav>\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\common\\navbar\\navbar.component.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":31,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1142,1145],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1142,1145],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ComponentFixture, TestBed } from '@angular/core/testing';\r\nimport { NavbarComponent } from './navbar.component';\r\nimport { provideMockStore, MockStore } from '@ngrx/store/testing';\r\nimport { AuthState } from '../../store/auth/auth.reducer';\r\nimport * as AuthSelectors from '../../store/auth/auth.selectors';\r\nimport * as AuthActions from '../../store/auth/auth.actions';\r\nimport { Router } from '@angular/router';\r\nimport { of } from 'rxjs';\r\nimport { RouterTestingModule } from '@angular/router/testing';\r\n\r\ndescribe('NavbarComponent', () => {\r\n  let component: NavbarComponent;\r\n  let fixture: ComponentFixture<NavbarComponent>;\r\n  let store: MockStore;\r\n  let router: Router;\r\n\r\n  beforeEach(async () => {\r\n    await TestBed.configureTestingModule({\r\n      imports: [\r\n        NavbarComponent,\r\n        RouterTestingModule.withRoutes([]),\r\n      ],\r\n      providers: [provideMockStore()],\r\n    }).compileComponents();\r\n\r\n    store = TestBed.inject(MockStore);\r\n    router = TestBed.inject(Router);\r\n    spyOn(router, 'navigate'); // spy after injection\r\n\r\n    // Mock selectors\r\n    spyOn(store, 'select').and.callFake((selector: any) => {\r\n      if (selector === AuthSelectors.selectAuthToken) {\r\n        return of('mockToken');\r\n      } else if (selector === AuthSelectors.selectAuthState) {\r\n        return of({ username: 'john' } as AuthState);\r\n      }\r\n      return of(null);\r\n    });\r\n\r\n    fixture = TestBed.createComponent(NavbarComponent);\r\n    component = fixture.componentInstance;\r\n    fixture.detectChanges();\r\n  });\r\n\r\n  it('should create', () => {\r\n    expect(component).toBeTruthy();\r\n  });\r\n\r\n  it('should initialize observables on ngOnInit', (done) => {\r\n    component.isLoggedIn$.subscribe((value) => {\r\n      expect(value).toBeTrue();\r\n    });\r\n\r\n    component.username$.subscribe((value) => {\r\n      expect(value).toBe('john');\r\n      done();\r\n    });\r\n  });\r\n\r\n  it('should dispatch logout and navigate to login on logout()', () => {\r\n    const dispatchSpy = spyOn(store, 'dispatch');\r\n    spyOn(localStorage, 'removeItem');\r\n\r\n    component.logout();\r\n\r\n    expect(localStorage.removeItem).toHaveBeenCalledWith('auth');\r\n    expect(dispatchSpy).toHaveBeenCalledWith(AuthActions.logout());\r\n    expect(router.navigate).toHaveBeenCalledWith(['/login']);\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\common\\navbar\\navbar.component.ts","messages":[{"ruleId":"@angular-eslint/use-lifecycle-interface","severity":1,"message":"Lifecycle interface 'OnInit' should be implemented for method 'ngOnInit'. (https://angular.dev/style-guide#style-09-01)","line":23,"column":3,"nodeType":"Identifier","messageId":"useLifecycleInterface","endLine":23,"endColumn":11,"fix":{"range":[67,629],"text":", OnInit } from '@angular/core';\r\nimport { Router, RouterModule } from '@angular/router';\r\nimport { AuthState } from '../../store/auth/auth.reducer';\r\nimport { Store } from '@ngrx/store';\r\nimport { Observable, map } from 'rxjs';\r\nimport { selectAuthState, selectAuthToken } from '../../store/auth/auth.selectors';\r\nimport { logout } from '../../store/auth/auth.actions';\r\n\r\n@Component({\r\n  selector: 'app-navbar',\r\n  imports: [CommonModule, RouterModule],\r\n  templateUrl: './navbar.component.html',\r\n  styleUrl: './navbar.component.css'\r\n})\r\nexport class NavbarComponent implements OnInit"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { CommonModule } from '@angular/common';\r\nimport { Component } from '@angular/core';\r\nimport { Router, RouterModule } from '@angular/router';\r\nimport { AuthState } from '../../store/auth/auth.reducer';\r\nimport { Store } from '@ngrx/store';\r\nimport { Observable, map } from 'rxjs';\r\nimport { selectAuthState, selectAuthToken } from '../../store/auth/auth.selectors';\r\nimport { logout } from '../../store/auth/auth.actions';\r\n\r\n@Component({\r\n  selector: 'app-navbar',\r\n  imports: [CommonModule, RouterModule],\r\n  templateUrl: './navbar.component.html',\r\n  styleUrl: './navbar.component.css'\r\n})\r\nexport class NavbarComponent {\r\n  isLoggedIn$!: Observable<boolean>;\r\n  username: string | null = null;\r\n  username$!: Observable<string | null>;\r\n\r\n  constructor(private router: Router, private store: Store<AuthState>) {}\r\n\r\n  ngOnInit() {\r\n    this.isLoggedIn$ = this.store.select(selectAuthToken).pipe(map(token => !!token));\r\n    this.username$ = this.store.select(selectAuthState).pipe(map(state => state.username));\r\n  }\r\n\r\n  // Handle logout and clear local storage\r\n  logout() {\r\n    localStorage.removeItem('auth');\r\n    this.store.dispatch(logout());\r\n    this.router.navigate(['/login']); \r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\dashboard\\dashboard.component.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\dashboard\\dashboard.component.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'of' is defined but never used.","line":6,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":12},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":76,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2454,2457],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2454,2457],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ComponentFixture, TestBed } from '@angular/core/testing';\r\nimport { DashboardComponent } from './dashboard.component';\r\nimport { provideMockStore, MockStore } from '@ngrx/store/testing';\r\nimport { Router } from '@angular/router';\r\nimport { CurrencyPipe, CommonModule } from '@angular/common';\r\nimport { of } from 'rxjs';\r\nimport * as LoanActions from '../store/loan/loan.actions';\r\nimport { ILoan } from '../models/ILoan';\r\nimport { selectLoans } from '../store/loan/loan.selectors';\r\nimport { provideAnimations } from '@angular/platform-browser/animations';\r\n\r\ndescribe('Dashboard Component', () => {\r\n  let component: DashboardComponent;\r\n  let fixture: ComponentFixture<DashboardComponent>;\r\n  let store: MockStore;\r\n  let routerSpy: jasmine.SpyObj<Router>;\r\n\r\n  const mockLoans: ILoan[] = [\r\n    {\r\n      LoanId: 1,\r\n      UserLoanNumber: 1,\r\n      LoanAmount: 200000,\r\n      InterestRate: 3.5,\r\n      LoanTermYears: 30,\r\n      ApplicationDate: '2024-01-01T00:00:00Z',\r\n      ApprovalStatus: 'Pending',\r\n    },\r\n  ];\r\n\r\n  beforeEach(async () => {\r\n    routerSpy = jasmine.createSpyObj('Router', ['navigate']);\r\n\r\n    await TestBed.configureTestingModule({\r\n      imports: [DashboardComponent, CommonModule],\r\n      providers: [\r\n        provideMockStore({\r\n          selectors: [\r\n            {\r\n              selector: selectLoans,\r\n              value: mockLoans,\r\n            },\r\n          ],\r\n        }),\r\n        provideAnimations(),\r\n        CurrencyPipe,\r\n        { provide: Router, useValue: routerSpy },\r\n      ],\r\n    }).compileComponents();\r\n\r\n    store = TestBed.inject(MockStore);\r\n    fixture = TestBed.createComponent(DashboardComponent);\r\n    component = fixture.componentInstance;\r\n    fixture.detectChanges();\r\n  });\r\n\r\n  it('should create the component', () => {\r\n    expect(component).toBeTruthy();\r\n  });\r\n\r\n  it('should dispatch loadLoans on init', () => {\r\n    const dispatchSpy = spyOn(store, 'dispatch');\r\n    component.ngOnInit();\r\n    expect(dispatchSpy).toHaveBeenCalledWith(LoanActions.loadLoans());\r\n  });\r\n\r\n  it('should call router.navigate with userLoanNumber on selectLoan()', () => {\r\n    const loan: ILoan = mockLoans[0];\r\n    component.selectLoan(loan);\r\n    expect(routerSpy.navigate).toHaveBeenCalledWith([\r\n      '/dashboard',\r\n      loan.UserLoanNumber,\r\n    ]);\r\n  });\r\n\r\n  it('should not throw if UserLoanNumber is null', () => {\r\n    const loan: ILoan = { ...mockLoans[0], UserLoanNumber: null as any };\r\n    expect(() => component.selectLoan(loan)).not.toThrow();\r\n    expect(routerSpy.navigate).toHaveBeenCalledWith(['/dashboard', 0]);\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\dashboard\\dashboard.component.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\dashboard\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\environment\\environment.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\loan-application\\loan-application.component.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\loan-application\\loan-application.component.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":48,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1986,1989],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1986,1989],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":125,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":125,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4083,4086],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4083,4086],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ComponentFixture, TestBed } from '@angular/core/testing';\r\nimport { LoanApplicationComponent } from './loan-application.component';\r\nimport { Store } from '@ngrx/store';\r\nimport { FormsModule, ReactiveFormsModule, FormBuilder } from '@angular/forms';\r\nimport { ToastrService } from 'ngx-toastr';\r\nimport { Router } from '@angular/router';\r\nimport { of } from 'rxjs';\r\nimport { addLoan, clearLastAddedLoan } from '../store/loan/loan.actions';\r\nimport { loadInterestRates } from '../store/interest-rates/interest-rate.actions';\r\nimport { selectAllInterestRates } from '../store/interest-rates/interest-rate.selectors';\r\nimport { ILoan } from '../models/ILoan';\r\nimport { IInterestRate } from '../models/IInterestRate';\r\nimport { selectLoanAddSuccess } from '../store/loan/loan.selectors';\r\nimport { provideAnimations } from '@angular/platform-browser/animations';\r\n\r\ndescribe('Loan Application Component', () => {\r\n  let component: LoanApplicationComponent;\r\n  let fixture: ComponentFixture<LoanApplicationComponent>;\r\n  let store: jasmine.SpyObj<Store>;\r\n  let toastr: jasmine.SpyObj<ToastrService>;\r\n  let router: jasmine.SpyObj<Router>;\r\n\r\n  beforeEach(async () => {\r\n    store = jasmine.createSpyObj('Store', ['dispatch', 'select']);\r\n    toastr = jasmine.createSpyObj('ToastrService', [\r\n      'success',\r\n      'info',\r\n      'error',\r\n    ]);\r\n    router = jasmine.createSpyObj('Router', ['navigate']);\r\n\r\n    await TestBed.configureTestingModule({\r\n      imports: [FormsModule, ReactiveFormsModule, LoanApplicationComponent],\r\n      providers: [\r\n        FormBuilder,\r\n        provideAnimations(),\r\n        { provide: Store, useValue: store },\r\n        { provide: ToastrService, useValue: toastr },\r\n        { provide: Router, useValue: router },\r\n      ],\r\n    }).compileComponents();\r\n\r\n    fixture = TestBed.createComponent(LoanApplicationComponent);\r\n    component = fixture.componentInstance;\r\n  });\r\n\r\n  beforeEach(() => {\r\n    store.select.and.callFake((selector: any) => {\r\n      if (selector === selectAllInterestRates) {\r\n        return of([\r\n          {\r\n            Id: '1', // Adding missing properties\r\n            Rate: 5.5,\r\n            ValidFrom: '2023-01-01',\r\n          } as IInterestRate,\r\n        ]);\r\n      }\r\n      return of([]);\r\n    });\r\n\r\n    fixture.detectChanges();\r\n  });\r\n\r\n  it('should create the component', () => {\r\n    expect(component).toBeTruthy();\r\n  });\r\n\r\n  it('should dispatch loadInterestRates on init', () => {\r\n    expect(store.dispatch).toHaveBeenCalledWith(loadInterestRates());\r\n  });\r\n\r\n  it('should submit loan form when form is valid', () => {\r\n    const validLoan: ILoan = {\r\n      LoanId: 0,\r\n      UserLoanNumber: 1,\r\n      LoanAmount: 150000,\r\n      InterestRate: 5.5,\r\n      LoanTermYears: 30,\r\n      ApplicationDate: new Date().toISOString(),\r\n      ApprovalStatus: 'Pending',\r\n    };\r\n\r\n    component.loanForm.setValue({\r\n      LoanAmount: validLoan.LoanAmount,\r\n      InterestRate: validLoan.InterestRate,\r\n      LoanTermYears: validLoan.LoanTermYears,\r\n    });\r\n\r\n    component.submitLoan();\r\n\r\n    expect(store.dispatch).toHaveBeenCalledWith(\r\n      addLoan({\r\n        loan: jasmine.objectContaining({\r\n          LoanAmount: validLoan.LoanAmount,\r\n          InterestRate: validLoan.InterestRate,\r\n          LoanTermYears: validLoan.LoanTermYears,\r\n          ApplicationStatus: 'Pending',\r\n        }) as unknown as ILoan,\r\n      })\r\n    );\r\n\r\n    expect(toastr.success).toHaveBeenCalledWith(\r\n      'Loan application submitted successfully!',\r\n      'Success'\r\n    );\r\n    expect(router.navigate).toHaveBeenCalledWith(['/dashboard']);\r\n  });\r\n\r\n  it('should show error when form is invalid', () => {\r\n    component.loanForm.setValue({\r\n      LoanAmount: '',\r\n      InterestRate: '',\r\n      LoanTermYears: '',\r\n    });\r\n\r\n    component.submitLoan();\r\n\r\n    expect(toastr.error).toHaveBeenCalledWith(\r\n      'Please fill in all required fields correctly.',\r\n      'Invalid Form'\r\n    );\r\n  });\r\n\r\n  it('should handle loan add success and clear last added loan', () => {\r\n    store.select.and.callFake((selector: any) => {\r\n      if (selector === selectLoanAddSuccess) {\r\n        return of(true);\r\n      }\r\n      return of([]);\r\n    });\r\n\r\n    component.ngOnInit(); // triggers the subscription for success\r\n\r\n    expect(store.dispatch).toHaveBeenCalledWith(clearLastAddedLoan());\r\n    expect(toastr.info).toHaveBeenCalledWith(\r\n      'Redirecting to dashboard...',\r\n      'Redirecting'\r\n    );\r\n    expect(toastr.success).toHaveBeenCalledWith(\r\n      'Loan application submitted successfully!',\r\n      'Success'\r\n    );\r\n    expect(router.navigate).toHaveBeenCalledWith(['/dashboard']);\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\loan-application\\loan-application.component.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\loan-application\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\loan-details\\bar-chart.component.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":9,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[361,364],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[361,364],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":9,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[381,384],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[381,384],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":19,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[653,656],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[653,656],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":73,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2088,2091],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2088,2091],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":89,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":89,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2542,2545],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2542,2545],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":112,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":112,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3262,3265],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3262,3265],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ComponentFixture, TestBed } from '@angular/core/testing';\r\nimport { BarChartComponent } from './bar-chart.component';\r\nimport { IAmortizationSchedule } from '../models/IAmortizationSchedule';\r\nimport { ElementRef } from '@angular/core';\r\n\r\n// Mocking Chart.js\r\nclass MockChart {\r\n  destroy = jasmine.createSpy('destroy');\r\n  constructor(public canvas: any, public config: any) {}\r\n}\r\n\r\ndescribe('Bar Chart Component', () => {\r\n  let component: BarChartComponent;\r\n  let fixture: ComponentFixture<BarChartComponent>;\r\n  let mockSchedule: IAmortizationSchedule[];\r\n\r\n  beforeAll(() => {\r\n    // Replace Chart constructor globally\r\n    (window as any).Chart = MockChart;\r\n  });\r\n\r\n  beforeEach(async () => {\r\n    await TestBed.configureTestingModule({\r\n      imports: [BarChartComponent],\r\n    }).compileComponents();\r\n\r\n    fixture = TestBed.createComponent(BarChartComponent);\r\n    component = fixture.componentInstance;\r\n\r\n    mockSchedule = [\r\n      {\r\n        PaymentNumber: 1,\r\n        PaymentDate: new Date(),\r\n        MonthlyPayment: 1000,\r\n        PrincipalPayment: 700,\r\n        InterestPayment: 300,\r\n        RemainingBalance: 93000,\r\n      },\r\n      {\r\n        PaymentNumber: 2,\r\n        PaymentDate: new Date(),\r\n        MonthlyPayment: 1000,\r\n        PrincipalPayment: 710,\r\n        InterestPayment: 290,\r\n        RemainingBalance: 92290,\r\n      },\r\n    ];\r\n\r\n    fixture.detectChanges();\r\n  });\r\n\r\n  it('should create the component', () => {\r\n    expect(component).toBeTruthy();\r\n  });\r\n\r\n  it('should not create chart if schedule is empty', () => {\r\n    component.schedule = [];\r\n    component.ngAfterViewInit();\r\n    expect(component['chart']).toBeUndefined();\r\n  });\r\n\r\n  it('should create chart on ngAfterViewInit if schedule exists', () => {\r\n    component.schedule = mockSchedule;\r\n\r\n    fixture.detectChanges();\r\n    component.ngAfterViewInit();\r\n\r\n    expect(component['chart']).toBeDefined();\r\n  });\r\n\r\n  it('should call createChart on ngOnChanges after view is initialized', () => {\r\n    component.schedule = mockSchedule;\r\n    const createChartSpy = spyOn<any>(component, 'createChart');\r\n    component.ngAfterViewInit();\r\n\r\n    component.ngOnChanges({\r\n      schedule: {\r\n        currentValue: mockSchedule,\r\n        previousValue: [],\r\n        firstChange: false,\r\n        isFirstChange: () => false,\r\n      },\r\n    });\r\n\r\n    expect(createChartSpy).toHaveBeenCalled();\r\n  });\r\n    \r\n    it('should not call createChart on ngOnChanges if view is not initialized', () => {\r\n      const createChartSpy = spyOn<any>(component, 'createChart');\r\n      component['viewInitialized'] = false;\r\n\r\n      component.ngOnChanges({\r\n        schedule: {\r\n          currentValue: mockSchedule,\r\n          previousValue: [],\r\n          firstChange: true,\r\n          isFirstChange: () => true,\r\n        },\r\n      });\r\n\r\n      expect(createChartSpy).not.toHaveBeenCalled();\r\n    });\r\n\r\n\r\n  it('should destroy previous chart before creating a new one', () => {\r\n    // Fake canvas element\r\n    const canvas = document.createElement('canvas');\r\n    component.chartRef = new ElementRef(canvas);\r\n\r\n    // First chart mock with spyable destroy\r\n    const destroySpy = jasmine.createSpy('destroy');\r\n    component['chart'] = { destroy: destroySpy } as any;\r\n\r\n    // Simulate initialized view\r\n    component['viewInitialized'] = true;\r\n    component.schedule = mockSchedule;\r\n\r\n    component.ngOnChanges({\r\n      schedule: {\r\n        currentValue: mockSchedule,\r\n        previousValue: [],\r\n        firstChange: false,\r\n        isFirstChange: () => false,\r\n      },\r\n    });\r\n\r\n    expect(destroySpy).toHaveBeenCalled();\r\n  });\r\n\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\loan-details\\bar-chart.component.ts","messages":[{"ruleId":"@angular-eslint/use-lifecycle-interface","severity":1,"message":"Lifecycle interface 'AfterViewInit' should be implemented for method 'ngAfterViewInit'. (https://angular.dev/style-guide#style-09-01)","line":16,"column":3,"nodeType":"Identifier","messageId":"useLifecycleInterface","endLine":16,"endColumn":18,"fix":{"range":[74,369],"text":", AfterViewInit } from '@angular/core';\r\nimport { Chart, registerables } from 'chart.js';\r\nimport { IAmortizationSchedule } from '../models/IAmortizationSchedule';\r\n\r\n@Component({\r\n  selector: 'app-bar-chart',\r\n  template: '<canvas #barChart></canvas>',\r\n})\r\nexport class BarChartComponent implements OnChanges, AfterViewInit"}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"import { Component, ElementRef, Input, OnChanges, SimpleChanges, ViewChild } from '@angular/core';\r\nimport { Chart, registerables } from 'chart.js';\r\nimport { IAmortizationSchedule } from '../models/IAmortizationSchedule';\r\n\r\n@Component({\r\n  selector: 'app-bar-chart',\r\n  template: '<canvas #barChart></canvas>',\r\n})\r\nexport class BarChartComponent implements OnChanges {\r\n  @Input() schedule: IAmortizationSchedule[] | null = [];\r\n  @ViewChild('barChart') chartRef!: ElementRef<HTMLCanvasElement>;\r\n\r\n  private chart: Chart | undefined;\r\n  private viewInitialized = false;\r\n\r\n  ngAfterViewInit(): void {\r\n    this.viewInitialized = true;\r\n    this.createChart();\r\n  }\r\n\r\n  ngOnChanges(changes: SimpleChanges): void {\r\n    if (this.viewInitialized && changes['schedule']) {\r\n      this.createChart();\r\n    }\r\n  }\r\n\r\n\r\n  private createChart(): void {\r\n    if (!this.chartRef || !this.schedule || this.schedule.length === 0) return;\r\n    if (this.chart) {\r\n        this.chart.destroy();\r\n     }\r\n    Chart.register(...registerables);\r\n\r\n    this.chart = new Chart(this.chartRef.nativeElement, {\r\n        type: 'bar',\r\n        data: {\r\n          labels: this.schedule.map((s) => s.PaymentNumber),\r\n          datasets: [\r\n            {\r\n              label: 'Principal',\r\n              data: this.schedule.map((s) => s.PrincipalPayment),\r\n              backgroundColor: '#4CAF50',\r\n            },\r\n            {\r\n              label: 'Interest',\r\n              data: this.schedule.map((s) => s.InterestPayment),\r\n              backgroundColor: '#FF5733',\r\n            },\r\n          ],\r\n        },\r\n      });\r\n    }\r\n  }\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\loan-details\\line-chart.component.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'canvasEl' is assigned a value but never used.","line":11,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":15}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ComponentFixture, TestBed } from '@angular/core/testing';\r\nimport { LineChartComponent } from './line-chart.component';\r\nimport { IAmortizationSchedule } from '../models/IAmortizationSchedule';\r\nimport { DebugElement } from '@angular/core';\r\nimport { By } from '@angular/platform-browser';\r\nimport { Chart, ChartConfiguration } from 'chart.js';\r\n\r\ndescribe('Line-Chart Component', () => {\r\n  let component: LineChartComponent;\r\n  let fixture: ComponentFixture<LineChartComponent>;\r\n  let canvasEl: DebugElement;\r\n\r\n  const mockSchedule: IAmortizationSchedule[] = [\r\n    {\r\n      PaymentNumber: 1,\r\n      PaymentDate: new Date(),\r\n      MonthlyPayment: 1000,\r\n      PrincipalPayment: 700,\r\n      InterestPayment: 300,\r\n      RemainingBalance: 93000,\r\n    },\r\n    {\r\n      PaymentNumber: 2,\r\n      PaymentDate: new Date(),\r\n      MonthlyPayment: 1000,\r\n      PrincipalPayment: 710,\r\n      InterestPayment: 290,\r\n      RemainingBalance: 92290,\r\n    },\r\n  ];\r\n\r\n  beforeEach(async () => {\r\n    await TestBed.configureTestingModule({\r\n      imports: [LineChartComponent],\r\n    }).compileComponents();\r\n\r\n    fixture = TestBed.createComponent(LineChartComponent);\r\n    component = fixture.componentInstance;\r\n    canvasEl = fixture.debugElement.query(By.css('canvas'));\r\n  });\r\n\r\n  afterEach(() => {\r\n    if (component['chart']) {\r\n      component['chart'].destroy();\r\n    }\r\n  });\r\n\r\n  it('should create the component', () => {\r\n    expect(component).toBeTruthy();\r\n  });\r\n\r\n  it('should initialize chart in ngAfterViewInit when schedule is set', () => {\r\n      component.schedule = mockSchedule;\r\n      fixture.detectChanges();\r\n      component.ngAfterViewInit();\r\n      \r\n      const chart = component['chart'] as Chart;\r\n    expect(component['chart']).toBeDefined();\r\n    expect((chart?.config as ChartConfiguration).type).toBe('line');\r\n      expect(component['chart']?.data.labels).toEqual([1, 2]);\r\n  });\r\n\r\n  it('should not create chart if schedule is null or empty', () => {\r\n    component.schedule = [];\r\n    fixture.detectChanges();\r\n    component.ngAfterViewInit();\r\n\r\n    expect(component['chart']).toBeUndefined();\r\n  });\r\n\r\n  it('should recreate chart on schedule input change after view init', () => {\r\n    component.schedule = mockSchedule;\r\n    fixture.detectChanges();\r\n    component.ngAfterViewInit();\r\n\r\n    const chartInstance = component['chart'];\r\n\r\n    // Trigger ngOnChanges with new data\r\n    const newSchedule: IAmortizationSchedule[] = [\r\n      {\r\n        PaymentNumber: 1,\r\n        PaymentDate: new Date(),\r\n        MonthlyPayment: 1000,\r\n        PrincipalPayment: 600,\r\n        InterestPayment: 400,\r\n        RemainingBalance: 94000,\r\n      },\r\n    ];\r\n    component.schedule = newSchedule;\r\n    component.ngOnChanges({\r\n      schedule: {\r\n        currentValue: newSchedule,\r\n        previousValue: mockSchedule,\r\n        firstChange: false,\r\n        isFirstChange: () => false,\r\n      },\r\n    });\r\n\r\n    expect(component['chart']).toBeDefined();\r\n    expect(component['chart']).not.toBe(chartInstance);\r\n    expect(component['chart']?.data.labels).toEqual([1]);\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\loan-details\\line-chart.component.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\loan-details\\loan-details.component.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\loan-details\\loan-details.component.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":105,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":105,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3372,3375],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3372,3375],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ComponentFixture, TestBed } from '@angular/core/testing';\r\nimport { LoanDetailsComponent } from './loan-details.component';\r\nimport { Store } from '@ngrx/store';\r\nimport { ActivatedRoute } from '@angular/router';\r\nimport { of } from 'rxjs';\r\nimport { loadLoanById } from '../store/loan/loan.actions';\r\nimport { loadAmortizationSchedule } from '../store/amortization/amortization.actions';\r\nimport { IAmortizationSchedule } from '../models/IAmortizationSchedule';\r\n\r\ndescribe('Loan Details Component', () => {\r\n  let component: LoanDetailsComponent;\r\n  let fixture: ComponentFixture<LoanDetailsComponent>;\r\n  let store: jasmine.SpyObj<Store>;\r\n  let dispatchSpy: jasmine.Spy;\r\n\r\n  beforeEach(async () => {\r\n    const mockStore = jasmine.createSpyObj('Store', ['dispatch', 'select']);\r\n    mockStore.select.withArgs(jasmine.any(Function)).and.returnValue(of(null));\r\n\r\n    await TestBed.configureTestingModule({\r\n      imports: [LoanDetailsComponent],\r\n      providers: [\r\n        { provide: Store, useValue: mockStore },\r\n        {\r\n          provide: ActivatedRoute,\r\n          useValue: {\r\n            snapshot: {\r\n              paramMap: {\r\n                get: () => '1', // Simulating userLoanNumber = 1\r\n              },\r\n            },\r\n          },\r\n        },\r\n      ],\r\n    }).compileComponents();\r\n\r\n    fixture = TestBed.createComponent(LoanDetailsComponent);\r\n    component = fixture.componentInstance;\r\n    store = TestBed.inject(Store) as jasmine.SpyObj<Store>;\r\n    dispatchSpy = store.dispatch;\r\n  });\r\n\r\n  it('should create', () => {\r\n    expect(component).toBeTruthy();\r\n  });\r\n\r\n  it('should dispatch loadLoanById and loadAmortizationSchedule on init', () => {\r\n    // override the observable with mock data\r\n    component['amortizationSchedule$'] = of(null);\r\n    component.ngOnInit();\r\n\r\n    expect(dispatchSpy).toHaveBeenCalledWith(\r\n      loadLoanById({ userLoanNumber: 1 })\r\n    );\r\n    expect(dispatchSpy).toHaveBeenCalledWith(\r\n      loadAmortizationSchedule({ userLoanNumber: 1 })\r\n    );\r\n  });\r\n\r\n  it('should calculate total interest, total payment and monthly payment correctly', () => {\r\n    const schedule: IAmortizationSchedule[] = [\r\n      {\r\n        PaymentNumber: 1,\r\n        PaymentDate: new Date(),\r\n        MonthlyPayment: 1000,\r\n        InterestPayment: 300,\r\n        PrincipalPayment: 700,\r\n        RemainingBalance: 93000,\r\n      },\r\n      {\r\n        PaymentNumber: 2,\r\n        PaymentDate: new Date(),\r\n        MonthlyPayment: 1000,\r\n        InterestPayment: 290,\r\n        PrincipalPayment: 710,\r\n        RemainingBalance: 92290,\r\n      },\r\n    ];\r\n\r\n    component['calculateSummary'](schedule);\r\n\r\n    expect(component.totalInterest).toBe(590);\r\n    expect(component.totalPayment).toBe(2000);\r\n    expect(component.monthlyPayment).toBe(1000);\r\n  });\r\n\r\n  it('should set the active tab correctly', () => {\r\n    component.setActiveTab('bar-chart');\r\n    expect(component.activeTab).toBe('bar-chart');\r\n  });\r\n\r\n  it('should call calculateSummary when schedule is emitted and not null', () => {\r\n    const schedule: IAmortizationSchedule[] = [\r\n      {\r\n        PaymentNumber: 1,\r\n        PaymentDate: new Date(),\r\n        MonthlyPayment: 1000,\r\n        InterestPayment: 300,\r\n        PrincipalPayment: 700,\r\n        RemainingBalance: 93000,\r\n      },\r\n    ];\r\n\r\n    // spy on calculateSummary\r\n    const calcSpy = spyOn<any>(component, 'calculateSummary');\r\n\r\n    component['amortizationSchedule$'] = of(schedule);\r\n    component.ngOnInit();\r\n\r\n    expect(calcSpy).toHaveBeenCalledWith(schedule);\r\n  });\r\n\r\n  it('should set monthlyPayment to 0 if schedule is empty', () => {\r\n    component['calculateSummary']([]);\r\n    expect(component.monthlyPayment).toBe(0);\r\n  });\r\n\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\loan-details\\loan-details.component.ts","messages":[{"ruleId":"@typescript-eslint/no-inferrable-types","severity":2,"message":"Type number trivially inferred from a number literal, remove type annotation.","line":29,"column":3,"nodeType":"PropertyDefinition","messageId":"noInferrableType","endLine":29,"endColumn":29,"fix":{"range":[1470,1478],"text":""}},{"ruleId":"@typescript-eslint/no-inferrable-types","severity":2,"message":"Type number trivially inferred from a number literal, remove type annotation.","line":30,"column":3,"nodeType":"PropertyDefinition","messageId":"noInferrableType","endLine":30,"endColumn":28,"fix":{"range":[1499,1507],"text":""}},{"ruleId":"@typescript-eslint/no-inferrable-types","severity":2,"message":"Type number trivially inferred from a number literal, remove type annotation.","line":31,"column":3,"nodeType":"PropertyDefinition","messageId":"noInferrableType","endLine":31,"endColumn":30,"fix":{"range":[1530,1538],"text":""}},{"ruleId":"@typescript-eslint/no-inferrable-types","severity":2,"message":"Type string trivially inferred from a string literal, remove type annotation.","line":32,"column":3,"nodeType":"PropertyDefinition","messageId":"noInferrableType","endLine":32,"endColumn":36,"fix":{"range":[1556,1564],"text":""}}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":4,"fixableWarningCount":0,"source":"import { Component, OnInit } from '@angular/core';\r\nimport { Store } from '@ngrx/store';\r\nimport { ActivatedRoute } from '@angular/router';\r\nimport { Observable } from 'rxjs';\r\nimport { ILoan } from '../models/ILoan';\r\nimport { IAmortizationSchedule } from '../models/IAmortizationSchedule';\r\nimport { selectSelectedLoan } from '../store/loan/loan.selectors';\r\nimport { selectAmortizationSchedule } from '../store/amortization/amortization.selectors';\r\nimport { loadLoanById } from '../store/loan/loan.actions';\r\nimport { loadAmortizationSchedule } from '../store/amortization/amortization.actions';\r\nimport { CommonModule, CurrencyPipe, DatePipe } from '@angular/common';\r\nimport { PieChartComponent } from './pie-chart.component';\r\nimport { BarChartComponent } from './bar-chart.component';\r\nimport { LineChartComponent } from './line-chart.component';\r\nimport { chartSlideAnimation, slideIn, slideOut, staggerList } from '../../animations';\r\n\r\n\r\n@Component({\r\n  selector: 'app-loan-detail',\r\n  standalone: true,\r\n  imports: [PieChartComponent,BarChartComponent,LineChartComponent,CurrencyPipe, DatePipe, CommonModule],\r\n  templateUrl: './loan-details.component.html',\r\n  styleUrls: ['./loan-details.component.css'],\r\n  animations: [slideIn, slideOut, staggerList, chartSlideAnimation],\r\n})\r\nexport class LoanDetailsComponent implements OnInit {\r\n  loan$: Observable<ILoan | null>;\r\n  amortizationSchedule$: Observable<IAmortizationSchedule[] | null>;\r\n  totalInterest: number = 0;\r\n  totalPayment: number = 0;\r\n  monthlyPayment: number = 0;\r\n  activeTab: string = 'line-chart'; // Default tab\r\n\r\n  constructor(private store: Store, private route: ActivatedRoute) {\r\n    this.loan$ = this.store.select(selectSelectedLoan);\r\n    this.amortizationSchedule$ = this.store.select(selectAmortizationSchedule);\r\n  }\r\n\r\n  ngOnInit() {\r\n    const userLoanNumber = Number(this.route.snapshot.paramMap.get('id'));\r\n    if (userLoanNumber) {\r\n      this.store.dispatch(loadLoanById({ userLoanNumber }));\r\n      this.store.dispatch(loadAmortizationSchedule({ userLoanNumber }));\r\n      this.amortizationSchedule$.subscribe((schedule) => {\r\n        if (schedule) {\r\n          this.calculateSummary(schedule);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  private calculateSummary(schedule: IAmortizationSchedule[]): void {\r\n    this.totalInterest = schedule.reduce(\r\n      (sum, p) => sum + p.InterestPayment,\r\n      0\r\n    );\r\n    this.totalPayment = schedule.reduce((sum, p) => sum + p.MonthlyPayment, 0);\r\n    this.monthlyPayment = schedule[0]?.MonthlyPayment || 0;\r\n  }\r\n\r\n  setActiveTab(tab: string) {\r\n    this.activeTab = tab;\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\loan-details\\pie-chart.component.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'canvasEl' is assigned a value but never used.","line":11,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":15}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ComponentFixture, TestBed } from '@angular/core/testing';\r\nimport { PieChartComponent } from './pie-chart.component';\r\nimport { IAmortizationSchedule } from '../models/IAmortizationSchedule';\r\nimport { DebugElement } from '@angular/core';\r\nimport { By } from '@angular/platform-browser';\r\nimport { Chart, ChartConfiguration } from 'chart.js';\r\n\r\ndescribe('PieChartComponent', () => {\r\n  let component: PieChartComponent;\r\n  let fixture: ComponentFixture<PieChartComponent>;\r\n  let canvasEl: DebugElement;\r\n\r\n  const mockSchedule: IAmortizationSchedule[] = [\r\n    {\r\n      PaymentNumber: 1,\r\n      PaymentDate: new Date(),\r\n      MonthlyPayment: 1000,\r\n      PrincipalPayment: 700,\r\n      InterestPayment: 300,\r\n      RemainingBalance: 93000,\r\n    },\r\n    {\r\n      PaymentNumber: 2,\r\n      PaymentDate: new Date(),\r\n      MonthlyPayment: 1000,\r\n      PrincipalPayment: 710,\r\n      InterestPayment: 290,\r\n      RemainingBalance: 92290,\r\n    },\r\n  ];\r\n\r\n  beforeEach(async () => {\r\n    await TestBed.configureTestingModule({\r\n      imports: [PieChartComponent],\r\n    }).compileComponents();\r\n\r\n    fixture = TestBed.createComponent(PieChartComponent);\r\n    component = fixture.componentInstance;\r\n    canvasEl = fixture.debugElement.query(By.css('canvas'));\r\n  });\r\n\r\n  afterEach(() => {\r\n    if (component['chart']) {\r\n      component['chart'].destroy();\r\n    }\r\n  });\r\n\r\n  it('should create the component', () => {\r\n    expect(component).toBeTruthy();\r\n  });\r\n\r\n  it('should initialize pie chart in ngAfterViewInit when schedule is set', () => {\r\n    component.schedule = mockSchedule;\r\n\r\n    fixture.detectChanges();\r\n    component.ngAfterViewInit();\r\n\r\n    const chart = component['chart'] as Chart;\r\n    expect(chart).toBeDefined();\r\n      expect((chart?.config as ChartConfiguration).type).toBe('pie');\r\n    expect(chart?.data.labels).toEqual(['Principal', 'Interest']);\r\n    expect(chart?.data.datasets[0].data).toEqual([\r\n      700 + 710, // Principal sum\r\n      300 + 290, // Interest sum\r\n    ]);\r\n  });\r\n\r\n  it('should not create chart if schedule is empty', () => {\r\n    component.schedule = [];\r\n    fixture.detectChanges();\r\n    component.ngAfterViewInit();\r\n\r\n    expect(component['chart']).toBeUndefined();\r\n  });\r\n\r\n  it('should recreate chart on schedule input change after view init', () => {\r\n    component.schedule = mockSchedule;\r\n    fixture.detectChanges();\r\n    component.ngAfterViewInit();\r\n    const originalChart = component['chart'];\r\n\r\n    const newSchedule: IAmortizationSchedule[] = [\r\n      {\r\n        PaymentNumber: 1,\r\n        PaymentDate: new Date(),\r\n        MonthlyPayment: 900,\r\n        PrincipalPayment: 600,\r\n        InterestPayment: 300,\r\n        RemainingBalance: 94000,\r\n      },\r\n    ];\r\n    component.schedule = newSchedule;\r\n\r\n    component.ngOnChanges({\r\n      schedule: {\r\n        currentValue: newSchedule,\r\n        previousValue: mockSchedule,\r\n        firstChange: false,\r\n        isFirstChange: () => false,\r\n      },\r\n    });\r\n\r\n    expect(component['chart']).toBeDefined();\r\n    expect(component['chart']).not.toBe(originalChart);\r\n    expect(component['chart']?.data.datasets[0].data).toEqual([600, 300]);\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\loan-details\\pie-chart.component.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\loan-details\\route.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\login\\login.component.html","messages":[{"ruleId":"@angular-eslint/template/label-has-associated-control","severity":2,"message":"A label component must be associated with a form element","line":12,"column":11,"nodeType":null,"messageId":"labelHasAssociatedControl","endLine":12,"endColumn":53},{"ruleId":"@angular-eslint/template/label-has-associated-control","severity":2,"message":"A label component must be associated with a form element","line":28,"column":11,"nodeType":null,"messageId":"labelHasAssociatedControl","endLine":28,"endColumn":53}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"<div class=\"container-fluid min-vh-100 d-flex align-items-center justify-content-center bg-light\">\r\n  <div class=\"row shadow rounded-4 overflow-hidden w-100\" style=\"max-width: 960px;\">\r\n\r\n    <!-- Left side: Login form -->\r\n    <div class=\"col-md-6 bg-white p-5\">\r\n\r\n      <h2 class=\"text-center fw-bold\"> <i class=\"bi bi-piggy-bank-fill\"></i> Loan Calculation App</h2>\r\n      <p class=\"text-center text-muted mb-4\">Please enter your details</p>\r\n\r\n      <form (ngSubmit)=\"login()\" #f=\"ngForm\" novalidate autocomplete=\"off\">\r\n        <div class=\"mb-3\">\r\n          <label class=\"form-label\">Username</label>\r\n          <div class=\"input-group\">\r\n            <input type=\"text\"\r\n                   class=\"form-control\"\r\n                   placeholder=\"Enter username\"\r\n                   [(ngModel)]=\"credentials.username\"\r\n                   name=\"username\"\r\n                   required\r\n                   #username=\"ngModel\" />\r\n          </div>\r\n          <div *ngIf=\"username.invalid && (username.dirty || username.touched)\" class=\"text-danger small mt-1\">\r\n            <div *ngIf=\"username.errors?.['required']\">Username is required</div>\r\n          </div>\r\n        </div>\r\n\r\n        <div class=\"mb-3\">\r\n          <label class=\"form-label\">Password</label>\r\n          <input type=\"password\"\r\n                 class=\"form-control\"\r\n                 placeholder=\"Enter password\"\r\n                 [(ngModel)]=\"credentials.password\"\r\n                 name=\"password\"\r\n                 required\r\n                 minlength=\"5\"\r\n                 #password=\"ngModel\" />\r\n          <div *ngIf=\"password.invalid && (password.dirty || password.touched)\" class=\"text-danger small mt-1\">\r\n            <div *ngIf=\"password.errors?.['required']\">Password is required</div>\r\n            <div *ngIf=\"password.errors?.['minlength']\">Min 5 characters</div>\r\n          </div>\r\n        </div>\r\n\r\n        <button type=\"submit\"\r\n                class=\"fancy-button w-100\"\r\n                style=\"--bg-color: black; --text-color:white;\"\r\n                >\r\n          <span *ngIf=\"isLoading$ | async\" class=\"spinner-border spinner-border-sm me-2 mt-2\"></span>\r\n          <span class=\"text-wrapper\">\r\n            <span class=\"text-default\">Continue</span>\r\n            <span class=\"text-hover\">Continue</span>\r\n          </span>\r\n        </button>\r\n      </form>\r\n\r\n      <p class=\"text-muted small text-center mt-4\">\r\n        Join the millions of smart investors who trust us to manage their finances...\r\n      </p>\r\n    </div>\r\n\r\n    <!-- Right side: Image -->\r\n    <div class=\"col-md-6 d-none d-md-flex align-items-center justify-content-center bg-primary-subtle\">\r\n      <img src=\"/login-bg.jpg\" alt=\"Safe\" class=\"img-fluid\" style=\"max-width: 300px;\" />\r\n    </div>\r\n  </div>\r\n</div>\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\login\\login.component.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'of' is defined but never used.","line":14,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'destroy$' is assigned a value but never used.","line":22,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":17},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":91,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3157,3160],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3157,3160],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":95,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3265,3268],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3265,3268],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ComponentFixture, TestBed } from '@angular/core/testing';\r\nimport { LoginComponent } from './login.component';\r\nimport { MockStore, provideMockStore } from '@ngrx/store/testing';\r\nimport { ToastrService } from 'ngx-toastr';\r\nimport { Router } from '@angular/router';\r\nimport { FormsModule } from '@angular/forms';\r\nimport { AuthState } from '../store/auth/auth.state';\r\nimport { login } from '../store/auth/auth.actions';\r\nimport {\r\n  selectAuthError,\r\n  selectAuthToken,\r\n  selectIsLoading,\r\n} from '../store/auth/auth.selectors';\r\nimport { of, Subject } from 'rxjs';\r\n\r\ndescribe('Login Component', () => {\r\n  let component: LoginComponent;\r\n  let fixture: ComponentFixture<LoginComponent>;\r\n  let store: MockStore<AuthState>;\r\n  let toastr: jasmine.SpyObj<ToastrService>;\r\n  let router: jasmine.SpyObj<Router>;\r\n  const destroy$ = new Subject<void>();\r\n\r\n  const initialState: AuthState = {\r\n    isLoading: false,\r\n    username: null,\r\n    token: null,\r\n    error: null,\r\n  };\r\n\r\n  beforeEach(async () => {\r\n    toastr = jasmine.createSpyObj('ToastrService', ['error', 'success']);\r\n    router = jasmine.createSpyObj('Router', ['navigate']);\r\n\r\n    await TestBed.configureTestingModule({\r\n      imports: [FormsModule, LoginComponent],\r\n      providers: [\r\n        provideMockStore({ initialState }),\r\n        { provide: ToastrService, useValue: toastr },\r\n        { provide: Router, useValue: router },\r\n      ],\r\n    }).compileComponents();\r\n\r\n    store = TestBed.inject(MockStore);\r\n    store.overrideSelector(selectIsLoading, false);\r\n    store.overrideSelector(selectAuthError, null);\r\n    store.overrideSelector(selectAuthToken, null);\r\n\r\n    fixture = TestBed.createComponent(LoginComponent);\r\n    component = fixture.componentInstance;\r\n    fixture.detectChanges();\r\n  });\r\n\r\n  it('should create', () => {\r\n    expect(component).toBeTruthy();\r\n  });\r\n\r\n  it('should dispatch login action when login() is called', () => {\r\n    const dispatchSpy = spyOn(store, 'dispatch');\r\n    component.credentials = { username: 'testuser', password: 'testpass' };\r\n    component.login();\r\n    expect(dispatchSpy).toHaveBeenCalledWith(\r\n      login({ credentials: component.credentials })\r\n    );\r\n  });\r\n\r\n\r\n  it('should show error and reset credentials on authError$', () => {\r\n    store.overrideSelector(selectAuthError, 'Invalid credentials');\r\n    store.refreshState(); // triggers new emissions\r\n\r\n    component.ngOnInit(); // re-run init to subscribe\r\n    expect(toastr.error).toHaveBeenCalledWith(\r\n      'Invalid credentials',\r\n      'Login Failed'\r\n    );\r\n    expect(component.credentials).toEqual({ username: '', password: '' });\r\n  });\r\n\r\n  it('should show success and navigate on authToken$', () => {\r\n    store.overrideSelector(selectAuthToken, 'valid.token.here');\r\n    store.refreshState(); // triggers new emissions\r\n\r\n    component.ngOnInit(); // re-run init to subscribe\r\n    expect(toastr.success).toHaveBeenCalledWith('Login successful!', 'Welcome');\r\n    expect(router.navigate).toHaveBeenCalledWith(['/dashboard']);\r\n  });\r\n\r\n  it('should clean up destroy$ on ngOnDestroy', () => {\r\n    const nextSpy = spyOn(\r\n      (component as any).destroy$,\r\n      'next'\r\n    ).and.callThrough();\r\n    const completeSpy = spyOn(\r\n      (component as any).destroy$,\r\n      'complete'\r\n    ).and.callThrough();\r\n\r\n    component.ngOnDestroy();\r\n    expect(nextSpy).toHaveBeenCalled();\r\n    expect(completeSpy).toHaveBeenCalled();\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\login\\login.component.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\models\\IAmortizationSchedule.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\models\\IAuth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\models\\IInterestRate.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\models\\ILoan.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\services\\amortization\\amortization.service.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\services\\amortization\\amortization.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\services\\auth\\auth.guard.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'GuardResult' is defined but never used.","line":2,"column":47,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":58},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'MaybeAsync' is defined but never used.","line":2,"column":60,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":70}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@angular/core';\r\nimport { ActivatedRouteSnapshot, CanActivate, GuardResult, MaybeAsync, Router, RouterStateSnapshot } from '@angular/router';\r\nimport { Store } from '@ngrx/store';\r\nimport { Observable } from 'rxjs';\r\nimport { map, take } from 'rxjs/operators';\r\nimport { AuthState } from '../../store/auth/auth.state';\r\nimport { selectAuthToken } from '../../store/auth/auth.selectors';\r\n\r\n@Injectable({\r\n  providedIn: 'root'\r\n})\r\nexport class AuthGuard implements CanActivate {\r\n\r\n  constructor(\r\n    private store: Store<{ auth: AuthState }>,\r\n    private router: Router\r\n  ) { }\r\n\r\n  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<boolean> {\r\n    return this.store.select(selectAuthToken).pipe(\r\n      take(1),\r\n      map(token => {\r\n        const savedAuth = localStorage.getItem('auth');\r\n        const savedToken = savedAuth ? JSON.parse(savedAuth).token : null;\r\n        const finalToken = token || savedToken;\r\n  \r\n        if (finalToken) {\r\n          return true;\r\n        } else {\r\n          this.router.navigate(['/login'], { queryParams: { returnUrl: state.url } });\r\n          return false;\r\n        }\r\n      })\r\n    );\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\services\\auth\\auth.service.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\services\\auth\\auth.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\services\\auth\\jwt.interceptor.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\services\\auth\\jwt.interceptor.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":16,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[332,335],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[332,335],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":18,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[388,391],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[388,391],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Injectable } from '@angular/core';\r\nimport {\r\n  HttpRequest,\r\n  HttpHandler,\r\n  HttpEvent,\r\n  HttpInterceptor,\r\n} from '@angular/common/http';\r\nimport { Observable } from 'rxjs';\r\n\r\n@Injectable({\r\n  providedIn: 'root',\r\n})\r\n\r\nexport class jwtInterceptor implements HttpInterceptor {\r\n  intercept(\r\n    request: HttpRequest<any>,\r\n    next: HttpHandler\r\n  ): Observable<HttpEvent<any>> {\r\n\r\n    // Retrieve the token from localStorage\r\n    const storedAuth = localStorage.getItem('auth');\r\n    let token = null;\r\n\r\n    if (storedAuth) {\r\n      const authData = JSON.parse(storedAuth);\r\n      token = authData.token;\r\n    }\r\n\r\n    if (token) {\r\n      request = request.clone({\r\n        setHeaders: {\r\n          Authorization: `Bearer ${token}`,\r\n        },\r\n      });\r\n    }\r\n\r\n    return next.handle(request);\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\services\\interestRate\\interest-rate.service.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\services\\interestRate\\interest-rate.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\services\\loan\\loan.service.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\services\\loan\\loan.service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\amortization\\amortization.actions.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\amortization\\amortization.actions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\amortization\\amortization.effects.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'store' is assigned a value but never used.","line":15,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":12}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TestBed } from '@angular/core/testing';\r\nimport { AmortizationEffects } from './amortization.effects';\r\nimport { Actions } from '@ngrx/effects';\r\nimport { provideMockActions } from '@ngrx/effects/testing';\r\nimport { MockStore, provideMockStore } from '@ngrx/store/testing';\r\nimport { of, throwError } from 'rxjs';\r\nimport { AmortizationService } from '../../services/amortization/amortization.service';\r\nimport * as fromActions from './amortization.actions';\r\nimport { RouterTestingModule } from '@angular/router/testing';\r\n\r\ndescribe('Amortization Effects', () => {\r\n  let actions$: Actions;\r\n  let effects: AmortizationEffects;\r\n  let amortizationService: jasmine.SpyObj<AmortizationService>;\r\n  let store: MockStore;\r\n\r\n  beforeEach(() => {\r\n    const amortizationServiceSpy = jasmine.createSpyObj('AmortizationService', ['getAmortizationByLoanId', 'calculateAmortization']);\r\n\r\n    TestBed.configureTestingModule({\r\n      imports: [RouterTestingModule],\r\n      providers: [\r\n        AmortizationEffects,\r\n        provideMockActions(() => actions$),\r\n        provideMockStore(),\r\n        { provide: AmortizationService, useValue: amortizationServiceSpy }\r\n      ]\r\n    });\r\n\r\n    effects = TestBed.inject(AmortizationEffects);\r\n    actions$ = TestBed.inject(Actions);\r\n    store = TestBed.inject(MockStore);\r\n    amortizationService = TestBed.inject(AmortizationService) as jasmine.SpyObj<AmortizationService>;\r\n  });\r\n\r\n  it('should dispatch loadAmortizationScheduleSuccess when loadAmortizationSchedule is successful', () => {\r\n    const userLoanNumber = 123;\r\n    const schedule = [{ PaymentNumber: 1, PaymentDate: new Date(), MonthlyPayment: 1000, PrincipalPayment: 900, InterestPayment: 100, RemainingBalance: 9900 }];\r\n    actions$ = of(fromActions.loadAmortizationSchedule({ userLoanNumber }));\r\n\r\n    amortizationService.getAmortizationByLoanId.and.returnValue(of(schedule));\r\n\r\n    effects.loadAmortization$.subscribe(action => {\r\n      expect(action).toEqual(fromActions.loadAmortizationScheduleSuccess({ schedule }));\r\n    });\r\n  });\r\n\r\n  it('should dispatch loadAmortizationScheduleFailure when loadAmortizationSchedule fails', () => {\r\n    const userLoanNumber = 123;\r\n    const error = 'Failed to load schedule';\r\n    actions$ = of(fromActions.loadAmortizationSchedule({ userLoanNumber }));\r\n\r\n    amortizationService.getAmortizationByLoanId.and.returnValue(throwError({ message: error }));\r\n\r\n    effects.loadAmortization$.subscribe(action => {\r\n      expect(action).toEqual(fromActions.loadAmortizationScheduleFailure({ error }));\r\n    });\r\n  });\r\n\r\n  it('should dispatch calculateAmortizationSuccess when calculateAmortization is successful', () => {\r\n    const request = { LoanAmount: 100000, InterestRate: 5, LoanTermYears: 30 };\r\n    const schedule = [{ PaymentNumber: 1, PaymentDate: new Date(), MonthlyPayment: 1000, PrincipalPayment: 900, InterestPayment: 100, RemainingBalance: 9900 }];\r\n    actions$ = of(fromActions.calculateAmortization({ request }));\r\n\r\n    amortizationService.calculateAmortization.and.returnValue(of(schedule));\r\n\r\n    effects.calculateAmortization$.subscribe(action => {\r\n      expect(action).toEqual(fromActions.calculateAmortizationSuccess({ schedule }));\r\n    });\r\n  });\r\n\r\n  it('should dispatch calculateAmortizationFailure when calculateAmortization fails', () => {\r\n    const request = { LoanAmount: 100000, InterestRate: 5, LoanTermYears: 30 };\r\n    const error = 'Calculation failed';\r\n    actions$ = of(fromActions.calculateAmortization({ request }));\r\n\r\n    amortizationService.calculateAmortization.and.returnValue(throwError({ message: error }));\r\n\r\n    effects.calculateAmortization$.subscribe(action => {\r\n      expect(action).toEqual(fromActions.calculateAmortizationFailure({ error }));\r\n    });\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\amortization\\amortization.effects.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\amortization\\amortization.reducer.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":43,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1789,1792],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1789,1792],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { amortizationReducer, AmortizationState } from './amortization.reducer';\r\nimport * as fromActions from './amortization.actions';\r\nimport { IAmortizationSchedule } from '../../models/IAmortizationSchedule';\r\n\r\ndescribe('Amortization Reducer', () => {\r\n  const initialState: AmortizationState = {\r\n    schedule: null,\r\n    loading: false,\r\n    error: null,\r\n    isLoading: false\r\n  };\r\n\r\n  it('should set isLoading to true when loadAmortizationSchedule is dispatched', () => {\r\n    const action = fromActions.loadAmortizationSchedule({ userLoanNumber: 123 });\r\n\r\n    const state = amortizationReducer(initialState, action);\r\n\r\n    expect(state.isLoading).toBeTrue();\r\n  });\r\n\r\n  it('should set schedule when loadAmortizationScheduleSuccess is dispatched', () => {\r\n    const schedule: IAmortizationSchedule[] = [{ PaymentNumber: 1, PaymentDate: new Date(), MonthlyPayment: 1000, PrincipalPayment: 900, InterestPayment: 100, RemainingBalance: 9900 }];\r\n    const action = fromActions.loadAmortizationScheduleSuccess({ schedule });\r\n\r\n    const state = amortizationReducer(initialState, action);\r\n\r\n    expect(state.schedule).toEqual(schedule);\r\n    expect(state.isLoading).toBeFalse();\r\n  });\r\n\r\n  it('should set error when loadAmortizationScheduleFailure is dispatched', () => {\r\n    const error = 'Failed to load schedule';\r\n    const action = fromActions.loadAmortizationScheduleFailure({ error });\r\n\r\n    const state = amortizationReducer(initialState, action);\r\n\r\n    expect(state.error).toBe(error);\r\n    expect(state.isLoading).toBeFalse();\r\n  });\r\n\r\n  it('should set isLoading to true and clear error when calculateAmortization is dispatched', () => {\r\n    const action = fromActions.calculateAmortization({\r\n      request: { loanAmount: 10000, interestRate: 5, term: 12 } as any,\r\n    });\r\n\r\n    const state = amortizationReducer(initialState, action);\r\n\r\n    expect(state.isLoading).toBeTrue();\r\n    expect(state.error).toBeNull();\r\n  });\r\n\r\n\r\n  it('should update schedule and set isLoading to false on calculateAmortizationSuccess', () => {\r\n    const schedule: IAmortizationSchedule[] = [\r\n      {\r\n        PaymentNumber: 1,\r\n        PaymentDate: new Date(),\r\n        MonthlyPayment: 1000,\r\n        PrincipalPayment: 800,\r\n        InterestPayment: 200,\r\n        RemainingBalance: 9200,\r\n      },\r\n    ];\r\n\r\n    const action = fromActions.calculateAmortizationSuccess({ schedule });\r\n    const state = amortizationReducer(initialState, action);\r\n\r\n    expect(state.schedule).toEqual(schedule);\r\n    expect(state.isLoading).toBeFalse();\r\n    expect(state.error).toBeNull();\r\n  });\r\n\r\n  it('should set error and isLoading to false on calculateAmortizationFailure', () => {\r\n    const error = 'Calculation failed';\r\n    const action = fromActions.calculateAmortizationFailure({ error });\r\n\r\n    const state = amortizationReducer(initialState, action);\r\n\r\n    expect(state.error).toBe(error);\r\n    expect(state.isLoading).toBeFalse();\r\n  });\r\n\r\n  it('should reset to initial state on resetAmortization', () => {\r\n    const modifiedState: AmortizationState = {\r\n      schedule: [\r\n        {\r\n          PaymentNumber: 1,\r\n          PaymentDate: new Date(),\r\n          MonthlyPayment: 1000,\r\n          PrincipalPayment: 800,\r\n          InterestPayment: 200,\r\n          RemainingBalance: 9200,\r\n        },\r\n      ],\r\n      loading: true,\r\n      error: 'Some error',\r\n      isLoading: true,\r\n    };\r\n\r\n    const action = fromActions.resetAmortization();\r\n    const state = amortizationReducer(modifiedState, action);\r\n\r\n    expect(state).toEqual(initialState);\r\n  });\r\n\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\amortization\\amortization.reducer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\amortization\\amortization.selectors.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\amortization\\amortization.selectors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\amortization\\amortization.state.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\auth\\auth.actions.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\auth\\auth.actions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\auth\\auth.effects.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'store' is assigned a value but never used.","line":15,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'router' is assigned a value but never used.","line":17,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":13}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TestBed } from '@angular/core/testing';\r\nimport { AuthEffects } from './auth.effects';\r\nimport { Actions } from '@ngrx/effects';\r\nimport { provideMockActions } from '@ngrx/effects/testing';\r\nimport { MockStore, provideMockStore } from '@ngrx/store/testing';\r\nimport { of, throwError } from 'rxjs';\r\nimport { login, loginSuccess, loginFailure } from './auth.actions';\r\nimport { AuthService } from '../../services/auth/auth.service';\r\nimport { Router } from '@angular/router';\r\nimport { RouterTestingModule } from '@angular/router/testing';\r\n\r\ndescribe('Auth Effects', () => {\r\n  let actions$: Actions;\r\n  let authService: jasmine.SpyObj<AuthService>; // Use SpyObj\r\n  let store: MockStore;\r\n  let effects: AuthEffects;\r\n  let router: Router;\r\n\r\n  beforeEach(() => {\r\n    // Create the spy object for AuthService\r\n    const authServiceSpy = jasmine.createSpyObj('AuthService', ['login']);\r\n\r\n    TestBed.configureTestingModule({\r\n      imports: [RouterTestingModule],\r\n      providers: [\r\n        AuthEffects,\r\n        provideMockActions(() => actions$),\r\n        provideMockStore(),\r\n        { provide: AuthService, useValue: authServiceSpy },\r\n        { provide: Router, useValue: { navigate: jasmine.createSpy('navigate') } }\r\n      ]\r\n    });\r\n\r\n    effects = TestBed.inject(AuthEffects);\r\n    actions$ = TestBed.inject(Actions);\r\n    store = TestBed.inject(MockStore);\r\n    authService = TestBed.inject(AuthService) as jasmine.SpyObj<AuthService>;  // Get the spy instance\r\n    router = TestBed.inject(Router);\r\n  });\r\n\r\n  it('should dispatch loginSuccess when login is successful', () => {\r\n    const credentials = { username: 'test@example.com', password: 'password' };\r\n    const loginResponse = { token: 'mock-token', username: 'user', message: 'Login successful' };\r\n    actions$ = of(login({ credentials }));\r\n\r\n    // Now, mock the login method to return a successful response\r\n    authService.login.and.returnValue(of(loginResponse));  // Mock successful login\r\n\r\n    effects.login$.subscribe(action => {\r\n      expect(action).toEqual(loginSuccess({ token: loginResponse.token, username: loginResponse.username }));\r\n    });\r\n  });\r\n\r\n  it('should dispatch loginFailure when login fails', () => {\r\n    const credentials = { username: 'test@example.com', password: 'password' };\r\n    actions$ = of(login({ credentials }));\r\n\r\n    // Mock the login method to simulate an error\r\n    authService.login.and.returnValue(throwError('error'));  // Mock failure response\r\n\r\n    effects.login$.subscribe(action => {\r\n      expect(action).toEqual(loginFailure({ error: 'Login failed. Please try again.' }));\r\n    });\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\auth\\auth.effects.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'logout' is defined but never used.","line":4,"column":45,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":51},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'switchMap' is defined but never used.","line":5,"column":43,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":52}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { inject, Injectable } from '@angular/core';\r\nimport { Actions, createEffect, ofType } from '@ngrx/effects';\r\nimport { AuthService } from '../../services/auth/auth.service';\r\nimport { login, loginFailure, loginSuccess, logout } from './auth.actions';\r\nimport { catchError, exhaustMap, map, of, switchMap, tap } from 'rxjs';\r\nimport { Router } from '@angular/router';\r\n\r\n@Injectable()\r\nexport class AuthEffects {\r\n  private actions$ = inject(Actions);\r\n  private authService = inject(AuthService);\r\n  private router = inject(Router);\r\n\r\n  login$ = createEffect(() =>\r\n    this.actions$.pipe(\r\n      ofType(login),\r\n      exhaustMap(({ credentials }) =>\r\n        this.authService.login(credentials).pipe(\r\n          tap(() => console.log('Login API call made...')),\r\n          map((response) => {\r\n            localStorage.setItem('auth', JSON.stringify(response));\r\n            return loginSuccess({ token: response.token, username: response.username });\r\n          }),\r\n          catchError((error) => {\r\n            console.error('Login API error:', error);\r\n            return of(loginFailure({ error: 'Login failed. Please try again.' }));\r\n          })\r\n        )\r\n      )\r\n    )\r\n  );\r\n\r\n  loginSuccess$ = createEffect(\r\n    () =>\r\n      this.actions$.pipe(\r\n        ofType(loginSuccess),\r\n        tap(() => {\r\n          this.router.navigate(['/dashboard']);\r\n        })\r\n      ),\r\n    { dispatch: false }\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\auth\\auth.reducer.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\auth\\auth.reducer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\auth\\auth.selectors.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Store' is defined but never used.","line":2,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'selectAuthError' is defined but never used.","line":7,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":18}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { TestBed } from '@angular/core/testing';\r\nimport { Store } from '@ngrx/store';\r\nimport { MockStore, provideMockStore } from '@ngrx/store/testing';\r\nimport {\r\n  selectAuthState,\r\n  selectAuthToken,\r\n  selectAuthError,\r\n  selectIsLoading,\r\n} from './auth.selectors';\r\nimport { firstValueFrom } from 'rxjs';\r\n\r\ndescribe('Auth Selectors', () => {\r\n  let store: MockStore;\r\n\r\n  const initialState = {\r\n    auth: {\r\n      token: 'mock-token',\r\n      username: 'user',\r\n      error: 'mock-error',\r\n      isLoading: false,\r\n    },\r\n  };\r\n\r\n  beforeEach(() => {\r\n    TestBed.configureTestingModule({\r\n      providers: [provideMockStore({ initialState })],\r\n    });\r\n\r\n    store = TestBed.inject(MockStore);\r\n  });\r\n\r\n  it('should select the auth state', () => {\r\n    store.setState(initialState); // Ensure the state is set before selecting\r\n    store.select(selectAuthState).subscribe((state) => {\r\n      expect(state).toEqual(initialState.auth);\r\n    });\r\n  });\r\n\r\n  it('should select the loading status', () => {\r\n    store.setState(initialState); // Ensure the state is set before selecting\r\n    store.select(selectIsLoading).subscribe((isLoading) => {\r\n      expect(isLoading).toBeFalse();\r\n    });\r\n  });\r\n\r\n  it('should select the auth token', async () => {\r\n    const token = await firstValueFrom(store.select(selectAuthToken));\r\n    expect(token).toBe('mock-token');\r\n  });\r\n\r\n});\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\auth\\auth.selectors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\auth\\auth.state.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\interest-rates\\interest-rate.actions.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\interest-rates\\interest-rate.actions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\interest-rates\\interest-rate.effects.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\interest-rates\\interest-rate.effects.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\interest-rates\\interest-rate.reducer.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\interest-rates\\interest-rate.reducer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\interest-rates\\interest-rate.selectors.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\interest-rates\\interest-rate.selectors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\interest-rates\\interest-rate.state.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\loan\\loan.actions.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\loan\\loan.actions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\loan\\loan.effects.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\loan\\loan.effects.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'tap' is defined but never used.","line":5,"column":41,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":44}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { inject, Injectable } from '@angular/core';\r\nimport { Actions, createEffect, ofType } from '@ngrx/effects';\r\nimport { LoanService } from '../../services/loan/loan.service';\r\nimport * as LoanActions from './loan.actions';\r\nimport { catchError, map, mergeMap, of, tap } from 'rxjs';\r\n\r\n@Injectable()\r\nexport class LoanEffects {\r\n  private actions$ = inject(Actions);\r\n  private loanService = inject(LoanService);\r\n\r\n  loadLoans$ = createEffect(() =>\r\n    this.actions$.pipe(\r\n      ofType(LoanActions.loadLoans),\r\n      mergeMap(() =>\r\n        this.loanService.getLoans().pipe(\r\n          map((loans) => LoanActions.loadLoansSuccess({ loans })),\r\n          catchError((error) => {\r\n            return of({ type: '[Loan] Load Loans Failure', error });\r\n          })\r\n        )\r\n      )\r\n    )\r\n  );\r\n\r\n  addLoan$ = createEffect(() =>\r\n    this.actions$.pipe(\r\n      ofType(LoanActions.addLoan),\r\n      mergeMap((action) =>\r\n        this.loanService.createLoan(action.loan).pipe(\r\n          map((newLoan) => LoanActions.addLoanSuccess({ loan: newLoan })),\r\n          catchError((error) => of({ type: '[Loan] Add Loan Failure', error }))\r\n        )\r\n      )\r\n    )\r\n  );\r\n\r\n  refreshLoansAfterAdd$ = createEffect(() =>\r\n    this.actions$.pipe(\r\n      ofType(LoanActions.addLoanSuccess),\r\n      map(() => LoanActions.loadLoans())\r\n    )\r\n  );\r\n\r\n  loadLoanById$ = createEffect(() =>\r\n    this.actions$.pipe(\r\n      ofType(LoanActions.loadLoanById),\r\n      mergeMap((action) =>\r\n        this.loanService.getLoanById(action.userLoanNumber).pipe(\r\n          map((loan) => LoanActions.loadLoanByIdSuccess({ loan })),\r\n          catchError((error) => of(LoanActions.loadLoanByIdFailure({ error })))\r\n        )\r\n      )\r\n    )\r\n  );\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\loan\\loan.reducer.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\loan\\loan.reducer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\loan\\loan.selectors.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'emptyState' is assigned a value but never used.","line":46,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":46,"endColumn":19}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\r\n  selectLoans,\r\n  selectSelectedLoan,\r\n  selectLoanLoading,\r\n  selectLoanError,\r\n  selectLoanById,\r\n  selectLoanAddSuccess,\r\n  selectLoanState,\r\n} from './loan.selectors';\r\nimport { LoanState } from './loan.state';\r\nimport { ILoan } from '../../models/ILoan';\r\nimport { TestBed } from '@angular/core/testing';\r\n\r\ndescribe('Loan Selectors', () => {\r\n  beforeEach(() => {\r\n    // Reset global mocks, state, etc.\r\n    jasmine.clock().uninstall?.(); // Uninstall any clocks if used\r\n  });\r\n\r\n  afterEach(() => {\r\n    // Fully cleanup to avoid memory leaks or cross-test pollution\r\n    TestBed.resetTestingModule();\r\n  });\r\n\r\n  \r\n  const mockLoan: ILoan = {\r\n    LoanId: 1,\r\n    UserLoanNumber: 1,\r\n    LoanAmount: 200000,\r\n    InterestRate: 3.5,\r\n    LoanTermYears: 30,\r\n    ApplicationDate: '2024-01-01T00:00:00Z',\r\n    ApprovalStatus: 'Pending',\r\n  };\r\n\r\n  const state: { loan: LoanState } = {\r\n    loan: {\r\n      loans: [mockLoan],\r\n      selectedLoan: mockLoan,\r\n      lastAddedLoan: mockLoan,\r\n      loading: true,\r\n      error: 'Something went wrong',\r\n    },\r\n  };\r\n\r\n  const emptyState = { loan: {} as LoanState }; // Empty state for testing\r\n\r\n  it('should select loan feature state', () => {\r\n    const result = selectLoanState(state);\r\n    expect(result).toEqual(state.loan);\r\n  });\r\n\r\n  it('should select all loans', () => {\r\n    const result = selectLoans(state);\r\n    expect(result).toEqual([mockLoan]);\r\n  });\r\n\r\n  it('should select selectedLoan', () => {\r\n    const result = selectSelectedLoan(state);\r\n    expect(result).toEqual(mockLoan);\r\n  });\r\n\r\n  it('should select loading status', () => {\r\n    const result = selectLoanLoading(state);\r\n    expect(result).toBeTrue();\r\n  });\r\n\r\n  it('should select error', () => {\r\n    const result = selectLoanError(state);\r\n    expect(result).toBe('Something went wrong');\r\n  });\r\n\r\n  it('should select loan by id (alias of selectedLoan)', () => {\r\n    const result = selectLoanById(state);\r\n    expect(result).toEqual(mockLoan);\r\n  });\r\n\r\n  it('should select last added loan', () => {\r\n    const result = selectLoanAddSuccess(state);\r\n    expect(result).toEqual(mockLoan);\r\n  });\r\n\r\n  // Test case when state is missing (empty)\r\n  it('should handle missing loan state gracefully', () => {\r\n    const state = { loan: {} as LoanState };\r\n\r\n    expect(selectLoans(state)).toEqual([]);\r\n    expect(selectSelectedLoan(state)).toBeNull();\r\n    expect(selectLoanLoading(state)).toBeFalse();\r\n    expect(selectLoanError(state)).toBeNull();\r\n    expect(selectLoanById(state)).toBeNull();\r\n  });\r\n  \r\n\r\n  // Test case when some state properties are missing\r\n  it('should handle partially missing loan state gracefully', () => {\r\n    const partialState = { loan: { loans: [], selectedLoan: null } };\r\n\r\n    const result = selectLoans(partialState);\r\n    expect(result).toEqual([]); // Default empty array when loans are missing\r\n\r\n    const selectedLoanResult = selectSelectedLoan(partialState);\r\n    expect(selectedLoanResult).toBeNull(); // Default null when selectedLoan is missing\r\n\r\n    const loadingResult = selectLoanLoading(partialState);\r\n    expect(loadingResult).toBeFalse(); // Default false when loading is missing\r\n\r\n    const errorResult = selectLoanError(partialState);\r\n    expect(errorResult).toBeNull(); // Default null when error is missing\r\n\r\n    const loanByIdResult = selectLoanById(partialState);\r\n    expect(loanByIdResult).toBeNull(); // Default null when selectedLoan is missing\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\loan\\loan.selectors.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\app\\store\\loan\\loan.state.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\index.html","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\Lenovo\\OneDrive\\Documents\\Mortgage-loan-application-app\\mortgage-app\\src\\main.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]