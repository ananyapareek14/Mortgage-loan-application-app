hi.I have generated some unit tests, but it is not according to the model. modify the spec code according to the model and add some edge cases to the test cases. The model is as follows:

IAuth.ts:
interface ILogin{
    token: string;
    username: string;
    message: string;
}

interface ILoginCredentials{
    username: string;
    password: string;
}

export type {ILogin as default, ILoginCredentials}

auth.state.ts:
export interface AuthState {
  username: string | null;
  token: string | null;
  error: string | null;
  isLoading: boolean;
}

export const initialAuthState: AuthState = {
  username: null,
  token: null,
  error: null,
  isLoading: false
};

auth.selectors.spec.ts:
import { TestBed } from '@angular/core/testing';
import { Store, StoreModule } from '@ngrx/store';
import { selectAuthState, selectAuthToken, selectAuthError, selectIsLoading } from './auth.selectors';
import { AuthState } from './auth.state';

describe('Auth Selectors', () => {
  let store: Store<{ auth: AuthState }>;

  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [
        StoreModule.forRoot({}),
        StoreModule.forFeature('auth', {} as any)
      ]
    });

    store = TestBed.inject(Store);
  });

  describe('selectAuthState', () => {
    it('should select the auth state', () => {
      const initialState: AuthState = {
        token: null,
        error: null,
        isLoading: false
      };

      let result: AuthState | undefined;
      store.select(selectAuthState).subscribe(value => {
        result = value;
      });

      store.setState({ auth: initialState });

      expect(result).toEqual(initialState);
    });
  });

  describe('selectAuthToken', () => {
    it('should return the auth token when present', () => {
      const state: AuthState = {
        token: 'test-token',
        error: null,
        isLoading: false
      };

      let result: string | null | undefined;
      store.select(selectAuthToken).subscribe(value => {
        result = value;
      });

      store.setState({ auth: state });

      expect(result).toBe('test-token');
    });

    it('should return null when auth token is not present', () => {
      const state: AuthState = {
        token: null,
        error: null,
        isLoading: false
      };

      let result: string | null | undefined;
      store.select(selectAuthToken).subscribe(value => {
        result = value;
      });

      store.setState({ auth: state });

      expect(result).toBeNull();
    });
  });

  describe('selectAuthError', () => {
    it('should return the error message when present', () => {
      const state: AuthState = {
        token: null,
        error: 'Authentication failed',
        isLoading: false
      };

      let result: string | null | undefined;
      store.select(selectAuthError).subscribe(value => {
        result = value;
      });

      store.setState({ auth: state });

      expect(result).toBe('Authentication failed');
    });

    it('should return null when no error is present', () => {
      const state: AuthState = {
        token: null,
        error: null,
        isLoading: false
      };

      let result: string | null | undefined;
      store.select(selectAuthError).subscribe(value => {
        result = value;
      });

      store.setState({ auth: state });

      expect(result).toBeNull();
    });
  });

  describe('selectIsLoading', () => {
    it('should return true when isLoading is true', () => {
      const state: AuthState = {
        token: null,
        error: null,
        isLoading: true
      };

      let result: boolean | undefined;
      store.select(selectIsLoading).subscribe(value => {
        result = value;
      });

      store.setState({ auth: state });

      expect(result).toBe(true);
    });

    it('should return false when isLoading is false', () => {
      const state: AuthState = {
        token: null,
        error: null,
        isLoading: false
      };

      let result: boolean | undefined;
      store.select(selectIsLoading).subscribe(value => {
        result = value;
      });

      store.setState({ auth: state });

      expect(result).toBe(false);
    });
  });

  // Edge case: Empty state
  it('should handle empty state', () => {
    const emptyState = {};

    store.setState(emptyState);

    store.select(selectAuthState).subscribe(value => {
      expect(value).toBeUndefined();
    });

    store.select(selectAuthToken).subscribe(value => {
      expect(value).toBeUndefined();
    });

    store.select(selectAuthError).subscribe(value => {
      expect(value).toBeUndefined();
    });

    store.select(selectIsLoading).subscribe(value => {
      expect(value).toBeUndefined();
    });
  });

  // Boundary condition: Large token
  it('should handle large token', () => {
    const largeToken = 'a'.repeat(10000);
    const state: AuthState = {
      token: largeToken,
      error: null,
      isLoading: false
    };

    let result: string | null | undefined;
    store.select(selectAuthToken).subscribe(value => {
      result = value;
    });

    store.setState({ auth: state });

    expect(result).toBe(largeToken);
    expect(result?.length).toBe(10000);
  });

  // Error handling: Incorrect state shape
  it('should handle incorrect state shape', () => {
    const incorrectState = {
      auth: {
        unexpectedField: 'value'
      }
    };

    store.setState(incorrectState);

    store.select(selectAuthToken).subscribe(value => {
      expect(value).toBeUndefined();
    });

    store.select(selectAuthError).subscribe(value => {
      expect(value).toBeUndefined();
    });

    store.select(selectIsLoading).subscribe(value => {
      expect(value).toBeUndefined();
    });
  });
});
