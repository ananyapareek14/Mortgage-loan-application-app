hi.I have generated some unit tests, but it is not according to the model. modify the spec code according to the model and add some edge cases to the test cases. The model is as follows:

ILoan.ts:
interface ILoan{
    LoanId?: number;
    UserLoanNumber: number;
    LoanAmount: number;
    InterestRate: number;
    LoanTermYears: number;
    ApplicationDate: string;
    ApprovalStatus: string;
}

export type {ILoan}


loan.effects.spec.ts:
import { TestBed } from '@angular/core/testing';
import { provideMockActions } from '@ngrx/effects/testing';
import { Observable, of, throwError } from 'rxjs';
import { TestScheduler } from 'rxjs/testing';
import { LoanEffects } from './loan.effects';
import { LoanService } from '../../services/loan/loan.service';
import * as LoanActions from './loan.actions';

describe('LoanEffects', () => {
  let actions$: Observable<any>;
  let effects: LoanEffects;
  let loanService: jasmine.SpyObj<LoanService>;
  let testScheduler: TestScheduler;

  beforeEach(() => {
    const loanServiceSpy = jasmine.createSpyObj('LoanService', ['getLoans', 'createLoan', 'getLoanById']);

    TestBed.configureTestingModule({
      providers: [
        LoanEffects,
        provideMockActions(() => actions$),
        { provide: LoanService, useValue: loanServiceSpy }
      ]
    });

    effects = TestBed.inject(LoanEffects);
    loanService = TestBed.inject(LoanService) as jasmine.SpyObj<LoanService>;
    testScheduler = new TestScheduler((actual, expected) => {
      expect(actual).toEqual(expected);
    });
  });

  it('should be created', () => {
    expect(effects).toBeTruthy();
  });

  describe('loadLoans$', () => {
    it('should return a loadLoansSuccess action with loans on success', () => {
      testScheduler.run(({ hot, cold, expectObservable }) => {
        const loans = [{ id: 1, amount: 1000 }, { id: 2, amount: 2000 }];
        actions$ = hot('-a', { a: LoanActions.loadLoans() });
        const response = cold('-b|', { b: loans });
        loanService.getLoans.and.returnValue(response);

        const expected = hot('--c', {
          c: LoanActions.loadLoansSuccess({ loans })
        });

        expectObservable(effects.loadLoans$).toEqual(expected);
      });
    });

    it('should return a loadLoansFailure action on error', () => {
      testScheduler.run(({ hot, cold, expectObservable }) => {
        const error = new Error('Test error');
        actions$ = hot('-a', { a: LoanActions.loadLoans() });
        const response = cold('-#|', {}, error);
        loanService.getLoans.and.returnValue(response);

        const expected = hot('--c', {
          c: { type: '[Loan] Load Loans Failure', error }
        });

        expectObservable(effects.loadLoans$).toEqual(expected);
      });
    });
  });

  describe('addLoan$', () => {
    it('should return an addLoanSuccess action with the new loan on success', () => {
      testScheduler.run(({ hot, cold, expectObservable }) => {
        const newLoan = { id: 3, amount: 3000 };
        actions$ = hot('-a', { a: LoanActions.addLoan({ loan: newLoan }) });
        const response = cold('-b|', { b: newLoan });
        loanService.createLoan.and.returnValue(response);

        const expected = hot('--c', {
          c: LoanActions.addLoanSuccess({ loan: newLoan })
        });

        expectObservable(effects.addLoan$).toEqual(expected);
      });
    });

    it('should return an addLoanFailure action on error', () => {
      testScheduler.run(({ hot, cold, expectObservable }) => {
        const error = new Error('Test error');
        const newLoan = { id: 3, amount: 3000 };
        actions$ = hot('-a', { a: LoanActions.addLoan({ loan: newLoan }) });
        const response = cold('-#|', {}, error);
        loanService.createLoan.and.returnValue(response);

        const expected = hot('--c', {
          c: { type: '[Loan] Add Loan Failure', error }
        });

        expectObservable(effects.addLoan$).toEqual(expected);
      });
    });
  });

  describe('refreshLoansAfterAdd$', () => {
    it('should dispatch a loadLoans action after addLoanSuccess', () => {
      testScheduler.run(({ hot, expectObservable }) => {
        const newLoan = { id: 3, amount: 3000 };
        actions$ = hot('-a', { a: LoanActions.addLoanSuccess({ loan: newLoan }) });

        const expected = hot('-b', {
          b: LoanActions.loadLoans()
        });

        expectObservable(effects.refreshLoansAfterAdd$).toEqual(expected);
      });
    });
  });

  describe('loadLoanById$', () => {
    it('should return a loadLoanByIdSuccess action with the loan on success', () => {
      testScheduler.run(({ hot, cold, expectObservable }) => {
        const loan = { id: 1, amount: 1000 };
        actions$ = hot('-a', { a: LoanActions.loadLoanById({ userLoanNumber: '1' }) });
        const response = cold('-b|', { b: loan });
        loanService.getLoanById.and.returnValue(response);

        const expected = hot('--c', {
          c: LoanActions.loadLoanByIdSuccess({ loan })
        });

        expectObservable(effects.loadLoanById$).toEqual(expected);
      });
    });

    it('should return a loadLoanByIdFailure action on error', () => {
      testScheduler.run(({ hot, cold, expectObservable }) => {
        const error = new Error('Test error');
        actions$ = hot('-a', { a: LoanActions.loadLoanById({ userLoanNumber: '1' }) });
        const response = cold('-#|', {}, error);
        loanService.getLoanById.and.returnValue(response);

        const expected = hot('--c', {
          c: LoanActions.loadLoanByIdFailure({ error })
        });

        expectObservable(effects.loadLoanById$).toEqual(expected);
      });
    });

    it('should handle empty loan ID', () => {
      testScheduler.run(({ hot, cold, expectObservable }) => {
        actions$ = hot('-a', { a: LoanActions.loadLoanById({ userLoanNumber: '' }) });
        const response = cold('-b|', { b: null });
        loanService.getLoanById.and.returnValue(response);

        const expected = hot('--c', {
          c: LoanActions.loadLoanByIdSuccess({ loan: null })
        });

        expectObservable(effects.loadLoanById$).toEqual(expected);
      });
    });
  });
});
